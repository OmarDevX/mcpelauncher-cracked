// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: play_settings.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_play_5fsettings_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_play_5fsettings_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "play_document.pb.h"
#include "play_search.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_play_5fsettings_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_play_5fsettings_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_play_5fsettings_2eproto;
namespace playapi {
namespace proto {
namespace finsky {
namespace settings {
class Family;
struct FamilyDefaultTypeInternal;
extern FamilyDefaultTypeInternal _Family_default_instance_;
class FamilyInfo;
struct FamilyInfoDefaultTypeInternal;
extern FamilyInfoDefaultTypeInternal _FamilyInfo_default_instance_;
class FamilyMember;
struct FamilyMemberDefaultTypeInternal;
extern FamilyMemberDefaultTypeInternal _FamilyMember_default_instance_;
class GetUserSettingsResponse;
struct GetUserSettingsResponseDefaultTypeInternal;
extern GetUserSettingsResponseDefaultTypeInternal _GetUserSettingsResponse_default_instance_;
class MarketingSettings;
struct MarketingSettingsDefaultTypeInternal;
extern MarketingSettingsDefaultTypeInternal _MarketingSettings_default_instance_;
class OBSOLETEUserSettings;
struct OBSOLETEUserSettingsDefaultTypeInternal;
extern OBSOLETEUserSettingsDefaultTypeInternal _OBSOLETEUserSettings_default_instance_;
class Onboarding;
struct OnboardingDefaultTypeInternal;
extern OnboardingDefaultTypeInternal _Onboarding_default_instance_;
class Onboardings;
struct OnboardingsDefaultTypeInternal;
extern OnboardingsDefaultTypeInternal _Onboardings_default_instance_;
class PrivacySetting;
struct PrivacySettingDefaultTypeInternal;
extern PrivacySettingDefaultTypeInternal _PrivacySetting_default_instance_;
class PrivacySettings;
struct PrivacySettingsDefaultTypeInternal;
extern PrivacySettingsDefaultTypeInternal _PrivacySettings_default_instance_;
class UserSettingDirtyData;
struct UserSettingDirtyDataDefaultTypeInternal;
extern UserSettingDirtyDataDefaultTypeInternal _UserSettingDirtyData_default_instance_;
class UserSettings;
struct UserSettingsDefaultTypeInternal;
extern UserSettingsDefaultTypeInternal _UserSettings_default_instance_;
class UserSettingsConsistencyTokens;
struct UserSettingsConsistencyTokensDefaultTypeInternal;
extern UserSettingsConsistencyTokensDefaultTypeInternal _UserSettingsConsistencyTokens_default_instance_;
class UserSettingsConsistencyTokens_ConsistencyTokenInfo;
struct UserSettingsConsistencyTokens_ConsistencyTokenInfoDefaultTypeInternal;
extern UserSettingsConsistencyTokens_ConsistencyTokenInfoDefaultTypeInternal _UserSettingsConsistencyTokens_ConsistencyTokenInfo_default_instance_;
}  // namespace settings
}  // namespace finsky
}  // namespace proto
}  // namespace playapi
PROTOBUF_NAMESPACE_OPEN
template<> ::playapi::proto::finsky::settings::Family* Arena::CreateMaybeMessage<::playapi::proto::finsky::settings::Family>(Arena*);
template<> ::playapi::proto::finsky::settings::FamilyInfo* Arena::CreateMaybeMessage<::playapi::proto::finsky::settings::FamilyInfo>(Arena*);
template<> ::playapi::proto::finsky::settings::FamilyMember* Arena::CreateMaybeMessage<::playapi::proto::finsky::settings::FamilyMember>(Arena*);
template<> ::playapi::proto::finsky::settings::GetUserSettingsResponse* Arena::CreateMaybeMessage<::playapi::proto::finsky::settings::GetUserSettingsResponse>(Arena*);
template<> ::playapi::proto::finsky::settings::MarketingSettings* Arena::CreateMaybeMessage<::playapi::proto::finsky::settings::MarketingSettings>(Arena*);
template<> ::playapi::proto::finsky::settings::OBSOLETEUserSettings* Arena::CreateMaybeMessage<::playapi::proto::finsky::settings::OBSOLETEUserSettings>(Arena*);
template<> ::playapi::proto::finsky::settings::Onboarding* Arena::CreateMaybeMessage<::playapi::proto::finsky::settings::Onboarding>(Arena*);
template<> ::playapi::proto::finsky::settings::Onboardings* Arena::CreateMaybeMessage<::playapi::proto::finsky::settings::Onboardings>(Arena*);
template<> ::playapi::proto::finsky::settings::PrivacySetting* Arena::CreateMaybeMessage<::playapi::proto::finsky::settings::PrivacySetting>(Arena*);
template<> ::playapi::proto::finsky::settings::PrivacySettings* Arena::CreateMaybeMessage<::playapi::proto::finsky::settings::PrivacySettings>(Arena*);
template<> ::playapi::proto::finsky::settings::UserSettingDirtyData* Arena::CreateMaybeMessage<::playapi::proto::finsky::settings::UserSettingDirtyData>(Arena*);
template<> ::playapi::proto::finsky::settings::UserSettings* Arena::CreateMaybeMessage<::playapi::proto::finsky::settings::UserSettings>(Arena*);
template<> ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens* Arena::CreateMaybeMessage<::playapi::proto::finsky::settings::UserSettingsConsistencyTokens>(Arena*);
template<> ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens_ConsistencyTokenInfo* Arena::CreateMaybeMessage<::playapi::proto::finsky::settings::UserSettingsConsistencyTokens_ConsistencyTokenInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace playapi {
namespace proto {
namespace finsky {
namespace settings {

// ===================================================================

class UserSettingsConsistencyTokens_ConsistencyTokenInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.settings.UserSettingsConsistencyTokens.ConsistencyTokenInfo) */ {
 public:
  inline UserSettingsConsistencyTokens_ConsistencyTokenInfo() : UserSettingsConsistencyTokens_ConsistencyTokenInfo(nullptr) {}
  ~UserSettingsConsistencyTokens_ConsistencyTokenInfo() override;
  explicit PROTOBUF_CONSTEXPR UserSettingsConsistencyTokens_ConsistencyTokenInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserSettingsConsistencyTokens_ConsistencyTokenInfo(const UserSettingsConsistencyTokens_ConsistencyTokenInfo& from);
  UserSettingsConsistencyTokens_ConsistencyTokenInfo(UserSettingsConsistencyTokens_ConsistencyTokenInfo&& from) noexcept
    : UserSettingsConsistencyTokens_ConsistencyTokenInfo() {
    *this = ::std::move(from);
  }

  inline UserSettingsConsistencyTokens_ConsistencyTokenInfo& operator=(const UserSettingsConsistencyTokens_ConsistencyTokenInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserSettingsConsistencyTokens_ConsistencyTokenInfo& operator=(UserSettingsConsistencyTokens_ConsistencyTokenInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserSettingsConsistencyTokens_ConsistencyTokenInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserSettingsConsistencyTokens_ConsistencyTokenInfo* internal_default_instance() {
    return reinterpret_cast<const UserSettingsConsistencyTokens_ConsistencyTokenInfo*>(
               &_UserSettingsConsistencyTokens_ConsistencyTokenInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(UserSettingsConsistencyTokens_ConsistencyTokenInfo& a, UserSettingsConsistencyTokens_ConsistencyTokenInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(UserSettingsConsistencyTokens_ConsistencyTokenInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserSettingsConsistencyTokens_ConsistencyTokenInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserSettingsConsistencyTokens_ConsistencyTokenInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserSettingsConsistencyTokens_ConsistencyTokenInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserSettingsConsistencyTokens_ConsistencyTokenInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserSettingsConsistencyTokens_ConsistencyTokenInfo& from) {
    UserSettingsConsistencyTokens_ConsistencyTokenInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserSettingsConsistencyTokens_ConsistencyTokenInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.settings.UserSettingsConsistencyTokens.ConsistencyTokenInfo";
  }
  protected:
  explicit UserSettingsConsistencyTokens_ConsistencyTokenInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestHeaderFieldNumber = 1,
    kConsistencyTokenFieldNumber = 2,
  };
  // optional string requestHeader = 1;
  bool has_requestheader() const;
  private:
  bool _internal_has_requestheader() const;
  public:
  void clear_requestheader();
  const std::string& requestheader() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_requestheader(ArgT0&& arg0, ArgT... args);
  std::string* mutable_requestheader();
  PROTOBUF_NODISCARD std::string* release_requestheader();
  void set_allocated_requestheader(std::string* requestheader);
  private:
  const std::string& _internal_requestheader() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_requestheader(const std::string& value);
  std::string* _internal_mutable_requestheader();
  public:

  // optional string consistencyToken = 2;
  bool has_consistencytoken() const;
  private:
  bool _internal_has_consistencytoken() const;
  public:
  void clear_consistencytoken();
  const std::string& consistencytoken() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_consistencytoken(ArgT0&& arg0, ArgT... args);
  std::string* mutable_consistencytoken();
  PROTOBUF_NODISCARD std::string* release_consistencytoken();
  void set_allocated_consistencytoken(std::string* consistencytoken);
  private:
  const std::string& _internal_consistencytoken() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_consistencytoken(const std::string& value);
  std::string* _internal_mutable_consistencytoken();
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.settings.UserSettingsConsistencyTokens.ConsistencyTokenInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr requestheader_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr consistencytoken_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fsettings_2eproto;
};
// -------------------------------------------------------------------

class UserSettingsConsistencyTokens final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.settings.UserSettingsConsistencyTokens) */ {
 public:
  inline UserSettingsConsistencyTokens() : UserSettingsConsistencyTokens(nullptr) {}
  ~UserSettingsConsistencyTokens() override;
  explicit PROTOBUF_CONSTEXPR UserSettingsConsistencyTokens(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserSettingsConsistencyTokens(const UserSettingsConsistencyTokens& from);
  UserSettingsConsistencyTokens(UserSettingsConsistencyTokens&& from) noexcept
    : UserSettingsConsistencyTokens() {
    *this = ::std::move(from);
  }

  inline UserSettingsConsistencyTokens& operator=(const UserSettingsConsistencyTokens& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserSettingsConsistencyTokens& operator=(UserSettingsConsistencyTokens&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserSettingsConsistencyTokens& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserSettingsConsistencyTokens* internal_default_instance() {
    return reinterpret_cast<const UserSettingsConsistencyTokens*>(
               &_UserSettingsConsistencyTokens_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(UserSettingsConsistencyTokens& a, UserSettingsConsistencyTokens& b) {
    a.Swap(&b);
  }
  inline void Swap(UserSettingsConsistencyTokens* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserSettingsConsistencyTokens* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserSettingsConsistencyTokens* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserSettingsConsistencyTokens>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserSettingsConsistencyTokens& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserSettingsConsistencyTokens& from) {
    UserSettingsConsistencyTokens::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserSettingsConsistencyTokens* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.settings.UserSettingsConsistencyTokens";
  }
  protected:
  explicit UserSettingsConsistencyTokens(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UserSettingsConsistencyTokens_ConsistencyTokenInfo ConsistencyTokenInfo;

  // accessors -------------------------------------------------------

  enum : int {
    kConsistencyTokenInfoFieldNumber = 1,
  };
  // repeated .playapi.proto.finsky.settings.UserSettingsConsistencyTokens.ConsistencyTokenInfo consistencyTokenInfo = 1;
  int consistencytokeninfo_size() const;
  private:
  int _internal_consistencytokeninfo_size() const;
  public:
  void clear_consistencytokeninfo();
  ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens_ConsistencyTokenInfo* mutable_consistencytokeninfo(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens_ConsistencyTokenInfo >*
      mutable_consistencytokeninfo();
  private:
  const ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens_ConsistencyTokenInfo& _internal_consistencytokeninfo(int index) const;
  ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens_ConsistencyTokenInfo* _internal_add_consistencytokeninfo();
  public:
  const ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens_ConsistencyTokenInfo& consistencytokeninfo(int index) const;
  ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens_ConsistencyTokenInfo* add_consistencytokeninfo();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens_ConsistencyTokenInfo >&
      consistencytokeninfo() const;

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.settings.UserSettingsConsistencyTokens)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens_ConsistencyTokenInfo > consistencytokeninfo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fsettings_2eproto;
};
// -------------------------------------------------------------------

class MarketingSettings final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.settings.MarketingSettings) */ {
 public:
  inline MarketingSettings() : MarketingSettings(nullptr) {}
  ~MarketingSettings() override;
  explicit PROTOBUF_CONSTEXPR MarketingSettings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarketingSettings(const MarketingSettings& from);
  MarketingSettings(MarketingSettings&& from) noexcept
    : MarketingSettings() {
    *this = ::std::move(from);
  }

  inline MarketingSettings& operator=(const MarketingSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarketingSettings& operator=(MarketingSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarketingSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarketingSettings* internal_default_instance() {
    return reinterpret_cast<const MarketingSettings*>(
               &_MarketingSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MarketingSettings& a, MarketingSettings& b) {
    a.Swap(&b);
  }
  inline void Swap(MarketingSettings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarketingSettings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarketingSettings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarketingSettings>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MarketingSettings& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MarketingSettings& from) {
    MarketingSettings::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketingSettings* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.settings.MarketingSettings";
  }
  protected:
  explicit MarketingSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketingEmailsOptedInFieldNumber = 1,
  };
  // optional bool marketingEmailsOptedIn = 1;
  bool has_marketingemailsoptedin() const;
  private:
  bool _internal_has_marketingemailsoptedin() const;
  public:
  void clear_marketingemailsoptedin();
  bool marketingemailsoptedin() const;
  void set_marketingemailsoptedin(bool value);
  private:
  bool _internal_marketingemailsoptedin() const;
  void _internal_set_marketingemailsoptedin(bool value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.settings.MarketingSettings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool marketingemailsoptedin_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fsettings_2eproto;
};
// -------------------------------------------------------------------

class PrivacySetting final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.settings.PrivacySetting) */ {
 public:
  inline PrivacySetting() : PrivacySetting(nullptr) {}
  ~PrivacySetting() override;
  explicit PROTOBUF_CONSTEXPR PrivacySetting(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PrivacySetting(const PrivacySetting& from);
  PrivacySetting(PrivacySetting&& from) noexcept
    : PrivacySetting() {
    *this = ::std::move(from);
  }

  inline PrivacySetting& operator=(const PrivacySetting& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrivacySetting& operator=(PrivacySetting&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrivacySetting& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrivacySetting* internal_default_instance() {
    return reinterpret_cast<const PrivacySetting*>(
               &_PrivacySetting_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PrivacySetting& a, PrivacySetting& b) {
    a.Swap(&b);
  }
  inline void Swap(PrivacySetting* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrivacySetting* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrivacySetting* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PrivacySetting>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PrivacySetting& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PrivacySetting& from) {
    PrivacySetting::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PrivacySetting* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.settings.PrivacySetting";
  }
  protected:
  explicit PrivacySetting(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kCurrentStatusFieldNumber = 2,
    kEnabledByDefaultFieldNumber = 3,
  };
  // optional int32 type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  int32_t type() const;
  void set_type(int32_t value);
  private:
  int32_t _internal_type() const;
  void _internal_set_type(int32_t value);
  public:

  // optional int32 currentStatus = 2;
  bool has_currentstatus() const;
  private:
  bool _internal_has_currentstatus() const;
  public:
  void clear_currentstatus();
  int32_t currentstatus() const;
  void set_currentstatus(int32_t value);
  private:
  int32_t _internal_currentstatus() const;
  void _internal_set_currentstatus(int32_t value);
  public:

  // optional bool enabledByDefault = 3;
  bool has_enabledbydefault() const;
  private:
  bool _internal_has_enabledbydefault() const;
  public:
  void clear_enabledbydefault();
  bool enabledbydefault() const;
  void set_enabledbydefault(bool value);
  private:
  bool _internal_enabledbydefault() const;
  void _internal_set_enabledbydefault(bool value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.settings.PrivacySetting)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t type_;
    int32_t currentstatus_;
    bool enabledbydefault_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fsettings_2eproto;
};
// -------------------------------------------------------------------

class PrivacySettings final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.settings.PrivacySettings) */ {
 public:
  inline PrivacySettings() : PrivacySettings(nullptr) {}
  ~PrivacySettings() override;
  explicit PROTOBUF_CONSTEXPR PrivacySettings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PrivacySettings(const PrivacySettings& from);
  PrivacySettings(PrivacySettings&& from) noexcept
    : PrivacySettings() {
    *this = ::std::move(from);
  }

  inline PrivacySettings& operator=(const PrivacySettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrivacySettings& operator=(PrivacySettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrivacySettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrivacySettings* internal_default_instance() {
    return reinterpret_cast<const PrivacySettings*>(
               &_PrivacySettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PrivacySettings& a, PrivacySettings& b) {
    a.Swap(&b);
  }
  inline void Swap(PrivacySettings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrivacySettings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrivacySettings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PrivacySettings>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PrivacySettings& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PrivacySettings& from) {
    PrivacySettings::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PrivacySettings* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.settings.PrivacySettings";
  }
  protected:
  explicit PrivacySettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrivacySettingFieldNumber = 1,
  };
  // repeated .playapi.proto.finsky.settings.PrivacySetting privacySetting = 1;
  int privacysetting_size() const;
  private:
  int _internal_privacysetting_size() const;
  public:
  void clear_privacysetting();
  ::playapi::proto::finsky::settings::PrivacySetting* mutable_privacysetting(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::settings::PrivacySetting >*
      mutable_privacysetting();
  private:
  const ::playapi::proto::finsky::settings::PrivacySetting& _internal_privacysetting(int index) const;
  ::playapi::proto::finsky::settings::PrivacySetting* _internal_add_privacysetting();
  public:
  const ::playapi::proto::finsky::settings::PrivacySetting& privacysetting(int index) const;
  ::playapi::proto::finsky::settings::PrivacySetting* add_privacysetting();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::settings::PrivacySetting >&
      privacysetting() const;

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.settings.PrivacySettings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::settings::PrivacySetting > privacysetting_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fsettings_2eproto;
};
// -------------------------------------------------------------------

class FamilyInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.settings.FamilyInfo) */ {
 public:
  inline FamilyInfo() : FamilyInfo(nullptr) {}
  ~FamilyInfo() override;
  explicit PROTOBUF_CONSTEXPR FamilyInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FamilyInfo(const FamilyInfo& from);
  FamilyInfo(FamilyInfo&& from) noexcept
    : FamilyInfo() {
    *this = ::std::move(from);
  }

  inline FamilyInfo& operator=(const FamilyInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline FamilyInfo& operator=(FamilyInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FamilyInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const FamilyInfo* internal_default_instance() {
    return reinterpret_cast<const FamilyInfo*>(
               &_FamilyInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(FamilyInfo& a, FamilyInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(FamilyInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FamilyInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FamilyInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FamilyInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FamilyInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FamilyInfo& from) {
    FamilyInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FamilyInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.settings.FamilyInfo";
  }
  protected:
  explicit FamilyInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFamilyFieldNumber = 2,
    kFamilyMembershipStatusFieldNumber = 1,
  };
  // optional .playapi.proto.finsky.settings.Family family = 2;
  bool has_family() const;
  private:
  bool _internal_has_family() const;
  public:
  void clear_family();
  const ::playapi::proto::finsky::settings::Family& family() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::settings::Family* release_family();
  ::playapi::proto::finsky::settings::Family* mutable_family();
  void set_allocated_family(::playapi::proto::finsky::settings::Family* family);
  private:
  const ::playapi::proto::finsky::settings::Family& _internal_family() const;
  ::playapi::proto::finsky::settings::Family* _internal_mutable_family();
  public:
  void unsafe_arena_set_allocated_family(
      ::playapi::proto::finsky::settings::Family* family);
  ::playapi::proto::finsky::settings::Family* unsafe_arena_release_family();

  // optional int32 familyMembershipStatus = 1;
  bool has_familymembershipstatus() const;
  private:
  bool _internal_has_familymembershipstatus() const;
  public:
  void clear_familymembershipstatus();
  int32_t familymembershipstatus() const;
  void set_familymembershipstatus(int32_t value);
  private:
  int32_t _internal_familymembershipstatus() const;
  void _internal_set_familymembershipstatus(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.settings.FamilyInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::playapi::proto::finsky::settings::Family* family_;
    int32_t familymembershipstatus_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fsettings_2eproto;
};
// -------------------------------------------------------------------

class Family final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.settings.Family) */ {
 public:
  inline Family() : Family(nullptr) {}
  ~Family() override;
  explicit PROTOBUF_CONSTEXPR Family(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Family(const Family& from);
  Family(Family&& from) noexcept
    : Family() {
    *this = ::std::move(from);
  }

  inline Family& operator=(const Family& from) {
    CopyFrom(from);
    return *this;
  }
  inline Family& operator=(Family&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Family& default_instance() {
    return *internal_default_instance();
  }
  static inline const Family* internal_default_instance() {
    return reinterpret_cast<const Family*>(
               &_Family_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Family& a, Family& b) {
    a.Swap(&b);
  }
  inline void Swap(Family* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Family* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Family* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Family>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Family& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Family& from) {
    Family::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Family* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.settings.Family";
  }
  protected:
  explicit Family(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMemberFieldNumber = 1,
  };
  // repeated .playapi.proto.finsky.settings.FamilyMember member = 1;
  int member_size() const;
  private:
  int _internal_member_size() const;
  public:
  void clear_member();
  ::playapi::proto::finsky::settings::FamilyMember* mutable_member(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::settings::FamilyMember >*
      mutable_member();
  private:
  const ::playapi::proto::finsky::settings::FamilyMember& _internal_member(int index) const;
  ::playapi::proto::finsky::settings::FamilyMember* _internal_add_member();
  public:
  const ::playapi::proto::finsky::settings::FamilyMember& member(int index) const;
  ::playapi::proto::finsky::settings::FamilyMember* add_member();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::settings::FamilyMember >&
      member() const;

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.settings.Family)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::settings::FamilyMember > member_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fsettings_2eproto;
};
// -------------------------------------------------------------------

class FamilyMember final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.settings.FamilyMember) */ {
 public:
  inline FamilyMember() : FamilyMember(nullptr) {}
  ~FamilyMember() override;
  explicit PROTOBUF_CONSTEXPR FamilyMember(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FamilyMember(const FamilyMember& from);
  FamilyMember(FamilyMember&& from) noexcept
    : FamilyMember() {
    *this = ::std::move(from);
  }

  inline FamilyMember& operator=(const FamilyMember& from) {
    CopyFrom(from);
    return *this;
  }
  inline FamilyMember& operator=(FamilyMember&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FamilyMember& default_instance() {
    return *internal_default_instance();
  }
  static inline const FamilyMember* internal_default_instance() {
    return reinterpret_cast<const FamilyMember*>(
               &_FamilyMember_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(FamilyMember& a, FamilyMember& b) {
    a.Swap(&b);
  }
  inline void Swap(FamilyMember* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FamilyMember* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FamilyMember* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FamilyMember>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FamilyMember& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FamilyMember& from) {
    FamilyMember::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FamilyMember* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.settings.FamilyMember";
  }
  protected:
  explicit FamilyMember(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPersonDocumentFieldNumber = 2,
    kRoleFieldNumber = 1,
  };
  // optional .playapi.proto.finsky.document.DocV2 personDocument = 2;
  bool has_persondocument() const;
  private:
  bool _internal_has_persondocument() const;
  public:
  void clear_persondocument();
  const ::playapi::proto::finsky::document::DocV2& persondocument() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::DocV2* release_persondocument();
  ::playapi::proto::finsky::document::DocV2* mutable_persondocument();
  void set_allocated_persondocument(::playapi::proto::finsky::document::DocV2* persondocument);
  private:
  const ::playapi::proto::finsky::document::DocV2& _internal_persondocument() const;
  ::playapi::proto::finsky::document::DocV2* _internal_mutable_persondocument();
  public:
  void unsafe_arena_set_allocated_persondocument(
      ::playapi::proto::finsky::document::DocV2* persondocument);
  ::playapi::proto::finsky::document::DocV2* unsafe_arena_release_persondocument();

  // optional int32 role = 1;
  bool has_role() const;
  private:
  bool _internal_has_role() const;
  public:
  void clear_role();
  int32_t role() const;
  void set_role(int32_t value);
  private:
  int32_t _internal_role() const;
  void _internal_set_role(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.settings.FamilyMember)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::playapi::proto::finsky::document::DocV2* persondocument_;
    int32_t role_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fsettings_2eproto;
};
// -------------------------------------------------------------------

class Onboarding final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.settings.Onboarding) */ {
 public:
  inline Onboarding() : Onboarding(nullptr) {}
  ~Onboarding() override;
  explicit PROTOBUF_CONSTEXPR Onboarding(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Onboarding(const Onboarding& from);
  Onboarding(Onboarding&& from) noexcept
    : Onboarding() {
    *this = ::std::move(from);
  }

  inline Onboarding& operator=(const Onboarding& from) {
    CopyFrom(from);
    return *this;
  }
  inline Onboarding& operator=(Onboarding&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Onboarding& default_instance() {
    return *internal_default_instance();
  }
  static inline const Onboarding* internal_default_instance() {
    return reinterpret_cast<const Onboarding*>(
               &_Onboarding_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Onboarding& a, Onboarding& b) {
    a.Swap(&b);
  }
  inline void Swap(Onboarding* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Onboarding* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Onboarding* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Onboarding>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Onboarding& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Onboarding& from) {
    Onboarding::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Onboarding* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.settings.Onboarding";
  }
  protected:
  explicit Onboarding(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // optional int32 type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  int32_t type() const;
  void set_type(int32_t value);
  private:
  int32_t _internal_type() const;
  void _internal_set_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.settings.Onboarding)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fsettings_2eproto;
};
// -------------------------------------------------------------------

class Onboardings final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.settings.Onboardings) */ {
 public:
  inline Onboardings() : Onboardings(nullptr) {}
  ~Onboardings() override;
  explicit PROTOBUF_CONSTEXPR Onboardings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Onboardings(const Onboardings& from);
  Onboardings(Onboardings&& from) noexcept
    : Onboardings() {
    *this = ::std::move(from);
  }

  inline Onboardings& operator=(const Onboardings& from) {
    CopyFrom(from);
    return *this;
  }
  inline Onboardings& operator=(Onboardings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Onboardings& default_instance() {
    return *internal_default_instance();
  }
  static inline const Onboardings* internal_default_instance() {
    return reinterpret_cast<const Onboardings*>(
               &_Onboardings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Onboardings& a, Onboardings& b) {
    a.Swap(&b);
  }
  inline void Swap(Onboardings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Onboardings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Onboardings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Onboardings>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Onboardings& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Onboardings& from) {
    Onboardings::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Onboardings* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.settings.Onboardings";
  }
  protected:
  explicit Onboardings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOnboardingFieldNumber = 1,
  };
  // repeated .playapi.proto.finsky.settings.Onboarding onboarding = 1;
  int onboarding_size() const;
  private:
  int _internal_onboarding_size() const;
  public:
  void clear_onboarding();
  ::playapi::proto::finsky::settings::Onboarding* mutable_onboarding(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::settings::Onboarding >*
      mutable_onboarding();
  private:
  const ::playapi::proto::finsky::settings::Onboarding& _internal_onboarding(int index) const;
  ::playapi::proto::finsky::settings::Onboarding* _internal_add_onboarding();
  public:
  const ::playapi::proto::finsky::settings::Onboarding& onboarding(int index) const;
  ::playapi::proto::finsky::settings::Onboarding* add_onboarding();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::settings::Onboarding >&
      onboarding() const;

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.settings.Onboardings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::settings::Onboarding > onboarding_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fsettings_2eproto;
};
// -------------------------------------------------------------------

class UserSettings final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.settings.UserSettings) */ {
 public:
  inline UserSettings() : UserSettings(nullptr) {}
  ~UserSettings() override;
  explicit PROTOBUF_CONSTEXPR UserSettings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserSettings(const UserSettings& from);
  UserSettings(UserSettings&& from) noexcept
    : UserSettings() {
    *this = ::std::move(from);
  }

  inline UserSettings& operator=(const UserSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserSettings& operator=(UserSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserSettings* internal_default_instance() {
    return reinterpret_cast<const UserSettings*>(
               &_UserSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(UserSettings& a, UserSettings& b) {
    a.Swap(&b);
  }
  inline void Swap(UserSettings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserSettings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserSettings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserSettings>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserSettings& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserSettings& from) {
    UserSettings::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserSettings* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.settings.UserSettings";
  }
  protected:
  explicit UserSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarketingSettingsFieldNumber = 1,
    kPrivacySettingsFieldNumber = 2,
    kFamilyInfoFieldNumber = 3,
    kDismissedOnboardingsFieldNumber = 4,
  };
  // optional .playapi.proto.finsky.settings.MarketingSettings marketingSettings = 1;
  bool has_marketingsettings() const;
  private:
  bool _internal_has_marketingsettings() const;
  public:
  void clear_marketingsettings();
  const ::playapi::proto::finsky::settings::MarketingSettings& marketingsettings() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::settings::MarketingSettings* release_marketingsettings();
  ::playapi::proto::finsky::settings::MarketingSettings* mutable_marketingsettings();
  void set_allocated_marketingsettings(::playapi::proto::finsky::settings::MarketingSettings* marketingsettings);
  private:
  const ::playapi::proto::finsky::settings::MarketingSettings& _internal_marketingsettings() const;
  ::playapi::proto::finsky::settings::MarketingSettings* _internal_mutable_marketingsettings();
  public:
  void unsafe_arena_set_allocated_marketingsettings(
      ::playapi::proto::finsky::settings::MarketingSettings* marketingsettings);
  ::playapi::proto::finsky::settings::MarketingSettings* unsafe_arena_release_marketingsettings();

  // optional .playapi.proto.finsky.settings.PrivacySettings privacySettings = 2;
  bool has_privacysettings() const;
  private:
  bool _internal_has_privacysettings() const;
  public:
  void clear_privacysettings();
  const ::playapi::proto::finsky::settings::PrivacySettings& privacysettings() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::settings::PrivacySettings* release_privacysettings();
  ::playapi::proto::finsky::settings::PrivacySettings* mutable_privacysettings();
  void set_allocated_privacysettings(::playapi::proto::finsky::settings::PrivacySettings* privacysettings);
  private:
  const ::playapi::proto::finsky::settings::PrivacySettings& _internal_privacysettings() const;
  ::playapi::proto::finsky::settings::PrivacySettings* _internal_mutable_privacysettings();
  public:
  void unsafe_arena_set_allocated_privacysettings(
      ::playapi::proto::finsky::settings::PrivacySettings* privacysettings);
  ::playapi::proto::finsky::settings::PrivacySettings* unsafe_arena_release_privacysettings();

  // optional .playapi.proto.finsky.settings.FamilyInfo familyInfo = 3;
  bool has_familyinfo() const;
  private:
  bool _internal_has_familyinfo() const;
  public:
  void clear_familyinfo();
  const ::playapi::proto::finsky::settings::FamilyInfo& familyinfo() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::settings::FamilyInfo* release_familyinfo();
  ::playapi::proto::finsky::settings::FamilyInfo* mutable_familyinfo();
  void set_allocated_familyinfo(::playapi::proto::finsky::settings::FamilyInfo* familyinfo);
  private:
  const ::playapi::proto::finsky::settings::FamilyInfo& _internal_familyinfo() const;
  ::playapi::proto::finsky::settings::FamilyInfo* _internal_mutable_familyinfo();
  public:
  void unsafe_arena_set_allocated_familyinfo(
      ::playapi::proto::finsky::settings::FamilyInfo* familyinfo);
  ::playapi::proto::finsky::settings::FamilyInfo* unsafe_arena_release_familyinfo();

  // optional .playapi.proto.finsky.settings.Onboardings dismissedOnboardings = 4;
  bool has_dismissedonboardings() const;
  private:
  bool _internal_has_dismissedonboardings() const;
  public:
  void clear_dismissedonboardings();
  const ::playapi::proto::finsky::settings::Onboardings& dismissedonboardings() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::settings::Onboardings* release_dismissedonboardings();
  ::playapi::proto::finsky::settings::Onboardings* mutable_dismissedonboardings();
  void set_allocated_dismissedonboardings(::playapi::proto::finsky::settings::Onboardings* dismissedonboardings);
  private:
  const ::playapi::proto::finsky::settings::Onboardings& _internal_dismissedonboardings() const;
  ::playapi::proto::finsky::settings::Onboardings* _internal_mutable_dismissedonboardings();
  public:
  void unsafe_arena_set_allocated_dismissedonboardings(
      ::playapi::proto::finsky::settings::Onboardings* dismissedonboardings);
  ::playapi::proto::finsky::settings::Onboardings* unsafe_arena_release_dismissedonboardings();

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.settings.UserSettings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::playapi::proto::finsky::settings::MarketingSettings* marketingsettings_;
    ::playapi::proto::finsky::settings::PrivacySettings* privacysettings_;
    ::playapi::proto::finsky::settings::FamilyInfo* familyinfo_;
    ::playapi::proto::finsky::settings::Onboardings* dismissedonboardings_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fsettings_2eproto;
};
// -------------------------------------------------------------------

class OBSOLETEUserSettings final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.settings.OBSOLETEUserSettings) */ {
 public:
  inline OBSOLETEUserSettings() : OBSOLETEUserSettings(nullptr) {}
  ~OBSOLETEUserSettings() override;
  explicit PROTOBUF_CONSTEXPR OBSOLETEUserSettings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OBSOLETEUserSettings(const OBSOLETEUserSettings& from);
  OBSOLETEUserSettings(OBSOLETEUserSettings&& from) noexcept
    : OBSOLETEUserSettings() {
    *this = ::std::move(from);
  }

  inline OBSOLETEUserSettings& operator=(const OBSOLETEUserSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline OBSOLETEUserSettings& operator=(OBSOLETEUserSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OBSOLETEUserSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const OBSOLETEUserSettings* internal_default_instance() {
    return reinterpret_cast<const OBSOLETEUserSettings*>(
               &_OBSOLETEUserSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(OBSOLETEUserSettings& a, OBSOLETEUserSettings& b) {
    a.Swap(&b);
  }
  inline void Swap(OBSOLETEUserSettings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OBSOLETEUserSettings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OBSOLETEUserSettings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OBSOLETEUserSettings>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OBSOLETEUserSettings& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OBSOLETEUserSettings& from) {
    OBSOLETEUserSettings::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OBSOLETEUserSettings* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.settings.OBSOLETEUserSettings";
  }
  protected:
  explicit OBSOLETEUserSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrivacySettingFieldNumber = 2,
    kTosCheckboxMarketingEmailsOptedInFieldNumber = 1,
  };
  // repeated .playapi.proto.finsky.settings.PrivacySetting privacySetting = 2;
  int privacysetting_size() const;
  private:
  int _internal_privacysetting_size() const;
  public:
  void clear_privacysetting();
  ::playapi::proto::finsky::settings::PrivacySetting* mutable_privacysetting(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::settings::PrivacySetting >*
      mutable_privacysetting();
  private:
  const ::playapi::proto::finsky::settings::PrivacySetting& _internal_privacysetting(int index) const;
  ::playapi::proto::finsky::settings::PrivacySetting* _internal_add_privacysetting();
  public:
  const ::playapi::proto::finsky::settings::PrivacySetting& privacysetting(int index) const;
  ::playapi::proto::finsky::settings::PrivacySetting* add_privacysetting();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::settings::PrivacySetting >&
      privacysetting() const;

  // optional bool tosCheckboxMarketingEmailsOptedIn = 1;
  bool has_toscheckboxmarketingemailsoptedin() const;
  private:
  bool _internal_has_toscheckboxmarketingemailsoptedin() const;
  public:
  void clear_toscheckboxmarketingemailsoptedin();
  bool toscheckboxmarketingemailsoptedin() const;
  void set_toscheckboxmarketingemailsoptedin(bool value);
  private:
  bool _internal_toscheckboxmarketingemailsoptedin() const;
  void _internal_set_toscheckboxmarketingemailsoptedin(bool value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.settings.OBSOLETEUserSettings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::settings::PrivacySetting > privacysetting_;
    bool toscheckboxmarketingemailsoptedin_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fsettings_2eproto;
};
// -------------------------------------------------------------------

class UserSettingDirtyData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.settings.UserSettingDirtyData) */ {
 public:
  inline UserSettingDirtyData() : UserSettingDirtyData(nullptr) {}
  ~UserSettingDirtyData() override;
  explicit PROTOBUF_CONSTEXPR UserSettingDirtyData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserSettingDirtyData(const UserSettingDirtyData& from);
  UserSettingDirtyData(UserSettingDirtyData&& from) noexcept
    : UserSettingDirtyData() {
    *this = ::std::move(from);
  }

  inline UserSettingDirtyData& operator=(const UserSettingDirtyData& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserSettingDirtyData& operator=(UserSettingDirtyData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserSettingDirtyData& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserSettingDirtyData* internal_default_instance() {
    return reinterpret_cast<const UserSettingDirtyData*>(
               &_UserSettingDirtyData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(UserSettingDirtyData& a, UserSettingDirtyData& b) {
    a.Swap(&b);
  }
  inline void Swap(UserSettingDirtyData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserSettingDirtyData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserSettingDirtyData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserSettingDirtyData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserSettingDirtyData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserSettingDirtyData& from) {
    UserSettingDirtyData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserSettingDirtyData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.settings.UserSettingDirtyData";
  }
  protected:
  explicit UserSettingDirtyData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConsistencyTokensFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // optional .playapi.proto.finsky.settings.UserSettingsConsistencyTokens consistencyTokens = 2;
  bool has_consistencytokens() const;
  private:
  bool _internal_has_consistencytokens() const;
  public:
  void clear_consistencytokens();
  const ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens& consistencytokens() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens* release_consistencytokens();
  ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens* mutable_consistencytokens();
  void set_allocated_consistencytokens(::playapi::proto::finsky::settings::UserSettingsConsistencyTokens* consistencytokens);
  private:
  const ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens& _internal_consistencytokens() const;
  ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens* _internal_mutable_consistencytokens();
  public:
  void unsafe_arena_set_allocated_consistencytokens(
      ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens* consistencytokens);
  ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens* unsafe_arena_release_consistencytokens();

  // optional int32 type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  int32_t type() const;
  void set_type(int32_t value);
  private:
  int32_t _internal_type() const;
  void _internal_set_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.settings.UserSettingDirtyData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens* consistencytokens_;
    int32_t type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fsettings_2eproto;
};
// -------------------------------------------------------------------

class GetUserSettingsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.settings.GetUserSettingsResponse) */ {
 public:
  inline GetUserSettingsResponse() : GetUserSettingsResponse(nullptr) {}
  ~GetUserSettingsResponse() override;
  explicit PROTOBUF_CONSTEXPR GetUserSettingsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetUserSettingsResponse(const GetUserSettingsResponse& from);
  GetUserSettingsResponse(GetUserSettingsResponse&& from) noexcept
    : GetUserSettingsResponse() {
    *this = ::std::move(from);
  }

  inline GetUserSettingsResponse& operator=(const GetUserSettingsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUserSettingsResponse& operator=(GetUserSettingsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetUserSettingsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetUserSettingsResponse* internal_default_instance() {
    return reinterpret_cast<const GetUserSettingsResponse*>(
               &_GetUserSettingsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GetUserSettingsResponse& a, GetUserSettingsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetUserSettingsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUserSettingsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetUserSettingsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetUserSettingsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetUserSettingsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetUserSettingsResponse& from) {
    GetUserSettingsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetUserSettingsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.settings.GetUserSettingsResponse";
  }
  protected:
  explicit GetUserSettingsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserSettingsFieldNumber = 1,
    kConsistencyTokensFieldNumber = 2,
  };
  // optional .playapi.proto.finsky.settings.UserSettings userSettings = 1;
  bool has_usersettings() const;
  private:
  bool _internal_has_usersettings() const;
  public:
  void clear_usersettings();
  const ::playapi::proto::finsky::settings::UserSettings& usersettings() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::settings::UserSettings* release_usersettings();
  ::playapi::proto::finsky::settings::UserSettings* mutable_usersettings();
  void set_allocated_usersettings(::playapi::proto::finsky::settings::UserSettings* usersettings);
  private:
  const ::playapi::proto::finsky::settings::UserSettings& _internal_usersettings() const;
  ::playapi::proto::finsky::settings::UserSettings* _internal_mutable_usersettings();
  public:
  void unsafe_arena_set_allocated_usersettings(
      ::playapi::proto::finsky::settings::UserSettings* usersettings);
  ::playapi::proto::finsky::settings::UserSettings* unsafe_arena_release_usersettings();

  // optional .playapi.proto.finsky.settings.UserSettingsConsistencyTokens consistencyTokens = 2;
  bool has_consistencytokens() const;
  private:
  bool _internal_has_consistencytokens() const;
  public:
  void clear_consistencytokens();
  const ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens& consistencytokens() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens* release_consistencytokens();
  ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens* mutable_consistencytokens();
  void set_allocated_consistencytokens(::playapi::proto::finsky::settings::UserSettingsConsistencyTokens* consistencytokens);
  private:
  const ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens& _internal_consistencytokens() const;
  ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens* _internal_mutable_consistencytokens();
  public:
  void unsafe_arena_set_allocated_consistencytokens(
      ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens* consistencytokens);
  ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens* unsafe_arena_release_consistencytokens();

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.settings.GetUserSettingsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::playapi::proto::finsky::settings::UserSettings* usersettings_;
    ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens* consistencytokens_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fsettings_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// UserSettingsConsistencyTokens_ConsistencyTokenInfo

// optional string requestHeader = 1;
inline bool UserSettingsConsistencyTokens_ConsistencyTokenInfo::_internal_has_requestheader() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UserSettingsConsistencyTokens_ConsistencyTokenInfo::has_requestheader() const {
  return _internal_has_requestheader();
}
inline void UserSettingsConsistencyTokens_ConsistencyTokenInfo::clear_requestheader() {
  _impl_.requestheader_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UserSettingsConsistencyTokens_ConsistencyTokenInfo::requestheader() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.settings.UserSettingsConsistencyTokens.ConsistencyTokenInfo.requestHeader)
  return _internal_requestheader();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserSettingsConsistencyTokens_ConsistencyTokenInfo::set_requestheader(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.requestheader_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.settings.UserSettingsConsistencyTokens.ConsistencyTokenInfo.requestHeader)
}
inline std::string* UserSettingsConsistencyTokens_ConsistencyTokenInfo::mutable_requestheader() {
  std::string* _s = _internal_mutable_requestheader();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.settings.UserSettingsConsistencyTokens.ConsistencyTokenInfo.requestHeader)
  return _s;
}
inline const std::string& UserSettingsConsistencyTokens_ConsistencyTokenInfo::_internal_requestheader() const {
  return _impl_.requestheader_.Get();
}
inline void UserSettingsConsistencyTokens_ConsistencyTokenInfo::_internal_set_requestheader(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.requestheader_.Set(value, GetArenaForAllocation());
}
inline std::string* UserSettingsConsistencyTokens_ConsistencyTokenInfo::_internal_mutable_requestheader() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.requestheader_.Mutable(GetArenaForAllocation());
}
inline std::string* UserSettingsConsistencyTokens_ConsistencyTokenInfo::release_requestheader() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.settings.UserSettingsConsistencyTokens.ConsistencyTokenInfo.requestHeader)
  if (!_internal_has_requestheader()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.requestheader_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.requestheader_.IsDefault()) {
    _impl_.requestheader_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserSettingsConsistencyTokens_ConsistencyTokenInfo::set_allocated_requestheader(std::string* requestheader) {
  if (requestheader != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.requestheader_.SetAllocated(requestheader, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.requestheader_.IsDefault()) {
    _impl_.requestheader_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.settings.UserSettingsConsistencyTokens.ConsistencyTokenInfo.requestHeader)
}

// optional string consistencyToken = 2;
inline bool UserSettingsConsistencyTokens_ConsistencyTokenInfo::_internal_has_consistencytoken() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UserSettingsConsistencyTokens_ConsistencyTokenInfo::has_consistencytoken() const {
  return _internal_has_consistencytoken();
}
inline void UserSettingsConsistencyTokens_ConsistencyTokenInfo::clear_consistencytoken() {
  _impl_.consistencytoken_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UserSettingsConsistencyTokens_ConsistencyTokenInfo::consistencytoken() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.settings.UserSettingsConsistencyTokens.ConsistencyTokenInfo.consistencyToken)
  return _internal_consistencytoken();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserSettingsConsistencyTokens_ConsistencyTokenInfo::set_consistencytoken(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.consistencytoken_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.settings.UserSettingsConsistencyTokens.ConsistencyTokenInfo.consistencyToken)
}
inline std::string* UserSettingsConsistencyTokens_ConsistencyTokenInfo::mutable_consistencytoken() {
  std::string* _s = _internal_mutable_consistencytoken();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.settings.UserSettingsConsistencyTokens.ConsistencyTokenInfo.consistencyToken)
  return _s;
}
inline const std::string& UserSettingsConsistencyTokens_ConsistencyTokenInfo::_internal_consistencytoken() const {
  return _impl_.consistencytoken_.Get();
}
inline void UserSettingsConsistencyTokens_ConsistencyTokenInfo::_internal_set_consistencytoken(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.consistencytoken_.Set(value, GetArenaForAllocation());
}
inline std::string* UserSettingsConsistencyTokens_ConsistencyTokenInfo::_internal_mutable_consistencytoken() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.consistencytoken_.Mutable(GetArenaForAllocation());
}
inline std::string* UserSettingsConsistencyTokens_ConsistencyTokenInfo::release_consistencytoken() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.settings.UserSettingsConsistencyTokens.ConsistencyTokenInfo.consistencyToken)
  if (!_internal_has_consistencytoken()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.consistencytoken_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.consistencytoken_.IsDefault()) {
    _impl_.consistencytoken_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserSettingsConsistencyTokens_ConsistencyTokenInfo::set_allocated_consistencytoken(std::string* consistencytoken) {
  if (consistencytoken != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.consistencytoken_.SetAllocated(consistencytoken, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.consistencytoken_.IsDefault()) {
    _impl_.consistencytoken_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.settings.UserSettingsConsistencyTokens.ConsistencyTokenInfo.consistencyToken)
}

// -------------------------------------------------------------------

// UserSettingsConsistencyTokens

// repeated .playapi.proto.finsky.settings.UserSettingsConsistencyTokens.ConsistencyTokenInfo consistencyTokenInfo = 1;
inline int UserSettingsConsistencyTokens::_internal_consistencytokeninfo_size() const {
  return _impl_.consistencytokeninfo_.size();
}
inline int UserSettingsConsistencyTokens::consistencytokeninfo_size() const {
  return _internal_consistencytokeninfo_size();
}
inline void UserSettingsConsistencyTokens::clear_consistencytokeninfo() {
  _impl_.consistencytokeninfo_.Clear();
}
inline ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens_ConsistencyTokenInfo* UserSettingsConsistencyTokens::mutable_consistencytokeninfo(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.settings.UserSettingsConsistencyTokens.consistencyTokenInfo)
  return _impl_.consistencytokeninfo_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens_ConsistencyTokenInfo >*
UserSettingsConsistencyTokens::mutable_consistencytokeninfo() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.settings.UserSettingsConsistencyTokens.consistencyTokenInfo)
  return &_impl_.consistencytokeninfo_;
}
inline const ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens_ConsistencyTokenInfo& UserSettingsConsistencyTokens::_internal_consistencytokeninfo(int index) const {
  return _impl_.consistencytokeninfo_.Get(index);
}
inline const ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens_ConsistencyTokenInfo& UserSettingsConsistencyTokens::consistencytokeninfo(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.settings.UserSettingsConsistencyTokens.consistencyTokenInfo)
  return _internal_consistencytokeninfo(index);
}
inline ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens_ConsistencyTokenInfo* UserSettingsConsistencyTokens::_internal_add_consistencytokeninfo() {
  return _impl_.consistencytokeninfo_.Add();
}
inline ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens_ConsistencyTokenInfo* UserSettingsConsistencyTokens::add_consistencytokeninfo() {
  ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens_ConsistencyTokenInfo* _add = _internal_add_consistencytokeninfo();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.settings.UserSettingsConsistencyTokens.consistencyTokenInfo)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens_ConsistencyTokenInfo >&
UserSettingsConsistencyTokens::consistencytokeninfo() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.settings.UserSettingsConsistencyTokens.consistencyTokenInfo)
  return _impl_.consistencytokeninfo_;
}

// -------------------------------------------------------------------

// MarketingSettings

// optional bool marketingEmailsOptedIn = 1;
inline bool MarketingSettings::_internal_has_marketingemailsoptedin() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MarketingSettings::has_marketingemailsoptedin() const {
  return _internal_has_marketingemailsoptedin();
}
inline void MarketingSettings::clear_marketingemailsoptedin() {
  _impl_.marketingemailsoptedin_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool MarketingSettings::_internal_marketingemailsoptedin() const {
  return _impl_.marketingemailsoptedin_;
}
inline bool MarketingSettings::marketingemailsoptedin() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.settings.MarketingSettings.marketingEmailsOptedIn)
  return _internal_marketingemailsoptedin();
}
inline void MarketingSettings::_internal_set_marketingemailsoptedin(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.marketingemailsoptedin_ = value;
}
inline void MarketingSettings::set_marketingemailsoptedin(bool value) {
  _internal_set_marketingemailsoptedin(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.settings.MarketingSettings.marketingEmailsOptedIn)
}

// -------------------------------------------------------------------

// PrivacySetting

// optional int32 type = 1;
inline bool PrivacySetting::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PrivacySetting::has_type() const {
  return _internal_has_type();
}
inline void PrivacySetting::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t PrivacySetting::_internal_type() const {
  return _impl_.type_;
}
inline int32_t PrivacySetting::type() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.settings.PrivacySetting.type)
  return _internal_type();
}
inline void PrivacySetting::_internal_set_type(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_ = value;
}
inline void PrivacySetting::set_type(int32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.settings.PrivacySetting.type)
}

// optional int32 currentStatus = 2;
inline bool PrivacySetting::_internal_has_currentstatus() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PrivacySetting::has_currentstatus() const {
  return _internal_has_currentstatus();
}
inline void PrivacySetting::clear_currentstatus() {
  _impl_.currentstatus_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t PrivacySetting::_internal_currentstatus() const {
  return _impl_.currentstatus_;
}
inline int32_t PrivacySetting::currentstatus() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.settings.PrivacySetting.currentStatus)
  return _internal_currentstatus();
}
inline void PrivacySetting::_internal_set_currentstatus(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.currentstatus_ = value;
}
inline void PrivacySetting::set_currentstatus(int32_t value) {
  _internal_set_currentstatus(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.settings.PrivacySetting.currentStatus)
}

// optional bool enabledByDefault = 3;
inline bool PrivacySetting::_internal_has_enabledbydefault() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PrivacySetting::has_enabledbydefault() const {
  return _internal_has_enabledbydefault();
}
inline void PrivacySetting::clear_enabledbydefault() {
  _impl_.enabledbydefault_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool PrivacySetting::_internal_enabledbydefault() const {
  return _impl_.enabledbydefault_;
}
inline bool PrivacySetting::enabledbydefault() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.settings.PrivacySetting.enabledByDefault)
  return _internal_enabledbydefault();
}
inline void PrivacySetting::_internal_set_enabledbydefault(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.enabledbydefault_ = value;
}
inline void PrivacySetting::set_enabledbydefault(bool value) {
  _internal_set_enabledbydefault(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.settings.PrivacySetting.enabledByDefault)
}

// -------------------------------------------------------------------

// PrivacySettings

// repeated .playapi.proto.finsky.settings.PrivacySetting privacySetting = 1;
inline int PrivacySettings::_internal_privacysetting_size() const {
  return _impl_.privacysetting_.size();
}
inline int PrivacySettings::privacysetting_size() const {
  return _internal_privacysetting_size();
}
inline void PrivacySettings::clear_privacysetting() {
  _impl_.privacysetting_.Clear();
}
inline ::playapi::proto::finsky::settings::PrivacySetting* PrivacySettings::mutable_privacysetting(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.settings.PrivacySettings.privacySetting)
  return _impl_.privacysetting_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::settings::PrivacySetting >*
PrivacySettings::mutable_privacysetting() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.settings.PrivacySettings.privacySetting)
  return &_impl_.privacysetting_;
}
inline const ::playapi::proto::finsky::settings::PrivacySetting& PrivacySettings::_internal_privacysetting(int index) const {
  return _impl_.privacysetting_.Get(index);
}
inline const ::playapi::proto::finsky::settings::PrivacySetting& PrivacySettings::privacysetting(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.settings.PrivacySettings.privacySetting)
  return _internal_privacysetting(index);
}
inline ::playapi::proto::finsky::settings::PrivacySetting* PrivacySettings::_internal_add_privacysetting() {
  return _impl_.privacysetting_.Add();
}
inline ::playapi::proto::finsky::settings::PrivacySetting* PrivacySettings::add_privacysetting() {
  ::playapi::proto::finsky::settings::PrivacySetting* _add = _internal_add_privacysetting();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.settings.PrivacySettings.privacySetting)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::settings::PrivacySetting >&
PrivacySettings::privacysetting() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.settings.PrivacySettings.privacySetting)
  return _impl_.privacysetting_;
}

// -------------------------------------------------------------------

// FamilyInfo

// optional int32 familyMembershipStatus = 1;
inline bool FamilyInfo::_internal_has_familymembershipstatus() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FamilyInfo::has_familymembershipstatus() const {
  return _internal_has_familymembershipstatus();
}
inline void FamilyInfo::clear_familymembershipstatus() {
  _impl_.familymembershipstatus_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t FamilyInfo::_internal_familymembershipstatus() const {
  return _impl_.familymembershipstatus_;
}
inline int32_t FamilyInfo::familymembershipstatus() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.settings.FamilyInfo.familyMembershipStatus)
  return _internal_familymembershipstatus();
}
inline void FamilyInfo::_internal_set_familymembershipstatus(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.familymembershipstatus_ = value;
}
inline void FamilyInfo::set_familymembershipstatus(int32_t value) {
  _internal_set_familymembershipstatus(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.settings.FamilyInfo.familyMembershipStatus)
}

// optional .playapi.proto.finsky.settings.Family family = 2;
inline bool FamilyInfo::_internal_has_family() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.family_ != nullptr);
  return value;
}
inline bool FamilyInfo::has_family() const {
  return _internal_has_family();
}
inline void FamilyInfo::clear_family() {
  if (_impl_.family_ != nullptr) _impl_.family_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::playapi::proto::finsky::settings::Family& FamilyInfo::_internal_family() const {
  const ::playapi::proto::finsky::settings::Family* p = _impl_.family_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::settings::Family&>(
      ::playapi::proto::finsky::settings::_Family_default_instance_);
}
inline const ::playapi::proto::finsky::settings::Family& FamilyInfo::family() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.settings.FamilyInfo.family)
  return _internal_family();
}
inline void FamilyInfo::unsafe_arena_set_allocated_family(
    ::playapi::proto::finsky::settings::Family* family) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.family_);
  }
  _impl_.family_ = family;
  if (family) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.settings.FamilyInfo.family)
}
inline ::playapi::proto::finsky::settings::Family* FamilyInfo::release_family() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::playapi::proto::finsky::settings::Family* temp = _impl_.family_;
  _impl_.family_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::settings::Family* FamilyInfo::unsafe_arena_release_family() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.settings.FamilyInfo.family)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::playapi::proto::finsky::settings::Family* temp = _impl_.family_;
  _impl_.family_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::settings::Family* FamilyInfo::_internal_mutable_family() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.family_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::settings::Family>(GetArenaForAllocation());
    _impl_.family_ = p;
  }
  return _impl_.family_;
}
inline ::playapi::proto::finsky::settings::Family* FamilyInfo::mutable_family() {
  ::playapi::proto::finsky::settings::Family* _msg = _internal_mutable_family();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.settings.FamilyInfo.family)
  return _msg;
}
inline void FamilyInfo::set_allocated_family(::playapi::proto::finsky::settings::Family* family) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.family_;
  }
  if (family) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(family);
    if (message_arena != submessage_arena) {
      family = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, family, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.family_ = family;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.settings.FamilyInfo.family)
}

// -------------------------------------------------------------------

// Family

// repeated .playapi.proto.finsky.settings.FamilyMember member = 1;
inline int Family::_internal_member_size() const {
  return _impl_.member_.size();
}
inline int Family::member_size() const {
  return _internal_member_size();
}
inline void Family::clear_member() {
  _impl_.member_.Clear();
}
inline ::playapi::proto::finsky::settings::FamilyMember* Family::mutable_member(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.settings.Family.member)
  return _impl_.member_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::settings::FamilyMember >*
Family::mutable_member() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.settings.Family.member)
  return &_impl_.member_;
}
inline const ::playapi::proto::finsky::settings::FamilyMember& Family::_internal_member(int index) const {
  return _impl_.member_.Get(index);
}
inline const ::playapi::proto::finsky::settings::FamilyMember& Family::member(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.settings.Family.member)
  return _internal_member(index);
}
inline ::playapi::proto::finsky::settings::FamilyMember* Family::_internal_add_member() {
  return _impl_.member_.Add();
}
inline ::playapi::proto::finsky::settings::FamilyMember* Family::add_member() {
  ::playapi::proto::finsky::settings::FamilyMember* _add = _internal_add_member();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.settings.Family.member)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::settings::FamilyMember >&
Family::member() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.settings.Family.member)
  return _impl_.member_;
}

// -------------------------------------------------------------------

// FamilyMember

// optional int32 role = 1;
inline bool FamilyMember::_internal_has_role() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FamilyMember::has_role() const {
  return _internal_has_role();
}
inline void FamilyMember::clear_role() {
  _impl_.role_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t FamilyMember::_internal_role() const {
  return _impl_.role_;
}
inline int32_t FamilyMember::role() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.settings.FamilyMember.role)
  return _internal_role();
}
inline void FamilyMember::_internal_set_role(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.role_ = value;
}
inline void FamilyMember::set_role(int32_t value) {
  _internal_set_role(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.settings.FamilyMember.role)
}

// optional .playapi.proto.finsky.document.DocV2 personDocument = 2;
inline bool FamilyMember::_internal_has_persondocument() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.persondocument_ != nullptr);
  return value;
}
inline bool FamilyMember::has_persondocument() const {
  return _internal_has_persondocument();
}
inline const ::playapi::proto::finsky::document::DocV2& FamilyMember::_internal_persondocument() const {
  const ::playapi::proto::finsky::document::DocV2* p = _impl_.persondocument_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::DocV2&>(
      ::playapi::proto::finsky::document::_DocV2_default_instance_);
}
inline const ::playapi::proto::finsky::document::DocV2& FamilyMember::persondocument() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.settings.FamilyMember.personDocument)
  return _internal_persondocument();
}
inline void FamilyMember::unsafe_arena_set_allocated_persondocument(
    ::playapi::proto::finsky::document::DocV2* persondocument) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.persondocument_);
  }
  _impl_.persondocument_ = persondocument;
  if (persondocument) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.settings.FamilyMember.personDocument)
}
inline ::playapi::proto::finsky::document::DocV2* FamilyMember::release_persondocument() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::playapi::proto::finsky::document::DocV2* temp = _impl_.persondocument_;
  _impl_.persondocument_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::DocV2* FamilyMember::unsafe_arena_release_persondocument() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.settings.FamilyMember.personDocument)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::playapi::proto::finsky::document::DocV2* temp = _impl_.persondocument_;
  _impl_.persondocument_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::DocV2* FamilyMember::_internal_mutable_persondocument() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.persondocument_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::DocV2>(GetArenaForAllocation());
    _impl_.persondocument_ = p;
  }
  return _impl_.persondocument_;
}
inline ::playapi::proto::finsky::document::DocV2* FamilyMember::mutable_persondocument() {
  ::playapi::proto::finsky::document::DocV2* _msg = _internal_mutable_persondocument();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.settings.FamilyMember.personDocument)
  return _msg;
}
inline void FamilyMember::set_allocated_persondocument(::playapi::proto::finsky::document::DocV2* persondocument) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.persondocument_);
  }
  if (persondocument) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(persondocument));
    if (message_arena != submessage_arena) {
      persondocument = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, persondocument, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.persondocument_ = persondocument;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.settings.FamilyMember.personDocument)
}

// -------------------------------------------------------------------

// Onboarding

// optional int32 type = 1;
inline bool Onboarding::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Onboarding::has_type() const {
  return _internal_has_type();
}
inline void Onboarding::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t Onboarding::_internal_type() const {
  return _impl_.type_;
}
inline int32_t Onboarding::type() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.settings.Onboarding.type)
  return _internal_type();
}
inline void Onboarding::_internal_set_type(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_ = value;
}
inline void Onboarding::set_type(int32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.settings.Onboarding.type)
}

// -------------------------------------------------------------------

// Onboardings

// repeated .playapi.proto.finsky.settings.Onboarding onboarding = 1;
inline int Onboardings::_internal_onboarding_size() const {
  return _impl_.onboarding_.size();
}
inline int Onboardings::onboarding_size() const {
  return _internal_onboarding_size();
}
inline void Onboardings::clear_onboarding() {
  _impl_.onboarding_.Clear();
}
inline ::playapi::proto::finsky::settings::Onboarding* Onboardings::mutable_onboarding(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.settings.Onboardings.onboarding)
  return _impl_.onboarding_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::settings::Onboarding >*
Onboardings::mutable_onboarding() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.settings.Onboardings.onboarding)
  return &_impl_.onboarding_;
}
inline const ::playapi::proto::finsky::settings::Onboarding& Onboardings::_internal_onboarding(int index) const {
  return _impl_.onboarding_.Get(index);
}
inline const ::playapi::proto::finsky::settings::Onboarding& Onboardings::onboarding(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.settings.Onboardings.onboarding)
  return _internal_onboarding(index);
}
inline ::playapi::proto::finsky::settings::Onboarding* Onboardings::_internal_add_onboarding() {
  return _impl_.onboarding_.Add();
}
inline ::playapi::proto::finsky::settings::Onboarding* Onboardings::add_onboarding() {
  ::playapi::proto::finsky::settings::Onboarding* _add = _internal_add_onboarding();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.settings.Onboardings.onboarding)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::settings::Onboarding >&
Onboardings::onboarding() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.settings.Onboardings.onboarding)
  return _impl_.onboarding_;
}

// -------------------------------------------------------------------

// UserSettings

// optional .playapi.proto.finsky.settings.MarketingSettings marketingSettings = 1;
inline bool UserSettings::_internal_has_marketingsettings() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.marketingsettings_ != nullptr);
  return value;
}
inline bool UserSettings::has_marketingsettings() const {
  return _internal_has_marketingsettings();
}
inline void UserSettings::clear_marketingsettings() {
  if (_impl_.marketingsettings_ != nullptr) _impl_.marketingsettings_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::playapi::proto::finsky::settings::MarketingSettings& UserSettings::_internal_marketingsettings() const {
  const ::playapi::proto::finsky::settings::MarketingSettings* p = _impl_.marketingsettings_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::settings::MarketingSettings&>(
      ::playapi::proto::finsky::settings::_MarketingSettings_default_instance_);
}
inline const ::playapi::proto::finsky::settings::MarketingSettings& UserSettings::marketingsettings() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.settings.UserSettings.marketingSettings)
  return _internal_marketingsettings();
}
inline void UserSettings::unsafe_arena_set_allocated_marketingsettings(
    ::playapi::proto::finsky::settings::MarketingSettings* marketingsettings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.marketingsettings_);
  }
  _impl_.marketingsettings_ = marketingsettings;
  if (marketingsettings) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.settings.UserSettings.marketingSettings)
}
inline ::playapi::proto::finsky::settings::MarketingSettings* UserSettings::release_marketingsettings() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::playapi::proto::finsky::settings::MarketingSettings* temp = _impl_.marketingsettings_;
  _impl_.marketingsettings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::settings::MarketingSettings* UserSettings::unsafe_arena_release_marketingsettings() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.settings.UserSettings.marketingSettings)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::playapi::proto::finsky::settings::MarketingSettings* temp = _impl_.marketingsettings_;
  _impl_.marketingsettings_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::settings::MarketingSettings* UserSettings::_internal_mutable_marketingsettings() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.marketingsettings_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::settings::MarketingSettings>(GetArenaForAllocation());
    _impl_.marketingsettings_ = p;
  }
  return _impl_.marketingsettings_;
}
inline ::playapi::proto::finsky::settings::MarketingSettings* UserSettings::mutable_marketingsettings() {
  ::playapi::proto::finsky::settings::MarketingSettings* _msg = _internal_mutable_marketingsettings();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.settings.UserSettings.marketingSettings)
  return _msg;
}
inline void UserSettings::set_allocated_marketingsettings(::playapi::proto::finsky::settings::MarketingSettings* marketingsettings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.marketingsettings_;
  }
  if (marketingsettings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(marketingsettings);
    if (message_arena != submessage_arena) {
      marketingsettings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, marketingsettings, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.marketingsettings_ = marketingsettings;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.settings.UserSettings.marketingSettings)
}

// optional .playapi.proto.finsky.settings.PrivacySettings privacySettings = 2;
inline bool UserSettings::_internal_has_privacysettings() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.privacysettings_ != nullptr);
  return value;
}
inline bool UserSettings::has_privacysettings() const {
  return _internal_has_privacysettings();
}
inline void UserSettings::clear_privacysettings() {
  if (_impl_.privacysettings_ != nullptr) _impl_.privacysettings_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::playapi::proto::finsky::settings::PrivacySettings& UserSettings::_internal_privacysettings() const {
  const ::playapi::proto::finsky::settings::PrivacySettings* p = _impl_.privacysettings_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::settings::PrivacySettings&>(
      ::playapi::proto::finsky::settings::_PrivacySettings_default_instance_);
}
inline const ::playapi::proto::finsky::settings::PrivacySettings& UserSettings::privacysettings() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.settings.UserSettings.privacySettings)
  return _internal_privacysettings();
}
inline void UserSettings::unsafe_arena_set_allocated_privacysettings(
    ::playapi::proto::finsky::settings::PrivacySettings* privacysettings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.privacysettings_);
  }
  _impl_.privacysettings_ = privacysettings;
  if (privacysettings) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.settings.UserSettings.privacySettings)
}
inline ::playapi::proto::finsky::settings::PrivacySettings* UserSettings::release_privacysettings() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::playapi::proto::finsky::settings::PrivacySettings* temp = _impl_.privacysettings_;
  _impl_.privacysettings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::settings::PrivacySettings* UserSettings::unsafe_arena_release_privacysettings() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.settings.UserSettings.privacySettings)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::playapi::proto::finsky::settings::PrivacySettings* temp = _impl_.privacysettings_;
  _impl_.privacysettings_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::settings::PrivacySettings* UserSettings::_internal_mutable_privacysettings() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.privacysettings_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::settings::PrivacySettings>(GetArenaForAllocation());
    _impl_.privacysettings_ = p;
  }
  return _impl_.privacysettings_;
}
inline ::playapi::proto::finsky::settings::PrivacySettings* UserSettings::mutable_privacysettings() {
  ::playapi::proto::finsky::settings::PrivacySettings* _msg = _internal_mutable_privacysettings();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.settings.UserSettings.privacySettings)
  return _msg;
}
inline void UserSettings::set_allocated_privacysettings(::playapi::proto::finsky::settings::PrivacySettings* privacysettings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.privacysettings_;
  }
  if (privacysettings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(privacysettings);
    if (message_arena != submessage_arena) {
      privacysettings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, privacysettings, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.privacysettings_ = privacysettings;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.settings.UserSettings.privacySettings)
}

// optional .playapi.proto.finsky.settings.FamilyInfo familyInfo = 3;
inline bool UserSettings::_internal_has_familyinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.familyinfo_ != nullptr);
  return value;
}
inline bool UserSettings::has_familyinfo() const {
  return _internal_has_familyinfo();
}
inline void UserSettings::clear_familyinfo() {
  if (_impl_.familyinfo_ != nullptr) _impl_.familyinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::playapi::proto::finsky::settings::FamilyInfo& UserSettings::_internal_familyinfo() const {
  const ::playapi::proto::finsky::settings::FamilyInfo* p = _impl_.familyinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::settings::FamilyInfo&>(
      ::playapi::proto::finsky::settings::_FamilyInfo_default_instance_);
}
inline const ::playapi::proto::finsky::settings::FamilyInfo& UserSettings::familyinfo() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.settings.UserSettings.familyInfo)
  return _internal_familyinfo();
}
inline void UserSettings::unsafe_arena_set_allocated_familyinfo(
    ::playapi::proto::finsky::settings::FamilyInfo* familyinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.familyinfo_);
  }
  _impl_.familyinfo_ = familyinfo;
  if (familyinfo) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.settings.UserSettings.familyInfo)
}
inline ::playapi::proto::finsky::settings::FamilyInfo* UserSettings::release_familyinfo() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::playapi::proto::finsky::settings::FamilyInfo* temp = _impl_.familyinfo_;
  _impl_.familyinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::settings::FamilyInfo* UserSettings::unsafe_arena_release_familyinfo() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.settings.UserSettings.familyInfo)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::playapi::proto::finsky::settings::FamilyInfo* temp = _impl_.familyinfo_;
  _impl_.familyinfo_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::settings::FamilyInfo* UserSettings::_internal_mutable_familyinfo() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.familyinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::settings::FamilyInfo>(GetArenaForAllocation());
    _impl_.familyinfo_ = p;
  }
  return _impl_.familyinfo_;
}
inline ::playapi::proto::finsky::settings::FamilyInfo* UserSettings::mutable_familyinfo() {
  ::playapi::proto::finsky::settings::FamilyInfo* _msg = _internal_mutable_familyinfo();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.settings.UserSettings.familyInfo)
  return _msg;
}
inline void UserSettings::set_allocated_familyinfo(::playapi::proto::finsky::settings::FamilyInfo* familyinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.familyinfo_;
  }
  if (familyinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(familyinfo);
    if (message_arena != submessage_arena) {
      familyinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, familyinfo, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.familyinfo_ = familyinfo;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.settings.UserSettings.familyInfo)
}

// optional .playapi.proto.finsky.settings.Onboardings dismissedOnboardings = 4;
inline bool UserSettings::_internal_has_dismissedonboardings() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dismissedonboardings_ != nullptr);
  return value;
}
inline bool UserSettings::has_dismissedonboardings() const {
  return _internal_has_dismissedonboardings();
}
inline void UserSettings::clear_dismissedonboardings() {
  if (_impl_.dismissedonboardings_ != nullptr) _impl_.dismissedonboardings_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::playapi::proto::finsky::settings::Onboardings& UserSettings::_internal_dismissedonboardings() const {
  const ::playapi::proto::finsky::settings::Onboardings* p = _impl_.dismissedonboardings_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::settings::Onboardings&>(
      ::playapi::proto::finsky::settings::_Onboardings_default_instance_);
}
inline const ::playapi::proto::finsky::settings::Onboardings& UserSettings::dismissedonboardings() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.settings.UserSettings.dismissedOnboardings)
  return _internal_dismissedonboardings();
}
inline void UserSettings::unsafe_arena_set_allocated_dismissedonboardings(
    ::playapi::proto::finsky::settings::Onboardings* dismissedonboardings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dismissedonboardings_);
  }
  _impl_.dismissedonboardings_ = dismissedonboardings;
  if (dismissedonboardings) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.settings.UserSettings.dismissedOnboardings)
}
inline ::playapi::proto::finsky::settings::Onboardings* UserSettings::release_dismissedonboardings() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::playapi::proto::finsky::settings::Onboardings* temp = _impl_.dismissedonboardings_;
  _impl_.dismissedonboardings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::settings::Onboardings* UserSettings::unsafe_arena_release_dismissedonboardings() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.settings.UserSettings.dismissedOnboardings)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::playapi::proto::finsky::settings::Onboardings* temp = _impl_.dismissedonboardings_;
  _impl_.dismissedonboardings_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::settings::Onboardings* UserSettings::_internal_mutable_dismissedonboardings() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.dismissedonboardings_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::settings::Onboardings>(GetArenaForAllocation());
    _impl_.dismissedonboardings_ = p;
  }
  return _impl_.dismissedonboardings_;
}
inline ::playapi::proto::finsky::settings::Onboardings* UserSettings::mutable_dismissedonboardings() {
  ::playapi::proto::finsky::settings::Onboardings* _msg = _internal_mutable_dismissedonboardings();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.settings.UserSettings.dismissedOnboardings)
  return _msg;
}
inline void UserSettings::set_allocated_dismissedonboardings(::playapi::proto::finsky::settings::Onboardings* dismissedonboardings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.dismissedonboardings_;
  }
  if (dismissedonboardings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dismissedonboardings);
    if (message_arena != submessage_arena) {
      dismissedonboardings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dismissedonboardings, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.dismissedonboardings_ = dismissedonboardings;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.settings.UserSettings.dismissedOnboardings)
}

// -------------------------------------------------------------------

// OBSOLETEUserSettings

// optional bool tosCheckboxMarketingEmailsOptedIn = 1;
inline bool OBSOLETEUserSettings::_internal_has_toscheckboxmarketingemailsoptedin() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OBSOLETEUserSettings::has_toscheckboxmarketingemailsoptedin() const {
  return _internal_has_toscheckboxmarketingemailsoptedin();
}
inline void OBSOLETEUserSettings::clear_toscheckboxmarketingemailsoptedin() {
  _impl_.toscheckboxmarketingemailsoptedin_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool OBSOLETEUserSettings::_internal_toscheckboxmarketingemailsoptedin() const {
  return _impl_.toscheckboxmarketingemailsoptedin_;
}
inline bool OBSOLETEUserSettings::toscheckboxmarketingemailsoptedin() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.settings.OBSOLETEUserSettings.tosCheckboxMarketingEmailsOptedIn)
  return _internal_toscheckboxmarketingemailsoptedin();
}
inline void OBSOLETEUserSettings::_internal_set_toscheckboxmarketingemailsoptedin(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.toscheckboxmarketingemailsoptedin_ = value;
}
inline void OBSOLETEUserSettings::set_toscheckboxmarketingemailsoptedin(bool value) {
  _internal_set_toscheckboxmarketingemailsoptedin(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.settings.OBSOLETEUserSettings.tosCheckboxMarketingEmailsOptedIn)
}

// repeated .playapi.proto.finsky.settings.PrivacySetting privacySetting = 2;
inline int OBSOLETEUserSettings::_internal_privacysetting_size() const {
  return _impl_.privacysetting_.size();
}
inline int OBSOLETEUserSettings::privacysetting_size() const {
  return _internal_privacysetting_size();
}
inline void OBSOLETEUserSettings::clear_privacysetting() {
  _impl_.privacysetting_.Clear();
}
inline ::playapi::proto::finsky::settings::PrivacySetting* OBSOLETEUserSettings::mutable_privacysetting(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.settings.OBSOLETEUserSettings.privacySetting)
  return _impl_.privacysetting_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::settings::PrivacySetting >*
OBSOLETEUserSettings::mutable_privacysetting() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.settings.OBSOLETEUserSettings.privacySetting)
  return &_impl_.privacysetting_;
}
inline const ::playapi::proto::finsky::settings::PrivacySetting& OBSOLETEUserSettings::_internal_privacysetting(int index) const {
  return _impl_.privacysetting_.Get(index);
}
inline const ::playapi::proto::finsky::settings::PrivacySetting& OBSOLETEUserSettings::privacysetting(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.settings.OBSOLETEUserSettings.privacySetting)
  return _internal_privacysetting(index);
}
inline ::playapi::proto::finsky::settings::PrivacySetting* OBSOLETEUserSettings::_internal_add_privacysetting() {
  return _impl_.privacysetting_.Add();
}
inline ::playapi::proto::finsky::settings::PrivacySetting* OBSOLETEUserSettings::add_privacysetting() {
  ::playapi::proto::finsky::settings::PrivacySetting* _add = _internal_add_privacysetting();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.settings.OBSOLETEUserSettings.privacySetting)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::settings::PrivacySetting >&
OBSOLETEUserSettings::privacysetting() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.settings.OBSOLETEUserSettings.privacySetting)
  return _impl_.privacysetting_;
}

// -------------------------------------------------------------------

// UserSettingDirtyData

// optional int32 type = 1;
inline bool UserSettingDirtyData::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UserSettingDirtyData::has_type() const {
  return _internal_has_type();
}
inline void UserSettingDirtyData::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t UserSettingDirtyData::_internal_type() const {
  return _impl_.type_;
}
inline int32_t UserSettingDirtyData::type() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.settings.UserSettingDirtyData.type)
  return _internal_type();
}
inline void UserSettingDirtyData::_internal_set_type(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}
inline void UserSettingDirtyData::set_type(int32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.settings.UserSettingDirtyData.type)
}

// optional .playapi.proto.finsky.settings.UserSettingsConsistencyTokens consistencyTokens = 2;
inline bool UserSettingDirtyData::_internal_has_consistencytokens() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.consistencytokens_ != nullptr);
  return value;
}
inline bool UserSettingDirtyData::has_consistencytokens() const {
  return _internal_has_consistencytokens();
}
inline void UserSettingDirtyData::clear_consistencytokens() {
  if (_impl_.consistencytokens_ != nullptr) _impl_.consistencytokens_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens& UserSettingDirtyData::_internal_consistencytokens() const {
  const ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens* p = _impl_.consistencytokens_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens&>(
      ::playapi::proto::finsky::settings::_UserSettingsConsistencyTokens_default_instance_);
}
inline const ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens& UserSettingDirtyData::consistencytokens() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.settings.UserSettingDirtyData.consistencyTokens)
  return _internal_consistencytokens();
}
inline void UserSettingDirtyData::unsafe_arena_set_allocated_consistencytokens(
    ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens* consistencytokens) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.consistencytokens_);
  }
  _impl_.consistencytokens_ = consistencytokens;
  if (consistencytokens) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.settings.UserSettingDirtyData.consistencyTokens)
}
inline ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens* UserSettingDirtyData::release_consistencytokens() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens* temp = _impl_.consistencytokens_;
  _impl_.consistencytokens_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens* UserSettingDirtyData::unsafe_arena_release_consistencytokens() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.settings.UserSettingDirtyData.consistencyTokens)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens* temp = _impl_.consistencytokens_;
  _impl_.consistencytokens_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens* UserSettingDirtyData::_internal_mutable_consistencytokens() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.consistencytokens_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::settings::UserSettingsConsistencyTokens>(GetArenaForAllocation());
    _impl_.consistencytokens_ = p;
  }
  return _impl_.consistencytokens_;
}
inline ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens* UserSettingDirtyData::mutable_consistencytokens() {
  ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens* _msg = _internal_mutable_consistencytokens();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.settings.UserSettingDirtyData.consistencyTokens)
  return _msg;
}
inline void UserSettingDirtyData::set_allocated_consistencytokens(::playapi::proto::finsky::settings::UserSettingsConsistencyTokens* consistencytokens) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.consistencytokens_;
  }
  if (consistencytokens) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(consistencytokens);
    if (message_arena != submessage_arena) {
      consistencytokens = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, consistencytokens, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.consistencytokens_ = consistencytokens;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.settings.UserSettingDirtyData.consistencyTokens)
}

// -------------------------------------------------------------------

// GetUserSettingsResponse

// optional .playapi.proto.finsky.settings.UserSettings userSettings = 1;
inline bool GetUserSettingsResponse::_internal_has_usersettings() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.usersettings_ != nullptr);
  return value;
}
inline bool GetUserSettingsResponse::has_usersettings() const {
  return _internal_has_usersettings();
}
inline void GetUserSettingsResponse::clear_usersettings() {
  if (_impl_.usersettings_ != nullptr) _impl_.usersettings_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::playapi::proto::finsky::settings::UserSettings& GetUserSettingsResponse::_internal_usersettings() const {
  const ::playapi::proto::finsky::settings::UserSettings* p = _impl_.usersettings_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::settings::UserSettings&>(
      ::playapi::proto::finsky::settings::_UserSettings_default_instance_);
}
inline const ::playapi::proto::finsky::settings::UserSettings& GetUserSettingsResponse::usersettings() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.settings.GetUserSettingsResponse.userSettings)
  return _internal_usersettings();
}
inline void GetUserSettingsResponse::unsafe_arena_set_allocated_usersettings(
    ::playapi::proto::finsky::settings::UserSettings* usersettings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.usersettings_);
  }
  _impl_.usersettings_ = usersettings;
  if (usersettings) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.settings.GetUserSettingsResponse.userSettings)
}
inline ::playapi::proto::finsky::settings::UserSettings* GetUserSettingsResponse::release_usersettings() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::playapi::proto::finsky::settings::UserSettings* temp = _impl_.usersettings_;
  _impl_.usersettings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::settings::UserSettings* GetUserSettingsResponse::unsafe_arena_release_usersettings() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.settings.GetUserSettingsResponse.userSettings)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::playapi::proto::finsky::settings::UserSettings* temp = _impl_.usersettings_;
  _impl_.usersettings_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::settings::UserSettings* GetUserSettingsResponse::_internal_mutable_usersettings() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.usersettings_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::settings::UserSettings>(GetArenaForAllocation());
    _impl_.usersettings_ = p;
  }
  return _impl_.usersettings_;
}
inline ::playapi::proto::finsky::settings::UserSettings* GetUserSettingsResponse::mutable_usersettings() {
  ::playapi::proto::finsky::settings::UserSettings* _msg = _internal_mutable_usersettings();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.settings.GetUserSettingsResponse.userSettings)
  return _msg;
}
inline void GetUserSettingsResponse::set_allocated_usersettings(::playapi::proto::finsky::settings::UserSettings* usersettings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.usersettings_;
  }
  if (usersettings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(usersettings);
    if (message_arena != submessage_arena) {
      usersettings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, usersettings, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.usersettings_ = usersettings;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.settings.GetUserSettingsResponse.userSettings)
}

// optional .playapi.proto.finsky.settings.UserSettingsConsistencyTokens consistencyTokens = 2;
inline bool GetUserSettingsResponse::_internal_has_consistencytokens() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.consistencytokens_ != nullptr);
  return value;
}
inline bool GetUserSettingsResponse::has_consistencytokens() const {
  return _internal_has_consistencytokens();
}
inline void GetUserSettingsResponse::clear_consistencytokens() {
  if (_impl_.consistencytokens_ != nullptr) _impl_.consistencytokens_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens& GetUserSettingsResponse::_internal_consistencytokens() const {
  const ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens* p = _impl_.consistencytokens_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens&>(
      ::playapi::proto::finsky::settings::_UserSettingsConsistencyTokens_default_instance_);
}
inline const ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens& GetUserSettingsResponse::consistencytokens() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.settings.GetUserSettingsResponse.consistencyTokens)
  return _internal_consistencytokens();
}
inline void GetUserSettingsResponse::unsafe_arena_set_allocated_consistencytokens(
    ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens* consistencytokens) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.consistencytokens_);
  }
  _impl_.consistencytokens_ = consistencytokens;
  if (consistencytokens) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.settings.GetUserSettingsResponse.consistencyTokens)
}
inline ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens* GetUserSettingsResponse::release_consistencytokens() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens* temp = _impl_.consistencytokens_;
  _impl_.consistencytokens_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens* GetUserSettingsResponse::unsafe_arena_release_consistencytokens() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.settings.GetUserSettingsResponse.consistencyTokens)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens* temp = _impl_.consistencytokens_;
  _impl_.consistencytokens_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens* GetUserSettingsResponse::_internal_mutable_consistencytokens() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.consistencytokens_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::settings::UserSettingsConsistencyTokens>(GetArenaForAllocation());
    _impl_.consistencytokens_ = p;
  }
  return _impl_.consistencytokens_;
}
inline ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens* GetUserSettingsResponse::mutable_consistencytokens() {
  ::playapi::proto::finsky::settings::UserSettingsConsistencyTokens* _msg = _internal_mutable_consistencytokens();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.settings.GetUserSettingsResponse.consistencyTokens)
  return _msg;
}
inline void GetUserSettingsResponse::set_allocated_consistencytokens(::playapi::proto::finsky::settings::UserSettingsConsistencyTokens* consistencytokens) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.consistencytokens_;
  }
  if (consistencytokens) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(consistencytokens);
    if (message_arena != submessage_arena) {
      consistencytokens = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, consistencytokens, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.consistencytokens_ = consistencytokens;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.settings.GetUserSettingsResponse.consistencyTokens)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace settings
}  // namespace finsky
}  // namespace proto
}  // namespace playapi

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_play_5fsettings_2eproto
