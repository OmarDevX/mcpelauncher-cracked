// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: play_ownership.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_play_5fownership_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_play_5fownership_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "play_common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_play_5fownership_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_play_5fownership_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_play_5fownership_2eproto;
namespace playapi {
namespace proto {
namespace finsky {
namespace ownership {
class OwnershipInfo;
struct OwnershipInfoDefaultTypeInternal;
extern OwnershipInfoDefaultTypeInternal _OwnershipInfo_default_instance_;
}  // namespace ownership
}  // namespace finsky
}  // namespace proto
}  // namespace playapi
PROTOBUF_NAMESPACE_OPEN
template<> ::playapi::proto::finsky::ownership::OwnershipInfo* Arena::CreateMaybeMessage<::playapi::proto::finsky::ownership::OwnershipInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace playapi {
namespace proto {
namespace finsky {
namespace ownership {

// ===================================================================

class OwnershipInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.ownership.OwnershipInfo) */ {
 public:
  inline OwnershipInfo() : OwnershipInfo(nullptr) {}
  ~OwnershipInfo() override;
  explicit PROTOBUF_CONSTEXPR OwnershipInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OwnershipInfo(const OwnershipInfo& from);
  OwnershipInfo(OwnershipInfo&& from) noexcept
    : OwnershipInfo() {
    *this = ::std::move(from);
  }

  inline OwnershipInfo& operator=(const OwnershipInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline OwnershipInfo& operator=(OwnershipInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OwnershipInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const OwnershipInfo* internal_default_instance() {
    return reinterpret_cast<const OwnershipInfo*>(
               &_OwnershipInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(OwnershipInfo& a, OwnershipInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(OwnershipInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OwnershipInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OwnershipInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OwnershipInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OwnershipInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OwnershipInfo& from) {
    OwnershipInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OwnershipInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.ownership.OwnershipInfo";
  }
  protected:
  explicit OwnershipInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeveloperPurchaseInfoFieldNumber = 6,
    kRentalTermsFieldNumber = 9,
    kGroupLicenseInfoFieldNumber = 10,
    kLicensedDocumentInfoFieldNumber = 11,
    kLibraryVoucherFieldNumber = 15,
    kBundleDocidFieldNumber = 16,
    kInitiationTimestampMsecFieldNumber = 1,
    kValidUntilTimestampMsecFieldNumber = 2,
    kRefundTimeoutTimestampMsecFieldNumber = 4,
    kPostDeliveryRefundWindowMsecFieldNumber = 5,
    kAutoRenewingFieldNumber = 3,
    kPreorderedFieldNumber = 7,
    kHiddenFieldNumber = 8,
    kBonusFieldNumber = 17,
    kQuantityFieldNumber = 12,
    kLibraryExpirationTimestampMsecFieldNumber = 14,
    kStoredValidUntilTimestampMsecFieldNumber = 18,
  };
  // optional .playapi.proto.finsky.SignedData developerPurchaseInfo = 6;
  bool has_developerpurchaseinfo() const;
  private:
  bool _internal_has_developerpurchaseinfo() const;
  public:
  void clear_developerpurchaseinfo();
  const ::playapi::proto::finsky::SignedData& developerpurchaseinfo() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::SignedData* release_developerpurchaseinfo();
  ::playapi::proto::finsky::SignedData* mutable_developerpurchaseinfo();
  void set_allocated_developerpurchaseinfo(::playapi::proto::finsky::SignedData* developerpurchaseinfo);
  private:
  const ::playapi::proto::finsky::SignedData& _internal_developerpurchaseinfo() const;
  ::playapi::proto::finsky::SignedData* _internal_mutable_developerpurchaseinfo();
  public:
  void unsafe_arena_set_allocated_developerpurchaseinfo(
      ::playapi::proto::finsky::SignedData* developerpurchaseinfo);
  ::playapi::proto::finsky::SignedData* unsafe_arena_release_developerpurchaseinfo();

  // optional .playapi.proto.finsky.RentalTerms rentalTerms = 9;
  bool has_rentalterms() const;
  private:
  bool _internal_has_rentalterms() const;
  public:
  void clear_rentalterms();
  const ::playapi::proto::finsky::RentalTerms& rentalterms() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::RentalTerms* release_rentalterms();
  ::playapi::proto::finsky::RentalTerms* mutable_rentalterms();
  void set_allocated_rentalterms(::playapi::proto::finsky::RentalTerms* rentalterms);
  private:
  const ::playapi::proto::finsky::RentalTerms& _internal_rentalterms() const;
  ::playapi::proto::finsky::RentalTerms* _internal_mutable_rentalterms();
  public:
  void unsafe_arena_set_allocated_rentalterms(
      ::playapi::proto::finsky::RentalTerms* rentalterms);
  ::playapi::proto::finsky::RentalTerms* unsafe_arena_release_rentalterms();

  // optional .playapi.proto.finsky.GroupLicenseInfo groupLicenseInfo = 10;
  bool has_grouplicenseinfo() const;
  private:
  bool _internal_has_grouplicenseinfo() const;
  public:
  void clear_grouplicenseinfo();
  const ::playapi::proto::finsky::GroupLicenseInfo& grouplicenseinfo() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::GroupLicenseInfo* release_grouplicenseinfo();
  ::playapi::proto::finsky::GroupLicenseInfo* mutable_grouplicenseinfo();
  void set_allocated_grouplicenseinfo(::playapi::proto::finsky::GroupLicenseInfo* grouplicenseinfo);
  private:
  const ::playapi::proto::finsky::GroupLicenseInfo& _internal_grouplicenseinfo() const;
  ::playapi::proto::finsky::GroupLicenseInfo* _internal_mutable_grouplicenseinfo();
  public:
  void unsafe_arena_set_allocated_grouplicenseinfo(
      ::playapi::proto::finsky::GroupLicenseInfo* grouplicenseinfo);
  ::playapi::proto::finsky::GroupLicenseInfo* unsafe_arena_release_grouplicenseinfo();

  // optional .playapi.proto.finsky.LicensedDocumentInfo licensedDocumentInfo = 11;
  bool has_licenseddocumentinfo() const;
  private:
  bool _internal_has_licenseddocumentinfo() const;
  public:
  void clear_licenseddocumentinfo();
  const ::playapi::proto::finsky::LicensedDocumentInfo& licenseddocumentinfo() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::LicensedDocumentInfo* release_licenseddocumentinfo();
  ::playapi::proto::finsky::LicensedDocumentInfo* mutable_licenseddocumentinfo();
  void set_allocated_licenseddocumentinfo(::playapi::proto::finsky::LicensedDocumentInfo* licenseddocumentinfo);
  private:
  const ::playapi::proto::finsky::LicensedDocumentInfo& _internal_licenseddocumentinfo() const;
  ::playapi::proto::finsky::LicensedDocumentInfo* _internal_mutable_licenseddocumentinfo();
  public:
  void unsafe_arena_set_allocated_licenseddocumentinfo(
      ::playapi::proto::finsky::LicensedDocumentInfo* licenseddocumentinfo);
  ::playapi::proto::finsky::LicensedDocumentInfo* unsafe_arena_release_licenseddocumentinfo();

  // optional .playapi.proto.finsky.LibraryVoucher libraryVoucher = 15;
  bool has_libraryvoucher() const;
  private:
  bool _internal_has_libraryvoucher() const;
  public:
  void clear_libraryvoucher();
  const ::playapi::proto::finsky::LibraryVoucher& libraryvoucher() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::LibraryVoucher* release_libraryvoucher();
  ::playapi::proto::finsky::LibraryVoucher* mutable_libraryvoucher();
  void set_allocated_libraryvoucher(::playapi::proto::finsky::LibraryVoucher* libraryvoucher);
  private:
  const ::playapi::proto::finsky::LibraryVoucher& _internal_libraryvoucher() const;
  ::playapi::proto::finsky::LibraryVoucher* _internal_mutable_libraryvoucher();
  public:
  void unsafe_arena_set_allocated_libraryvoucher(
      ::playapi::proto::finsky::LibraryVoucher* libraryvoucher);
  ::playapi::proto::finsky::LibraryVoucher* unsafe_arena_release_libraryvoucher();

  // optional .playapi.proto.finsky.Docid bundleDocid = 16;
  bool has_bundledocid() const;
  private:
  bool _internal_has_bundledocid() const;
  public:
  void clear_bundledocid();
  const ::playapi::proto::finsky::Docid& bundledocid() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::Docid* release_bundledocid();
  ::playapi::proto::finsky::Docid* mutable_bundledocid();
  void set_allocated_bundledocid(::playapi::proto::finsky::Docid* bundledocid);
  private:
  const ::playapi::proto::finsky::Docid& _internal_bundledocid() const;
  ::playapi::proto::finsky::Docid* _internal_mutable_bundledocid();
  public:
  void unsafe_arena_set_allocated_bundledocid(
      ::playapi::proto::finsky::Docid* bundledocid);
  ::playapi::proto::finsky::Docid* unsafe_arena_release_bundledocid();

  // optional int64 initiationTimestampMsec = 1;
  bool has_initiationtimestampmsec() const;
  private:
  bool _internal_has_initiationtimestampmsec() const;
  public:
  void clear_initiationtimestampmsec();
  int64_t initiationtimestampmsec() const;
  void set_initiationtimestampmsec(int64_t value);
  private:
  int64_t _internal_initiationtimestampmsec() const;
  void _internal_set_initiationtimestampmsec(int64_t value);
  public:

  // optional int64 validUntilTimestampMsec = 2;
  bool has_validuntiltimestampmsec() const;
  private:
  bool _internal_has_validuntiltimestampmsec() const;
  public:
  void clear_validuntiltimestampmsec();
  int64_t validuntiltimestampmsec() const;
  void set_validuntiltimestampmsec(int64_t value);
  private:
  int64_t _internal_validuntiltimestampmsec() const;
  void _internal_set_validuntiltimestampmsec(int64_t value);
  public:

  // optional int64 refundTimeoutTimestampMsec = 4;
  bool has_refundtimeouttimestampmsec() const;
  private:
  bool _internal_has_refundtimeouttimestampmsec() const;
  public:
  void clear_refundtimeouttimestampmsec();
  int64_t refundtimeouttimestampmsec() const;
  void set_refundtimeouttimestampmsec(int64_t value);
  private:
  int64_t _internal_refundtimeouttimestampmsec() const;
  void _internal_set_refundtimeouttimestampmsec(int64_t value);
  public:

  // optional int64 postDeliveryRefundWindowMsec = 5;
  bool has_postdeliveryrefundwindowmsec() const;
  private:
  bool _internal_has_postdeliveryrefundwindowmsec() const;
  public:
  void clear_postdeliveryrefundwindowmsec();
  int64_t postdeliveryrefundwindowmsec() const;
  void set_postdeliveryrefundwindowmsec(int64_t value);
  private:
  int64_t _internal_postdeliveryrefundwindowmsec() const;
  void _internal_set_postdeliveryrefundwindowmsec(int64_t value);
  public:

  // optional bool autoRenewing = 3;
  bool has_autorenewing() const;
  private:
  bool _internal_has_autorenewing() const;
  public:
  void clear_autorenewing();
  bool autorenewing() const;
  void set_autorenewing(bool value);
  private:
  bool _internal_autorenewing() const;
  void _internal_set_autorenewing(bool value);
  public:

  // optional bool preordered = 7;
  bool has_preordered() const;
  private:
  bool _internal_has_preordered() const;
  public:
  void clear_preordered();
  bool preordered() const;
  void set_preordered(bool value);
  private:
  bool _internal_preordered() const;
  void _internal_set_preordered(bool value);
  public:

  // optional bool hidden = 8;
  bool has_hidden() const;
  private:
  bool _internal_has_hidden() const;
  public:
  void clear_hidden();
  bool hidden() const;
  void set_hidden(bool value);
  private:
  bool _internal_hidden() const;
  void _internal_set_hidden(bool value);
  public:

  // optional bool bonus = 17;
  bool has_bonus() const;
  private:
  bool _internal_has_bonus() const;
  public:
  void clear_bonus();
  bool bonus() const;
  void set_bonus(bool value);
  private:
  bool _internal_bonus() const;
  void _internal_set_bonus(bool value);
  public:

  // optional int32 quantity = 12;
  bool has_quantity() const;
  private:
  bool _internal_has_quantity() const;
  public:
  void clear_quantity();
  int32_t quantity() const;
  void set_quantity(int32_t value);
  private:
  int32_t _internal_quantity() const;
  void _internal_set_quantity(int32_t value);
  public:

  // optional int64 libraryExpirationTimestampMsec = 14;
  bool has_libraryexpirationtimestampmsec() const;
  private:
  bool _internal_has_libraryexpirationtimestampmsec() const;
  public:
  void clear_libraryexpirationtimestampmsec();
  int64_t libraryexpirationtimestampmsec() const;
  void set_libraryexpirationtimestampmsec(int64_t value);
  private:
  int64_t _internal_libraryexpirationtimestampmsec() const;
  void _internal_set_libraryexpirationtimestampmsec(int64_t value);
  public:

  // optional int64 storedValidUntilTimestampMsec = 18;
  bool has_storedvaliduntiltimestampmsec() const;
  private:
  bool _internal_has_storedvaliduntiltimestampmsec() const;
  public:
  void clear_storedvaliduntiltimestampmsec();
  int64_t storedvaliduntiltimestampmsec() const;
  void set_storedvaliduntiltimestampmsec(int64_t value);
  private:
  int64_t _internal_storedvaliduntiltimestampmsec() const;
  void _internal_set_storedvaliduntiltimestampmsec(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.ownership.OwnershipInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::playapi::proto::finsky::SignedData* developerpurchaseinfo_;
    ::playapi::proto::finsky::RentalTerms* rentalterms_;
    ::playapi::proto::finsky::GroupLicenseInfo* grouplicenseinfo_;
    ::playapi::proto::finsky::LicensedDocumentInfo* licenseddocumentinfo_;
    ::playapi::proto::finsky::LibraryVoucher* libraryvoucher_;
    ::playapi::proto::finsky::Docid* bundledocid_;
    int64_t initiationtimestampmsec_;
    int64_t validuntiltimestampmsec_;
    int64_t refundtimeouttimestampmsec_;
    int64_t postdeliveryrefundwindowmsec_;
    bool autorenewing_;
    bool preordered_;
    bool hidden_;
    bool bonus_;
    int32_t quantity_;
    int64_t libraryexpirationtimestampmsec_;
    int64_t storedvaliduntiltimestampmsec_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fownership_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// OwnershipInfo

// optional int64 initiationTimestampMsec = 1;
inline bool OwnershipInfo::_internal_has_initiationtimestampmsec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool OwnershipInfo::has_initiationtimestampmsec() const {
  return _internal_has_initiationtimestampmsec();
}
inline void OwnershipInfo::clear_initiationtimestampmsec() {
  _impl_.initiationtimestampmsec_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int64_t OwnershipInfo::_internal_initiationtimestampmsec() const {
  return _impl_.initiationtimestampmsec_;
}
inline int64_t OwnershipInfo::initiationtimestampmsec() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.ownership.OwnershipInfo.initiationTimestampMsec)
  return _internal_initiationtimestampmsec();
}
inline void OwnershipInfo::_internal_set_initiationtimestampmsec(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.initiationtimestampmsec_ = value;
}
inline void OwnershipInfo::set_initiationtimestampmsec(int64_t value) {
  _internal_set_initiationtimestampmsec(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.ownership.OwnershipInfo.initiationTimestampMsec)
}

// optional int64 validUntilTimestampMsec = 2;
inline bool OwnershipInfo::_internal_has_validuntiltimestampmsec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool OwnershipInfo::has_validuntiltimestampmsec() const {
  return _internal_has_validuntiltimestampmsec();
}
inline void OwnershipInfo::clear_validuntiltimestampmsec() {
  _impl_.validuntiltimestampmsec_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline int64_t OwnershipInfo::_internal_validuntiltimestampmsec() const {
  return _impl_.validuntiltimestampmsec_;
}
inline int64_t OwnershipInfo::validuntiltimestampmsec() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.ownership.OwnershipInfo.validUntilTimestampMsec)
  return _internal_validuntiltimestampmsec();
}
inline void OwnershipInfo::_internal_set_validuntiltimestampmsec(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.validuntiltimestampmsec_ = value;
}
inline void OwnershipInfo::set_validuntiltimestampmsec(int64_t value) {
  _internal_set_validuntiltimestampmsec(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.ownership.OwnershipInfo.validUntilTimestampMsec)
}

// optional bool autoRenewing = 3;
inline bool OwnershipInfo::_internal_has_autorenewing() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool OwnershipInfo::has_autorenewing() const {
  return _internal_has_autorenewing();
}
inline void OwnershipInfo::clear_autorenewing() {
  _impl_.autorenewing_ = false;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline bool OwnershipInfo::_internal_autorenewing() const {
  return _impl_.autorenewing_;
}
inline bool OwnershipInfo::autorenewing() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.ownership.OwnershipInfo.autoRenewing)
  return _internal_autorenewing();
}
inline void OwnershipInfo::_internal_set_autorenewing(bool value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.autorenewing_ = value;
}
inline void OwnershipInfo::set_autorenewing(bool value) {
  _internal_set_autorenewing(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.ownership.OwnershipInfo.autoRenewing)
}

// optional int64 refundTimeoutTimestampMsec = 4;
inline bool OwnershipInfo::_internal_has_refundtimeouttimestampmsec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool OwnershipInfo::has_refundtimeouttimestampmsec() const {
  return _internal_has_refundtimeouttimestampmsec();
}
inline void OwnershipInfo::clear_refundtimeouttimestampmsec() {
  _impl_.refundtimeouttimestampmsec_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline int64_t OwnershipInfo::_internal_refundtimeouttimestampmsec() const {
  return _impl_.refundtimeouttimestampmsec_;
}
inline int64_t OwnershipInfo::refundtimeouttimestampmsec() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.ownership.OwnershipInfo.refundTimeoutTimestampMsec)
  return _internal_refundtimeouttimestampmsec();
}
inline void OwnershipInfo::_internal_set_refundtimeouttimestampmsec(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.refundtimeouttimestampmsec_ = value;
}
inline void OwnershipInfo::set_refundtimeouttimestampmsec(int64_t value) {
  _internal_set_refundtimeouttimestampmsec(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.ownership.OwnershipInfo.refundTimeoutTimestampMsec)
}

// optional int64 postDeliveryRefundWindowMsec = 5;
inline bool OwnershipInfo::_internal_has_postdeliveryrefundwindowmsec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool OwnershipInfo::has_postdeliveryrefundwindowmsec() const {
  return _internal_has_postdeliveryrefundwindowmsec();
}
inline void OwnershipInfo::clear_postdeliveryrefundwindowmsec() {
  _impl_.postdeliveryrefundwindowmsec_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline int64_t OwnershipInfo::_internal_postdeliveryrefundwindowmsec() const {
  return _impl_.postdeliveryrefundwindowmsec_;
}
inline int64_t OwnershipInfo::postdeliveryrefundwindowmsec() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.ownership.OwnershipInfo.postDeliveryRefundWindowMsec)
  return _internal_postdeliveryrefundwindowmsec();
}
inline void OwnershipInfo::_internal_set_postdeliveryrefundwindowmsec(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.postdeliveryrefundwindowmsec_ = value;
}
inline void OwnershipInfo::set_postdeliveryrefundwindowmsec(int64_t value) {
  _internal_set_postdeliveryrefundwindowmsec(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.ownership.OwnershipInfo.postDeliveryRefundWindowMsec)
}

// optional .playapi.proto.finsky.SignedData developerPurchaseInfo = 6;
inline bool OwnershipInfo::_internal_has_developerpurchaseinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.developerpurchaseinfo_ != nullptr);
  return value;
}
inline bool OwnershipInfo::has_developerpurchaseinfo() const {
  return _internal_has_developerpurchaseinfo();
}
inline const ::playapi::proto::finsky::SignedData& OwnershipInfo::_internal_developerpurchaseinfo() const {
  const ::playapi::proto::finsky::SignedData* p = _impl_.developerpurchaseinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::SignedData&>(
      ::playapi::proto::finsky::_SignedData_default_instance_);
}
inline const ::playapi::proto::finsky::SignedData& OwnershipInfo::developerpurchaseinfo() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.ownership.OwnershipInfo.developerPurchaseInfo)
  return _internal_developerpurchaseinfo();
}
inline void OwnershipInfo::unsafe_arena_set_allocated_developerpurchaseinfo(
    ::playapi::proto::finsky::SignedData* developerpurchaseinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.developerpurchaseinfo_);
  }
  _impl_.developerpurchaseinfo_ = developerpurchaseinfo;
  if (developerpurchaseinfo) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.ownership.OwnershipInfo.developerPurchaseInfo)
}
inline ::playapi::proto::finsky::SignedData* OwnershipInfo::release_developerpurchaseinfo() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::playapi::proto::finsky::SignedData* temp = _impl_.developerpurchaseinfo_;
  _impl_.developerpurchaseinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::SignedData* OwnershipInfo::unsafe_arena_release_developerpurchaseinfo() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.ownership.OwnershipInfo.developerPurchaseInfo)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::playapi::proto::finsky::SignedData* temp = _impl_.developerpurchaseinfo_;
  _impl_.developerpurchaseinfo_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::SignedData* OwnershipInfo::_internal_mutable_developerpurchaseinfo() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.developerpurchaseinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::SignedData>(GetArenaForAllocation());
    _impl_.developerpurchaseinfo_ = p;
  }
  return _impl_.developerpurchaseinfo_;
}
inline ::playapi::proto::finsky::SignedData* OwnershipInfo::mutable_developerpurchaseinfo() {
  ::playapi::proto::finsky::SignedData* _msg = _internal_mutable_developerpurchaseinfo();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.ownership.OwnershipInfo.developerPurchaseInfo)
  return _msg;
}
inline void OwnershipInfo::set_allocated_developerpurchaseinfo(::playapi::proto::finsky::SignedData* developerpurchaseinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.developerpurchaseinfo_);
  }
  if (developerpurchaseinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(developerpurchaseinfo));
    if (message_arena != submessage_arena) {
      developerpurchaseinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, developerpurchaseinfo, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.developerpurchaseinfo_ = developerpurchaseinfo;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.ownership.OwnershipInfo.developerPurchaseInfo)
}

// optional bool preordered = 7;
inline bool OwnershipInfo::_internal_has_preordered() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool OwnershipInfo::has_preordered() const {
  return _internal_has_preordered();
}
inline void OwnershipInfo::clear_preordered() {
  _impl_.preordered_ = false;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline bool OwnershipInfo::_internal_preordered() const {
  return _impl_.preordered_;
}
inline bool OwnershipInfo::preordered() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.ownership.OwnershipInfo.preordered)
  return _internal_preordered();
}
inline void OwnershipInfo::_internal_set_preordered(bool value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.preordered_ = value;
}
inline void OwnershipInfo::set_preordered(bool value) {
  _internal_set_preordered(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.ownership.OwnershipInfo.preordered)
}

// optional bool hidden = 8;
inline bool OwnershipInfo::_internal_has_hidden() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool OwnershipInfo::has_hidden() const {
  return _internal_has_hidden();
}
inline void OwnershipInfo::clear_hidden() {
  _impl_.hidden_ = false;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline bool OwnershipInfo::_internal_hidden() const {
  return _impl_.hidden_;
}
inline bool OwnershipInfo::hidden() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.ownership.OwnershipInfo.hidden)
  return _internal_hidden();
}
inline void OwnershipInfo::_internal_set_hidden(bool value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.hidden_ = value;
}
inline void OwnershipInfo::set_hidden(bool value) {
  _internal_set_hidden(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.ownership.OwnershipInfo.hidden)
}

// optional .playapi.proto.finsky.RentalTerms rentalTerms = 9;
inline bool OwnershipInfo::_internal_has_rentalterms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rentalterms_ != nullptr);
  return value;
}
inline bool OwnershipInfo::has_rentalterms() const {
  return _internal_has_rentalterms();
}
inline const ::playapi::proto::finsky::RentalTerms& OwnershipInfo::_internal_rentalterms() const {
  const ::playapi::proto::finsky::RentalTerms* p = _impl_.rentalterms_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::RentalTerms&>(
      ::playapi::proto::finsky::_RentalTerms_default_instance_);
}
inline const ::playapi::proto::finsky::RentalTerms& OwnershipInfo::rentalterms() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.ownership.OwnershipInfo.rentalTerms)
  return _internal_rentalterms();
}
inline void OwnershipInfo::unsafe_arena_set_allocated_rentalterms(
    ::playapi::proto::finsky::RentalTerms* rentalterms) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rentalterms_);
  }
  _impl_.rentalterms_ = rentalterms;
  if (rentalterms) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.ownership.OwnershipInfo.rentalTerms)
}
inline ::playapi::proto::finsky::RentalTerms* OwnershipInfo::release_rentalterms() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::playapi::proto::finsky::RentalTerms* temp = _impl_.rentalterms_;
  _impl_.rentalterms_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::RentalTerms* OwnershipInfo::unsafe_arena_release_rentalterms() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.ownership.OwnershipInfo.rentalTerms)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::playapi::proto::finsky::RentalTerms* temp = _impl_.rentalterms_;
  _impl_.rentalterms_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::RentalTerms* OwnershipInfo::_internal_mutable_rentalterms() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.rentalterms_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::RentalTerms>(GetArenaForAllocation());
    _impl_.rentalterms_ = p;
  }
  return _impl_.rentalterms_;
}
inline ::playapi::proto::finsky::RentalTerms* OwnershipInfo::mutable_rentalterms() {
  ::playapi::proto::finsky::RentalTerms* _msg = _internal_mutable_rentalterms();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.ownership.OwnershipInfo.rentalTerms)
  return _msg;
}
inline void OwnershipInfo::set_allocated_rentalterms(::playapi::proto::finsky::RentalTerms* rentalterms) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rentalterms_);
  }
  if (rentalterms) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rentalterms));
    if (message_arena != submessage_arena) {
      rentalterms = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rentalterms, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.rentalterms_ = rentalterms;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.ownership.OwnershipInfo.rentalTerms)
}

// optional .playapi.proto.finsky.GroupLicenseInfo groupLicenseInfo = 10;
inline bool OwnershipInfo::_internal_has_grouplicenseinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.grouplicenseinfo_ != nullptr);
  return value;
}
inline bool OwnershipInfo::has_grouplicenseinfo() const {
  return _internal_has_grouplicenseinfo();
}
inline const ::playapi::proto::finsky::GroupLicenseInfo& OwnershipInfo::_internal_grouplicenseinfo() const {
  const ::playapi::proto::finsky::GroupLicenseInfo* p = _impl_.grouplicenseinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::GroupLicenseInfo&>(
      ::playapi::proto::finsky::_GroupLicenseInfo_default_instance_);
}
inline const ::playapi::proto::finsky::GroupLicenseInfo& OwnershipInfo::grouplicenseinfo() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.ownership.OwnershipInfo.groupLicenseInfo)
  return _internal_grouplicenseinfo();
}
inline void OwnershipInfo::unsafe_arena_set_allocated_grouplicenseinfo(
    ::playapi::proto::finsky::GroupLicenseInfo* grouplicenseinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.grouplicenseinfo_);
  }
  _impl_.grouplicenseinfo_ = grouplicenseinfo;
  if (grouplicenseinfo) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.ownership.OwnershipInfo.groupLicenseInfo)
}
inline ::playapi::proto::finsky::GroupLicenseInfo* OwnershipInfo::release_grouplicenseinfo() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::playapi::proto::finsky::GroupLicenseInfo* temp = _impl_.grouplicenseinfo_;
  _impl_.grouplicenseinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::GroupLicenseInfo* OwnershipInfo::unsafe_arena_release_grouplicenseinfo() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.ownership.OwnershipInfo.groupLicenseInfo)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::playapi::proto::finsky::GroupLicenseInfo* temp = _impl_.grouplicenseinfo_;
  _impl_.grouplicenseinfo_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::GroupLicenseInfo* OwnershipInfo::_internal_mutable_grouplicenseinfo() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.grouplicenseinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::GroupLicenseInfo>(GetArenaForAllocation());
    _impl_.grouplicenseinfo_ = p;
  }
  return _impl_.grouplicenseinfo_;
}
inline ::playapi::proto::finsky::GroupLicenseInfo* OwnershipInfo::mutable_grouplicenseinfo() {
  ::playapi::proto::finsky::GroupLicenseInfo* _msg = _internal_mutable_grouplicenseinfo();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.ownership.OwnershipInfo.groupLicenseInfo)
  return _msg;
}
inline void OwnershipInfo::set_allocated_grouplicenseinfo(::playapi::proto::finsky::GroupLicenseInfo* grouplicenseinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.grouplicenseinfo_);
  }
  if (grouplicenseinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(grouplicenseinfo));
    if (message_arena != submessage_arena) {
      grouplicenseinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, grouplicenseinfo, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.grouplicenseinfo_ = grouplicenseinfo;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.ownership.OwnershipInfo.groupLicenseInfo)
}

// optional .playapi.proto.finsky.LicensedDocumentInfo licensedDocumentInfo = 11;
inline bool OwnershipInfo::_internal_has_licenseddocumentinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.licenseddocumentinfo_ != nullptr);
  return value;
}
inline bool OwnershipInfo::has_licenseddocumentinfo() const {
  return _internal_has_licenseddocumentinfo();
}
inline const ::playapi::proto::finsky::LicensedDocumentInfo& OwnershipInfo::_internal_licenseddocumentinfo() const {
  const ::playapi::proto::finsky::LicensedDocumentInfo* p = _impl_.licenseddocumentinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::LicensedDocumentInfo&>(
      ::playapi::proto::finsky::_LicensedDocumentInfo_default_instance_);
}
inline const ::playapi::proto::finsky::LicensedDocumentInfo& OwnershipInfo::licenseddocumentinfo() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.ownership.OwnershipInfo.licensedDocumentInfo)
  return _internal_licenseddocumentinfo();
}
inline void OwnershipInfo::unsafe_arena_set_allocated_licenseddocumentinfo(
    ::playapi::proto::finsky::LicensedDocumentInfo* licenseddocumentinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.licenseddocumentinfo_);
  }
  _impl_.licenseddocumentinfo_ = licenseddocumentinfo;
  if (licenseddocumentinfo) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.ownership.OwnershipInfo.licensedDocumentInfo)
}
inline ::playapi::proto::finsky::LicensedDocumentInfo* OwnershipInfo::release_licenseddocumentinfo() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::playapi::proto::finsky::LicensedDocumentInfo* temp = _impl_.licenseddocumentinfo_;
  _impl_.licenseddocumentinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::LicensedDocumentInfo* OwnershipInfo::unsafe_arena_release_licenseddocumentinfo() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.ownership.OwnershipInfo.licensedDocumentInfo)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::playapi::proto::finsky::LicensedDocumentInfo* temp = _impl_.licenseddocumentinfo_;
  _impl_.licenseddocumentinfo_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::LicensedDocumentInfo* OwnershipInfo::_internal_mutable_licenseddocumentinfo() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.licenseddocumentinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::LicensedDocumentInfo>(GetArenaForAllocation());
    _impl_.licenseddocumentinfo_ = p;
  }
  return _impl_.licenseddocumentinfo_;
}
inline ::playapi::proto::finsky::LicensedDocumentInfo* OwnershipInfo::mutable_licenseddocumentinfo() {
  ::playapi::proto::finsky::LicensedDocumentInfo* _msg = _internal_mutable_licenseddocumentinfo();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.ownership.OwnershipInfo.licensedDocumentInfo)
  return _msg;
}
inline void OwnershipInfo::set_allocated_licenseddocumentinfo(::playapi::proto::finsky::LicensedDocumentInfo* licenseddocumentinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.licenseddocumentinfo_);
  }
  if (licenseddocumentinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(licenseddocumentinfo));
    if (message_arena != submessage_arena) {
      licenseddocumentinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, licenseddocumentinfo, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.licenseddocumentinfo_ = licenseddocumentinfo;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.ownership.OwnershipInfo.licensedDocumentInfo)
}

// optional int32 quantity = 12;
inline bool OwnershipInfo::_internal_has_quantity() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool OwnershipInfo::has_quantity() const {
  return _internal_has_quantity();
}
inline void OwnershipInfo::clear_quantity() {
  _impl_.quantity_ = 0;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline int32_t OwnershipInfo::_internal_quantity() const {
  return _impl_.quantity_;
}
inline int32_t OwnershipInfo::quantity() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.ownership.OwnershipInfo.quantity)
  return _internal_quantity();
}
inline void OwnershipInfo::_internal_set_quantity(int32_t value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.quantity_ = value;
}
inline void OwnershipInfo::set_quantity(int32_t value) {
  _internal_set_quantity(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.ownership.OwnershipInfo.quantity)
}

// optional int64 libraryExpirationTimestampMsec = 14;
inline bool OwnershipInfo::_internal_has_libraryexpirationtimestampmsec() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool OwnershipInfo::has_libraryexpirationtimestampmsec() const {
  return _internal_has_libraryexpirationtimestampmsec();
}
inline void OwnershipInfo::clear_libraryexpirationtimestampmsec() {
  _impl_.libraryexpirationtimestampmsec_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline int64_t OwnershipInfo::_internal_libraryexpirationtimestampmsec() const {
  return _impl_.libraryexpirationtimestampmsec_;
}
inline int64_t OwnershipInfo::libraryexpirationtimestampmsec() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.ownership.OwnershipInfo.libraryExpirationTimestampMsec)
  return _internal_libraryexpirationtimestampmsec();
}
inline void OwnershipInfo::_internal_set_libraryexpirationtimestampmsec(int64_t value) {
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.libraryexpirationtimestampmsec_ = value;
}
inline void OwnershipInfo::set_libraryexpirationtimestampmsec(int64_t value) {
  _internal_set_libraryexpirationtimestampmsec(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.ownership.OwnershipInfo.libraryExpirationTimestampMsec)
}

// optional .playapi.proto.finsky.LibraryVoucher libraryVoucher = 15;
inline bool OwnershipInfo::_internal_has_libraryvoucher() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.libraryvoucher_ != nullptr);
  return value;
}
inline bool OwnershipInfo::has_libraryvoucher() const {
  return _internal_has_libraryvoucher();
}
inline const ::playapi::proto::finsky::LibraryVoucher& OwnershipInfo::_internal_libraryvoucher() const {
  const ::playapi::proto::finsky::LibraryVoucher* p = _impl_.libraryvoucher_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::LibraryVoucher&>(
      ::playapi::proto::finsky::_LibraryVoucher_default_instance_);
}
inline const ::playapi::proto::finsky::LibraryVoucher& OwnershipInfo::libraryvoucher() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.ownership.OwnershipInfo.libraryVoucher)
  return _internal_libraryvoucher();
}
inline void OwnershipInfo::unsafe_arena_set_allocated_libraryvoucher(
    ::playapi::proto::finsky::LibraryVoucher* libraryvoucher) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.libraryvoucher_);
  }
  _impl_.libraryvoucher_ = libraryvoucher;
  if (libraryvoucher) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.ownership.OwnershipInfo.libraryVoucher)
}
inline ::playapi::proto::finsky::LibraryVoucher* OwnershipInfo::release_libraryvoucher() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::playapi::proto::finsky::LibraryVoucher* temp = _impl_.libraryvoucher_;
  _impl_.libraryvoucher_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::LibraryVoucher* OwnershipInfo::unsafe_arena_release_libraryvoucher() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.ownership.OwnershipInfo.libraryVoucher)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::playapi::proto::finsky::LibraryVoucher* temp = _impl_.libraryvoucher_;
  _impl_.libraryvoucher_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::LibraryVoucher* OwnershipInfo::_internal_mutable_libraryvoucher() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.libraryvoucher_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::LibraryVoucher>(GetArenaForAllocation());
    _impl_.libraryvoucher_ = p;
  }
  return _impl_.libraryvoucher_;
}
inline ::playapi::proto::finsky::LibraryVoucher* OwnershipInfo::mutable_libraryvoucher() {
  ::playapi::proto::finsky::LibraryVoucher* _msg = _internal_mutable_libraryvoucher();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.ownership.OwnershipInfo.libraryVoucher)
  return _msg;
}
inline void OwnershipInfo::set_allocated_libraryvoucher(::playapi::proto::finsky::LibraryVoucher* libraryvoucher) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.libraryvoucher_);
  }
  if (libraryvoucher) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(libraryvoucher));
    if (message_arena != submessage_arena) {
      libraryvoucher = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, libraryvoucher, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.libraryvoucher_ = libraryvoucher;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.ownership.OwnershipInfo.libraryVoucher)
}

// optional .playapi.proto.finsky.Docid bundleDocid = 16;
inline bool OwnershipInfo::_internal_has_bundledocid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.bundledocid_ != nullptr);
  return value;
}
inline bool OwnershipInfo::has_bundledocid() const {
  return _internal_has_bundledocid();
}
inline const ::playapi::proto::finsky::Docid& OwnershipInfo::_internal_bundledocid() const {
  const ::playapi::proto::finsky::Docid* p = _impl_.bundledocid_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::Docid&>(
      ::playapi::proto::finsky::_Docid_default_instance_);
}
inline const ::playapi::proto::finsky::Docid& OwnershipInfo::bundledocid() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.ownership.OwnershipInfo.bundleDocid)
  return _internal_bundledocid();
}
inline void OwnershipInfo::unsafe_arena_set_allocated_bundledocid(
    ::playapi::proto::finsky::Docid* bundledocid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bundledocid_);
  }
  _impl_.bundledocid_ = bundledocid;
  if (bundledocid) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.ownership.OwnershipInfo.bundleDocid)
}
inline ::playapi::proto::finsky::Docid* OwnershipInfo::release_bundledocid() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::playapi::proto::finsky::Docid* temp = _impl_.bundledocid_;
  _impl_.bundledocid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::Docid* OwnershipInfo::unsafe_arena_release_bundledocid() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.ownership.OwnershipInfo.bundleDocid)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::playapi::proto::finsky::Docid* temp = _impl_.bundledocid_;
  _impl_.bundledocid_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::Docid* OwnershipInfo::_internal_mutable_bundledocid() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.bundledocid_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::Docid>(GetArenaForAllocation());
    _impl_.bundledocid_ = p;
  }
  return _impl_.bundledocid_;
}
inline ::playapi::proto::finsky::Docid* OwnershipInfo::mutable_bundledocid() {
  ::playapi::proto::finsky::Docid* _msg = _internal_mutable_bundledocid();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.ownership.OwnershipInfo.bundleDocid)
  return _msg;
}
inline void OwnershipInfo::set_allocated_bundledocid(::playapi::proto::finsky::Docid* bundledocid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bundledocid_);
  }
  if (bundledocid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bundledocid));
    if (message_arena != submessage_arena) {
      bundledocid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bundledocid, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.bundledocid_ = bundledocid;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.ownership.OwnershipInfo.bundleDocid)
}

// optional bool bonus = 17;
inline bool OwnershipInfo::_internal_has_bonus() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool OwnershipInfo::has_bonus() const {
  return _internal_has_bonus();
}
inline void OwnershipInfo::clear_bonus() {
  _impl_.bonus_ = false;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline bool OwnershipInfo::_internal_bonus() const {
  return _impl_.bonus_;
}
inline bool OwnershipInfo::bonus() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.ownership.OwnershipInfo.bonus)
  return _internal_bonus();
}
inline void OwnershipInfo::_internal_set_bonus(bool value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.bonus_ = value;
}
inline void OwnershipInfo::set_bonus(bool value) {
  _internal_set_bonus(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.ownership.OwnershipInfo.bonus)
}

// optional int64 storedValidUntilTimestampMsec = 18;
inline bool OwnershipInfo::_internal_has_storedvaliduntiltimestampmsec() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool OwnershipInfo::has_storedvaliduntiltimestampmsec() const {
  return _internal_has_storedvaliduntiltimestampmsec();
}
inline void OwnershipInfo::clear_storedvaliduntiltimestampmsec() {
  _impl_.storedvaliduntiltimestampmsec_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline int64_t OwnershipInfo::_internal_storedvaliduntiltimestampmsec() const {
  return _impl_.storedvaliduntiltimestampmsec_;
}
inline int64_t OwnershipInfo::storedvaliduntiltimestampmsec() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.ownership.OwnershipInfo.storedValidUntilTimestampMsec)
  return _internal_storedvaliduntiltimestampmsec();
}
inline void OwnershipInfo::_internal_set_storedvaliduntiltimestampmsec(int64_t value) {
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.storedvaliduntiltimestampmsec_ = value;
}
inline void OwnershipInfo::set_storedvaliduntiltimestampmsec(int64_t value) {
  _internal_set_storedvaliduntiltimestampmsec(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.ownership.OwnershipInfo.storedValidUntilTimestampMsec)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace ownership
}  // namespace finsky
}  // namespace proto
}  // namespace playapi

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_play_5fownership_2eproto
