// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: play_respone.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_play_5frespone_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_play_5frespone_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "play_common.pb.h"
#include "play_download.pb.h"
#include "play_settings.pb.h"
#include "play_toc.pb.h"
#include "play_device_config.pb.h"
#include "play_search.pb.h"
#include "play_browse.pb.h"
#include "play_details.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_play_5frespone_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_play_5frespone_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_play_5frespone_2eproto;
namespace playapi {
namespace proto {
namespace finsky {
namespace response {
class AcceptTosResponse;
struct AcceptTosResponseDefaultTypeInternal;
extern AcceptTosResponseDefaultTypeInternal _AcceptTosResponse_default_instance_;
class AndroidAppNotificationData;
struct AndroidAppNotificationDataDefaultTypeInternal;
extern AndroidAppNotificationDataDefaultTypeInternal _AndroidAppNotificationData_default_instance_;
class InAppNotificationData;
struct InAppNotificationDataDefaultTypeInternal;
extern InAppNotificationDataDefaultTypeInternal _InAppNotificationData_default_instance_;
class LibraryDirtyData;
struct LibraryDirtyDataDefaultTypeInternal;
extern LibraryDirtyDataDefaultTypeInternal _LibraryDirtyData_default_instance_;
class Notification;
struct NotificationDefaultTypeInternal;
extern NotificationDefaultTypeInternal _Notification_default_instance_;
class Payload;
struct PayloadDefaultTypeInternal;
extern PayloadDefaultTypeInternal _Payload_default_instance_;
class PreFetch;
struct PreFetchDefaultTypeInternal;
extern PreFetchDefaultTypeInternal _PreFetch_default_instance_;
class PurchaseDeclinedData;
struct PurchaseDeclinedDataDefaultTypeInternal;
extern PurchaseDeclinedDataDefaultTypeInternal _PurchaseDeclinedData_default_instance_;
class PurchaseRemovalData;
struct PurchaseRemovalDataDefaultTypeInternal;
extern PurchaseRemovalDataDefaultTypeInternal _PurchaseRemovalData_default_instance_;
class ResponseWrapper;
struct ResponseWrapperDefaultTypeInternal;
extern ResponseWrapperDefaultTypeInternal _ResponseWrapper_default_instance_;
class ServerCommands;
struct ServerCommandsDefaultTypeInternal;
extern ServerCommandsDefaultTypeInternal _ServerCommands_default_instance_;
class ServerCookie;
struct ServerCookieDefaultTypeInternal;
extern ServerCookieDefaultTypeInternal _ServerCookie_default_instance_;
class ServerCookies;
struct ServerCookiesDefaultTypeInternal;
extern ServerCookiesDefaultTypeInternal _ServerCookies_default_instance_;
class ServerMetadata;
struct ServerMetadataDefaultTypeInternal;
extern ServerMetadataDefaultTypeInternal _ServerMetadata_default_instance_;
class Targets;
struct TargetsDefaultTypeInternal;
extern TargetsDefaultTypeInternal _Targets_default_instance_;
class UserNotificationData;
struct UserNotificationDataDefaultTypeInternal;
extern UserNotificationDataDefaultTypeInternal _UserNotificationData_default_instance_;
}  // namespace response
}  // namespace finsky
}  // namespace proto
}  // namespace playapi
PROTOBUF_NAMESPACE_OPEN
template<> ::playapi::proto::finsky::response::AcceptTosResponse* Arena::CreateMaybeMessage<::playapi::proto::finsky::response::AcceptTosResponse>(Arena*);
template<> ::playapi::proto::finsky::response::AndroidAppNotificationData* Arena::CreateMaybeMessage<::playapi::proto::finsky::response::AndroidAppNotificationData>(Arena*);
template<> ::playapi::proto::finsky::response::InAppNotificationData* Arena::CreateMaybeMessage<::playapi::proto::finsky::response::InAppNotificationData>(Arena*);
template<> ::playapi::proto::finsky::response::LibraryDirtyData* Arena::CreateMaybeMessage<::playapi::proto::finsky::response::LibraryDirtyData>(Arena*);
template<> ::playapi::proto::finsky::response::Notification* Arena::CreateMaybeMessage<::playapi::proto::finsky::response::Notification>(Arena*);
template<> ::playapi::proto::finsky::response::Payload* Arena::CreateMaybeMessage<::playapi::proto::finsky::response::Payload>(Arena*);
template<> ::playapi::proto::finsky::response::PreFetch* Arena::CreateMaybeMessage<::playapi::proto::finsky::response::PreFetch>(Arena*);
template<> ::playapi::proto::finsky::response::PurchaseDeclinedData* Arena::CreateMaybeMessage<::playapi::proto::finsky::response::PurchaseDeclinedData>(Arena*);
template<> ::playapi::proto::finsky::response::PurchaseRemovalData* Arena::CreateMaybeMessage<::playapi::proto::finsky::response::PurchaseRemovalData>(Arena*);
template<> ::playapi::proto::finsky::response::ResponseWrapper* Arena::CreateMaybeMessage<::playapi::proto::finsky::response::ResponseWrapper>(Arena*);
template<> ::playapi::proto::finsky::response::ServerCommands* Arena::CreateMaybeMessage<::playapi::proto::finsky::response::ServerCommands>(Arena*);
template<> ::playapi::proto::finsky::response::ServerCookie* Arena::CreateMaybeMessage<::playapi::proto::finsky::response::ServerCookie>(Arena*);
template<> ::playapi::proto::finsky::response::ServerCookies* Arena::CreateMaybeMessage<::playapi::proto::finsky::response::ServerCookies>(Arena*);
template<> ::playapi::proto::finsky::response::ServerMetadata* Arena::CreateMaybeMessage<::playapi::proto::finsky::response::ServerMetadata>(Arena*);
template<> ::playapi::proto::finsky::response::Targets* Arena::CreateMaybeMessage<::playapi::proto::finsky::response::Targets>(Arena*);
template<> ::playapi::proto::finsky::response::UserNotificationData* Arena::CreateMaybeMessage<::playapi::proto::finsky::response::UserNotificationData>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace playapi {
namespace proto {
namespace finsky {
namespace response {

// ===================================================================

class ServerCommands final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.response.ServerCommands) */ {
 public:
  inline ServerCommands() : ServerCommands(nullptr) {}
  ~ServerCommands() override;
  explicit PROTOBUF_CONSTEXPR ServerCommands(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerCommands(const ServerCommands& from);
  ServerCommands(ServerCommands&& from) noexcept
    : ServerCommands() {
    *this = ::std::move(from);
  }

  inline ServerCommands& operator=(const ServerCommands& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerCommands& operator=(ServerCommands&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerCommands& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerCommands* internal_default_instance() {
    return reinterpret_cast<const ServerCommands*>(
               &_ServerCommands_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ServerCommands& a, ServerCommands& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerCommands* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerCommands* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerCommands* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServerCommands>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServerCommands& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServerCommands& from) {
    ServerCommands::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerCommands* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.response.ServerCommands";
  }
  protected:
  explicit ServerCommands(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserSettingDirtyDataFieldNumber = 4,
    kDisplayErrorMessageFieldNumber = 2,
    kLogErrorStacktraceFieldNumber = 3,
    kClearCacheFieldNumber = 1,
  };
  // repeated .playapi.proto.finsky.settings.UserSettingDirtyData userSettingDirtyData = 4;
  int usersettingdirtydata_size() const;
  private:
  int _internal_usersettingdirtydata_size() const;
  public:
  void clear_usersettingdirtydata();
  ::playapi::proto::finsky::settings::UserSettingDirtyData* mutable_usersettingdirtydata(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::settings::UserSettingDirtyData >*
      mutable_usersettingdirtydata();
  private:
  const ::playapi::proto::finsky::settings::UserSettingDirtyData& _internal_usersettingdirtydata(int index) const;
  ::playapi::proto::finsky::settings::UserSettingDirtyData* _internal_add_usersettingdirtydata();
  public:
  const ::playapi::proto::finsky::settings::UserSettingDirtyData& usersettingdirtydata(int index) const;
  ::playapi::proto::finsky::settings::UserSettingDirtyData* add_usersettingdirtydata();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::settings::UserSettingDirtyData >&
      usersettingdirtydata() const;

  // optional string displayErrorMessage = 2;
  bool has_displayerrormessage() const;
  private:
  bool _internal_has_displayerrormessage() const;
  public:
  void clear_displayerrormessage();
  const std::string& displayerrormessage() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_displayerrormessage(ArgT0&& arg0, ArgT... args);
  std::string* mutable_displayerrormessage();
  PROTOBUF_NODISCARD std::string* release_displayerrormessage();
  void set_allocated_displayerrormessage(std::string* displayerrormessage);
  private:
  const std::string& _internal_displayerrormessage() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_displayerrormessage(const std::string& value);
  std::string* _internal_mutable_displayerrormessage();
  public:

  // optional string logErrorStacktrace = 3;
  bool has_logerrorstacktrace() const;
  private:
  bool _internal_has_logerrorstacktrace() const;
  public:
  void clear_logerrorstacktrace();
  const std::string& logerrorstacktrace() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_logerrorstacktrace(ArgT0&& arg0, ArgT... args);
  std::string* mutable_logerrorstacktrace();
  PROTOBUF_NODISCARD std::string* release_logerrorstacktrace();
  void set_allocated_logerrorstacktrace(std::string* logerrorstacktrace);
  private:
  const std::string& _internal_logerrorstacktrace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_logerrorstacktrace(const std::string& value);
  std::string* _internal_mutable_logerrorstacktrace();
  public:

  // optional bool clearCache = 1;
  bool has_clearcache() const;
  private:
  bool _internal_has_clearcache() const;
  public:
  void clear_clearcache();
  bool clearcache() const;
  void set_clearcache(bool value);
  private:
  bool _internal_clearcache() const;
  void _internal_set_clearcache(bool value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.response.ServerCommands)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::settings::UserSettingDirtyData > usersettingdirtydata_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr displayerrormessage_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr logerrorstacktrace_;
    bool clearcache_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5frespone_2eproto;
};
// -------------------------------------------------------------------

class PreFetch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.response.PreFetch) */ {
 public:
  inline PreFetch() : PreFetch(nullptr) {}
  ~PreFetch() override;
  explicit PROTOBUF_CONSTEXPR PreFetch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PreFetch(const PreFetch& from);
  PreFetch(PreFetch&& from) noexcept
    : PreFetch() {
    *this = ::std::move(from);
  }

  inline PreFetch& operator=(const PreFetch& from) {
    CopyFrom(from);
    return *this;
  }
  inline PreFetch& operator=(PreFetch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PreFetch& default_instance() {
    return *internal_default_instance();
  }
  static inline const PreFetch* internal_default_instance() {
    return reinterpret_cast<const PreFetch*>(
               &_PreFetch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PreFetch& a, PreFetch& b) {
    a.Swap(&b);
  }
  inline void Swap(PreFetch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PreFetch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PreFetch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PreFetch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PreFetch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PreFetch& from) {
    PreFetch::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PreFetch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.response.PreFetch";
  }
  protected:
  explicit PreFetch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 1,
    kResponseFieldNumber = 2,
    kEtagFieldNumber = 3,
    kTtlFieldNumber = 4,
    kSoftTtlFieldNumber = 5,
  };
  // optional string url = 1;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // optional bytes response = 2;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const std::string& response() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_response(ArgT0&& arg0, ArgT... args);
  std::string* mutable_response();
  PROTOBUF_NODISCARD std::string* release_response();
  void set_allocated_response(std::string* response);
  private:
  const std::string& _internal_response() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_response(const std::string& value);
  std::string* _internal_mutable_response();
  public:

  // optional string etag = 3;
  bool has_etag() const;
  private:
  bool _internal_has_etag() const;
  public:
  void clear_etag();
  const std::string& etag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_etag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_etag();
  PROTOBUF_NODISCARD std::string* release_etag();
  void set_allocated_etag(std::string* etag);
  private:
  const std::string& _internal_etag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_etag(const std::string& value);
  std::string* _internal_mutable_etag();
  public:

  // optional int64 ttl = 4;
  bool has_ttl() const;
  private:
  bool _internal_has_ttl() const;
  public:
  void clear_ttl();
  int64_t ttl() const;
  void set_ttl(int64_t value);
  private:
  int64_t _internal_ttl() const;
  void _internal_set_ttl(int64_t value);
  public:

  // optional int64 softTtl = 5;
  bool has_softttl() const;
  private:
  bool _internal_has_softttl() const;
  public:
  void clear_softttl();
  int64_t softttl() const;
  void set_softttl(int64_t value);
  private:
  int64_t _internal_softttl() const;
  void _internal_set_softttl(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.response.PreFetch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr response_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr etag_;
    int64_t ttl_;
    int64_t softttl_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5frespone_2eproto;
};
// -------------------------------------------------------------------

class AndroidAppNotificationData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.response.AndroidAppNotificationData) */ {
 public:
  inline AndroidAppNotificationData() : AndroidAppNotificationData(nullptr) {}
  ~AndroidAppNotificationData() override;
  explicit PROTOBUF_CONSTEXPR AndroidAppNotificationData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AndroidAppNotificationData(const AndroidAppNotificationData& from);
  AndroidAppNotificationData(AndroidAppNotificationData&& from) noexcept
    : AndroidAppNotificationData() {
    *this = ::std::move(from);
  }

  inline AndroidAppNotificationData& operator=(const AndroidAppNotificationData& from) {
    CopyFrom(from);
    return *this;
  }
  inline AndroidAppNotificationData& operator=(AndroidAppNotificationData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AndroidAppNotificationData& default_instance() {
    return *internal_default_instance();
  }
  static inline const AndroidAppNotificationData* internal_default_instance() {
    return reinterpret_cast<const AndroidAppNotificationData*>(
               &_AndroidAppNotificationData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AndroidAppNotificationData& a, AndroidAppNotificationData& b) {
    a.Swap(&b);
  }
  inline void Swap(AndroidAppNotificationData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AndroidAppNotificationData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AndroidAppNotificationData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AndroidAppNotificationData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AndroidAppNotificationData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AndroidAppNotificationData& from) {
    AndroidAppNotificationData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AndroidAppNotificationData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.response.AndroidAppNotificationData";
  }
  protected:
  explicit AndroidAppNotificationData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAssetIdFieldNumber = 2,
    kInstallReferrerFieldNumber = 3,
    kInstallDetailsFieldNumber = 4,
    kVersionCodeFieldNumber = 1,
  };
  // optional string assetId = 2;
  bool has_assetid() const;
  private:
  bool _internal_has_assetid() const;
  public:
  void clear_assetid();
  const std::string& assetid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_assetid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_assetid();
  PROTOBUF_NODISCARD std::string* release_assetid();
  void set_allocated_assetid(std::string* assetid);
  private:
  const std::string& _internal_assetid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_assetid(const std::string& value);
  std::string* _internal_mutable_assetid();
  public:

  // optional string installReferrer = 3;
  bool has_installreferrer() const;
  private:
  bool _internal_has_installreferrer() const;
  public:
  void clear_installreferrer();
  const std::string& installreferrer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_installreferrer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_installreferrer();
  PROTOBUF_NODISCARD std::string* release_installreferrer();
  void set_allocated_installreferrer(std::string* installreferrer);
  private:
  const std::string& _internal_installreferrer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_installreferrer(const std::string& value);
  std::string* _internal_mutable_installreferrer();
  public:

  // optional .playapi.proto.finsky.download.InstallDetails installDetails = 4;
  bool has_installdetails() const;
  private:
  bool _internal_has_installdetails() const;
  public:
  void clear_installdetails();
  const ::playapi::proto::finsky::download::InstallDetails& installdetails() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::download::InstallDetails* release_installdetails();
  ::playapi::proto::finsky::download::InstallDetails* mutable_installdetails();
  void set_allocated_installdetails(::playapi::proto::finsky::download::InstallDetails* installdetails);
  private:
  const ::playapi::proto::finsky::download::InstallDetails& _internal_installdetails() const;
  ::playapi::proto::finsky::download::InstallDetails* _internal_mutable_installdetails();
  public:
  void unsafe_arena_set_allocated_installdetails(
      ::playapi::proto::finsky::download::InstallDetails* installdetails);
  ::playapi::proto::finsky::download::InstallDetails* unsafe_arena_release_installdetails();

  // optional int32 versionCode = 1;
  bool has_versioncode() const;
  private:
  bool _internal_has_versioncode() const;
  public:
  void clear_versioncode();
  int32_t versioncode() const;
  void set_versioncode(int32_t value);
  private:
  int32_t _internal_versioncode() const;
  void _internal_set_versioncode(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.response.AndroidAppNotificationData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr assetid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr installreferrer_;
    ::playapi::proto::finsky::download::InstallDetails* installdetails_;
    int32_t versioncode_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5frespone_2eproto;
};
// -------------------------------------------------------------------

class PurchaseRemovalData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.response.PurchaseRemovalData) */ {
 public:
  inline PurchaseRemovalData() : PurchaseRemovalData(nullptr) {}
  ~PurchaseRemovalData() override;
  explicit PROTOBUF_CONSTEXPR PurchaseRemovalData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PurchaseRemovalData(const PurchaseRemovalData& from);
  PurchaseRemovalData(PurchaseRemovalData&& from) noexcept
    : PurchaseRemovalData() {
    *this = ::std::move(from);
  }

  inline PurchaseRemovalData& operator=(const PurchaseRemovalData& from) {
    CopyFrom(from);
    return *this;
  }
  inline PurchaseRemovalData& operator=(PurchaseRemovalData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PurchaseRemovalData& default_instance() {
    return *internal_default_instance();
  }
  static inline const PurchaseRemovalData* internal_default_instance() {
    return reinterpret_cast<const PurchaseRemovalData*>(
               &_PurchaseRemovalData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PurchaseRemovalData& a, PurchaseRemovalData& b) {
    a.Swap(&b);
  }
  inline void Swap(PurchaseRemovalData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PurchaseRemovalData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PurchaseRemovalData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PurchaseRemovalData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PurchaseRemovalData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PurchaseRemovalData& from) {
    PurchaseRemovalData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PurchaseRemovalData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.response.PurchaseRemovalData";
  }
  protected:
  explicit PurchaseRemovalData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaliciousFieldNumber = 1,
  };
  // optional bool malicious = 1;
  bool has_malicious() const;
  private:
  bool _internal_has_malicious() const;
  public:
  void clear_malicious();
  bool malicious() const;
  void set_malicious(bool value);
  private:
  bool _internal_malicious() const;
  void _internal_set_malicious(bool value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.response.PurchaseRemovalData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool malicious_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5frespone_2eproto;
};
// -------------------------------------------------------------------

class UserNotificationData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.response.UserNotificationData) */ {
 public:
  inline UserNotificationData() : UserNotificationData(nullptr) {}
  ~UserNotificationData() override;
  explicit PROTOBUF_CONSTEXPR UserNotificationData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserNotificationData(const UserNotificationData& from);
  UserNotificationData(UserNotificationData&& from) noexcept
    : UserNotificationData() {
    *this = ::std::move(from);
  }

  inline UserNotificationData& operator=(const UserNotificationData& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserNotificationData& operator=(UserNotificationData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserNotificationData& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserNotificationData* internal_default_instance() {
    return reinterpret_cast<const UserNotificationData*>(
               &_UserNotificationData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(UserNotificationData& a, UserNotificationData& b) {
    a.Swap(&b);
  }
  inline void Swap(UserNotificationData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserNotificationData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserNotificationData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserNotificationData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserNotificationData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserNotificationData& from) {
    UserNotificationData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserNotificationData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.response.UserNotificationData";
  }
  protected:
  explicit UserNotificationData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNotificationTitleFieldNumber = 1,
    kNotificationTextFieldNumber = 2,
    kTickerTextFieldNumber = 3,
    kDialogTitleFieldNumber = 4,
    kDialogTextFieldNumber = 5,
  };
  // optional string notificationTitle = 1;
  bool has_notificationtitle() const;
  private:
  bool _internal_has_notificationtitle() const;
  public:
  void clear_notificationtitle();
  const std::string& notificationtitle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_notificationtitle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_notificationtitle();
  PROTOBUF_NODISCARD std::string* release_notificationtitle();
  void set_allocated_notificationtitle(std::string* notificationtitle);
  private:
  const std::string& _internal_notificationtitle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_notificationtitle(const std::string& value);
  std::string* _internal_mutable_notificationtitle();
  public:

  // optional string notificationText = 2;
  bool has_notificationtext() const;
  private:
  bool _internal_has_notificationtext() const;
  public:
  void clear_notificationtext();
  const std::string& notificationtext() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_notificationtext(ArgT0&& arg0, ArgT... args);
  std::string* mutable_notificationtext();
  PROTOBUF_NODISCARD std::string* release_notificationtext();
  void set_allocated_notificationtext(std::string* notificationtext);
  private:
  const std::string& _internal_notificationtext() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_notificationtext(const std::string& value);
  std::string* _internal_mutable_notificationtext();
  public:

  // optional string tickerText = 3;
  bool has_tickertext() const;
  private:
  bool _internal_has_tickertext() const;
  public:
  void clear_tickertext();
  const std::string& tickertext() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tickertext(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tickertext();
  PROTOBUF_NODISCARD std::string* release_tickertext();
  void set_allocated_tickertext(std::string* tickertext);
  private:
  const std::string& _internal_tickertext() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tickertext(const std::string& value);
  std::string* _internal_mutable_tickertext();
  public:

  // optional string dialogTitle = 4;
  bool has_dialogtitle() const;
  private:
  bool _internal_has_dialogtitle() const;
  public:
  void clear_dialogtitle();
  const std::string& dialogtitle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dialogtitle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dialogtitle();
  PROTOBUF_NODISCARD std::string* release_dialogtitle();
  void set_allocated_dialogtitle(std::string* dialogtitle);
  private:
  const std::string& _internal_dialogtitle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dialogtitle(const std::string& value);
  std::string* _internal_mutable_dialogtitle();
  public:

  // optional string dialogText = 5;
  bool has_dialogtext() const;
  private:
  bool _internal_has_dialogtext() const;
  public:
  void clear_dialogtext();
  const std::string& dialogtext() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dialogtext(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dialogtext();
  PROTOBUF_NODISCARD std::string* release_dialogtext();
  void set_allocated_dialogtext(std::string* dialogtext);
  private:
  const std::string& _internal_dialogtext() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dialogtext(const std::string& value);
  std::string* _internal_mutable_dialogtext();
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.response.UserNotificationData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr notificationtitle_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr notificationtext_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tickertext_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dialogtitle_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dialogtext_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5frespone_2eproto;
};
// -------------------------------------------------------------------

class InAppNotificationData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.response.InAppNotificationData) */ {
 public:
  inline InAppNotificationData() : InAppNotificationData(nullptr) {}
  ~InAppNotificationData() override;
  explicit PROTOBUF_CONSTEXPR InAppNotificationData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InAppNotificationData(const InAppNotificationData& from);
  InAppNotificationData(InAppNotificationData&& from) noexcept
    : InAppNotificationData() {
    *this = ::std::move(from);
  }

  inline InAppNotificationData& operator=(const InAppNotificationData& from) {
    CopyFrom(from);
    return *this;
  }
  inline InAppNotificationData& operator=(InAppNotificationData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InAppNotificationData& default_instance() {
    return *internal_default_instance();
  }
  static inline const InAppNotificationData* internal_default_instance() {
    return reinterpret_cast<const InAppNotificationData*>(
               &_InAppNotificationData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(InAppNotificationData& a, InAppNotificationData& b) {
    a.Swap(&b);
  }
  inline void Swap(InAppNotificationData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InAppNotificationData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InAppNotificationData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InAppNotificationData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InAppNotificationData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InAppNotificationData& from) {
    InAppNotificationData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InAppNotificationData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.response.InAppNotificationData";
  }
  protected:
  explicit InAppNotificationData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCheckoutOrderIdFieldNumber = 1,
    kInAppNotificationIdFieldNumber = 2,
  };
  // optional string checkoutOrderId = 1;
  bool has_checkoutorderid() const;
  private:
  bool _internal_has_checkoutorderid() const;
  public:
  void clear_checkoutorderid();
  const std::string& checkoutorderid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_checkoutorderid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_checkoutorderid();
  PROTOBUF_NODISCARD std::string* release_checkoutorderid();
  void set_allocated_checkoutorderid(std::string* checkoutorderid);
  private:
  const std::string& _internal_checkoutorderid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_checkoutorderid(const std::string& value);
  std::string* _internal_mutable_checkoutorderid();
  public:

  // optional string inAppNotificationId = 2;
  bool has_inappnotificationid() const;
  private:
  bool _internal_has_inappnotificationid() const;
  public:
  void clear_inappnotificationid();
  const std::string& inappnotificationid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_inappnotificationid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_inappnotificationid();
  PROTOBUF_NODISCARD std::string* release_inappnotificationid();
  void set_allocated_inappnotificationid(std::string* inappnotificationid);
  private:
  const std::string& _internal_inappnotificationid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_inappnotificationid(const std::string& value);
  std::string* _internal_mutable_inappnotificationid();
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.response.InAppNotificationData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr checkoutorderid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr inappnotificationid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5frespone_2eproto;
};
// -------------------------------------------------------------------

class PurchaseDeclinedData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.response.PurchaseDeclinedData) */ {
 public:
  inline PurchaseDeclinedData() : PurchaseDeclinedData(nullptr) {}
  ~PurchaseDeclinedData() override;
  explicit PROTOBUF_CONSTEXPR PurchaseDeclinedData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PurchaseDeclinedData(const PurchaseDeclinedData& from);
  PurchaseDeclinedData(PurchaseDeclinedData&& from) noexcept
    : PurchaseDeclinedData() {
    *this = ::std::move(from);
  }

  inline PurchaseDeclinedData& operator=(const PurchaseDeclinedData& from) {
    CopyFrom(from);
    return *this;
  }
  inline PurchaseDeclinedData& operator=(PurchaseDeclinedData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PurchaseDeclinedData& default_instance() {
    return *internal_default_instance();
  }
  static inline const PurchaseDeclinedData* internal_default_instance() {
    return reinterpret_cast<const PurchaseDeclinedData*>(
               &_PurchaseDeclinedData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PurchaseDeclinedData& a, PurchaseDeclinedData& b) {
    a.Swap(&b);
  }
  inline void Swap(PurchaseDeclinedData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PurchaseDeclinedData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PurchaseDeclinedData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PurchaseDeclinedData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PurchaseDeclinedData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PurchaseDeclinedData& from) {
    PurchaseDeclinedData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PurchaseDeclinedData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.response.PurchaseDeclinedData";
  }
  protected:
  explicit PurchaseDeclinedData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReasonFieldNumber = 1,
    kShowNotificationFieldNumber = 2,
  };
  // optional int32 reason = 1;
  bool has_reason() const;
  private:
  bool _internal_has_reason() const;
  public:
  void clear_reason();
  int32_t reason() const;
  void set_reason(int32_t value);
  private:
  int32_t _internal_reason() const;
  void _internal_set_reason(int32_t value);
  public:

  // optional bool showNotification = 2;
  bool has_shownotification() const;
  private:
  bool _internal_has_shownotification() const;
  public:
  void clear_shownotification();
  bool shownotification() const;
  void set_shownotification(bool value);
  private:
  bool _internal_shownotification() const;
  void _internal_set_shownotification(bool value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.response.PurchaseDeclinedData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t reason_;
    bool shownotification_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5frespone_2eproto;
};
// -------------------------------------------------------------------

class LibraryDirtyData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.response.LibraryDirtyData) */ {
 public:
  inline LibraryDirtyData() : LibraryDirtyData(nullptr) {}
  ~LibraryDirtyData() override;
  explicit PROTOBUF_CONSTEXPR LibraryDirtyData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LibraryDirtyData(const LibraryDirtyData& from);
  LibraryDirtyData(LibraryDirtyData&& from) noexcept
    : LibraryDirtyData() {
    *this = ::std::move(from);
  }

  inline LibraryDirtyData& operator=(const LibraryDirtyData& from) {
    CopyFrom(from);
    return *this;
  }
  inline LibraryDirtyData& operator=(LibraryDirtyData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LibraryDirtyData& default_instance() {
    return *internal_default_instance();
  }
  static inline const LibraryDirtyData* internal_default_instance() {
    return reinterpret_cast<const LibraryDirtyData*>(
               &_LibraryDirtyData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(LibraryDirtyData& a, LibraryDirtyData& b) {
    a.Swap(&b);
  }
  inline void Swap(LibraryDirtyData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LibraryDirtyData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LibraryDirtyData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LibraryDirtyData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LibraryDirtyData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LibraryDirtyData& from) {
    LibraryDirtyData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LibraryDirtyData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.response.LibraryDirtyData";
  }
  protected:
  explicit LibraryDirtyData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLibraryIdFieldNumber = 2,
    kBackendFieldNumber = 1,
  };
  // optional string libraryId = 2;
  bool has_libraryid() const;
  private:
  bool _internal_has_libraryid() const;
  public:
  void clear_libraryid();
  const std::string& libraryid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_libraryid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_libraryid();
  PROTOBUF_NODISCARD std::string* release_libraryid();
  void set_allocated_libraryid(std::string* libraryid);
  private:
  const std::string& _internal_libraryid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_libraryid(const std::string& value);
  std::string* _internal_mutable_libraryid();
  public:

  // optional int32 backend = 1;
  bool has_backend() const;
  private:
  bool _internal_has_backend() const;
  public:
  void clear_backend();
  int32_t backend() const;
  void set_backend(int32_t value);
  private:
  int32_t _internal_backend() const;
  void _internal_set_backend(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.response.LibraryDirtyData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr libraryid_;
    int32_t backend_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5frespone_2eproto;
};
// -------------------------------------------------------------------

class Notification final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.response.Notification) */ {
 public:
  inline Notification() : Notification(nullptr) {}
  ~Notification() override;
  explicit PROTOBUF_CONSTEXPR Notification(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Notification(const Notification& from);
  Notification(Notification&& from) noexcept
    : Notification() {
    *this = ::std::move(from);
  }

  inline Notification& operator=(const Notification& from) {
    CopyFrom(from);
    return *this;
  }
  inline Notification& operator=(Notification&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Notification& default_instance() {
    return *internal_default_instance();
  }
  static inline const Notification* internal_default_instance() {
    return reinterpret_cast<const Notification*>(
               &_Notification_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Notification& a, Notification& b) {
    a.Swap(&b);
  }
  inline void Swap(Notification* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Notification* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Notification* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Notification>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Notification& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Notification& from) {
    Notification::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Notification* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.response.Notification";
  }
  protected:
  explicit Notification(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDocTitleFieldNumber = 5,
    kUserEmailFieldNumber = 6,
    kNotificationIdFieldNumber = 13,
    kDocidFieldNumber = 4,
    kAppDataFieldNumber = 7,
    kAppDeliveryDataFieldNumber = 8,
    kPurchaseRemovalDataFieldNumber = 9,
    kUserNotificationDataFieldNumber = 10,
    kInAppNotificationDataFieldNumber = 11,
    kPurchaseDeclinedDataFieldNumber = 12,
    kLibraryDirtyDataFieldNumber = 15,
    kUserSettingDirtyDataFieldNumber = 16,
    kTimestampFieldNumber = 3,
    kNotificationTypeFieldNumber = 1,
    kNotificationAckRequiredFieldNumber = 17,
  };
  // optional string docTitle = 5;
  bool has_doctitle() const;
  private:
  bool _internal_has_doctitle() const;
  public:
  void clear_doctitle();
  const std::string& doctitle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_doctitle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_doctitle();
  PROTOBUF_NODISCARD std::string* release_doctitle();
  void set_allocated_doctitle(std::string* doctitle);
  private:
  const std::string& _internal_doctitle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_doctitle(const std::string& value);
  std::string* _internal_mutable_doctitle();
  public:

  // optional string userEmail = 6;
  bool has_useremail() const;
  private:
  bool _internal_has_useremail() const;
  public:
  void clear_useremail();
  const std::string& useremail() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_useremail(ArgT0&& arg0, ArgT... args);
  std::string* mutable_useremail();
  PROTOBUF_NODISCARD std::string* release_useremail();
  void set_allocated_useremail(std::string* useremail);
  private:
  const std::string& _internal_useremail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_useremail(const std::string& value);
  std::string* _internal_mutable_useremail();
  public:

  // optional string notificationId = 13;
  bool has_notificationid() const;
  private:
  bool _internal_has_notificationid() const;
  public:
  void clear_notificationid();
  const std::string& notificationid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_notificationid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_notificationid();
  PROTOBUF_NODISCARD std::string* release_notificationid();
  void set_allocated_notificationid(std::string* notificationid);
  private:
  const std::string& _internal_notificationid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_notificationid(const std::string& value);
  std::string* _internal_mutable_notificationid();
  public:

  // optional .playapi.proto.finsky.Docid docid = 4;
  bool has_docid() const;
  private:
  bool _internal_has_docid() const;
  public:
  void clear_docid();
  const ::playapi::proto::finsky::Docid& docid() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::Docid* release_docid();
  ::playapi::proto::finsky::Docid* mutable_docid();
  void set_allocated_docid(::playapi::proto::finsky::Docid* docid);
  private:
  const ::playapi::proto::finsky::Docid& _internal_docid() const;
  ::playapi::proto::finsky::Docid* _internal_mutable_docid();
  public:
  void unsafe_arena_set_allocated_docid(
      ::playapi::proto::finsky::Docid* docid);
  ::playapi::proto::finsky::Docid* unsafe_arena_release_docid();

  // optional .playapi.proto.finsky.response.AndroidAppNotificationData appData = 7;
  bool has_appdata() const;
  private:
  bool _internal_has_appdata() const;
  public:
  void clear_appdata();
  const ::playapi::proto::finsky::response::AndroidAppNotificationData& appdata() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::response::AndroidAppNotificationData* release_appdata();
  ::playapi::proto::finsky::response::AndroidAppNotificationData* mutable_appdata();
  void set_allocated_appdata(::playapi::proto::finsky::response::AndroidAppNotificationData* appdata);
  private:
  const ::playapi::proto::finsky::response::AndroidAppNotificationData& _internal_appdata() const;
  ::playapi::proto::finsky::response::AndroidAppNotificationData* _internal_mutable_appdata();
  public:
  void unsafe_arena_set_allocated_appdata(
      ::playapi::proto::finsky::response::AndroidAppNotificationData* appdata);
  ::playapi::proto::finsky::response::AndroidAppNotificationData* unsafe_arena_release_appdata();

  // optional .playapi.proto.finsky.download.AndroidAppDeliveryData appDeliveryData = 8;
  bool has_appdeliverydata() const;
  private:
  bool _internal_has_appdeliverydata() const;
  public:
  void clear_appdeliverydata();
  const ::playapi::proto::finsky::download::AndroidAppDeliveryData& appdeliverydata() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::download::AndroidAppDeliveryData* release_appdeliverydata();
  ::playapi::proto::finsky::download::AndroidAppDeliveryData* mutable_appdeliverydata();
  void set_allocated_appdeliverydata(::playapi::proto::finsky::download::AndroidAppDeliveryData* appdeliverydata);
  private:
  const ::playapi::proto::finsky::download::AndroidAppDeliveryData& _internal_appdeliverydata() const;
  ::playapi::proto::finsky::download::AndroidAppDeliveryData* _internal_mutable_appdeliverydata();
  public:
  void unsafe_arena_set_allocated_appdeliverydata(
      ::playapi::proto::finsky::download::AndroidAppDeliveryData* appdeliverydata);
  ::playapi::proto::finsky::download::AndroidAppDeliveryData* unsafe_arena_release_appdeliverydata();

  // optional .playapi.proto.finsky.response.PurchaseRemovalData purchaseRemovalData = 9;
  bool has_purchaseremovaldata() const;
  private:
  bool _internal_has_purchaseremovaldata() const;
  public:
  void clear_purchaseremovaldata();
  const ::playapi::proto::finsky::response::PurchaseRemovalData& purchaseremovaldata() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::response::PurchaseRemovalData* release_purchaseremovaldata();
  ::playapi::proto::finsky::response::PurchaseRemovalData* mutable_purchaseremovaldata();
  void set_allocated_purchaseremovaldata(::playapi::proto::finsky::response::PurchaseRemovalData* purchaseremovaldata);
  private:
  const ::playapi::proto::finsky::response::PurchaseRemovalData& _internal_purchaseremovaldata() const;
  ::playapi::proto::finsky::response::PurchaseRemovalData* _internal_mutable_purchaseremovaldata();
  public:
  void unsafe_arena_set_allocated_purchaseremovaldata(
      ::playapi::proto::finsky::response::PurchaseRemovalData* purchaseremovaldata);
  ::playapi::proto::finsky::response::PurchaseRemovalData* unsafe_arena_release_purchaseremovaldata();

  // optional .playapi.proto.finsky.response.UserNotificationData userNotificationData = 10;
  bool has_usernotificationdata() const;
  private:
  bool _internal_has_usernotificationdata() const;
  public:
  void clear_usernotificationdata();
  const ::playapi::proto::finsky::response::UserNotificationData& usernotificationdata() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::response::UserNotificationData* release_usernotificationdata();
  ::playapi::proto::finsky::response::UserNotificationData* mutable_usernotificationdata();
  void set_allocated_usernotificationdata(::playapi::proto::finsky::response::UserNotificationData* usernotificationdata);
  private:
  const ::playapi::proto::finsky::response::UserNotificationData& _internal_usernotificationdata() const;
  ::playapi::proto::finsky::response::UserNotificationData* _internal_mutable_usernotificationdata();
  public:
  void unsafe_arena_set_allocated_usernotificationdata(
      ::playapi::proto::finsky::response::UserNotificationData* usernotificationdata);
  ::playapi::proto::finsky::response::UserNotificationData* unsafe_arena_release_usernotificationdata();

  // optional .playapi.proto.finsky.response.InAppNotificationData inAppNotificationData = 11;
  bool has_inappnotificationdata() const;
  private:
  bool _internal_has_inappnotificationdata() const;
  public:
  void clear_inappnotificationdata();
  const ::playapi::proto::finsky::response::InAppNotificationData& inappnotificationdata() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::response::InAppNotificationData* release_inappnotificationdata();
  ::playapi::proto::finsky::response::InAppNotificationData* mutable_inappnotificationdata();
  void set_allocated_inappnotificationdata(::playapi::proto::finsky::response::InAppNotificationData* inappnotificationdata);
  private:
  const ::playapi::proto::finsky::response::InAppNotificationData& _internal_inappnotificationdata() const;
  ::playapi::proto::finsky::response::InAppNotificationData* _internal_mutable_inappnotificationdata();
  public:
  void unsafe_arena_set_allocated_inappnotificationdata(
      ::playapi::proto::finsky::response::InAppNotificationData* inappnotificationdata);
  ::playapi::proto::finsky::response::InAppNotificationData* unsafe_arena_release_inappnotificationdata();

  // optional .playapi.proto.finsky.response.PurchaseDeclinedData purchaseDeclinedData = 12;
  bool has_purchasedeclineddata() const;
  private:
  bool _internal_has_purchasedeclineddata() const;
  public:
  void clear_purchasedeclineddata();
  const ::playapi::proto::finsky::response::PurchaseDeclinedData& purchasedeclineddata() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::response::PurchaseDeclinedData* release_purchasedeclineddata();
  ::playapi::proto::finsky::response::PurchaseDeclinedData* mutable_purchasedeclineddata();
  void set_allocated_purchasedeclineddata(::playapi::proto::finsky::response::PurchaseDeclinedData* purchasedeclineddata);
  private:
  const ::playapi::proto::finsky::response::PurchaseDeclinedData& _internal_purchasedeclineddata() const;
  ::playapi::proto::finsky::response::PurchaseDeclinedData* _internal_mutable_purchasedeclineddata();
  public:
  void unsafe_arena_set_allocated_purchasedeclineddata(
      ::playapi::proto::finsky::response::PurchaseDeclinedData* purchasedeclineddata);
  ::playapi::proto::finsky::response::PurchaseDeclinedData* unsafe_arena_release_purchasedeclineddata();

  // optional .playapi.proto.finsky.response.LibraryDirtyData libraryDirtyData = 15;
  bool has_librarydirtydata() const;
  private:
  bool _internal_has_librarydirtydata() const;
  public:
  void clear_librarydirtydata();
  const ::playapi::proto::finsky::response::LibraryDirtyData& librarydirtydata() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::response::LibraryDirtyData* release_librarydirtydata();
  ::playapi::proto::finsky::response::LibraryDirtyData* mutable_librarydirtydata();
  void set_allocated_librarydirtydata(::playapi::proto::finsky::response::LibraryDirtyData* librarydirtydata);
  private:
  const ::playapi::proto::finsky::response::LibraryDirtyData& _internal_librarydirtydata() const;
  ::playapi::proto::finsky::response::LibraryDirtyData* _internal_mutable_librarydirtydata();
  public:
  void unsafe_arena_set_allocated_librarydirtydata(
      ::playapi::proto::finsky::response::LibraryDirtyData* librarydirtydata);
  ::playapi::proto::finsky::response::LibraryDirtyData* unsafe_arena_release_librarydirtydata();

  // optional .playapi.proto.finsky.settings.UserSettingDirtyData userSettingDirtyData = 16;
  bool has_usersettingdirtydata() const;
  private:
  bool _internal_has_usersettingdirtydata() const;
  public:
  void clear_usersettingdirtydata();
  const ::playapi::proto::finsky::settings::UserSettingDirtyData& usersettingdirtydata() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::settings::UserSettingDirtyData* release_usersettingdirtydata();
  ::playapi::proto::finsky::settings::UserSettingDirtyData* mutable_usersettingdirtydata();
  void set_allocated_usersettingdirtydata(::playapi::proto::finsky::settings::UserSettingDirtyData* usersettingdirtydata);
  private:
  const ::playapi::proto::finsky::settings::UserSettingDirtyData& _internal_usersettingdirtydata() const;
  ::playapi::proto::finsky::settings::UserSettingDirtyData* _internal_mutable_usersettingdirtydata();
  public:
  void unsafe_arena_set_allocated_usersettingdirtydata(
      ::playapi::proto::finsky::settings::UserSettingDirtyData* usersettingdirtydata);
  ::playapi::proto::finsky::settings::UserSettingDirtyData* unsafe_arena_release_usersettingdirtydata();

  // optional int64 timestamp = 3;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // optional int32 notificationType = 1;
  bool has_notificationtype() const;
  private:
  bool _internal_has_notificationtype() const;
  public:
  void clear_notificationtype();
  int32_t notificationtype() const;
  void set_notificationtype(int32_t value);
  private:
  int32_t _internal_notificationtype() const;
  void _internal_set_notificationtype(int32_t value);
  public:

  // optional bool notificationAckRequired = 17;
  bool has_notificationackrequired() const;
  private:
  bool _internal_has_notificationackrequired() const;
  public:
  void clear_notificationackrequired();
  bool notificationackrequired() const;
  void set_notificationackrequired(bool value);
  private:
  bool _internal_notificationackrequired() const;
  void _internal_set_notificationackrequired(bool value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.response.Notification)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr doctitle_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr useremail_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr notificationid_;
    ::playapi::proto::finsky::Docid* docid_;
    ::playapi::proto::finsky::response::AndroidAppNotificationData* appdata_;
    ::playapi::proto::finsky::download::AndroidAppDeliveryData* appdeliverydata_;
    ::playapi::proto::finsky::response::PurchaseRemovalData* purchaseremovaldata_;
    ::playapi::proto::finsky::response::UserNotificationData* usernotificationdata_;
    ::playapi::proto::finsky::response::InAppNotificationData* inappnotificationdata_;
    ::playapi::proto::finsky::response::PurchaseDeclinedData* purchasedeclineddata_;
    ::playapi::proto::finsky::response::LibraryDirtyData* librarydirtydata_;
    ::playapi::proto::finsky::settings::UserSettingDirtyData* usersettingdirtydata_;
    int64_t timestamp_;
    int32_t notificationtype_;
    bool notificationackrequired_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5frespone_2eproto;
};
// -------------------------------------------------------------------

class ServerMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.response.ServerMetadata) */ {
 public:
  inline ServerMetadata() : ServerMetadata(nullptr) {}
  ~ServerMetadata() override;
  explicit PROTOBUF_CONSTEXPR ServerMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerMetadata(const ServerMetadata& from);
  ServerMetadata(ServerMetadata&& from) noexcept
    : ServerMetadata() {
    *this = ::std::move(from);
  }

  inline ServerMetadata& operator=(const ServerMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerMetadata& operator=(ServerMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerMetadata* internal_default_instance() {
    return reinterpret_cast<const ServerMetadata*>(
               &_ServerMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ServerMetadata& a, ServerMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServerMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServerMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServerMetadata& from) {
    ServerMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.response.ServerMetadata";
  }
  protected:
  explicit ServerMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLatencyMillisFieldNumber = 1,
  };
  // optional int64 latencyMillis = 1;
  bool has_latencymillis() const;
  private:
  bool _internal_has_latencymillis() const;
  public:
  void clear_latencymillis();
  int64_t latencymillis() const;
  void set_latencymillis(int64_t value);
  private:
  int64_t _internal_latencymillis() const;
  void _internal_set_latencymillis(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.response.ServerMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t latencymillis_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5frespone_2eproto;
};
// -------------------------------------------------------------------

class Targets final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.response.Targets) */ {
 public:
  inline Targets() : Targets(nullptr) {}
  ~Targets() override;
  explicit PROTOBUF_CONSTEXPR Targets(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Targets(const Targets& from);
  Targets(Targets&& from) noexcept
    : Targets() {
    *this = ::std::move(from);
  }

  inline Targets& operator=(const Targets& from) {
    CopyFrom(from);
    return *this;
  }
  inline Targets& operator=(Targets&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Targets& default_instance() {
    return *internal_default_instance();
  }
  static inline const Targets* internal_default_instance() {
    return reinterpret_cast<const Targets*>(
               &_Targets_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Targets& a, Targets& b) {
    a.Swap(&b);
  }
  inline void Swap(Targets* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Targets* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Targets* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Targets>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Targets& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Targets& from) {
    Targets::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Targets* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.response.Targets";
  }
  protected:
  explicit Targets(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetIdFieldNumber = 1,
    kSignatureFieldNumber = 2,
  };
  // repeated int64 targetId = 1;
  int targetid_size() const;
  private:
  int _internal_targetid_size() const;
  public:
  void clear_targetid();
  private:
  int64_t _internal_targetid(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_targetid() const;
  void _internal_add_targetid(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_targetid();
  public:
  int64_t targetid(int index) const;
  void set_targetid(int index, int64_t value);
  void add_targetid(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      targetid() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_targetid();

  // optional bytes signature = 2;
  bool has_signature() const;
  private:
  bool _internal_has_signature() const;
  public:
  void clear_signature();
  const std::string& signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature();
  PROTOBUF_NODISCARD std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.response.Targets)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > targetid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5frespone_2eproto;
};
// -------------------------------------------------------------------

class ServerCookie final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.response.ServerCookie) */ {
 public:
  inline ServerCookie() : ServerCookie(nullptr) {}
  ~ServerCookie() override;
  explicit PROTOBUF_CONSTEXPR ServerCookie(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerCookie(const ServerCookie& from);
  ServerCookie(ServerCookie&& from) noexcept
    : ServerCookie() {
    *this = ::std::move(from);
  }

  inline ServerCookie& operator=(const ServerCookie& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerCookie& operator=(ServerCookie&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerCookie& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerCookie* internal_default_instance() {
    return reinterpret_cast<const ServerCookie*>(
               &_ServerCookie_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ServerCookie& a, ServerCookie& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerCookie* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerCookie* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerCookie* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServerCookie>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServerCookie& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServerCookie& from) {
    ServerCookie::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerCookie* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.response.ServerCookie";
  }
  protected:
  explicit ServerCookie(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // optional bytes token = 2;
  bool has_token() const;
  private:
  bool _internal_has_token() const;
  public:
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // optional int32 type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  int32_t type() const;
  void set_type(int32_t value);
  private:
  int32_t _internal_type() const;
  void _internal_set_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.response.ServerCookie)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    int32_t type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5frespone_2eproto;
};
// -------------------------------------------------------------------

class ServerCookies final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.response.ServerCookies) */ {
 public:
  inline ServerCookies() : ServerCookies(nullptr) {}
  ~ServerCookies() override;
  explicit PROTOBUF_CONSTEXPR ServerCookies(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerCookies(const ServerCookies& from);
  ServerCookies(ServerCookies&& from) noexcept
    : ServerCookies() {
    *this = ::std::move(from);
  }

  inline ServerCookies& operator=(const ServerCookies& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerCookies& operator=(ServerCookies&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerCookies& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerCookies* internal_default_instance() {
    return reinterpret_cast<const ServerCookies*>(
               &_ServerCookies_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ServerCookies& a, ServerCookies& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerCookies* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerCookies* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerCookies* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServerCookies>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServerCookies& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServerCookies& from) {
    ServerCookies::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerCookies* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.response.ServerCookies";
  }
  protected:
  explicit ServerCookies(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerCookieFieldNumber = 1,
  };
  // repeated .playapi.proto.finsky.response.ServerCookie serverCookie = 1;
  int servercookie_size() const;
  private:
  int _internal_servercookie_size() const;
  public:
  void clear_servercookie();
  ::playapi::proto::finsky::response::ServerCookie* mutable_servercookie(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::response::ServerCookie >*
      mutable_servercookie();
  private:
  const ::playapi::proto::finsky::response::ServerCookie& _internal_servercookie(int index) const;
  ::playapi::proto::finsky::response::ServerCookie* _internal_add_servercookie();
  public:
  const ::playapi::proto::finsky::response::ServerCookie& servercookie(int index) const;
  ::playapi::proto::finsky::response::ServerCookie* add_servercookie();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::response::ServerCookie >&
      servercookie() const;

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.response.ServerCookies)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::response::ServerCookie > servercookie_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5frespone_2eproto;
};
// -------------------------------------------------------------------

class AcceptTosResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.response.AcceptTosResponse) */ {
 public:
  inline AcceptTosResponse() : AcceptTosResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR AcceptTosResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AcceptTosResponse(const AcceptTosResponse& from);
  AcceptTosResponse(AcceptTosResponse&& from) noexcept
    : AcceptTosResponse() {
    *this = ::std::move(from);
  }

  inline AcceptTosResponse& operator=(const AcceptTosResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AcceptTosResponse& operator=(AcceptTosResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AcceptTosResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AcceptTosResponse* internal_default_instance() {
    return reinterpret_cast<const AcceptTosResponse*>(
               &_AcceptTosResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(AcceptTosResponse& a, AcceptTosResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AcceptTosResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AcceptTosResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AcceptTosResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AcceptTosResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AcceptTosResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AcceptTosResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.response.AcceptTosResponse";
  }
  protected:
  explicit AcceptTosResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.response.AcceptTosResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_play_5frespone_2eproto;
};
// -------------------------------------------------------------------

class Payload final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.response.Payload) */ {
 public:
  inline Payload() : Payload(nullptr) {}
  ~Payload() override;
  explicit PROTOBUF_CONSTEXPR Payload(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Payload(const Payload& from);
  Payload(Payload&& from) noexcept
    : Payload() {
    *this = ::std::move(from);
  }

  inline Payload& operator=(const Payload& from) {
    CopyFrom(from);
    return *this;
  }
  inline Payload& operator=(Payload&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Payload& default_instance() {
    return *internal_default_instance();
  }
  static inline const Payload* internal_default_instance() {
    return reinterpret_cast<const Payload*>(
               &_Payload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Payload& a, Payload& b) {
    a.Swap(&b);
  }
  inline void Swap(Payload* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Payload* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Payload* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Payload>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Payload& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Payload& from) {
    Payload::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Payload* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.response.Payload";
  }
  protected:
  explicit Payload(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDetailsResponseFieldNumber = 2,
    kSearchResponseFieldNumber = 5,
    kTocResponseFieldNumber = 6,
    kBrowseResponseFieldNumber = 7,
    kBulkDetailsResponseFieldNumber = 19,
    kDeliveryResponseFieldNumber = 21,
    kAcceptTosResponseFieldNumber = 22,
    kUploadDeviceConfigResponseFieldNumber = 28,
    kSearchSuggestResponseFieldNumber = 40,
    kGetUserSettingsResponseFieldNumber = 54,
  };
  // optional .playapi.proto.finsky.details.DetailsResponse detailsResponse = 2;
  bool has_detailsresponse() const;
  private:
  bool _internal_has_detailsresponse() const;
  public:
  void clear_detailsresponse();
  const ::playapi::proto::finsky::details::DetailsResponse& detailsresponse() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::details::DetailsResponse* release_detailsresponse();
  ::playapi::proto::finsky::details::DetailsResponse* mutable_detailsresponse();
  void set_allocated_detailsresponse(::playapi::proto::finsky::details::DetailsResponse* detailsresponse);
  private:
  const ::playapi::proto::finsky::details::DetailsResponse& _internal_detailsresponse() const;
  ::playapi::proto::finsky::details::DetailsResponse* _internal_mutable_detailsresponse();
  public:
  void unsafe_arena_set_allocated_detailsresponse(
      ::playapi::proto::finsky::details::DetailsResponse* detailsresponse);
  ::playapi::proto::finsky::details::DetailsResponse* unsafe_arena_release_detailsresponse();

  // optional .playapi.proto.finsky.search.SearchResponse searchResponse = 5;
  bool has_searchresponse() const;
  private:
  bool _internal_has_searchresponse() const;
  public:
  void clear_searchresponse();
  const ::playapi::proto::finsky::search::SearchResponse& searchresponse() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::search::SearchResponse* release_searchresponse();
  ::playapi::proto::finsky::search::SearchResponse* mutable_searchresponse();
  void set_allocated_searchresponse(::playapi::proto::finsky::search::SearchResponse* searchresponse);
  private:
  const ::playapi::proto::finsky::search::SearchResponse& _internal_searchresponse() const;
  ::playapi::proto::finsky::search::SearchResponse* _internal_mutable_searchresponse();
  public:
  void unsafe_arena_set_allocated_searchresponse(
      ::playapi::proto::finsky::search::SearchResponse* searchresponse);
  ::playapi::proto::finsky::search::SearchResponse* unsafe_arena_release_searchresponse();

  // optional .playapi.proto.finsky.toc.TocResponse tocResponse = 6;
  bool has_tocresponse() const;
  private:
  bool _internal_has_tocresponse() const;
  public:
  void clear_tocresponse();
  const ::playapi::proto::finsky::toc::TocResponse& tocresponse() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::toc::TocResponse* release_tocresponse();
  ::playapi::proto::finsky::toc::TocResponse* mutable_tocresponse();
  void set_allocated_tocresponse(::playapi::proto::finsky::toc::TocResponse* tocresponse);
  private:
  const ::playapi::proto::finsky::toc::TocResponse& _internal_tocresponse() const;
  ::playapi::proto::finsky::toc::TocResponse* _internal_mutable_tocresponse();
  public:
  void unsafe_arena_set_allocated_tocresponse(
      ::playapi::proto::finsky::toc::TocResponse* tocresponse);
  ::playapi::proto::finsky::toc::TocResponse* unsafe_arena_release_tocresponse();

  // optional .playapi.proto.finsky.browse.BrowseResponse browseResponse = 7;
  bool has_browseresponse() const;
  private:
  bool _internal_has_browseresponse() const;
  public:
  void clear_browseresponse();
  const ::playapi::proto::finsky::browse::BrowseResponse& browseresponse() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::browse::BrowseResponse* release_browseresponse();
  ::playapi::proto::finsky::browse::BrowseResponse* mutable_browseresponse();
  void set_allocated_browseresponse(::playapi::proto::finsky::browse::BrowseResponse* browseresponse);
  private:
  const ::playapi::proto::finsky::browse::BrowseResponse& _internal_browseresponse() const;
  ::playapi::proto::finsky::browse::BrowseResponse* _internal_mutable_browseresponse();
  public:
  void unsafe_arena_set_allocated_browseresponse(
      ::playapi::proto::finsky::browse::BrowseResponse* browseresponse);
  ::playapi::proto::finsky::browse::BrowseResponse* unsafe_arena_release_browseresponse();

  // optional .playapi.proto.finsky.details.BulkDetailsResponse bulkDetailsResponse = 19;
  bool has_bulkdetailsresponse() const;
  private:
  bool _internal_has_bulkdetailsresponse() const;
  public:
  void clear_bulkdetailsresponse();
  const ::playapi::proto::finsky::details::BulkDetailsResponse& bulkdetailsresponse() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::details::BulkDetailsResponse* release_bulkdetailsresponse();
  ::playapi::proto::finsky::details::BulkDetailsResponse* mutable_bulkdetailsresponse();
  void set_allocated_bulkdetailsresponse(::playapi::proto::finsky::details::BulkDetailsResponse* bulkdetailsresponse);
  private:
  const ::playapi::proto::finsky::details::BulkDetailsResponse& _internal_bulkdetailsresponse() const;
  ::playapi::proto::finsky::details::BulkDetailsResponse* _internal_mutable_bulkdetailsresponse();
  public:
  void unsafe_arena_set_allocated_bulkdetailsresponse(
      ::playapi::proto::finsky::details::BulkDetailsResponse* bulkdetailsresponse);
  ::playapi::proto::finsky::details::BulkDetailsResponse* unsafe_arena_release_bulkdetailsresponse();

  // optional .playapi.proto.finsky.download.DeliveryResponse deliveryResponse = 21;
  bool has_deliveryresponse() const;
  private:
  bool _internal_has_deliveryresponse() const;
  public:
  void clear_deliveryresponse();
  const ::playapi::proto::finsky::download::DeliveryResponse& deliveryresponse() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::download::DeliveryResponse* release_deliveryresponse();
  ::playapi::proto::finsky::download::DeliveryResponse* mutable_deliveryresponse();
  void set_allocated_deliveryresponse(::playapi::proto::finsky::download::DeliveryResponse* deliveryresponse);
  private:
  const ::playapi::proto::finsky::download::DeliveryResponse& _internal_deliveryresponse() const;
  ::playapi::proto::finsky::download::DeliveryResponse* _internal_mutable_deliveryresponse();
  public:
  void unsafe_arena_set_allocated_deliveryresponse(
      ::playapi::proto::finsky::download::DeliveryResponse* deliveryresponse);
  ::playapi::proto::finsky::download::DeliveryResponse* unsafe_arena_release_deliveryresponse();

  // optional .playapi.proto.finsky.response.AcceptTosResponse acceptTosResponse = 22;
  bool has_accepttosresponse() const;
  private:
  bool _internal_has_accepttosresponse() const;
  public:
  void clear_accepttosresponse();
  const ::playapi::proto::finsky::response::AcceptTosResponse& accepttosresponse() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::response::AcceptTosResponse* release_accepttosresponse();
  ::playapi::proto::finsky::response::AcceptTosResponse* mutable_accepttosresponse();
  void set_allocated_accepttosresponse(::playapi::proto::finsky::response::AcceptTosResponse* accepttosresponse);
  private:
  const ::playapi::proto::finsky::response::AcceptTosResponse& _internal_accepttosresponse() const;
  ::playapi::proto::finsky::response::AcceptTosResponse* _internal_mutable_accepttosresponse();
  public:
  void unsafe_arena_set_allocated_accepttosresponse(
      ::playapi::proto::finsky::response::AcceptTosResponse* accepttosresponse);
  ::playapi::proto::finsky::response::AcceptTosResponse* unsafe_arena_release_accepttosresponse();

  // optional .playapi.proto.finsky.device_config.UploadDeviceConfigResponse uploadDeviceConfigResponse = 28;
  bool has_uploaddeviceconfigresponse() const;
  private:
  bool _internal_has_uploaddeviceconfigresponse() const;
  public:
  void clear_uploaddeviceconfigresponse();
  const ::playapi::proto::finsky::device_config::UploadDeviceConfigResponse& uploaddeviceconfigresponse() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::device_config::UploadDeviceConfigResponse* release_uploaddeviceconfigresponse();
  ::playapi::proto::finsky::device_config::UploadDeviceConfigResponse* mutable_uploaddeviceconfigresponse();
  void set_allocated_uploaddeviceconfigresponse(::playapi::proto::finsky::device_config::UploadDeviceConfigResponse* uploaddeviceconfigresponse);
  private:
  const ::playapi::proto::finsky::device_config::UploadDeviceConfigResponse& _internal_uploaddeviceconfigresponse() const;
  ::playapi::proto::finsky::device_config::UploadDeviceConfigResponse* _internal_mutable_uploaddeviceconfigresponse();
  public:
  void unsafe_arena_set_allocated_uploaddeviceconfigresponse(
      ::playapi::proto::finsky::device_config::UploadDeviceConfigResponse* uploaddeviceconfigresponse);
  ::playapi::proto::finsky::device_config::UploadDeviceConfigResponse* unsafe_arena_release_uploaddeviceconfigresponse();

  // optional .playapi.proto.finsky.search.SearchSuggestResponse searchSuggestResponse = 40;
  bool has_searchsuggestresponse() const;
  private:
  bool _internal_has_searchsuggestresponse() const;
  public:
  void clear_searchsuggestresponse();
  const ::playapi::proto::finsky::search::SearchSuggestResponse& searchsuggestresponse() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::search::SearchSuggestResponse* release_searchsuggestresponse();
  ::playapi::proto::finsky::search::SearchSuggestResponse* mutable_searchsuggestresponse();
  void set_allocated_searchsuggestresponse(::playapi::proto::finsky::search::SearchSuggestResponse* searchsuggestresponse);
  private:
  const ::playapi::proto::finsky::search::SearchSuggestResponse& _internal_searchsuggestresponse() const;
  ::playapi::proto::finsky::search::SearchSuggestResponse* _internal_mutable_searchsuggestresponse();
  public:
  void unsafe_arena_set_allocated_searchsuggestresponse(
      ::playapi::proto::finsky::search::SearchSuggestResponse* searchsuggestresponse);
  ::playapi::proto::finsky::search::SearchSuggestResponse* unsafe_arena_release_searchsuggestresponse();

  // optional .playapi.proto.finsky.settings.GetUserSettingsResponse getUserSettingsResponse = 54;
  bool has_getusersettingsresponse() const;
  private:
  bool _internal_has_getusersettingsresponse() const;
  public:
  void clear_getusersettingsresponse();
  const ::playapi::proto::finsky::settings::GetUserSettingsResponse& getusersettingsresponse() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::settings::GetUserSettingsResponse* release_getusersettingsresponse();
  ::playapi::proto::finsky::settings::GetUserSettingsResponse* mutable_getusersettingsresponse();
  void set_allocated_getusersettingsresponse(::playapi::proto::finsky::settings::GetUserSettingsResponse* getusersettingsresponse);
  private:
  const ::playapi::proto::finsky::settings::GetUserSettingsResponse& _internal_getusersettingsresponse() const;
  ::playapi::proto::finsky::settings::GetUserSettingsResponse* _internal_mutable_getusersettingsresponse();
  public:
  void unsafe_arena_set_allocated_getusersettingsresponse(
      ::playapi::proto::finsky::settings::GetUserSettingsResponse* getusersettingsresponse);
  ::playapi::proto::finsky::settings::GetUserSettingsResponse* unsafe_arena_release_getusersettingsresponse();

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.response.Payload)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::playapi::proto::finsky::details::DetailsResponse* detailsresponse_;
    ::playapi::proto::finsky::search::SearchResponse* searchresponse_;
    ::playapi::proto::finsky::toc::TocResponse* tocresponse_;
    ::playapi::proto::finsky::browse::BrowseResponse* browseresponse_;
    ::playapi::proto::finsky::details::BulkDetailsResponse* bulkdetailsresponse_;
    ::playapi::proto::finsky::download::DeliveryResponse* deliveryresponse_;
    ::playapi::proto::finsky::response::AcceptTosResponse* accepttosresponse_;
    ::playapi::proto::finsky::device_config::UploadDeviceConfigResponse* uploaddeviceconfigresponse_;
    ::playapi::proto::finsky::search::SearchSuggestResponse* searchsuggestresponse_;
    ::playapi::proto::finsky::settings::GetUserSettingsResponse* getusersettingsresponse_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5frespone_2eproto;
};
// -------------------------------------------------------------------

class ResponseWrapper final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.response.ResponseWrapper) */ {
 public:
  inline ResponseWrapper() : ResponseWrapper(nullptr) {}
  ~ResponseWrapper() override;
  explicit PROTOBUF_CONSTEXPR ResponseWrapper(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseWrapper(const ResponseWrapper& from);
  ResponseWrapper(ResponseWrapper&& from) noexcept
    : ResponseWrapper() {
    *this = ::std::move(from);
  }

  inline ResponseWrapper& operator=(const ResponseWrapper& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseWrapper& operator=(ResponseWrapper&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseWrapper& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseWrapper* internal_default_instance() {
    return reinterpret_cast<const ResponseWrapper*>(
               &_ResponseWrapper_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ResponseWrapper& a, ResponseWrapper& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseWrapper* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseWrapper* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseWrapper* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseWrapper>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseWrapper& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResponseWrapper& from) {
    ResponseWrapper::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseWrapper* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.response.ResponseWrapper";
  }
  protected:
  explicit ResponseWrapper(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPreFetchFieldNumber = 3,
    kNotificationFieldNumber = 4,
    kServerLogsCookieFieldNumber = 9,
    kPayloadFieldNumber = 1,
    kCommandsFieldNumber = 2,
    kServerMetadataFieldNumber = 5,
    kTargetsFieldNumber = 6,
    kServerCookiesFieldNumber = 7,
  };
  // repeated .playapi.proto.finsky.response.PreFetch preFetch = 3;
  int prefetch_size() const;
  private:
  int _internal_prefetch_size() const;
  public:
  void clear_prefetch();
  ::playapi::proto::finsky::response::PreFetch* mutable_prefetch(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::response::PreFetch >*
      mutable_prefetch();
  private:
  const ::playapi::proto::finsky::response::PreFetch& _internal_prefetch(int index) const;
  ::playapi::proto::finsky::response::PreFetch* _internal_add_prefetch();
  public:
  const ::playapi::proto::finsky::response::PreFetch& prefetch(int index) const;
  ::playapi::proto::finsky::response::PreFetch* add_prefetch();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::response::PreFetch >&
      prefetch() const;

  // repeated .playapi.proto.finsky.response.Notification notification = 4;
  int notification_size() const;
  private:
  int _internal_notification_size() const;
  public:
  void clear_notification();
  ::playapi::proto::finsky::response::Notification* mutable_notification(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::response::Notification >*
      mutable_notification();
  private:
  const ::playapi::proto::finsky::response::Notification& _internal_notification(int index) const;
  ::playapi::proto::finsky::response::Notification* _internal_add_notification();
  public:
  const ::playapi::proto::finsky::response::Notification& notification(int index) const;
  ::playapi::proto::finsky::response::Notification* add_notification();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::response::Notification >&
      notification() const;

  // optional bytes serverLogsCookie = 9;
  bool has_serverlogscookie() const;
  private:
  bool _internal_has_serverlogscookie() const;
  public:
  void clear_serverlogscookie();
  const std::string& serverlogscookie() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serverlogscookie(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serverlogscookie();
  PROTOBUF_NODISCARD std::string* release_serverlogscookie();
  void set_allocated_serverlogscookie(std::string* serverlogscookie);
  private:
  const std::string& _internal_serverlogscookie() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serverlogscookie(const std::string& value);
  std::string* _internal_mutable_serverlogscookie();
  public:

  // optional .playapi.proto.finsky.response.Payload payload = 1;
  bool has_payload() const;
  private:
  bool _internal_has_payload() const;
  public:
  void clear_payload();
  const ::playapi::proto::finsky::response::Payload& payload() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::response::Payload* release_payload();
  ::playapi::proto::finsky::response::Payload* mutable_payload();
  void set_allocated_payload(::playapi::proto::finsky::response::Payload* payload);
  private:
  const ::playapi::proto::finsky::response::Payload& _internal_payload() const;
  ::playapi::proto::finsky::response::Payload* _internal_mutable_payload();
  public:
  void unsafe_arena_set_allocated_payload(
      ::playapi::proto::finsky::response::Payload* payload);
  ::playapi::proto::finsky::response::Payload* unsafe_arena_release_payload();

  // optional .playapi.proto.finsky.response.ServerCommands commands = 2;
  bool has_commands() const;
  private:
  bool _internal_has_commands() const;
  public:
  void clear_commands();
  const ::playapi::proto::finsky::response::ServerCommands& commands() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::response::ServerCommands* release_commands();
  ::playapi::proto::finsky::response::ServerCommands* mutable_commands();
  void set_allocated_commands(::playapi::proto::finsky::response::ServerCommands* commands);
  private:
  const ::playapi::proto::finsky::response::ServerCommands& _internal_commands() const;
  ::playapi::proto::finsky::response::ServerCommands* _internal_mutable_commands();
  public:
  void unsafe_arena_set_allocated_commands(
      ::playapi::proto::finsky::response::ServerCommands* commands);
  ::playapi::proto::finsky::response::ServerCommands* unsafe_arena_release_commands();

  // optional .playapi.proto.finsky.response.ServerMetadata serverMetadata = 5;
  bool has_servermetadata() const;
  private:
  bool _internal_has_servermetadata() const;
  public:
  void clear_servermetadata();
  const ::playapi::proto::finsky::response::ServerMetadata& servermetadata() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::response::ServerMetadata* release_servermetadata();
  ::playapi::proto::finsky::response::ServerMetadata* mutable_servermetadata();
  void set_allocated_servermetadata(::playapi::proto::finsky::response::ServerMetadata* servermetadata);
  private:
  const ::playapi::proto::finsky::response::ServerMetadata& _internal_servermetadata() const;
  ::playapi::proto::finsky::response::ServerMetadata* _internal_mutable_servermetadata();
  public:
  void unsafe_arena_set_allocated_servermetadata(
      ::playapi::proto::finsky::response::ServerMetadata* servermetadata);
  ::playapi::proto::finsky::response::ServerMetadata* unsafe_arena_release_servermetadata();

  // optional .playapi.proto.finsky.response.Targets targets = 6;
  bool has_targets() const;
  private:
  bool _internal_has_targets() const;
  public:
  void clear_targets();
  const ::playapi::proto::finsky::response::Targets& targets() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::response::Targets* release_targets();
  ::playapi::proto::finsky::response::Targets* mutable_targets();
  void set_allocated_targets(::playapi::proto::finsky::response::Targets* targets);
  private:
  const ::playapi::proto::finsky::response::Targets& _internal_targets() const;
  ::playapi::proto::finsky::response::Targets* _internal_mutable_targets();
  public:
  void unsafe_arena_set_allocated_targets(
      ::playapi::proto::finsky::response::Targets* targets);
  ::playapi::proto::finsky::response::Targets* unsafe_arena_release_targets();

  // optional .playapi.proto.finsky.response.ServerCookies serverCookies = 7;
  bool has_servercookies() const;
  private:
  bool _internal_has_servercookies() const;
  public:
  void clear_servercookies();
  const ::playapi::proto::finsky::response::ServerCookies& servercookies() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::response::ServerCookies* release_servercookies();
  ::playapi::proto::finsky::response::ServerCookies* mutable_servercookies();
  void set_allocated_servercookies(::playapi::proto::finsky::response::ServerCookies* servercookies);
  private:
  const ::playapi::proto::finsky::response::ServerCookies& _internal_servercookies() const;
  ::playapi::proto::finsky::response::ServerCookies* _internal_mutable_servercookies();
  public:
  void unsafe_arena_set_allocated_servercookies(
      ::playapi::proto::finsky::response::ServerCookies* servercookies);
  ::playapi::proto::finsky::response::ServerCookies* unsafe_arena_release_servercookies();

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.response.ResponseWrapper)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::response::PreFetch > prefetch_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::response::Notification > notification_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serverlogscookie_;
    ::playapi::proto::finsky::response::Payload* payload_;
    ::playapi::proto::finsky::response::ServerCommands* commands_;
    ::playapi::proto::finsky::response::ServerMetadata* servermetadata_;
    ::playapi::proto::finsky::response::Targets* targets_;
    ::playapi::proto::finsky::response::ServerCookies* servercookies_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5frespone_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ServerCommands

// optional bool clearCache = 1;
inline bool ServerCommands::_internal_has_clearcache() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ServerCommands::has_clearcache() const {
  return _internal_has_clearcache();
}
inline void ServerCommands::clear_clearcache() {
  _impl_.clearcache_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool ServerCommands::_internal_clearcache() const {
  return _impl_.clearcache_;
}
inline bool ServerCommands::clearcache() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.ServerCommands.clearCache)
  return _internal_clearcache();
}
inline void ServerCommands::_internal_set_clearcache(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.clearcache_ = value;
}
inline void ServerCommands::set_clearcache(bool value) {
  _internal_set_clearcache(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.response.ServerCommands.clearCache)
}

// optional string displayErrorMessage = 2;
inline bool ServerCommands::_internal_has_displayerrormessage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ServerCommands::has_displayerrormessage() const {
  return _internal_has_displayerrormessage();
}
inline void ServerCommands::clear_displayerrormessage() {
  _impl_.displayerrormessage_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ServerCommands::displayerrormessage() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.ServerCommands.displayErrorMessage)
  return _internal_displayerrormessage();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServerCommands::set_displayerrormessage(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.displayerrormessage_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.response.ServerCommands.displayErrorMessage)
}
inline std::string* ServerCommands::mutable_displayerrormessage() {
  std::string* _s = _internal_mutable_displayerrormessage();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.response.ServerCommands.displayErrorMessage)
  return _s;
}
inline const std::string& ServerCommands::_internal_displayerrormessage() const {
  return _impl_.displayerrormessage_.Get();
}
inline void ServerCommands::_internal_set_displayerrormessage(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.displayerrormessage_.Set(value, GetArenaForAllocation());
}
inline std::string* ServerCommands::_internal_mutable_displayerrormessage() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.displayerrormessage_.Mutable(GetArenaForAllocation());
}
inline std::string* ServerCommands::release_displayerrormessage() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.response.ServerCommands.displayErrorMessage)
  if (!_internal_has_displayerrormessage()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.displayerrormessage_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.displayerrormessage_.IsDefault()) {
    _impl_.displayerrormessage_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ServerCommands::set_allocated_displayerrormessage(std::string* displayerrormessage) {
  if (displayerrormessage != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.displayerrormessage_.SetAllocated(displayerrormessage, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.displayerrormessage_.IsDefault()) {
    _impl_.displayerrormessage_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.response.ServerCommands.displayErrorMessage)
}

// optional string logErrorStacktrace = 3;
inline bool ServerCommands::_internal_has_logerrorstacktrace() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ServerCommands::has_logerrorstacktrace() const {
  return _internal_has_logerrorstacktrace();
}
inline void ServerCommands::clear_logerrorstacktrace() {
  _impl_.logerrorstacktrace_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ServerCommands::logerrorstacktrace() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.ServerCommands.logErrorStacktrace)
  return _internal_logerrorstacktrace();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServerCommands::set_logerrorstacktrace(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.logerrorstacktrace_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.response.ServerCommands.logErrorStacktrace)
}
inline std::string* ServerCommands::mutable_logerrorstacktrace() {
  std::string* _s = _internal_mutable_logerrorstacktrace();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.response.ServerCommands.logErrorStacktrace)
  return _s;
}
inline const std::string& ServerCommands::_internal_logerrorstacktrace() const {
  return _impl_.logerrorstacktrace_.Get();
}
inline void ServerCommands::_internal_set_logerrorstacktrace(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.logerrorstacktrace_.Set(value, GetArenaForAllocation());
}
inline std::string* ServerCommands::_internal_mutable_logerrorstacktrace() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.logerrorstacktrace_.Mutable(GetArenaForAllocation());
}
inline std::string* ServerCommands::release_logerrorstacktrace() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.response.ServerCommands.logErrorStacktrace)
  if (!_internal_has_logerrorstacktrace()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.logerrorstacktrace_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.logerrorstacktrace_.IsDefault()) {
    _impl_.logerrorstacktrace_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ServerCommands::set_allocated_logerrorstacktrace(std::string* logerrorstacktrace) {
  if (logerrorstacktrace != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.logerrorstacktrace_.SetAllocated(logerrorstacktrace, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.logerrorstacktrace_.IsDefault()) {
    _impl_.logerrorstacktrace_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.response.ServerCommands.logErrorStacktrace)
}

// repeated .playapi.proto.finsky.settings.UserSettingDirtyData userSettingDirtyData = 4;
inline int ServerCommands::_internal_usersettingdirtydata_size() const {
  return _impl_.usersettingdirtydata_.size();
}
inline int ServerCommands::usersettingdirtydata_size() const {
  return _internal_usersettingdirtydata_size();
}
inline ::playapi::proto::finsky::settings::UserSettingDirtyData* ServerCommands::mutable_usersettingdirtydata(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.response.ServerCommands.userSettingDirtyData)
  return _impl_.usersettingdirtydata_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::settings::UserSettingDirtyData >*
ServerCommands::mutable_usersettingdirtydata() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.response.ServerCommands.userSettingDirtyData)
  return &_impl_.usersettingdirtydata_;
}
inline const ::playapi::proto::finsky::settings::UserSettingDirtyData& ServerCommands::_internal_usersettingdirtydata(int index) const {
  return _impl_.usersettingdirtydata_.Get(index);
}
inline const ::playapi::proto::finsky::settings::UserSettingDirtyData& ServerCommands::usersettingdirtydata(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.ServerCommands.userSettingDirtyData)
  return _internal_usersettingdirtydata(index);
}
inline ::playapi::proto::finsky::settings::UserSettingDirtyData* ServerCommands::_internal_add_usersettingdirtydata() {
  return _impl_.usersettingdirtydata_.Add();
}
inline ::playapi::proto::finsky::settings::UserSettingDirtyData* ServerCommands::add_usersettingdirtydata() {
  ::playapi::proto::finsky::settings::UserSettingDirtyData* _add = _internal_add_usersettingdirtydata();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.response.ServerCommands.userSettingDirtyData)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::settings::UserSettingDirtyData >&
ServerCommands::usersettingdirtydata() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.response.ServerCommands.userSettingDirtyData)
  return _impl_.usersettingdirtydata_;
}

// -------------------------------------------------------------------

// PreFetch

// optional string url = 1;
inline bool PreFetch::_internal_has_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PreFetch::has_url() const {
  return _internal_has_url();
}
inline void PreFetch::clear_url() {
  _impl_.url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PreFetch::url() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.PreFetch.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PreFetch::set_url(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.response.PreFetch.url)
}
inline std::string* PreFetch::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.response.PreFetch.url)
  return _s;
}
inline const std::string& PreFetch::_internal_url() const {
  return _impl_.url_.Get();
}
inline void PreFetch::_internal_set_url(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* PreFetch::_internal_mutable_url() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* PreFetch::release_url() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.response.PreFetch.url)
  if (!_internal_has_url()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PreFetch::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.response.PreFetch.url)
}

// optional bytes response = 2;
inline bool PreFetch::_internal_has_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PreFetch::has_response() const {
  return _internal_has_response();
}
inline void PreFetch::clear_response() {
  _impl_.response_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PreFetch::response() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.PreFetch.response)
  return _internal_response();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PreFetch::set_response(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.response_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.response.PreFetch.response)
}
inline std::string* PreFetch::mutable_response() {
  std::string* _s = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.response.PreFetch.response)
  return _s;
}
inline const std::string& PreFetch::_internal_response() const {
  return _impl_.response_.Get();
}
inline void PreFetch::_internal_set_response(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.response_.Set(value, GetArenaForAllocation());
}
inline std::string* PreFetch::_internal_mutable_response() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.response_.Mutable(GetArenaForAllocation());
}
inline std::string* PreFetch::release_response() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.response.PreFetch.response)
  if (!_internal_has_response()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.response_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.response_.IsDefault()) {
    _impl_.response_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PreFetch::set_allocated_response(std::string* response) {
  if (response != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.response_.SetAllocated(response, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.response_.IsDefault()) {
    _impl_.response_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.response.PreFetch.response)
}

// optional string etag = 3;
inline bool PreFetch::_internal_has_etag() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PreFetch::has_etag() const {
  return _internal_has_etag();
}
inline void PreFetch::clear_etag() {
  _impl_.etag_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& PreFetch::etag() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.PreFetch.etag)
  return _internal_etag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PreFetch::set_etag(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.etag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.response.PreFetch.etag)
}
inline std::string* PreFetch::mutable_etag() {
  std::string* _s = _internal_mutable_etag();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.response.PreFetch.etag)
  return _s;
}
inline const std::string& PreFetch::_internal_etag() const {
  return _impl_.etag_.Get();
}
inline void PreFetch::_internal_set_etag(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.etag_.Set(value, GetArenaForAllocation());
}
inline std::string* PreFetch::_internal_mutable_etag() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.etag_.Mutable(GetArenaForAllocation());
}
inline std::string* PreFetch::release_etag() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.response.PreFetch.etag)
  if (!_internal_has_etag()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.etag_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.etag_.IsDefault()) {
    _impl_.etag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PreFetch::set_allocated_etag(std::string* etag) {
  if (etag != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.etag_.SetAllocated(etag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.etag_.IsDefault()) {
    _impl_.etag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.response.PreFetch.etag)
}

// optional int64 ttl = 4;
inline bool PreFetch::_internal_has_ttl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PreFetch::has_ttl() const {
  return _internal_has_ttl();
}
inline void PreFetch::clear_ttl() {
  _impl_.ttl_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int64_t PreFetch::_internal_ttl() const {
  return _impl_.ttl_;
}
inline int64_t PreFetch::ttl() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.PreFetch.ttl)
  return _internal_ttl();
}
inline void PreFetch::_internal_set_ttl(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.ttl_ = value;
}
inline void PreFetch::set_ttl(int64_t value) {
  _internal_set_ttl(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.response.PreFetch.ttl)
}

// optional int64 softTtl = 5;
inline bool PreFetch::_internal_has_softttl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PreFetch::has_softttl() const {
  return _internal_has_softttl();
}
inline void PreFetch::clear_softttl() {
  _impl_.softttl_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int64_t PreFetch::_internal_softttl() const {
  return _impl_.softttl_;
}
inline int64_t PreFetch::softttl() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.PreFetch.softTtl)
  return _internal_softttl();
}
inline void PreFetch::_internal_set_softttl(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.softttl_ = value;
}
inline void PreFetch::set_softttl(int64_t value) {
  _internal_set_softttl(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.response.PreFetch.softTtl)
}

// -------------------------------------------------------------------

// AndroidAppNotificationData

// optional int32 versionCode = 1;
inline bool AndroidAppNotificationData::_internal_has_versioncode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool AndroidAppNotificationData::has_versioncode() const {
  return _internal_has_versioncode();
}
inline void AndroidAppNotificationData::clear_versioncode() {
  _impl_.versioncode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t AndroidAppNotificationData::_internal_versioncode() const {
  return _impl_.versioncode_;
}
inline int32_t AndroidAppNotificationData::versioncode() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.AndroidAppNotificationData.versionCode)
  return _internal_versioncode();
}
inline void AndroidAppNotificationData::_internal_set_versioncode(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.versioncode_ = value;
}
inline void AndroidAppNotificationData::set_versioncode(int32_t value) {
  _internal_set_versioncode(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.response.AndroidAppNotificationData.versionCode)
}

// optional string assetId = 2;
inline bool AndroidAppNotificationData::_internal_has_assetid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AndroidAppNotificationData::has_assetid() const {
  return _internal_has_assetid();
}
inline void AndroidAppNotificationData::clear_assetid() {
  _impl_.assetid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AndroidAppNotificationData::assetid() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.AndroidAppNotificationData.assetId)
  return _internal_assetid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AndroidAppNotificationData::set_assetid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.assetid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.response.AndroidAppNotificationData.assetId)
}
inline std::string* AndroidAppNotificationData::mutable_assetid() {
  std::string* _s = _internal_mutable_assetid();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.response.AndroidAppNotificationData.assetId)
  return _s;
}
inline const std::string& AndroidAppNotificationData::_internal_assetid() const {
  return _impl_.assetid_.Get();
}
inline void AndroidAppNotificationData::_internal_set_assetid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.assetid_.Set(value, GetArenaForAllocation());
}
inline std::string* AndroidAppNotificationData::_internal_mutable_assetid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.assetid_.Mutable(GetArenaForAllocation());
}
inline std::string* AndroidAppNotificationData::release_assetid() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.response.AndroidAppNotificationData.assetId)
  if (!_internal_has_assetid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.assetid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.assetid_.IsDefault()) {
    _impl_.assetid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AndroidAppNotificationData::set_allocated_assetid(std::string* assetid) {
  if (assetid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.assetid_.SetAllocated(assetid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.assetid_.IsDefault()) {
    _impl_.assetid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.response.AndroidAppNotificationData.assetId)
}

// optional string installReferrer = 3;
inline bool AndroidAppNotificationData::_internal_has_installreferrer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AndroidAppNotificationData::has_installreferrer() const {
  return _internal_has_installreferrer();
}
inline void AndroidAppNotificationData::clear_installreferrer() {
  _impl_.installreferrer_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AndroidAppNotificationData::installreferrer() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.AndroidAppNotificationData.installReferrer)
  return _internal_installreferrer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AndroidAppNotificationData::set_installreferrer(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.installreferrer_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.response.AndroidAppNotificationData.installReferrer)
}
inline std::string* AndroidAppNotificationData::mutable_installreferrer() {
  std::string* _s = _internal_mutable_installreferrer();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.response.AndroidAppNotificationData.installReferrer)
  return _s;
}
inline const std::string& AndroidAppNotificationData::_internal_installreferrer() const {
  return _impl_.installreferrer_.Get();
}
inline void AndroidAppNotificationData::_internal_set_installreferrer(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.installreferrer_.Set(value, GetArenaForAllocation());
}
inline std::string* AndroidAppNotificationData::_internal_mutable_installreferrer() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.installreferrer_.Mutable(GetArenaForAllocation());
}
inline std::string* AndroidAppNotificationData::release_installreferrer() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.response.AndroidAppNotificationData.installReferrer)
  if (!_internal_has_installreferrer()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.installreferrer_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.installreferrer_.IsDefault()) {
    _impl_.installreferrer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AndroidAppNotificationData::set_allocated_installreferrer(std::string* installreferrer) {
  if (installreferrer != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.installreferrer_.SetAllocated(installreferrer, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.installreferrer_.IsDefault()) {
    _impl_.installreferrer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.response.AndroidAppNotificationData.installReferrer)
}

// optional .playapi.proto.finsky.download.InstallDetails installDetails = 4;
inline bool AndroidAppNotificationData::_internal_has_installdetails() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.installdetails_ != nullptr);
  return value;
}
inline bool AndroidAppNotificationData::has_installdetails() const {
  return _internal_has_installdetails();
}
inline const ::playapi::proto::finsky::download::InstallDetails& AndroidAppNotificationData::_internal_installdetails() const {
  const ::playapi::proto::finsky::download::InstallDetails* p = _impl_.installdetails_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::download::InstallDetails&>(
      ::playapi::proto::finsky::download::_InstallDetails_default_instance_);
}
inline const ::playapi::proto::finsky::download::InstallDetails& AndroidAppNotificationData::installdetails() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.AndroidAppNotificationData.installDetails)
  return _internal_installdetails();
}
inline void AndroidAppNotificationData::unsafe_arena_set_allocated_installdetails(
    ::playapi::proto::finsky::download::InstallDetails* installdetails) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.installdetails_);
  }
  _impl_.installdetails_ = installdetails;
  if (installdetails) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.response.AndroidAppNotificationData.installDetails)
}
inline ::playapi::proto::finsky::download::InstallDetails* AndroidAppNotificationData::release_installdetails() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::playapi::proto::finsky::download::InstallDetails* temp = _impl_.installdetails_;
  _impl_.installdetails_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::download::InstallDetails* AndroidAppNotificationData::unsafe_arena_release_installdetails() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.response.AndroidAppNotificationData.installDetails)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::playapi::proto::finsky::download::InstallDetails* temp = _impl_.installdetails_;
  _impl_.installdetails_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::download::InstallDetails* AndroidAppNotificationData::_internal_mutable_installdetails() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.installdetails_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::download::InstallDetails>(GetArenaForAllocation());
    _impl_.installdetails_ = p;
  }
  return _impl_.installdetails_;
}
inline ::playapi::proto::finsky::download::InstallDetails* AndroidAppNotificationData::mutable_installdetails() {
  ::playapi::proto::finsky::download::InstallDetails* _msg = _internal_mutable_installdetails();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.response.AndroidAppNotificationData.installDetails)
  return _msg;
}
inline void AndroidAppNotificationData::set_allocated_installdetails(::playapi::proto::finsky::download::InstallDetails* installdetails) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.installdetails_);
  }
  if (installdetails) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(installdetails));
    if (message_arena != submessage_arena) {
      installdetails = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, installdetails, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.installdetails_ = installdetails;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.response.AndroidAppNotificationData.installDetails)
}

// -------------------------------------------------------------------

// PurchaseRemovalData

// optional bool malicious = 1;
inline bool PurchaseRemovalData::_internal_has_malicious() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PurchaseRemovalData::has_malicious() const {
  return _internal_has_malicious();
}
inline void PurchaseRemovalData::clear_malicious() {
  _impl_.malicious_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool PurchaseRemovalData::_internal_malicious() const {
  return _impl_.malicious_;
}
inline bool PurchaseRemovalData::malicious() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.PurchaseRemovalData.malicious)
  return _internal_malicious();
}
inline void PurchaseRemovalData::_internal_set_malicious(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.malicious_ = value;
}
inline void PurchaseRemovalData::set_malicious(bool value) {
  _internal_set_malicious(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.response.PurchaseRemovalData.malicious)
}

// -------------------------------------------------------------------

// UserNotificationData

// optional string notificationTitle = 1;
inline bool UserNotificationData::_internal_has_notificationtitle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UserNotificationData::has_notificationtitle() const {
  return _internal_has_notificationtitle();
}
inline void UserNotificationData::clear_notificationtitle() {
  _impl_.notificationtitle_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UserNotificationData::notificationtitle() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.UserNotificationData.notificationTitle)
  return _internal_notificationtitle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserNotificationData::set_notificationtitle(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.notificationtitle_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.response.UserNotificationData.notificationTitle)
}
inline std::string* UserNotificationData::mutable_notificationtitle() {
  std::string* _s = _internal_mutable_notificationtitle();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.response.UserNotificationData.notificationTitle)
  return _s;
}
inline const std::string& UserNotificationData::_internal_notificationtitle() const {
  return _impl_.notificationtitle_.Get();
}
inline void UserNotificationData::_internal_set_notificationtitle(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.notificationtitle_.Set(value, GetArenaForAllocation());
}
inline std::string* UserNotificationData::_internal_mutable_notificationtitle() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.notificationtitle_.Mutable(GetArenaForAllocation());
}
inline std::string* UserNotificationData::release_notificationtitle() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.response.UserNotificationData.notificationTitle)
  if (!_internal_has_notificationtitle()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.notificationtitle_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.notificationtitle_.IsDefault()) {
    _impl_.notificationtitle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserNotificationData::set_allocated_notificationtitle(std::string* notificationtitle) {
  if (notificationtitle != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.notificationtitle_.SetAllocated(notificationtitle, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.notificationtitle_.IsDefault()) {
    _impl_.notificationtitle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.response.UserNotificationData.notificationTitle)
}

// optional string notificationText = 2;
inline bool UserNotificationData::_internal_has_notificationtext() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UserNotificationData::has_notificationtext() const {
  return _internal_has_notificationtext();
}
inline void UserNotificationData::clear_notificationtext() {
  _impl_.notificationtext_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UserNotificationData::notificationtext() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.UserNotificationData.notificationText)
  return _internal_notificationtext();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserNotificationData::set_notificationtext(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.notificationtext_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.response.UserNotificationData.notificationText)
}
inline std::string* UserNotificationData::mutable_notificationtext() {
  std::string* _s = _internal_mutable_notificationtext();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.response.UserNotificationData.notificationText)
  return _s;
}
inline const std::string& UserNotificationData::_internal_notificationtext() const {
  return _impl_.notificationtext_.Get();
}
inline void UserNotificationData::_internal_set_notificationtext(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.notificationtext_.Set(value, GetArenaForAllocation());
}
inline std::string* UserNotificationData::_internal_mutable_notificationtext() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.notificationtext_.Mutable(GetArenaForAllocation());
}
inline std::string* UserNotificationData::release_notificationtext() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.response.UserNotificationData.notificationText)
  if (!_internal_has_notificationtext()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.notificationtext_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.notificationtext_.IsDefault()) {
    _impl_.notificationtext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserNotificationData::set_allocated_notificationtext(std::string* notificationtext) {
  if (notificationtext != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.notificationtext_.SetAllocated(notificationtext, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.notificationtext_.IsDefault()) {
    _impl_.notificationtext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.response.UserNotificationData.notificationText)
}

// optional string tickerText = 3;
inline bool UserNotificationData::_internal_has_tickertext() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UserNotificationData::has_tickertext() const {
  return _internal_has_tickertext();
}
inline void UserNotificationData::clear_tickertext() {
  _impl_.tickertext_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& UserNotificationData::tickertext() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.UserNotificationData.tickerText)
  return _internal_tickertext();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserNotificationData::set_tickertext(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.tickertext_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.response.UserNotificationData.tickerText)
}
inline std::string* UserNotificationData::mutable_tickertext() {
  std::string* _s = _internal_mutable_tickertext();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.response.UserNotificationData.tickerText)
  return _s;
}
inline const std::string& UserNotificationData::_internal_tickertext() const {
  return _impl_.tickertext_.Get();
}
inline void UserNotificationData::_internal_set_tickertext(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.tickertext_.Set(value, GetArenaForAllocation());
}
inline std::string* UserNotificationData::_internal_mutable_tickertext() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.tickertext_.Mutable(GetArenaForAllocation());
}
inline std::string* UserNotificationData::release_tickertext() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.response.UserNotificationData.tickerText)
  if (!_internal_has_tickertext()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.tickertext_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tickertext_.IsDefault()) {
    _impl_.tickertext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserNotificationData::set_allocated_tickertext(std::string* tickertext) {
  if (tickertext != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.tickertext_.SetAllocated(tickertext, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tickertext_.IsDefault()) {
    _impl_.tickertext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.response.UserNotificationData.tickerText)
}

// optional string dialogTitle = 4;
inline bool UserNotificationData::_internal_has_dialogtitle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool UserNotificationData::has_dialogtitle() const {
  return _internal_has_dialogtitle();
}
inline void UserNotificationData::clear_dialogtitle() {
  _impl_.dialogtitle_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& UserNotificationData::dialogtitle() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.UserNotificationData.dialogTitle)
  return _internal_dialogtitle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserNotificationData::set_dialogtitle(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.dialogtitle_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.response.UserNotificationData.dialogTitle)
}
inline std::string* UserNotificationData::mutable_dialogtitle() {
  std::string* _s = _internal_mutable_dialogtitle();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.response.UserNotificationData.dialogTitle)
  return _s;
}
inline const std::string& UserNotificationData::_internal_dialogtitle() const {
  return _impl_.dialogtitle_.Get();
}
inline void UserNotificationData::_internal_set_dialogtitle(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.dialogtitle_.Set(value, GetArenaForAllocation());
}
inline std::string* UserNotificationData::_internal_mutable_dialogtitle() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.dialogtitle_.Mutable(GetArenaForAllocation());
}
inline std::string* UserNotificationData::release_dialogtitle() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.response.UserNotificationData.dialogTitle)
  if (!_internal_has_dialogtitle()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.dialogtitle_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dialogtitle_.IsDefault()) {
    _impl_.dialogtitle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserNotificationData::set_allocated_dialogtitle(std::string* dialogtitle) {
  if (dialogtitle != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.dialogtitle_.SetAllocated(dialogtitle, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dialogtitle_.IsDefault()) {
    _impl_.dialogtitle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.response.UserNotificationData.dialogTitle)
}

// optional string dialogText = 5;
inline bool UserNotificationData::_internal_has_dialogtext() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool UserNotificationData::has_dialogtext() const {
  return _internal_has_dialogtext();
}
inline void UserNotificationData::clear_dialogtext() {
  _impl_.dialogtext_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& UserNotificationData::dialogtext() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.UserNotificationData.dialogText)
  return _internal_dialogtext();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserNotificationData::set_dialogtext(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.dialogtext_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.response.UserNotificationData.dialogText)
}
inline std::string* UserNotificationData::mutable_dialogtext() {
  std::string* _s = _internal_mutable_dialogtext();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.response.UserNotificationData.dialogText)
  return _s;
}
inline const std::string& UserNotificationData::_internal_dialogtext() const {
  return _impl_.dialogtext_.Get();
}
inline void UserNotificationData::_internal_set_dialogtext(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.dialogtext_.Set(value, GetArenaForAllocation());
}
inline std::string* UserNotificationData::_internal_mutable_dialogtext() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.dialogtext_.Mutable(GetArenaForAllocation());
}
inline std::string* UserNotificationData::release_dialogtext() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.response.UserNotificationData.dialogText)
  if (!_internal_has_dialogtext()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.dialogtext_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dialogtext_.IsDefault()) {
    _impl_.dialogtext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserNotificationData::set_allocated_dialogtext(std::string* dialogtext) {
  if (dialogtext != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.dialogtext_.SetAllocated(dialogtext, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dialogtext_.IsDefault()) {
    _impl_.dialogtext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.response.UserNotificationData.dialogText)
}

// -------------------------------------------------------------------

// InAppNotificationData

// optional string checkoutOrderId = 1;
inline bool InAppNotificationData::_internal_has_checkoutorderid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InAppNotificationData::has_checkoutorderid() const {
  return _internal_has_checkoutorderid();
}
inline void InAppNotificationData::clear_checkoutorderid() {
  _impl_.checkoutorderid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InAppNotificationData::checkoutorderid() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.InAppNotificationData.checkoutOrderId)
  return _internal_checkoutorderid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InAppNotificationData::set_checkoutorderid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.checkoutorderid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.response.InAppNotificationData.checkoutOrderId)
}
inline std::string* InAppNotificationData::mutable_checkoutorderid() {
  std::string* _s = _internal_mutable_checkoutorderid();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.response.InAppNotificationData.checkoutOrderId)
  return _s;
}
inline const std::string& InAppNotificationData::_internal_checkoutorderid() const {
  return _impl_.checkoutorderid_.Get();
}
inline void InAppNotificationData::_internal_set_checkoutorderid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.checkoutorderid_.Set(value, GetArenaForAllocation());
}
inline std::string* InAppNotificationData::_internal_mutable_checkoutorderid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.checkoutorderid_.Mutable(GetArenaForAllocation());
}
inline std::string* InAppNotificationData::release_checkoutorderid() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.response.InAppNotificationData.checkoutOrderId)
  if (!_internal_has_checkoutorderid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.checkoutorderid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.checkoutorderid_.IsDefault()) {
    _impl_.checkoutorderid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InAppNotificationData::set_allocated_checkoutorderid(std::string* checkoutorderid) {
  if (checkoutorderid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.checkoutorderid_.SetAllocated(checkoutorderid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.checkoutorderid_.IsDefault()) {
    _impl_.checkoutorderid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.response.InAppNotificationData.checkoutOrderId)
}

// optional string inAppNotificationId = 2;
inline bool InAppNotificationData::_internal_has_inappnotificationid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool InAppNotificationData::has_inappnotificationid() const {
  return _internal_has_inappnotificationid();
}
inline void InAppNotificationData::clear_inappnotificationid() {
  _impl_.inappnotificationid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& InAppNotificationData::inappnotificationid() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.InAppNotificationData.inAppNotificationId)
  return _internal_inappnotificationid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InAppNotificationData::set_inappnotificationid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.inappnotificationid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.response.InAppNotificationData.inAppNotificationId)
}
inline std::string* InAppNotificationData::mutable_inappnotificationid() {
  std::string* _s = _internal_mutable_inappnotificationid();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.response.InAppNotificationData.inAppNotificationId)
  return _s;
}
inline const std::string& InAppNotificationData::_internal_inappnotificationid() const {
  return _impl_.inappnotificationid_.Get();
}
inline void InAppNotificationData::_internal_set_inappnotificationid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.inappnotificationid_.Set(value, GetArenaForAllocation());
}
inline std::string* InAppNotificationData::_internal_mutable_inappnotificationid() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.inappnotificationid_.Mutable(GetArenaForAllocation());
}
inline std::string* InAppNotificationData::release_inappnotificationid() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.response.InAppNotificationData.inAppNotificationId)
  if (!_internal_has_inappnotificationid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.inappnotificationid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.inappnotificationid_.IsDefault()) {
    _impl_.inappnotificationid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InAppNotificationData::set_allocated_inappnotificationid(std::string* inappnotificationid) {
  if (inappnotificationid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.inappnotificationid_.SetAllocated(inappnotificationid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.inappnotificationid_.IsDefault()) {
    _impl_.inappnotificationid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.response.InAppNotificationData.inAppNotificationId)
}

// -------------------------------------------------------------------

// PurchaseDeclinedData

// optional int32 reason = 1;
inline bool PurchaseDeclinedData::_internal_has_reason() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PurchaseDeclinedData::has_reason() const {
  return _internal_has_reason();
}
inline void PurchaseDeclinedData::clear_reason() {
  _impl_.reason_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t PurchaseDeclinedData::_internal_reason() const {
  return _impl_.reason_;
}
inline int32_t PurchaseDeclinedData::reason() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.PurchaseDeclinedData.reason)
  return _internal_reason();
}
inline void PurchaseDeclinedData::_internal_set_reason(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.reason_ = value;
}
inline void PurchaseDeclinedData::set_reason(int32_t value) {
  _internal_set_reason(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.response.PurchaseDeclinedData.reason)
}

// optional bool showNotification = 2;
inline bool PurchaseDeclinedData::_internal_has_shownotification() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PurchaseDeclinedData::has_shownotification() const {
  return _internal_has_shownotification();
}
inline void PurchaseDeclinedData::clear_shownotification() {
  _impl_.shownotification_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool PurchaseDeclinedData::_internal_shownotification() const {
  return _impl_.shownotification_;
}
inline bool PurchaseDeclinedData::shownotification() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.PurchaseDeclinedData.showNotification)
  return _internal_shownotification();
}
inline void PurchaseDeclinedData::_internal_set_shownotification(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.shownotification_ = value;
}
inline void PurchaseDeclinedData::set_shownotification(bool value) {
  _internal_set_shownotification(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.response.PurchaseDeclinedData.showNotification)
}

// -------------------------------------------------------------------

// LibraryDirtyData

// optional int32 backend = 1;
inline bool LibraryDirtyData::_internal_has_backend() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LibraryDirtyData::has_backend() const {
  return _internal_has_backend();
}
inline void LibraryDirtyData::clear_backend() {
  _impl_.backend_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t LibraryDirtyData::_internal_backend() const {
  return _impl_.backend_;
}
inline int32_t LibraryDirtyData::backend() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.LibraryDirtyData.backend)
  return _internal_backend();
}
inline void LibraryDirtyData::_internal_set_backend(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.backend_ = value;
}
inline void LibraryDirtyData::set_backend(int32_t value) {
  _internal_set_backend(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.response.LibraryDirtyData.backend)
}

// optional string libraryId = 2;
inline bool LibraryDirtyData::_internal_has_libraryid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LibraryDirtyData::has_libraryid() const {
  return _internal_has_libraryid();
}
inline void LibraryDirtyData::clear_libraryid() {
  _impl_.libraryid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LibraryDirtyData::libraryid() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.LibraryDirtyData.libraryId)
  return _internal_libraryid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LibraryDirtyData::set_libraryid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.libraryid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.response.LibraryDirtyData.libraryId)
}
inline std::string* LibraryDirtyData::mutable_libraryid() {
  std::string* _s = _internal_mutable_libraryid();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.response.LibraryDirtyData.libraryId)
  return _s;
}
inline const std::string& LibraryDirtyData::_internal_libraryid() const {
  return _impl_.libraryid_.Get();
}
inline void LibraryDirtyData::_internal_set_libraryid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.libraryid_.Set(value, GetArenaForAllocation());
}
inline std::string* LibraryDirtyData::_internal_mutable_libraryid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.libraryid_.Mutable(GetArenaForAllocation());
}
inline std::string* LibraryDirtyData::release_libraryid() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.response.LibraryDirtyData.libraryId)
  if (!_internal_has_libraryid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.libraryid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.libraryid_.IsDefault()) {
    _impl_.libraryid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LibraryDirtyData::set_allocated_libraryid(std::string* libraryid) {
  if (libraryid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.libraryid_.SetAllocated(libraryid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.libraryid_.IsDefault()) {
    _impl_.libraryid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.response.LibraryDirtyData.libraryId)
}

// -------------------------------------------------------------------

// Notification

// optional int32 notificationType = 1;
inline bool Notification::_internal_has_notificationtype() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool Notification::has_notificationtype() const {
  return _internal_has_notificationtype();
}
inline void Notification::clear_notificationtype() {
  _impl_.notificationtype_ = 0;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline int32_t Notification::_internal_notificationtype() const {
  return _impl_.notificationtype_;
}
inline int32_t Notification::notificationtype() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.Notification.notificationType)
  return _internal_notificationtype();
}
inline void Notification::_internal_set_notificationtype(int32_t value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.notificationtype_ = value;
}
inline void Notification::set_notificationtype(int32_t value) {
  _internal_set_notificationtype(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.response.Notification.notificationType)
}

// optional int64 timestamp = 3;
inline bool Notification::_internal_has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool Notification::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void Notification::clear_timestamp() {
  _impl_.timestamp_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline int64_t Notification::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int64_t Notification::timestamp() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.Notification.timestamp)
  return _internal_timestamp();
}
inline void Notification::_internal_set_timestamp(int64_t value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.timestamp_ = value;
}
inline void Notification::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.response.Notification.timestamp)
}

// optional .playapi.proto.finsky.Docid docid = 4;
inline bool Notification::_internal_has_docid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.docid_ != nullptr);
  return value;
}
inline bool Notification::has_docid() const {
  return _internal_has_docid();
}
inline const ::playapi::proto::finsky::Docid& Notification::_internal_docid() const {
  const ::playapi::proto::finsky::Docid* p = _impl_.docid_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::Docid&>(
      ::playapi::proto::finsky::_Docid_default_instance_);
}
inline const ::playapi::proto::finsky::Docid& Notification::docid() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.Notification.docid)
  return _internal_docid();
}
inline void Notification::unsafe_arena_set_allocated_docid(
    ::playapi::proto::finsky::Docid* docid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.docid_);
  }
  _impl_.docid_ = docid;
  if (docid) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.response.Notification.docid)
}
inline ::playapi::proto::finsky::Docid* Notification::release_docid() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::playapi::proto::finsky::Docid* temp = _impl_.docid_;
  _impl_.docid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::Docid* Notification::unsafe_arena_release_docid() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.response.Notification.docid)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::playapi::proto::finsky::Docid* temp = _impl_.docid_;
  _impl_.docid_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::Docid* Notification::_internal_mutable_docid() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.docid_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::Docid>(GetArenaForAllocation());
    _impl_.docid_ = p;
  }
  return _impl_.docid_;
}
inline ::playapi::proto::finsky::Docid* Notification::mutable_docid() {
  ::playapi::proto::finsky::Docid* _msg = _internal_mutable_docid();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.response.Notification.docid)
  return _msg;
}
inline void Notification::set_allocated_docid(::playapi::proto::finsky::Docid* docid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.docid_);
  }
  if (docid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(docid));
    if (message_arena != submessage_arena) {
      docid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, docid, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.docid_ = docid;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.response.Notification.docid)
}

// optional string docTitle = 5;
inline bool Notification::_internal_has_doctitle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Notification::has_doctitle() const {
  return _internal_has_doctitle();
}
inline void Notification::clear_doctitle() {
  _impl_.doctitle_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Notification::doctitle() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.Notification.docTitle)
  return _internal_doctitle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Notification::set_doctitle(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.doctitle_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.response.Notification.docTitle)
}
inline std::string* Notification::mutable_doctitle() {
  std::string* _s = _internal_mutable_doctitle();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.response.Notification.docTitle)
  return _s;
}
inline const std::string& Notification::_internal_doctitle() const {
  return _impl_.doctitle_.Get();
}
inline void Notification::_internal_set_doctitle(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.doctitle_.Set(value, GetArenaForAllocation());
}
inline std::string* Notification::_internal_mutable_doctitle() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.doctitle_.Mutable(GetArenaForAllocation());
}
inline std::string* Notification::release_doctitle() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.response.Notification.docTitle)
  if (!_internal_has_doctitle()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.doctitle_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.doctitle_.IsDefault()) {
    _impl_.doctitle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Notification::set_allocated_doctitle(std::string* doctitle) {
  if (doctitle != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.doctitle_.SetAllocated(doctitle, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.doctitle_.IsDefault()) {
    _impl_.doctitle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.response.Notification.docTitle)
}

// optional string userEmail = 6;
inline bool Notification::_internal_has_useremail() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Notification::has_useremail() const {
  return _internal_has_useremail();
}
inline void Notification::clear_useremail() {
  _impl_.useremail_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Notification::useremail() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.Notification.userEmail)
  return _internal_useremail();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Notification::set_useremail(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.useremail_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.response.Notification.userEmail)
}
inline std::string* Notification::mutable_useremail() {
  std::string* _s = _internal_mutable_useremail();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.response.Notification.userEmail)
  return _s;
}
inline const std::string& Notification::_internal_useremail() const {
  return _impl_.useremail_.Get();
}
inline void Notification::_internal_set_useremail(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.useremail_.Set(value, GetArenaForAllocation());
}
inline std::string* Notification::_internal_mutable_useremail() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.useremail_.Mutable(GetArenaForAllocation());
}
inline std::string* Notification::release_useremail() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.response.Notification.userEmail)
  if (!_internal_has_useremail()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.useremail_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.useremail_.IsDefault()) {
    _impl_.useremail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Notification::set_allocated_useremail(std::string* useremail) {
  if (useremail != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.useremail_.SetAllocated(useremail, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.useremail_.IsDefault()) {
    _impl_.useremail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.response.Notification.userEmail)
}

// optional .playapi.proto.finsky.response.AndroidAppNotificationData appData = 7;
inline bool Notification::_internal_has_appdata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.appdata_ != nullptr);
  return value;
}
inline bool Notification::has_appdata() const {
  return _internal_has_appdata();
}
inline void Notification::clear_appdata() {
  if (_impl_.appdata_ != nullptr) _impl_.appdata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::playapi::proto::finsky::response::AndroidAppNotificationData& Notification::_internal_appdata() const {
  const ::playapi::proto::finsky::response::AndroidAppNotificationData* p = _impl_.appdata_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::response::AndroidAppNotificationData&>(
      ::playapi::proto::finsky::response::_AndroidAppNotificationData_default_instance_);
}
inline const ::playapi::proto::finsky::response::AndroidAppNotificationData& Notification::appdata() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.Notification.appData)
  return _internal_appdata();
}
inline void Notification::unsafe_arena_set_allocated_appdata(
    ::playapi::proto::finsky::response::AndroidAppNotificationData* appdata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.appdata_);
  }
  _impl_.appdata_ = appdata;
  if (appdata) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.response.Notification.appData)
}
inline ::playapi::proto::finsky::response::AndroidAppNotificationData* Notification::release_appdata() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::playapi::proto::finsky::response::AndroidAppNotificationData* temp = _impl_.appdata_;
  _impl_.appdata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::response::AndroidAppNotificationData* Notification::unsafe_arena_release_appdata() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.response.Notification.appData)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::playapi::proto::finsky::response::AndroidAppNotificationData* temp = _impl_.appdata_;
  _impl_.appdata_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::response::AndroidAppNotificationData* Notification::_internal_mutable_appdata() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.appdata_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::response::AndroidAppNotificationData>(GetArenaForAllocation());
    _impl_.appdata_ = p;
  }
  return _impl_.appdata_;
}
inline ::playapi::proto::finsky::response::AndroidAppNotificationData* Notification::mutable_appdata() {
  ::playapi::proto::finsky::response::AndroidAppNotificationData* _msg = _internal_mutable_appdata();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.response.Notification.appData)
  return _msg;
}
inline void Notification::set_allocated_appdata(::playapi::proto::finsky::response::AndroidAppNotificationData* appdata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.appdata_;
  }
  if (appdata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(appdata);
    if (message_arena != submessage_arena) {
      appdata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, appdata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.appdata_ = appdata;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.response.Notification.appData)
}

// optional .playapi.proto.finsky.download.AndroidAppDeliveryData appDeliveryData = 8;
inline bool Notification::_internal_has_appdeliverydata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.appdeliverydata_ != nullptr);
  return value;
}
inline bool Notification::has_appdeliverydata() const {
  return _internal_has_appdeliverydata();
}
inline const ::playapi::proto::finsky::download::AndroidAppDeliveryData& Notification::_internal_appdeliverydata() const {
  const ::playapi::proto::finsky::download::AndroidAppDeliveryData* p = _impl_.appdeliverydata_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::download::AndroidAppDeliveryData&>(
      ::playapi::proto::finsky::download::_AndroidAppDeliveryData_default_instance_);
}
inline const ::playapi::proto::finsky::download::AndroidAppDeliveryData& Notification::appdeliverydata() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.Notification.appDeliveryData)
  return _internal_appdeliverydata();
}
inline void Notification::unsafe_arena_set_allocated_appdeliverydata(
    ::playapi::proto::finsky::download::AndroidAppDeliveryData* appdeliverydata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.appdeliverydata_);
  }
  _impl_.appdeliverydata_ = appdeliverydata;
  if (appdeliverydata) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.response.Notification.appDeliveryData)
}
inline ::playapi::proto::finsky::download::AndroidAppDeliveryData* Notification::release_appdeliverydata() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::playapi::proto::finsky::download::AndroidAppDeliveryData* temp = _impl_.appdeliverydata_;
  _impl_.appdeliverydata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::download::AndroidAppDeliveryData* Notification::unsafe_arena_release_appdeliverydata() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.response.Notification.appDeliveryData)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::playapi::proto::finsky::download::AndroidAppDeliveryData* temp = _impl_.appdeliverydata_;
  _impl_.appdeliverydata_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::download::AndroidAppDeliveryData* Notification::_internal_mutable_appdeliverydata() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.appdeliverydata_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::download::AndroidAppDeliveryData>(GetArenaForAllocation());
    _impl_.appdeliverydata_ = p;
  }
  return _impl_.appdeliverydata_;
}
inline ::playapi::proto::finsky::download::AndroidAppDeliveryData* Notification::mutable_appdeliverydata() {
  ::playapi::proto::finsky::download::AndroidAppDeliveryData* _msg = _internal_mutable_appdeliverydata();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.response.Notification.appDeliveryData)
  return _msg;
}
inline void Notification::set_allocated_appdeliverydata(::playapi::proto::finsky::download::AndroidAppDeliveryData* appdeliverydata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.appdeliverydata_);
  }
  if (appdeliverydata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(appdeliverydata));
    if (message_arena != submessage_arena) {
      appdeliverydata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, appdeliverydata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.appdeliverydata_ = appdeliverydata;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.response.Notification.appDeliveryData)
}

// optional .playapi.proto.finsky.response.PurchaseRemovalData purchaseRemovalData = 9;
inline bool Notification::_internal_has_purchaseremovaldata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.purchaseremovaldata_ != nullptr);
  return value;
}
inline bool Notification::has_purchaseremovaldata() const {
  return _internal_has_purchaseremovaldata();
}
inline void Notification::clear_purchaseremovaldata() {
  if (_impl_.purchaseremovaldata_ != nullptr) _impl_.purchaseremovaldata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::playapi::proto::finsky::response::PurchaseRemovalData& Notification::_internal_purchaseremovaldata() const {
  const ::playapi::proto::finsky::response::PurchaseRemovalData* p = _impl_.purchaseremovaldata_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::response::PurchaseRemovalData&>(
      ::playapi::proto::finsky::response::_PurchaseRemovalData_default_instance_);
}
inline const ::playapi::proto::finsky::response::PurchaseRemovalData& Notification::purchaseremovaldata() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.Notification.purchaseRemovalData)
  return _internal_purchaseremovaldata();
}
inline void Notification::unsafe_arena_set_allocated_purchaseremovaldata(
    ::playapi::proto::finsky::response::PurchaseRemovalData* purchaseremovaldata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.purchaseremovaldata_);
  }
  _impl_.purchaseremovaldata_ = purchaseremovaldata;
  if (purchaseremovaldata) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.response.Notification.purchaseRemovalData)
}
inline ::playapi::proto::finsky::response::PurchaseRemovalData* Notification::release_purchaseremovaldata() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::playapi::proto::finsky::response::PurchaseRemovalData* temp = _impl_.purchaseremovaldata_;
  _impl_.purchaseremovaldata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::response::PurchaseRemovalData* Notification::unsafe_arena_release_purchaseremovaldata() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.response.Notification.purchaseRemovalData)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::playapi::proto::finsky::response::PurchaseRemovalData* temp = _impl_.purchaseremovaldata_;
  _impl_.purchaseremovaldata_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::response::PurchaseRemovalData* Notification::_internal_mutable_purchaseremovaldata() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.purchaseremovaldata_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::response::PurchaseRemovalData>(GetArenaForAllocation());
    _impl_.purchaseremovaldata_ = p;
  }
  return _impl_.purchaseremovaldata_;
}
inline ::playapi::proto::finsky::response::PurchaseRemovalData* Notification::mutable_purchaseremovaldata() {
  ::playapi::proto::finsky::response::PurchaseRemovalData* _msg = _internal_mutable_purchaseremovaldata();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.response.Notification.purchaseRemovalData)
  return _msg;
}
inline void Notification::set_allocated_purchaseremovaldata(::playapi::proto::finsky::response::PurchaseRemovalData* purchaseremovaldata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.purchaseremovaldata_;
  }
  if (purchaseremovaldata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(purchaseremovaldata);
    if (message_arena != submessage_arena) {
      purchaseremovaldata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, purchaseremovaldata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.purchaseremovaldata_ = purchaseremovaldata;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.response.Notification.purchaseRemovalData)
}

// optional .playapi.proto.finsky.response.UserNotificationData userNotificationData = 10;
inline bool Notification::_internal_has_usernotificationdata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.usernotificationdata_ != nullptr);
  return value;
}
inline bool Notification::has_usernotificationdata() const {
  return _internal_has_usernotificationdata();
}
inline void Notification::clear_usernotificationdata() {
  if (_impl_.usernotificationdata_ != nullptr) _impl_.usernotificationdata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::playapi::proto::finsky::response::UserNotificationData& Notification::_internal_usernotificationdata() const {
  const ::playapi::proto::finsky::response::UserNotificationData* p = _impl_.usernotificationdata_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::response::UserNotificationData&>(
      ::playapi::proto::finsky::response::_UserNotificationData_default_instance_);
}
inline const ::playapi::proto::finsky::response::UserNotificationData& Notification::usernotificationdata() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.Notification.userNotificationData)
  return _internal_usernotificationdata();
}
inline void Notification::unsafe_arena_set_allocated_usernotificationdata(
    ::playapi::proto::finsky::response::UserNotificationData* usernotificationdata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.usernotificationdata_);
  }
  _impl_.usernotificationdata_ = usernotificationdata;
  if (usernotificationdata) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.response.Notification.userNotificationData)
}
inline ::playapi::proto::finsky::response::UserNotificationData* Notification::release_usernotificationdata() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::playapi::proto::finsky::response::UserNotificationData* temp = _impl_.usernotificationdata_;
  _impl_.usernotificationdata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::response::UserNotificationData* Notification::unsafe_arena_release_usernotificationdata() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.response.Notification.userNotificationData)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::playapi::proto::finsky::response::UserNotificationData* temp = _impl_.usernotificationdata_;
  _impl_.usernotificationdata_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::response::UserNotificationData* Notification::_internal_mutable_usernotificationdata() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.usernotificationdata_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::response::UserNotificationData>(GetArenaForAllocation());
    _impl_.usernotificationdata_ = p;
  }
  return _impl_.usernotificationdata_;
}
inline ::playapi::proto::finsky::response::UserNotificationData* Notification::mutable_usernotificationdata() {
  ::playapi::proto::finsky::response::UserNotificationData* _msg = _internal_mutable_usernotificationdata();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.response.Notification.userNotificationData)
  return _msg;
}
inline void Notification::set_allocated_usernotificationdata(::playapi::proto::finsky::response::UserNotificationData* usernotificationdata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.usernotificationdata_;
  }
  if (usernotificationdata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(usernotificationdata);
    if (message_arena != submessage_arena) {
      usernotificationdata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, usernotificationdata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.usernotificationdata_ = usernotificationdata;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.response.Notification.userNotificationData)
}

// optional .playapi.proto.finsky.response.InAppNotificationData inAppNotificationData = 11;
inline bool Notification::_internal_has_inappnotificationdata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.inappnotificationdata_ != nullptr);
  return value;
}
inline bool Notification::has_inappnotificationdata() const {
  return _internal_has_inappnotificationdata();
}
inline void Notification::clear_inappnotificationdata() {
  if (_impl_.inappnotificationdata_ != nullptr) _impl_.inappnotificationdata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::playapi::proto::finsky::response::InAppNotificationData& Notification::_internal_inappnotificationdata() const {
  const ::playapi::proto::finsky::response::InAppNotificationData* p = _impl_.inappnotificationdata_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::response::InAppNotificationData&>(
      ::playapi::proto::finsky::response::_InAppNotificationData_default_instance_);
}
inline const ::playapi::proto::finsky::response::InAppNotificationData& Notification::inappnotificationdata() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.Notification.inAppNotificationData)
  return _internal_inappnotificationdata();
}
inline void Notification::unsafe_arena_set_allocated_inappnotificationdata(
    ::playapi::proto::finsky::response::InAppNotificationData* inappnotificationdata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.inappnotificationdata_);
  }
  _impl_.inappnotificationdata_ = inappnotificationdata;
  if (inappnotificationdata) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.response.Notification.inAppNotificationData)
}
inline ::playapi::proto::finsky::response::InAppNotificationData* Notification::release_inappnotificationdata() {
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::playapi::proto::finsky::response::InAppNotificationData* temp = _impl_.inappnotificationdata_;
  _impl_.inappnotificationdata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::response::InAppNotificationData* Notification::unsafe_arena_release_inappnotificationdata() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.response.Notification.inAppNotificationData)
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::playapi::proto::finsky::response::InAppNotificationData* temp = _impl_.inappnotificationdata_;
  _impl_.inappnotificationdata_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::response::InAppNotificationData* Notification::_internal_mutable_inappnotificationdata() {
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.inappnotificationdata_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::response::InAppNotificationData>(GetArenaForAllocation());
    _impl_.inappnotificationdata_ = p;
  }
  return _impl_.inappnotificationdata_;
}
inline ::playapi::proto::finsky::response::InAppNotificationData* Notification::mutable_inappnotificationdata() {
  ::playapi::proto::finsky::response::InAppNotificationData* _msg = _internal_mutable_inappnotificationdata();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.response.Notification.inAppNotificationData)
  return _msg;
}
inline void Notification::set_allocated_inappnotificationdata(::playapi::proto::finsky::response::InAppNotificationData* inappnotificationdata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.inappnotificationdata_;
  }
  if (inappnotificationdata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(inappnotificationdata);
    if (message_arena != submessage_arena) {
      inappnotificationdata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inappnotificationdata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.inappnotificationdata_ = inappnotificationdata;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.response.Notification.inAppNotificationData)
}

// optional .playapi.proto.finsky.response.PurchaseDeclinedData purchaseDeclinedData = 12;
inline bool Notification::_internal_has_purchasedeclineddata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.purchasedeclineddata_ != nullptr);
  return value;
}
inline bool Notification::has_purchasedeclineddata() const {
  return _internal_has_purchasedeclineddata();
}
inline void Notification::clear_purchasedeclineddata() {
  if (_impl_.purchasedeclineddata_ != nullptr) _impl_.purchasedeclineddata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const ::playapi::proto::finsky::response::PurchaseDeclinedData& Notification::_internal_purchasedeclineddata() const {
  const ::playapi::proto::finsky::response::PurchaseDeclinedData* p = _impl_.purchasedeclineddata_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::response::PurchaseDeclinedData&>(
      ::playapi::proto::finsky::response::_PurchaseDeclinedData_default_instance_);
}
inline const ::playapi::proto::finsky::response::PurchaseDeclinedData& Notification::purchasedeclineddata() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.Notification.purchaseDeclinedData)
  return _internal_purchasedeclineddata();
}
inline void Notification::unsafe_arena_set_allocated_purchasedeclineddata(
    ::playapi::proto::finsky::response::PurchaseDeclinedData* purchasedeclineddata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.purchasedeclineddata_);
  }
  _impl_.purchasedeclineddata_ = purchasedeclineddata;
  if (purchasedeclineddata) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.response.Notification.purchaseDeclinedData)
}
inline ::playapi::proto::finsky::response::PurchaseDeclinedData* Notification::release_purchasedeclineddata() {
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::playapi::proto::finsky::response::PurchaseDeclinedData* temp = _impl_.purchasedeclineddata_;
  _impl_.purchasedeclineddata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::response::PurchaseDeclinedData* Notification::unsafe_arena_release_purchasedeclineddata() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.response.Notification.purchaseDeclinedData)
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::playapi::proto::finsky::response::PurchaseDeclinedData* temp = _impl_.purchasedeclineddata_;
  _impl_.purchasedeclineddata_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::response::PurchaseDeclinedData* Notification::_internal_mutable_purchasedeclineddata() {
  _impl_._has_bits_[0] |= 0x00000200u;
  if (_impl_.purchasedeclineddata_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::response::PurchaseDeclinedData>(GetArenaForAllocation());
    _impl_.purchasedeclineddata_ = p;
  }
  return _impl_.purchasedeclineddata_;
}
inline ::playapi::proto::finsky::response::PurchaseDeclinedData* Notification::mutable_purchasedeclineddata() {
  ::playapi::proto::finsky::response::PurchaseDeclinedData* _msg = _internal_mutable_purchasedeclineddata();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.response.Notification.purchaseDeclinedData)
  return _msg;
}
inline void Notification::set_allocated_purchasedeclineddata(::playapi::proto::finsky::response::PurchaseDeclinedData* purchasedeclineddata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.purchasedeclineddata_;
  }
  if (purchasedeclineddata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(purchasedeclineddata);
    if (message_arena != submessage_arena) {
      purchasedeclineddata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, purchasedeclineddata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.purchasedeclineddata_ = purchasedeclineddata;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.response.Notification.purchaseDeclinedData)
}

// optional string notificationId = 13;
inline bool Notification::_internal_has_notificationid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Notification::has_notificationid() const {
  return _internal_has_notificationid();
}
inline void Notification::clear_notificationid() {
  _impl_.notificationid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Notification::notificationid() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.Notification.notificationId)
  return _internal_notificationid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Notification::set_notificationid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.notificationid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.response.Notification.notificationId)
}
inline std::string* Notification::mutable_notificationid() {
  std::string* _s = _internal_mutable_notificationid();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.response.Notification.notificationId)
  return _s;
}
inline const std::string& Notification::_internal_notificationid() const {
  return _impl_.notificationid_.Get();
}
inline void Notification::_internal_set_notificationid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.notificationid_.Set(value, GetArenaForAllocation());
}
inline std::string* Notification::_internal_mutable_notificationid() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.notificationid_.Mutable(GetArenaForAllocation());
}
inline std::string* Notification::release_notificationid() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.response.Notification.notificationId)
  if (!_internal_has_notificationid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.notificationid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.notificationid_.IsDefault()) {
    _impl_.notificationid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Notification::set_allocated_notificationid(std::string* notificationid) {
  if (notificationid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.notificationid_.SetAllocated(notificationid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.notificationid_.IsDefault()) {
    _impl_.notificationid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.response.Notification.notificationId)
}

// optional .playapi.proto.finsky.response.LibraryDirtyData libraryDirtyData = 15;
inline bool Notification::_internal_has_librarydirtydata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.librarydirtydata_ != nullptr);
  return value;
}
inline bool Notification::has_librarydirtydata() const {
  return _internal_has_librarydirtydata();
}
inline void Notification::clear_librarydirtydata() {
  if (_impl_.librarydirtydata_ != nullptr) _impl_.librarydirtydata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const ::playapi::proto::finsky::response::LibraryDirtyData& Notification::_internal_librarydirtydata() const {
  const ::playapi::proto::finsky::response::LibraryDirtyData* p = _impl_.librarydirtydata_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::response::LibraryDirtyData&>(
      ::playapi::proto::finsky::response::_LibraryDirtyData_default_instance_);
}
inline const ::playapi::proto::finsky::response::LibraryDirtyData& Notification::librarydirtydata() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.Notification.libraryDirtyData)
  return _internal_librarydirtydata();
}
inline void Notification::unsafe_arena_set_allocated_librarydirtydata(
    ::playapi::proto::finsky::response::LibraryDirtyData* librarydirtydata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.librarydirtydata_);
  }
  _impl_.librarydirtydata_ = librarydirtydata;
  if (librarydirtydata) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.response.Notification.libraryDirtyData)
}
inline ::playapi::proto::finsky::response::LibraryDirtyData* Notification::release_librarydirtydata() {
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::playapi::proto::finsky::response::LibraryDirtyData* temp = _impl_.librarydirtydata_;
  _impl_.librarydirtydata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::response::LibraryDirtyData* Notification::unsafe_arena_release_librarydirtydata() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.response.Notification.libraryDirtyData)
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::playapi::proto::finsky::response::LibraryDirtyData* temp = _impl_.librarydirtydata_;
  _impl_.librarydirtydata_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::response::LibraryDirtyData* Notification::_internal_mutable_librarydirtydata() {
  _impl_._has_bits_[0] |= 0x00000400u;
  if (_impl_.librarydirtydata_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::response::LibraryDirtyData>(GetArenaForAllocation());
    _impl_.librarydirtydata_ = p;
  }
  return _impl_.librarydirtydata_;
}
inline ::playapi::proto::finsky::response::LibraryDirtyData* Notification::mutable_librarydirtydata() {
  ::playapi::proto::finsky::response::LibraryDirtyData* _msg = _internal_mutable_librarydirtydata();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.response.Notification.libraryDirtyData)
  return _msg;
}
inline void Notification::set_allocated_librarydirtydata(::playapi::proto::finsky::response::LibraryDirtyData* librarydirtydata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.librarydirtydata_;
  }
  if (librarydirtydata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(librarydirtydata);
    if (message_arena != submessage_arena) {
      librarydirtydata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, librarydirtydata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.librarydirtydata_ = librarydirtydata;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.response.Notification.libraryDirtyData)
}

// optional .playapi.proto.finsky.settings.UserSettingDirtyData userSettingDirtyData = 16;
inline bool Notification::_internal_has_usersettingdirtydata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.usersettingdirtydata_ != nullptr);
  return value;
}
inline bool Notification::has_usersettingdirtydata() const {
  return _internal_has_usersettingdirtydata();
}
inline const ::playapi::proto::finsky::settings::UserSettingDirtyData& Notification::_internal_usersettingdirtydata() const {
  const ::playapi::proto::finsky::settings::UserSettingDirtyData* p = _impl_.usersettingdirtydata_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::settings::UserSettingDirtyData&>(
      ::playapi::proto::finsky::settings::_UserSettingDirtyData_default_instance_);
}
inline const ::playapi::proto::finsky::settings::UserSettingDirtyData& Notification::usersettingdirtydata() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.Notification.userSettingDirtyData)
  return _internal_usersettingdirtydata();
}
inline void Notification::unsafe_arena_set_allocated_usersettingdirtydata(
    ::playapi::proto::finsky::settings::UserSettingDirtyData* usersettingdirtydata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.usersettingdirtydata_);
  }
  _impl_.usersettingdirtydata_ = usersettingdirtydata;
  if (usersettingdirtydata) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.response.Notification.userSettingDirtyData)
}
inline ::playapi::proto::finsky::settings::UserSettingDirtyData* Notification::release_usersettingdirtydata() {
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::playapi::proto::finsky::settings::UserSettingDirtyData* temp = _impl_.usersettingdirtydata_;
  _impl_.usersettingdirtydata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::settings::UserSettingDirtyData* Notification::unsafe_arena_release_usersettingdirtydata() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.response.Notification.userSettingDirtyData)
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::playapi::proto::finsky::settings::UserSettingDirtyData* temp = _impl_.usersettingdirtydata_;
  _impl_.usersettingdirtydata_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::settings::UserSettingDirtyData* Notification::_internal_mutable_usersettingdirtydata() {
  _impl_._has_bits_[0] |= 0x00000800u;
  if (_impl_.usersettingdirtydata_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::settings::UserSettingDirtyData>(GetArenaForAllocation());
    _impl_.usersettingdirtydata_ = p;
  }
  return _impl_.usersettingdirtydata_;
}
inline ::playapi::proto::finsky::settings::UserSettingDirtyData* Notification::mutable_usersettingdirtydata() {
  ::playapi::proto::finsky::settings::UserSettingDirtyData* _msg = _internal_mutable_usersettingdirtydata();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.response.Notification.userSettingDirtyData)
  return _msg;
}
inline void Notification::set_allocated_usersettingdirtydata(::playapi::proto::finsky::settings::UserSettingDirtyData* usersettingdirtydata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.usersettingdirtydata_);
  }
  if (usersettingdirtydata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(usersettingdirtydata));
    if (message_arena != submessage_arena) {
      usersettingdirtydata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, usersettingdirtydata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  _impl_.usersettingdirtydata_ = usersettingdirtydata;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.response.Notification.userSettingDirtyData)
}

// optional bool notificationAckRequired = 17;
inline bool Notification::_internal_has_notificationackrequired() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool Notification::has_notificationackrequired() const {
  return _internal_has_notificationackrequired();
}
inline void Notification::clear_notificationackrequired() {
  _impl_.notificationackrequired_ = false;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline bool Notification::_internal_notificationackrequired() const {
  return _impl_.notificationackrequired_;
}
inline bool Notification::notificationackrequired() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.Notification.notificationAckRequired)
  return _internal_notificationackrequired();
}
inline void Notification::_internal_set_notificationackrequired(bool value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.notificationackrequired_ = value;
}
inline void Notification::set_notificationackrequired(bool value) {
  _internal_set_notificationackrequired(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.response.Notification.notificationAckRequired)
}

// -------------------------------------------------------------------

// ServerMetadata

// optional int64 latencyMillis = 1;
inline bool ServerMetadata::_internal_has_latencymillis() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ServerMetadata::has_latencymillis() const {
  return _internal_has_latencymillis();
}
inline void ServerMetadata::clear_latencymillis() {
  _impl_.latencymillis_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t ServerMetadata::_internal_latencymillis() const {
  return _impl_.latencymillis_;
}
inline int64_t ServerMetadata::latencymillis() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.ServerMetadata.latencyMillis)
  return _internal_latencymillis();
}
inline void ServerMetadata::_internal_set_latencymillis(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.latencymillis_ = value;
}
inline void ServerMetadata::set_latencymillis(int64_t value) {
  _internal_set_latencymillis(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.response.ServerMetadata.latencyMillis)
}

// -------------------------------------------------------------------

// Targets

// repeated int64 targetId = 1;
inline int Targets::_internal_targetid_size() const {
  return _impl_.targetid_.size();
}
inline int Targets::targetid_size() const {
  return _internal_targetid_size();
}
inline void Targets::clear_targetid() {
  _impl_.targetid_.Clear();
}
inline int64_t Targets::_internal_targetid(int index) const {
  return _impl_.targetid_.Get(index);
}
inline int64_t Targets::targetid(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.Targets.targetId)
  return _internal_targetid(index);
}
inline void Targets::set_targetid(int index, int64_t value) {
  _impl_.targetid_.Set(index, value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.response.Targets.targetId)
}
inline void Targets::_internal_add_targetid(int64_t value) {
  _impl_.targetid_.Add(value);
}
inline void Targets::add_targetid(int64_t value) {
  _internal_add_targetid(value);
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.response.Targets.targetId)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
Targets::_internal_targetid() const {
  return _impl_.targetid_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
Targets::targetid() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.response.Targets.targetId)
  return _internal_targetid();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
Targets::_internal_mutable_targetid() {
  return &_impl_.targetid_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
Targets::mutable_targetid() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.response.Targets.targetId)
  return _internal_mutable_targetid();
}

// optional bytes signature = 2;
inline bool Targets::_internal_has_signature() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Targets::has_signature() const {
  return _internal_has_signature();
}
inline void Targets::clear_signature() {
  _impl_.signature_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Targets::signature() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.Targets.signature)
  return _internal_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Targets::set_signature(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.signature_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.response.Targets.signature)
}
inline std::string* Targets::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.response.Targets.signature)
  return _s;
}
inline const std::string& Targets::_internal_signature() const {
  return _impl_.signature_.Get();
}
inline void Targets::_internal_set_signature(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.signature_.Set(value, GetArenaForAllocation());
}
inline std::string* Targets::_internal_mutable_signature() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.signature_.Mutable(GetArenaForAllocation());
}
inline std::string* Targets::release_signature() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.response.Targets.signature)
  if (!_internal_has_signature()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.signature_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.signature_.IsDefault()) {
    _impl_.signature_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Targets::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.signature_.SetAllocated(signature, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.signature_.IsDefault()) {
    _impl_.signature_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.response.Targets.signature)
}

// -------------------------------------------------------------------

// ServerCookie

// optional int32 type = 1;
inline bool ServerCookie::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ServerCookie::has_type() const {
  return _internal_has_type();
}
inline void ServerCookie::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t ServerCookie::_internal_type() const {
  return _impl_.type_;
}
inline int32_t ServerCookie::type() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.ServerCookie.type)
  return _internal_type();
}
inline void ServerCookie::_internal_set_type(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}
inline void ServerCookie::set_type(int32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.response.ServerCookie.type)
}

// optional bytes token = 2;
inline bool ServerCookie::_internal_has_token() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ServerCookie::has_token() const {
  return _internal_has_token();
}
inline void ServerCookie::clear_token() {
  _impl_.token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ServerCookie::token() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.ServerCookie.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServerCookie::set_token(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.token_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.response.ServerCookie.token)
}
inline std::string* ServerCookie::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.response.ServerCookie.token)
  return _s;
}
inline const std::string& ServerCookie::_internal_token() const {
  return _impl_.token_.Get();
}
inline void ServerCookie::_internal_set_token(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* ServerCookie::_internal_mutable_token() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.token_.Mutable(GetArenaForAllocation());
}
inline std::string* ServerCookie::release_token() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.response.ServerCookie.token)
  if (!_internal_has_token()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ServerCookie::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.response.ServerCookie.token)
}

// -------------------------------------------------------------------

// ServerCookies

// repeated .playapi.proto.finsky.response.ServerCookie serverCookie = 1;
inline int ServerCookies::_internal_servercookie_size() const {
  return _impl_.servercookie_.size();
}
inline int ServerCookies::servercookie_size() const {
  return _internal_servercookie_size();
}
inline void ServerCookies::clear_servercookie() {
  _impl_.servercookie_.Clear();
}
inline ::playapi::proto::finsky::response::ServerCookie* ServerCookies::mutable_servercookie(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.response.ServerCookies.serverCookie)
  return _impl_.servercookie_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::response::ServerCookie >*
ServerCookies::mutable_servercookie() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.response.ServerCookies.serverCookie)
  return &_impl_.servercookie_;
}
inline const ::playapi::proto::finsky::response::ServerCookie& ServerCookies::_internal_servercookie(int index) const {
  return _impl_.servercookie_.Get(index);
}
inline const ::playapi::proto::finsky::response::ServerCookie& ServerCookies::servercookie(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.ServerCookies.serverCookie)
  return _internal_servercookie(index);
}
inline ::playapi::proto::finsky::response::ServerCookie* ServerCookies::_internal_add_servercookie() {
  return _impl_.servercookie_.Add();
}
inline ::playapi::proto::finsky::response::ServerCookie* ServerCookies::add_servercookie() {
  ::playapi::proto::finsky::response::ServerCookie* _add = _internal_add_servercookie();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.response.ServerCookies.serverCookie)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::response::ServerCookie >&
ServerCookies::servercookie() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.response.ServerCookies.serverCookie)
  return _impl_.servercookie_;
}

// -------------------------------------------------------------------

// AcceptTosResponse

// -------------------------------------------------------------------

// Payload

// optional .playapi.proto.finsky.details.DetailsResponse detailsResponse = 2;
inline bool Payload::_internal_has_detailsresponse() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.detailsresponse_ != nullptr);
  return value;
}
inline bool Payload::has_detailsresponse() const {
  return _internal_has_detailsresponse();
}
inline const ::playapi::proto::finsky::details::DetailsResponse& Payload::_internal_detailsresponse() const {
  const ::playapi::proto::finsky::details::DetailsResponse* p = _impl_.detailsresponse_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::details::DetailsResponse&>(
      ::playapi::proto::finsky::details::_DetailsResponse_default_instance_);
}
inline const ::playapi::proto::finsky::details::DetailsResponse& Payload::detailsresponse() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.Payload.detailsResponse)
  return _internal_detailsresponse();
}
inline void Payload::unsafe_arena_set_allocated_detailsresponse(
    ::playapi::proto::finsky::details::DetailsResponse* detailsresponse) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.detailsresponse_);
  }
  _impl_.detailsresponse_ = detailsresponse;
  if (detailsresponse) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.response.Payload.detailsResponse)
}
inline ::playapi::proto::finsky::details::DetailsResponse* Payload::release_detailsresponse() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::playapi::proto::finsky::details::DetailsResponse* temp = _impl_.detailsresponse_;
  _impl_.detailsresponse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::details::DetailsResponse* Payload::unsafe_arena_release_detailsresponse() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.response.Payload.detailsResponse)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::playapi::proto::finsky::details::DetailsResponse* temp = _impl_.detailsresponse_;
  _impl_.detailsresponse_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::details::DetailsResponse* Payload::_internal_mutable_detailsresponse() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.detailsresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::details::DetailsResponse>(GetArenaForAllocation());
    _impl_.detailsresponse_ = p;
  }
  return _impl_.detailsresponse_;
}
inline ::playapi::proto::finsky::details::DetailsResponse* Payload::mutable_detailsresponse() {
  ::playapi::proto::finsky::details::DetailsResponse* _msg = _internal_mutable_detailsresponse();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.response.Payload.detailsResponse)
  return _msg;
}
inline void Payload::set_allocated_detailsresponse(::playapi::proto::finsky::details::DetailsResponse* detailsresponse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.detailsresponse_);
  }
  if (detailsresponse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(detailsresponse));
    if (message_arena != submessage_arena) {
      detailsresponse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, detailsresponse, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.detailsresponse_ = detailsresponse;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.response.Payload.detailsResponse)
}

// optional .playapi.proto.finsky.search.SearchResponse searchResponse = 5;
inline bool Payload::_internal_has_searchresponse() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.searchresponse_ != nullptr);
  return value;
}
inline bool Payload::has_searchresponse() const {
  return _internal_has_searchresponse();
}
inline const ::playapi::proto::finsky::search::SearchResponse& Payload::_internal_searchresponse() const {
  const ::playapi::proto::finsky::search::SearchResponse* p = _impl_.searchresponse_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::search::SearchResponse&>(
      ::playapi::proto::finsky::search::_SearchResponse_default_instance_);
}
inline const ::playapi::proto::finsky::search::SearchResponse& Payload::searchresponse() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.Payload.searchResponse)
  return _internal_searchresponse();
}
inline void Payload::unsafe_arena_set_allocated_searchresponse(
    ::playapi::proto::finsky::search::SearchResponse* searchresponse) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.searchresponse_);
  }
  _impl_.searchresponse_ = searchresponse;
  if (searchresponse) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.response.Payload.searchResponse)
}
inline ::playapi::proto::finsky::search::SearchResponse* Payload::release_searchresponse() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::playapi::proto::finsky::search::SearchResponse* temp = _impl_.searchresponse_;
  _impl_.searchresponse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::search::SearchResponse* Payload::unsafe_arena_release_searchresponse() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.response.Payload.searchResponse)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::playapi::proto::finsky::search::SearchResponse* temp = _impl_.searchresponse_;
  _impl_.searchresponse_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::search::SearchResponse* Payload::_internal_mutable_searchresponse() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.searchresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::search::SearchResponse>(GetArenaForAllocation());
    _impl_.searchresponse_ = p;
  }
  return _impl_.searchresponse_;
}
inline ::playapi::proto::finsky::search::SearchResponse* Payload::mutable_searchresponse() {
  ::playapi::proto::finsky::search::SearchResponse* _msg = _internal_mutable_searchresponse();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.response.Payload.searchResponse)
  return _msg;
}
inline void Payload::set_allocated_searchresponse(::playapi::proto::finsky::search::SearchResponse* searchresponse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.searchresponse_);
  }
  if (searchresponse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(searchresponse));
    if (message_arena != submessage_arena) {
      searchresponse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, searchresponse, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.searchresponse_ = searchresponse;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.response.Payload.searchResponse)
}

// optional .playapi.proto.finsky.toc.TocResponse tocResponse = 6;
inline bool Payload::_internal_has_tocresponse() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tocresponse_ != nullptr);
  return value;
}
inline bool Payload::has_tocresponse() const {
  return _internal_has_tocresponse();
}
inline const ::playapi::proto::finsky::toc::TocResponse& Payload::_internal_tocresponse() const {
  const ::playapi::proto::finsky::toc::TocResponse* p = _impl_.tocresponse_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::toc::TocResponse&>(
      ::playapi::proto::finsky::toc::_TocResponse_default_instance_);
}
inline const ::playapi::proto::finsky::toc::TocResponse& Payload::tocresponse() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.Payload.tocResponse)
  return _internal_tocresponse();
}
inline void Payload::unsafe_arena_set_allocated_tocresponse(
    ::playapi::proto::finsky::toc::TocResponse* tocresponse) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tocresponse_);
  }
  _impl_.tocresponse_ = tocresponse;
  if (tocresponse) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.response.Payload.tocResponse)
}
inline ::playapi::proto::finsky::toc::TocResponse* Payload::release_tocresponse() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::playapi::proto::finsky::toc::TocResponse* temp = _impl_.tocresponse_;
  _impl_.tocresponse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::toc::TocResponse* Payload::unsafe_arena_release_tocresponse() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.response.Payload.tocResponse)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::playapi::proto::finsky::toc::TocResponse* temp = _impl_.tocresponse_;
  _impl_.tocresponse_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::toc::TocResponse* Payload::_internal_mutable_tocresponse() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.tocresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::toc::TocResponse>(GetArenaForAllocation());
    _impl_.tocresponse_ = p;
  }
  return _impl_.tocresponse_;
}
inline ::playapi::proto::finsky::toc::TocResponse* Payload::mutable_tocresponse() {
  ::playapi::proto::finsky::toc::TocResponse* _msg = _internal_mutable_tocresponse();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.response.Payload.tocResponse)
  return _msg;
}
inline void Payload::set_allocated_tocresponse(::playapi::proto::finsky::toc::TocResponse* tocresponse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tocresponse_);
  }
  if (tocresponse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tocresponse));
    if (message_arena != submessage_arena) {
      tocresponse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tocresponse, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.tocresponse_ = tocresponse;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.response.Payload.tocResponse)
}

// optional .playapi.proto.finsky.browse.BrowseResponse browseResponse = 7;
inline bool Payload::_internal_has_browseresponse() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.browseresponse_ != nullptr);
  return value;
}
inline bool Payload::has_browseresponse() const {
  return _internal_has_browseresponse();
}
inline const ::playapi::proto::finsky::browse::BrowseResponse& Payload::_internal_browseresponse() const {
  const ::playapi::proto::finsky::browse::BrowseResponse* p = _impl_.browseresponse_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::browse::BrowseResponse&>(
      ::playapi::proto::finsky::browse::_BrowseResponse_default_instance_);
}
inline const ::playapi::proto::finsky::browse::BrowseResponse& Payload::browseresponse() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.Payload.browseResponse)
  return _internal_browseresponse();
}
inline void Payload::unsafe_arena_set_allocated_browseresponse(
    ::playapi::proto::finsky::browse::BrowseResponse* browseresponse) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.browseresponse_);
  }
  _impl_.browseresponse_ = browseresponse;
  if (browseresponse) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.response.Payload.browseResponse)
}
inline ::playapi::proto::finsky::browse::BrowseResponse* Payload::release_browseresponse() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::playapi::proto::finsky::browse::BrowseResponse* temp = _impl_.browseresponse_;
  _impl_.browseresponse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::browse::BrowseResponse* Payload::unsafe_arena_release_browseresponse() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.response.Payload.browseResponse)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::playapi::proto::finsky::browse::BrowseResponse* temp = _impl_.browseresponse_;
  _impl_.browseresponse_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::browse::BrowseResponse* Payload::_internal_mutable_browseresponse() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.browseresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::browse::BrowseResponse>(GetArenaForAllocation());
    _impl_.browseresponse_ = p;
  }
  return _impl_.browseresponse_;
}
inline ::playapi::proto::finsky::browse::BrowseResponse* Payload::mutable_browseresponse() {
  ::playapi::proto::finsky::browse::BrowseResponse* _msg = _internal_mutable_browseresponse();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.response.Payload.browseResponse)
  return _msg;
}
inline void Payload::set_allocated_browseresponse(::playapi::proto::finsky::browse::BrowseResponse* browseresponse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.browseresponse_);
  }
  if (browseresponse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(browseresponse));
    if (message_arena != submessage_arena) {
      browseresponse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, browseresponse, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.browseresponse_ = browseresponse;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.response.Payload.browseResponse)
}

// optional .playapi.proto.finsky.details.BulkDetailsResponse bulkDetailsResponse = 19;
inline bool Payload::_internal_has_bulkdetailsresponse() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.bulkdetailsresponse_ != nullptr);
  return value;
}
inline bool Payload::has_bulkdetailsresponse() const {
  return _internal_has_bulkdetailsresponse();
}
inline const ::playapi::proto::finsky::details::BulkDetailsResponse& Payload::_internal_bulkdetailsresponse() const {
  const ::playapi::proto::finsky::details::BulkDetailsResponse* p = _impl_.bulkdetailsresponse_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::details::BulkDetailsResponse&>(
      ::playapi::proto::finsky::details::_BulkDetailsResponse_default_instance_);
}
inline const ::playapi::proto::finsky::details::BulkDetailsResponse& Payload::bulkdetailsresponse() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.Payload.bulkDetailsResponse)
  return _internal_bulkdetailsresponse();
}
inline void Payload::unsafe_arena_set_allocated_bulkdetailsresponse(
    ::playapi::proto::finsky::details::BulkDetailsResponse* bulkdetailsresponse) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bulkdetailsresponse_);
  }
  _impl_.bulkdetailsresponse_ = bulkdetailsresponse;
  if (bulkdetailsresponse) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.response.Payload.bulkDetailsResponse)
}
inline ::playapi::proto::finsky::details::BulkDetailsResponse* Payload::release_bulkdetailsresponse() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::playapi::proto::finsky::details::BulkDetailsResponse* temp = _impl_.bulkdetailsresponse_;
  _impl_.bulkdetailsresponse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::details::BulkDetailsResponse* Payload::unsafe_arena_release_bulkdetailsresponse() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.response.Payload.bulkDetailsResponse)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::playapi::proto::finsky::details::BulkDetailsResponse* temp = _impl_.bulkdetailsresponse_;
  _impl_.bulkdetailsresponse_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::details::BulkDetailsResponse* Payload::_internal_mutable_bulkdetailsresponse() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.bulkdetailsresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::details::BulkDetailsResponse>(GetArenaForAllocation());
    _impl_.bulkdetailsresponse_ = p;
  }
  return _impl_.bulkdetailsresponse_;
}
inline ::playapi::proto::finsky::details::BulkDetailsResponse* Payload::mutable_bulkdetailsresponse() {
  ::playapi::proto::finsky::details::BulkDetailsResponse* _msg = _internal_mutable_bulkdetailsresponse();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.response.Payload.bulkDetailsResponse)
  return _msg;
}
inline void Payload::set_allocated_bulkdetailsresponse(::playapi::proto::finsky::details::BulkDetailsResponse* bulkdetailsresponse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bulkdetailsresponse_);
  }
  if (bulkdetailsresponse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bulkdetailsresponse));
    if (message_arena != submessage_arena) {
      bulkdetailsresponse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bulkdetailsresponse, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.bulkdetailsresponse_ = bulkdetailsresponse;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.response.Payload.bulkDetailsResponse)
}

// optional .playapi.proto.finsky.download.DeliveryResponse deliveryResponse = 21;
inline bool Payload::_internal_has_deliveryresponse() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.deliveryresponse_ != nullptr);
  return value;
}
inline bool Payload::has_deliveryresponse() const {
  return _internal_has_deliveryresponse();
}
inline const ::playapi::proto::finsky::download::DeliveryResponse& Payload::_internal_deliveryresponse() const {
  const ::playapi::proto::finsky::download::DeliveryResponse* p = _impl_.deliveryresponse_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::download::DeliveryResponse&>(
      ::playapi::proto::finsky::download::_DeliveryResponse_default_instance_);
}
inline const ::playapi::proto::finsky::download::DeliveryResponse& Payload::deliveryresponse() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.Payload.deliveryResponse)
  return _internal_deliveryresponse();
}
inline void Payload::unsafe_arena_set_allocated_deliveryresponse(
    ::playapi::proto::finsky::download::DeliveryResponse* deliveryresponse) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.deliveryresponse_);
  }
  _impl_.deliveryresponse_ = deliveryresponse;
  if (deliveryresponse) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.response.Payload.deliveryResponse)
}
inline ::playapi::proto::finsky::download::DeliveryResponse* Payload::release_deliveryresponse() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::playapi::proto::finsky::download::DeliveryResponse* temp = _impl_.deliveryresponse_;
  _impl_.deliveryresponse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::download::DeliveryResponse* Payload::unsafe_arena_release_deliveryresponse() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.response.Payload.deliveryResponse)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::playapi::proto::finsky::download::DeliveryResponse* temp = _impl_.deliveryresponse_;
  _impl_.deliveryresponse_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::download::DeliveryResponse* Payload::_internal_mutable_deliveryresponse() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.deliveryresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::download::DeliveryResponse>(GetArenaForAllocation());
    _impl_.deliveryresponse_ = p;
  }
  return _impl_.deliveryresponse_;
}
inline ::playapi::proto::finsky::download::DeliveryResponse* Payload::mutable_deliveryresponse() {
  ::playapi::proto::finsky::download::DeliveryResponse* _msg = _internal_mutable_deliveryresponse();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.response.Payload.deliveryResponse)
  return _msg;
}
inline void Payload::set_allocated_deliveryresponse(::playapi::proto::finsky::download::DeliveryResponse* deliveryresponse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.deliveryresponse_);
  }
  if (deliveryresponse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(deliveryresponse));
    if (message_arena != submessage_arena) {
      deliveryresponse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, deliveryresponse, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.deliveryresponse_ = deliveryresponse;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.response.Payload.deliveryResponse)
}

// optional .playapi.proto.finsky.response.AcceptTosResponse acceptTosResponse = 22;
inline bool Payload::_internal_has_accepttosresponse() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.accepttosresponse_ != nullptr);
  return value;
}
inline bool Payload::has_accepttosresponse() const {
  return _internal_has_accepttosresponse();
}
inline void Payload::clear_accepttosresponse() {
  if (_impl_.accepttosresponse_ != nullptr) _impl_.accepttosresponse_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::playapi::proto::finsky::response::AcceptTosResponse& Payload::_internal_accepttosresponse() const {
  const ::playapi::proto::finsky::response::AcceptTosResponse* p = _impl_.accepttosresponse_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::response::AcceptTosResponse&>(
      ::playapi::proto::finsky::response::_AcceptTosResponse_default_instance_);
}
inline const ::playapi::proto::finsky::response::AcceptTosResponse& Payload::accepttosresponse() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.Payload.acceptTosResponse)
  return _internal_accepttosresponse();
}
inline void Payload::unsafe_arena_set_allocated_accepttosresponse(
    ::playapi::proto::finsky::response::AcceptTosResponse* accepttosresponse) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.accepttosresponse_);
  }
  _impl_.accepttosresponse_ = accepttosresponse;
  if (accepttosresponse) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.response.Payload.acceptTosResponse)
}
inline ::playapi::proto::finsky::response::AcceptTosResponse* Payload::release_accepttosresponse() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::playapi::proto::finsky::response::AcceptTosResponse* temp = _impl_.accepttosresponse_;
  _impl_.accepttosresponse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::response::AcceptTosResponse* Payload::unsafe_arena_release_accepttosresponse() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.response.Payload.acceptTosResponse)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::playapi::proto::finsky::response::AcceptTosResponse* temp = _impl_.accepttosresponse_;
  _impl_.accepttosresponse_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::response::AcceptTosResponse* Payload::_internal_mutable_accepttosresponse() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.accepttosresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::response::AcceptTosResponse>(GetArenaForAllocation());
    _impl_.accepttosresponse_ = p;
  }
  return _impl_.accepttosresponse_;
}
inline ::playapi::proto::finsky::response::AcceptTosResponse* Payload::mutable_accepttosresponse() {
  ::playapi::proto::finsky::response::AcceptTosResponse* _msg = _internal_mutable_accepttosresponse();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.response.Payload.acceptTosResponse)
  return _msg;
}
inline void Payload::set_allocated_accepttosresponse(::playapi::proto::finsky::response::AcceptTosResponse* accepttosresponse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.accepttosresponse_;
  }
  if (accepttosresponse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(accepttosresponse);
    if (message_arena != submessage_arena) {
      accepttosresponse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, accepttosresponse, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.accepttosresponse_ = accepttosresponse;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.response.Payload.acceptTosResponse)
}

// optional .playapi.proto.finsky.device_config.UploadDeviceConfigResponse uploadDeviceConfigResponse = 28;
inline bool Payload::_internal_has_uploaddeviceconfigresponse() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.uploaddeviceconfigresponse_ != nullptr);
  return value;
}
inline bool Payload::has_uploaddeviceconfigresponse() const {
  return _internal_has_uploaddeviceconfigresponse();
}
inline const ::playapi::proto::finsky::device_config::UploadDeviceConfigResponse& Payload::_internal_uploaddeviceconfigresponse() const {
  const ::playapi::proto::finsky::device_config::UploadDeviceConfigResponse* p = _impl_.uploaddeviceconfigresponse_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::device_config::UploadDeviceConfigResponse&>(
      ::playapi::proto::finsky::device_config::_UploadDeviceConfigResponse_default_instance_);
}
inline const ::playapi::proto::finsky::device_config::UploadDeviceConfigResponse& Payload::uploaddeviceconfigresponse() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.Payload.uploadDeviceConfigResponse)
  return _internal_uploaddeviceconfigresponse();
}
inline void Payload::unsafe_arena_set_allocated_uploaddeviceconfigresponse(
    ::playapi::proto::finsky::device_config::UploadDeviceConfigResponse* uploaddeviceconfigresponse) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.uploaddeviceconfigresponse_);
  }
  _impl_.uploaddeviceconfigresponse_ = uploaddeviceconfigresponse;
  if (uploaddeviceconfigresponse) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.response.Payload.uploadDeviceConfigResponse)
}
inline ::playapi::proto::finsky::device_config::UploadDeviceConfigResponse* Payload::release_uploaddeviceconfigresponse() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::playapi::proto::finsky::device_config::UploadDeviceConfigResponse* temp = _impl_.uploaddeviceconfigresponse_;
  _impl_.uploaddeviceconfigresponse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::device_config::UploadDeviceConfigResponse* Payload::unsafe_arena_release_uploaddeviceconfigresponse() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.response.Payload.uploadDeviceConfigResponse)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::playapi::proto::finsky::device_config::UploadDeviceConfigResponse* temp = _impl_.uploaddeviceconfigresponse_;
  _impl_.uploaddeviceconfigresponse_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::device_config::UploadDeviceConfigResponse* Payload::_internal_mutable_uploaddeviceconfigresponse() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.uploaddeviceconfigresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::device_config::UploadDeviceConfigResponse>(GetArenaForAllocation());
    _impl_.uploaddeviceconfigresponse_ = p;
  }
  return _impl_.uploaddeviceconfigresponse_;
}
inline ::playapi::proto::finsky::device_config::UploadDeviceConfigResponse* Payload::mutable_uploaddeviceconfigresponse() {
  ::playapi::proto::finsky::device_config::UploadDeviceConfigResponse* _msg = _internal_mutable_uploaddeviceconfigresponse();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.response.Payload.uploadDeviceConfigResponse)
  return _msg;
}
inline void Payload::set_allocated_uploaddeviceconfigresponse(::playapi::proto::finsky::device_config::UploadDeviceConfigResponse* uploaddeviceconfigresponse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.uploaddeviceconfigresponse_);
  }
  if (uploaddeviceconfigresponse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(uploaddeviceconfigresponse));
    if (message_arena != submessage_arena) {
      uploaddeviceconfigresponse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, uploaddeviceconfigresponse, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.uploaddeviceconfigresponse_ = uploaddeviceconfigresponse;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.response.Payload.uploadDeviceConfigResponse)
}

// optional .playapi.proto.finsky.search.SearchSuggestResponse searchSuggestResponse = 40;
inline bool Payload::_internal_has_searchsuggestresponse() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.searchsuggestresponse_ != nullptr);
  return value;
}
inline bool Payload::has_searchsuggestresponse() const {
  return _internal_has_searchsuggestresponse();
}
inline const ::playapi::proto::finsky::search::SearchSuggestResponse& Payload::_internal_searchsuggestresponse() const {
  const ::playapi::proto::finsky::search::SearchSuggestResponse* p = _impl_.searchsuggestresponse_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::search::SearchSuggestResponse&>(
      ::playapi::proto::finsky::search::_SearchSuggestResponse_default_instance_);
}
inline const ::playapi::proto::finsky::search::SearchSuggestResponse& Payload::searchsuggestresponse() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.Payload.searchSuggestResponse)
  return _internal_searchsuggestresponse();
}
inline void Payload::unsafe_arena_set_allocated_searchsuggestresponse(
    ::playapi::proto::finsky::search::SearchSuggestResponse* searchsuggestresponse) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.searchsuggestresponse_);
  }
  _impl_.searchsuggestresponse_ = searchsuggestresponse;
  if (searchsuggestresponse) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.response.Payload.searchSuggestResponse)
}
inline ::playapi::proto::finsky::search::SearchSuggestResponse* Payload::release_searchsuggestresponse() {
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::playapi::proto::finsky::search::SearchSuggestResponse* temp = _impl_.searchsuggestresponse_;
  _impl_.searchsuggestresponse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::search::SearchSuggestResponse* Payload::unsafe_arena_release_searchsuggestresponse() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.response.Payload.searchSuggestResponse)
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::playapi::proto::finsky::search::SearchSuggestResponse* temp = _impl_.searchsuggestresponse_;
  _impl_.searchsuggestresponse_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::search::SearchSuggestResponse* Payload::_internal_mutable_searchsuggestresponse() {
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.searchsuggestresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::search::SearchSuggestResponse>(GetArenaForAllocation());
    _impl_.searchsuggestresponse_ = p;
  }
  return _impl_.searchsuggestresponse_;
}
inline ::playapi::proto::finsky::search::SearchSuggestResponse* Payload::mutable_searchsuggestresponse() {
  ::playapi::proto::finsky::search::SearchSuggestResponse* _msg = _internal_mutable_searchsuggestresponse();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.response.Payload.searchSuggestResponse)
  return _msg;
}
inline void Payload::set_allocated_searchsuggestresponse(::playapi::proto::finsky::search::SearchSuggestResponse* searchsuggestresponse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.searchsuggestresponse_);
  }
  if (searchsuggestresponse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(searchsuggestresponse));
    if (message_arena != submessage_arena) {
      searchsuggestresponse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, searchsuggestresponse, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.searchsuggestresponse_ = searchsuggestresponse;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.response.Payload.searchSuggestResponse)
}

// optional .playapi.proto.finsky.settings.GetUserSettingsResponse getUserSettingsResponse = 54;
inline bool Payload::_internal_has_getusersettingsresponse() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.getusersettingsresponse_ != nullptr);
  return value;
}
inline bool Payload::has_getusersettingsresponse() const {
  return _internal_has_getusersettingsresponse();
}
inline const ::playapi::proto::finsky::settings::GetUserSettingsResponse& Payload::_internal_getusersettingsresponse() const {
  const ::playapi::proto::finsky::settings::GetUserSettingsResponse* p = _impl_.getusersettingsresponse_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::settings::GetUserSettingsResponse&>(
      ::playapi::proto::finsky::settings::_GetUserSettingsResponse_default_instance_);
}
inline const ::playapi::proto::finsky::settings::GetUserSettingsResponse& Payload::getusersettingsresponse() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.Payload.getUserSettingsResponse)
  return _internal_getusersettingsresponse();
}
inline void Payload::unsafe_arena_set_allocated_getusersettingsresponse(
    ::playapi::proto::finsky::settings::GetUserSettingsResponse* getusersettingsresponse) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.getusersettingsresponse_);
  }
  _impl_.getusersettingsresponse_ = getusersettingsresponse;
  if (getusersettingsresponse) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.response.Payload.getUserSettingsResponse)
}
inline ::playapi::proto::finsky::settings::GetUserSettingsResponse* Payload::release_getusersettingsresponse() {
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::playapi::proto::finsky::settings::GetUserSettingsResponse* temp = _impl_.getusersettingsresponse_;
  _impl_.getusersettingsresponse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::settings::GetUserSettingsResponse* Payload::unsafe_arena_release_getusersettingsresponse() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.response.Payload.getUserSettingsResponse)
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::playapi::proto::finsky::settings::GetUserSettingsResponse* temp = _impl_.getusersettingsresponse_;
  _impl_.getusersettingsresponse_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::settings::GetUserSettingsResponse* Payload::_internal_mutable_getusersettingsresponse() {
  _impl_._has_bits_[0] |= 0x00000200u;
  if (_impl_.getusersettingsresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::settings::GetUserSettingsResponse>(GetArenaForAllocation());
    _impl_.getusersettingsresponse_ = p;
  }
  return _impl_.getusersettingsresponse_;
}
inline ::playapi::proto::finsky::settings::GetUserSettingsResponse* Payload::mutable_getusersettingsresponse() {
  ::playapi::proto::finsky::settings::GetUserSettingsResponse* _msg = _internal_mutable_getusersettingsresponse();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.response.Payload.getUserSettingsResponse)
  return _msg;
}
inline void Payload::set_allocated_getusersettingsresponse(::playapi::proto::finsky::settings::GetUserSettingsResponse* getusersettingsresponse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.getusersettingsresponse_);
  }
  if (getusersettingsresponse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(getusersettingsresponse));
    if (message_arena != submessage_arena) {
      getusersettingsresponse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, getusersettingsresponse, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.getusersettingsresponse_ = getusersettingsresponse;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.response.Payload.getUserSettingsResponse)
}

// -------------------------------------------------------------------

// ResponseWrapper

// optional .playapi.proto.finsky.response.Payload payload = 1;
inline bool ResponseWrapper::_internal_has_payload() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.payload_ != nullptr);
  return value;
}
inline bool ResponseWrapper::has_payload() const {
  return _internal_has_payload();
}
inline void ResponseWrapper::clear_payload() {
  if (_impl_.payload_ != nullptr) _impl_.payload_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::playapi::proto::finsky::response::Payload& ResponseWrapper::_internal_payload() const {
  const ::playapi::proto::finsky::response::Payload* p = _impl_.payload_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::response::Payload&>(
      ::playapi::proto::finsky::response::_Payload_default_instance_);
}
inline const ::playapi::proto::finsky::response::Payload& ResponseWrapper::payload() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.ResponseWrapper.payload)
  return _internal_payload();
}
inline void ResponseWrapper::unsafe_arena_set_allocated_payload(
    ::playapi::proto::finsky::response::Payload* payload) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.payload_);
  }
  _impl_.payload_ = payload;
  if (payload) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.response.ResponseWrapper.payload)
}
inline ::playapi::proto::finsky::response::Payload* ResponseWrapper::release_payload() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::playapi::proto::finsky::response::Payload* temp = _impl_.payload_;
  _impl_.payload_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::response::Payload* ResponseWrapper::unsafe_arena_release_payload() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.response.ResponseWrapper.payload)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::playapi::proto::finsky::response::Payload* temp = _impl_.payload_;
  _impl_.payload_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::response::Payload* ResponseWrapper::_internal_mutable_payload() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.payload_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::response::Payload>(GetArenaForAllocation());
    _impl_.payload_ = p;
  }
  return _impl_.payload_;
}
inline ::playapi::proto::finsky::response::Payload* ResponseWrapper::mutable_payload() {
  ::playapi::proto::finsky::response::Payload* _msg = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.response.ResponseWrapper.payload)
  return _msg;
}
inline void ResponseWrapper::set_allocated_payload(::playapi::proto::finsky::response::Payload* payload) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.payload_;
  }
  if (payload) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(payload);
    if (message_arena != submessage_arena) {
      payload = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payload, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.payload_ = payload;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.response.ResponseWrapper.payload)
}

// optional .playapi.proto.finsky.response.ServerCommands commands = 2;
inline bool ResponseWrapper::_internal_has_commands() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.commands_ != nullptr);
  return value;
}
inline bool ResponseWrapper::has_commands() const {
  return _internal_has_commands();
}
inline void ResponseWrapper::clear_commands() {
  if (_impl_.commands_ != nullptr) _impl_.commands_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::playapi::proto::finsky::response::ServerCommands& ResponseWrapper::_internal_commands() const {
  const ::playapi::proto::finsky::response::ServerCommands* p = _impl_.commands_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::response::ServerCommands&>(
      ::playapi::proto::finsky::response::_ServerCommands_default_instance_);
}
inline const ::playapi::proto::finsky::response::ServerCommands& ResponseWrapper::commands() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.ResponseWrapper.commands)
  return _internal_commands();
}
inline void ResponseWrapper::unsafe_arena_set_allocated_commands(
    ::playapi::proto::finsky::response::ServerCommands* commands) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.commands_);
  }
  _impl_.commands_ = commands;
  if (commands) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.response.ResponseWrapper.commands)
}
inline ::playapi::proto::finsky::response::ServerCommands* ResponseWrapper::release_commands() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::playapi::proto::finsky::response::ServerCommands* temp = _impl_.commands_;
  _impl_.commands_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::response::ServerCommands* ResponseWrapper::unsafe_arena_release_commands() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.response.ResponseWrapper.commands)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::playapi::proto::finsky::response::ServerCommands* temp = _impl_.commands_;
  _impl_.commands_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::response::ServerCommands* ResponseWrapper::_internal_mutable_commands() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.commands_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::response::ServerCommands>(GetArenaForAllocation());
    _impl_.commands_ = p;
  }
  return _impl_.commands_;
}
inline ::playapi::proto::finsky::response::ServerCommands* ResponseWrapper::mutable_commands() {
  ::playapi::proto::finsky::response::ServerCommands* _msg = _internal_mutable_commands();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.response.ResponseWrapper.commands)
  return _msg;
}
inline void ResponseWrapper::set_allocated_commands(::playapi::proto::finsky::response::ServerCommands* commands) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.commands_;
  }
  if (commands) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(commands);
    if (message_arena != submessage_arena) {
      commands = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, commands, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.commands_ = commands;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.response.ResponseWrapper.commands)
}

// repeated .playapi.proto.finsky.response.PreFetch preFetch = 3;
inline int ResponseWrapper::_internal_prefetch_size() const {
  return _impl_.prefetch_.size();
}
inline int ResponseWrapper::prefetch_size() const {
  return _internal_prefetch_size();
}
inline void ResponseWrapper::clear_prefetch() {
  _impl_.prefetch_.Clear();
}
inline ::playapi::proto::finsky::response::PreFetch* ResponseWrapper::mutable_prefetch(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.response.ResponseWrapper.preFetch)
  return _impl_.prefetch_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::response::PreFetch >*
ResponseWrapper::mutable_prefetch() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.response.ResponseWrapper.preFetch)
  return &_impl_.prefetch_;
}
inline const ::playapi::proto::finsky::response::PreFetch& ResponseWrapper::_internal_prefetch(int index) const {
  return _impl_.prefetch_.Get(index);
}
inline const ::playapi::proto::finsky::response::PreFetch& ResponseWrapper::prefetch(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.ResponseWrapper.preFetch)
  return _internal_prefetch(index);
}
inline ::playapi::proto::finsky::response::PreFetch* ResponseWrapper::_internal_add_prefetch() {
  return _impl_.prefetch_.Add();
}
inline ::playapi::proto::finsky::response::PreFetch* ResponseWrapper::add_prefetch() {
  ::playapi::proto::finsky::response::PreFetch* _add = _internal_add_prefetch();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.response.ResponseWrapper.preFetch)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::response::PreFetch >&
ResponseWrapper::prefetch() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.response.ResponseWrapper.preFetch)
  return _impl_.prefetch_;
}

// repeated .playapi.proto.finsky.response.Notification notification = 4;
inline int ResponseWrapper::_internal_notification_size() const {
  return _impl_.notification_.size();
}
inline int ResponseWrapper::notification_size() const {
  return _internal_notification_size();
}
inline void ResponseWrapper::clear_notification() {
  _impl_.notification_.Clear();
}
inline ::playapi::proto::finsky::response::Notification* ResponseWrapper::mutable_notification(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.response.ResponseWrapper.notification)
  return _impl_.notification_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::response::Notification >*
ResponseWrapper::mutable_notification() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.response.ResponseWrapper.notification)
  return &_impl_.notification_;
}
inline const ::playapi::proto::finsky::response::Notification& ResponseWrapper::_internal_notification(int index) const {
  return _impl_.notification_.Get(index);
}
inline const ::playapi::proto::finsky::response::Notification& ResponseWrapper::notification(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.ResponseWrapper.notification)
  return _internal_notification(index);
}
inline ::playapi::proto::finsky::response::Notification* ResponseWrapper::_internal_add_notification() {
  return _impl_.notification_.Add();
}
inline ::playapi::proto::finsky::response::Notification* ResponseWrapper::add_notification() {
  ::playapi::proto::finsky::response::Notification* _add = _internal_add_notification();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.response.ResponseWrapper.notification)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::response::Notification >&
ResponseWrapper::notification() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.response.ResponseWrapper.notification)
  return _impl_.notification_;
}

// optional .playapi.proto.finsky.response.ServerMetadata serverMetadata = 5;
inline bool ResponseWrapper::_internal_has_servermetadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.servermetadata_ != nullptr);
  return value;
}
inline bool ResponseWrapper::has_servermetadata() const {
  return _internal_has_servermetadata();
}
inline void ResponseWrapper::clear_servermetadata() {
  if (_impl_.servermetadata_ != nullptr) _impl_.servermetadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::playapi::proto::finsky::response::ServerMetadata& ResponseWrapper::_internal_servermetadata() const {
  const ::playapi::proto::finsky::response::ServerMetadata* p = _impl_.servermetadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::response::ServerMetadata&>(
      ::playapi::proto::finsky::response::_ServerMetadata_default_instance_);
}
inline const ::playapi::proto::finsky::response::ServerMetadata& ResponseWrapper::servermetadata() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.ResponseWrapper.serverMetadata)
  return _internal_servermetadata();
}
inline void ResponseWrapper::unsafe_arena_set_allocated_servermetadata(
    ::playapi::proto::finsky::response::ServerMetadata* servermetadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.servermetadata_);
  }
  _impl_.servermetadata_ = servermetadata;
  if (servermetadata) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.response.ResponseWrapper.serverMetadata)
}
inline ::playapi::proto::finsky::response::ServerMetadata* ResponseWrapper::release_servermetadata() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::playapi::proto::finsky::response::ServerMetadata* temp = _impl_.servermetadata_;
  _impl_.servermetadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::response::ServerMetadata* ResponseWrapper::unsafe_arena_release_servermetadata() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.response.ResponseWrapper.serverMetadata)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::playapi::proto::finsky::response::ServerMetadata* temp = _impl_.servermetadata_;
  _impl_.servermetadata_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::response::ServerMetadata* ResponseWrapper::_internal_mutable_servermetadata() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.servermetadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::response::ServerMetadata>(GetArenaForAllocation());
    _impl_.servermetadata_ = p;
  }
  return _impl_.servermetadata_;
}
inline ::playapi::proto::finsky::response::ServerMetadata* ResponseWrapper::mutable_servermetadata() {
  ::playapi::proto::finsky::response::ServerMetadata* _msg = _internal_mutable_servermetadata();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.response.ResponseWrapper.serverMetadata)
  return _msg;
}
inline void ResponseWrapper::set_allocated_servermetadata(::playapi::proto::finsky::response::ServerMetadata* servermetadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.servermetadata_;
  }
  if (servermetadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(servermetadata);
    if (message_arena != submessage_arena) {
      servermetadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, servermetadata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.servermetadata_ = servermetadata;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.response.ResponseWrapper.serverMetadata)
}

// optional .playapi.proto.finsky.response.Targets targets = 6;
inline bool ResponseWrapper::_internal_has_targets() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.targets_ != nullptr);
  return value;
}
inline bool ResponseWrapper::has_targets() const {
  return _internal_has_targets();
}
inline void ResponseWrapper::clear_targets() {
  if (_impl_.targets_ != nullptr) _impl_.targets_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::playapi::proto::finsky::response::Targets& ResponseWrapper::_internal_targets() const {
  const ::playapi::proto::finsky::response::Targets* p = _impl_.targets_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::response::Targets&>(
      ::playapi::proto::finsky::response::_Targets_default_instance_);
}
inline const ::playapi::proto::finsky::response::Targets& ResponseWrapper::targets() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.ResponseWrapper.targets)
  return _internal_targets();
}
inline void ResponseWrapper::unsafe_arena_set_allocated_targets(
    ::playapi::proto::finsky::response::Targets* targets) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.targets_);
  }
  _impl_.targets_ = targets;
  if (targets) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.response.ResponseWrapper.targets)
}
inline ::playapi::proto::finsky::response::Targets* ResponseWrapper::release_targets() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::playapi::proto::finsky::response::Targets* temp = _impl_.targets_;
  _impl_.targets_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::response::Targets* ResponseWrapper::unsafe_arena_release_targets() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.response.ResponseWrapper.targets)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::playapi::proto::finsky::response::Targets* temp = _impl_.targets_;
  _impl_.targets_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::response::Targets* ResponseWrapper::_internal_mutable_targets() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.targets_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::response::Targets>(GetArenaForAllocation());
    _impl_.targets_ = p;
  }
  return _impl_.targets_;
}
inline ::playapi::proto::finsky::response::Targets* ResponseWrapper::mutable_targets() {
  ::playapi::proto::finsky::response::Targets* _msg = _internal_mutable_targets();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.response.ResponseWrapper.targets)
  return _msg;
}
inline void ResponseWrapper::set_allocated_targets(::playapi::proto::finsky::response::Targets* targets) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.targets_;
  }
  if (targets) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(targets);
    if (message_arena != submessage_arena) {
      targets = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, targets, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.targets_ = targets;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.response.ResponseWrapper.targets)
}

// optional .playapi.proto.finsky.response.ServerCookies serverCookies = 7;
inline bool ResponseWrapper::_internal_has_servercookies() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.servercookies_ != nullptr);
  return value;
}
inline bool ResponseWrapper::has_servercookies() const {
  return _internal_has_servercookies();
}
inline void ResponseWrapper::clear_servercookies() {
  if (_impl_.servercookies_ != nullptr) _impl_.servercookies_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::playapi::proto::finsky::response::ServerCookies& ResponseWrapper::_internal_servercookies() const {
  const ::playapi::proto::finsky::response::ServerCookies* p = _impl_.servercookies_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::response::ServerCookies&>(
      ::playapi::proto::finsky::response::_ServerCookies_default_instance_);
}
inline const ::playapi::proto::finsky::response::ServerCookies& ResponseWrapper::servercookies() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.ResponseWrapper.serverCookies)
  return _internal_servercookies();
}
inline void ResponseWrapper::unsafe_arena_set_allocated_servercookies(
    ::playapi::proto::finsky::response::ServerCookies* servercookies) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.servercookies_);
  }
  _impl_.servercookies_ = servercookies;
  if (servercookies) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.response.ResponseWrapper.serverCookies)
}
inline ::playapi::proto::finsky::response::ServerCookies* ResponseWrapper::release_servercookies() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::playapi::proto::finsky::response::ServerCookies* temp = _impl_.servercookies_;
  _impl_.servercookies_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::response::ServerCookies* ResponseWrapper::unsafe_arena_release_servercookies() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.response.ResponseWrapper.serverCookies)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::playapi::proto::finsky::response::ServerCookies* temp = _impl_.servercookies_;
  _impl_.servercookies_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::response::ServerCookies* ResponseWrapper::_internal_mutable_servercookies() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.servercookies_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::response::ServerCookies>(GetArenaForAllocation());
    _impl_.servercookies_ = p;
  }
  return _impl_.servercookies_;
}
inline ::playapi::proto::finsky::response::ServerCookies* ResponseWrapper::mutable_servercookies() {
  ::playapi::proto::finsky::response::ServerCookies* _msg = _internal_mutable_servercookies();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.response.ResponseWrapper.serverCookies)
  return _msg;
}
inline void ResponseWrapper::set_allocated_servercookies(::playapi::proto::finsky::response::ServerCookies* servercookies) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.servercookies_;
  }
  if (servercookies) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(servercookies);
    if (message_arena != submessage_arena) {
      servercookies = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, servercookies, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.servercookies_ = servercookies;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.response.ResponseWrapper.serverCookies)
}

// optional bytes serverLogsCookie = 9;
inline bool ResponseWrapper::_internal_has_serverlogscookie() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResponseWrapper::has_serverlogscookie() const {
  return _internal_has_serverlogscookie();
}
inline void ResponseWrapper::clear_serverlogscookie() {
  _impl_.serverlogscookie_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ResponseWrapper::serverlogscookie() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.response.ResponseWrapper.serverLogsCookie)
  return _internal_serverlogscookie();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseWrapper::set_serverlogscookie(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.serverlogscookie_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.response.ResponseWrapper.serverLogsCookie)
}
inline std::string* ResponseWrapper::mutable_serverlogscookie() {
  std::string* _s = _internal_mutable_serverlogscookie();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.response.ResponseWrapper.serverLogsCookie)
  return _s;
}
inline const std::string& ResponseWrapper::_internal_serverlogscookie() const {
  return _impl_.serverlogscookie_.Get();
}
inline void ResponseWrapper::_internal_set_serverlogscookie(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.serverlogscookie_.Set(value, GetArenaForAllocation());
}
inline std::string* ResponseWrapper::_internal_mutable_serverlogscookie() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.serverlogscookie_.Mutable(GetArenaForAllocation());
}
inline std::string* ResponseWrapper::release_serverlogscookie() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.response.ResponseWrapper.serverLogsCookie)
  if (!_internal_has_serverlogscookie()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.serverlogscookie_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.serverlogscookie_.IsDefault()) {
    _impl_.serverlogscookie_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ResponseWrapper::set_allocated_serverlogscookie(std::string* serverlogscookie) {
  if (serverlogscookie != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.serverlogscookie_.SetAllocated(serverlogscookie, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.serverlogscookie_.IsDefault()) {
    _impl_.serverlogscookie_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.response.ResponseWrapper.serverLogsCookie)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace response
}  // namespace finsky
}  // namespace proto
}  // namespace playapi

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_play_5frespone_2eproto
