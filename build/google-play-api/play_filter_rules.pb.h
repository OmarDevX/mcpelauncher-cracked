// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: play_filter_rules.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_play_5ffilter_5frules_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_play_5ffilter_5frules_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "play_common.pb.h"
#include "play_download.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_play_5ffilter_5frules_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_play_5ffilter_5frules_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_play_5ffilter_5frules_2eproto;
namespace playapi {
namespace proto {
namespace finsky {
namespace filter_rules {
class Availability;
struct AvailabilityDefaultTypeInternal;
extern AvailabilityDefaultTypeInternal _Availability_default_instance_;
class AvailabilityProblem;
struct AvailabilityProblemDefaultTypeInternal;
extern AvailabilityProblemDefaultTypeInternal _AvailabilityProblem_default_instance_;
class Availability_PerDeviceAvailabilityRestriction;
struct Availability_PerDeviceAvailabilityRestrictionDefaultTypeInternal;
extern Availability_PerDeviceAvailabilityRestrictionDefaultTypeInternal _Availability_PerDeviceAvailabilityRestriction_default_instance_;
class FilterEvaluationInfo;
struct FilterEvaluationInfoDefaultTypeInternal;
extern FilterEvaluationInfoDefaultTypeInternal _FilterEvaluationInfo_default_instance_;
class Rule;
struct RuleDefaultTypeInternal;
extern RuleDefaultTypeInternal _Rule_default_instance_;
class RuleEvaluation;
struct RuleEvaluationDefaultTypeInternal;
extern RuleEvaluationDefaultTypeInternal _RuleEvaluation_default_instance_;
}  // namespace filter_rules
}  // namespace finsky
}  // namespace proto
}  // namespace playapi
PROTOBUF_NAMESPACE_OPEN
template<> ::playapi::proto::finsky::filter_rules::Availability* Arena::CreateMaybeMessage<::playapi::proto::finsky::filter_rules::Availability>(Arena*);
template<> ::playapi::proto::finsky::filter_rules::AvailabilityProblem* Arena::CreateMaybeMessage<::playapi::proto::finsky::filter_rules::AvailabilityProblem>(Arena*);
template<> ::playapi::proto::finsky::filter_rules::Availability_PerDeviceAvailabilityRestriction* Arena::CreateMaybeMessage<::playapi::proto::finsky::filter_rules::Availability_PerDeviceAvailabilityRestriction>(Arena*);
template<> ::playapi::proto::finsky::filter_rules::FilterEvaluationInfo* Arena::CreateMaybeMessage<::playapi::proto::finsky::filter_rules::FilterEvaluationInfo>(Arena*);
template<> ::playapi::proto::finsky::filter_rules::Rule* Arena::CreateMaybeMessage<::playapi::proto::finsky::filter_rules::Rule>(Arena*);
template<> ::playapi::proto::finsky::filter_rules::RuleEvaluation* Arena::CreateMaybeMessage<::playapi::proto::finsky::filter_rules::RuleEvaluation>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace playapi {
namespace proto {
namespace finsky {
namespace filter_rules {

// ===================================================================

class Availability_PerDeviceAvailabilityRestriction final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.filter_rules.Availability.PerDeviceAvailabilityRestriction) */ {
 public:
  inline Availability_PerDeviceAvailabilityRestriction() : Availability_PerDeviceAvailabilityRestriction(nullptr) {}
  ~Availability_PerDeviceAvailabilityRestriction() override;
  explicit PROTOBUF_CONSTEXPR Availability_PerDeviceAvailabilityRestriction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Availability_PerDeviceAvailabilityRestriction(const Availability_PerDeviceAvailabilityRestriction& from);
  Availability_PerDeviceAvailabilityRestriction(Availability_PerDeviceAvailabilityRestriction&& from) noexcept
    : Availability_PerDeviceAvailabilityRestriction() {
    *this = ::std::move(from);
  }

  inline Availability_PerDeviceAvailabilityRestriction& operator=(const Availability_PerDeviceAvailabilityRestriction& from) {
    CopyFrom(from);
    return *this;
  }
  inline Availability_PerDeviceAvailabilityRestriction& operator=(Availability_PerDeviceAvailabilityRestriction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Availability_PerDeviceAvailabilityRestriction& default_instance() {
    return *internal_default_instance();
  }
  static inline const Availability_PerDeviceAvailabilityRestriction* internal_default_instance() {
    return reinterpret_cast<const Availability_PerDeviceAvailabilityRestriction*>(
               &_Availability_PerDeviceAvailabilityRestriction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Availability_PerDeviceAvailabilityRestriction& a, Availability_PerDeviceAvailabilityRestriction& b) {
    a.Swap(&b);
  }
  inline void Swap(Availability_PerDeviceAvailabilityRestriction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Availability_PerDeviceAvailabilityRestriction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Availability_PerDeviceAvailabilityRestriction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Availability_PerDeviceAvailabilityRestriction>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Availability_PerDeviceAvailabilityRestriction& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Availability_PerDeviceAvailabilityRestriction& from) {
    Availability_PerDeviceAvailabilityRestriction::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Availability_PerDeviceAvailabilityRestriction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.filter_rules.Availability.PerDeviceAvailabilityRestriction";
  }
  protected:
  explicit Availability_PerDeviceAvailabilityRestriction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilterInfoFieldNumber = 15,
    kAndroidIdFieldNumber = 10,
    kChannelIdFieldNumber = 12,
    kDeviceRestrictionFieldNumber = 11,
    kAvailableIfOwnedFieldNumber = 22,
  };
  // optional .playapi.proto.finsky.filter_rules.FilterEvaluationInfo filterInfo = 15;
  bool has_filterinfo() const;
  private:
  bool _internal_has_filterinfo() const;
  public:
  void clear_filterinfo();
  const ::playapi::proto::finsky::filter_rules::FilterEvaluationInfo& filterinfo() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::filter_rules::FilterEvaluationInfo* release_filterinfo();
  ::playapi::proto::finsky::filter_rules::FilterEvaluationInfo* mutable_filterinfo();
  void set_allocated_filterinfo(::playapi::proto::finsky::filter_rules::FilterEvaluationInfo* filterinfo);
  private:
  const ::playapi::proto::finsky::filter_rules::FilterEvaluationInfo& _internal_filterinfo() const;
  ::playapi::proto::finsky::filter_rules::FilterEvaluationInfo* _internal_mutable_filterinfo();
  public:
  void unsafe_arena_set_allocated_filterinfo(
      ::playapi::proto::finsky::filter_rules::FilterEvaluationInfo* filterinfo);
  ::playapi::proto::finsky::filter_rules::FilterEvaluationInfo* unsafe_arena_release_filterinfo();

  // optional fixed64 androidId = 10;
  bool has_androidid() const;
  private:
  bool _internal_has_androidid() const;
  public:
  void clear_androidid();
  uint64_t androidid() const;
  void set_androidid(uint64_t value);
  private:
  uint64_t _internal_androidid() const;
  void _internal_set_androidid(uint64_t value);
  public:

  // optional int64 channelId = 12;
  bool has_channelid() const;
  private:
  bool _internal_has_channelid() const;
  public:
  void clear_channelid();
  int64_t channelid() const;
  void set_channelid(int64_t value);
  private:
  int64_t _internal_channelid() const;
  void _internal_set_channelid(int64_t value);
  public:

  // optional int32 deviceRestriction = 11;
  bool has_devicerestriction() const;
  private:
  bool _internal_has_devicerestriction() const;
  public:
  void clear_devicerestriction();
  int32_t devicerestriction() const;
  void set_devicerestriction(int32_t value);
  private:
  int32_t _internal_devicerestriction() const;
  void _internal_set_devicerestriction(int32_t value);
  public:

  // optional bool availableIfOwned = 22;
  bool has_availableifowned() const;
  private:
  bool _internal_has_availableifowned() const;
  public:
  void clear_availableifowned();
  bool availableifowned() const;
  void set_availableifowned(bool value);
  private:
  bool _internal_availableifowned() const;
  void _internal_set_availableifowned(bool value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.filter_rules.Availability.PerDeviceAvailabilityRestriction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::playapi::proto::finsky::filter_rules::FilterEvaluationInfo* filterinfo_;
    uint64_t androidid_;
    int64_t channelid_;
    int32_t devicerestriction_;
    bool availableifowned_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5ffilter_5frules_2eproto;
};
// -------------------------------------------------------------------

class Availability final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.filter_rules.Availability) */ {
 public:
  inline Availability() : Availability(nullptr) {}
  ~Availability() override;
  explicit PROTOBUF_CONSTEXPR Availability(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Availability(const Availability& from);
  Availability(Availability&& from) noexcept
    : Availability() {
    *this = ::std::move(from);
  }

  inline Availability& operator=(const Availability& from) {
    CopyFrom(from);
    return *this;
  }
  inline Availability& operator=(Availability&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Availability& default_instance() {
    return *internal_default_instance();
  }
  static inline const Availability* internal_default_instance() {
    return reinterpret_cast<const Availability*>(
               &_Availability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Availability& a, Availability& b) {
    a.Swap(&b);
  }
  inline void Swap(Availability* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Availability* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Availability* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Availability>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Availability& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Availability& from) {
    Availability::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Availability* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.filter_rules.Availability";
  }
  protected:
  explicit Availability(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Availability_PerDeviceAvailabilityRestriction PerDeviceAvailabilityRestriction;

  // accessors -------------------------------------------------------

  enum : int {
    kPerdeviceavailabilityrestrictionFieldNumber = 9,
    kInstallFieldNumber = 14,
    kAvailabilityProblemFieldNumber = 18,
    kRuleFieldNumber = 7,
    kFilterInfoFieldNumber = 16,
    kOwnershipInfoFieldNumber = 17,
    kRestrictionFieldNumber = 5,
    kOfferTypeFieldNumber = 6,
    kAvailableIfOwnedFieldNumber = 13,
    kHiddenFieldNumber = 21,
  };
  // repeated group PerDeviceAvailabilityRestriction = 9 { ... };
  int perdeviceavailabilityrestriction_size() const;
  private:
  int _internal_perdeviceavailabilityrestriction_size() const;
  public:
  void clear_perdeviceavailabilityrestriction();
  ::playapi::proto::finsky::filter_rules::Availability_PerDeviceAvailabilityRestriction* mutable_perdeviceavailabilityrestriction(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::filter_rules::Availability_PerDeviceAvailabilityRestriction >*
      mutable_perdeviceavailabilityrestriction();
  private:
  const ::playapi::proto::finsky::filter_rules::Availability_PerDeviceAvailabilityRestriction& _internal_perdeviceavailabilityrestriction(int index) const;
  ::playapi::proto::finsky::filter_rules::Availability_PerDeviceAvailabilityRestriction* _internal_add_perdeviceavailabilityrestriction();
  public:
  const ::playapi::proto::finsky::filter_rules::Availability_PerDeviceAvailabilityRestriction& perdeviceavailabilityrestriction(int index) const;
  ::playapi::proto::finsky::filter_rules::Availability_PerDeviceAvailabilityRestriction* add_perdeviceavailabilityrestriction();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::filter_rules::Availability_PerDeviceAvailabilityRestriction >&
      perdeviceavailabilityrestriction() const;

  // repeated .playapi.proto.finsky.download.Install install = 14;
  int install_size() const;
  private:
  int _internal_install_size() const;
  public:
  void clear_install();
  ::playapi::proto::finsky::download::Install* mutable_install(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::download::Install >*
      mutable_install();
  private:
  const ::playapi::proto::finsky::download::Install& _internal_install(int index) const;
  ::playapi::proto::finsky::download::Install* _internal_add_install();
  public:
  const ::playapi::proto::finsky::download::Install& install(int index) const;
  ::playapi::proto::finsky::download::Install* add_install();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::download::Install >&
      install() const;

  // repeated .playapi.proto.finsky.filter_rules.AvailabilityProblem availabilityProblem = 18;
  int availabilityproblem_size() const;
  private:
  int _internal_availabilityproblem_size() const;
  public:
  void clear_availabilityproblem();
  ::playapi::proto::finsky::filter_rules::AvailabilityProblem* mutable_availabilityproblem(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::filter_rules::AvailabilityProblem >*
      mutable_availabilityproblem();
  private:
  const ::playapi::proto::finsky::filter_rules::AvailabilityProblem& _internal_availabilityproblem(int index) const;
  ::playapi::proto::finsky::filter_rules::AvailabilityProblem* _internal_add_availabilityproblem();
  public:
  const ::playapi::proto::finsky::filter_rules::AvailabilityProblem& availabilityproblem(int index) const;
  ::playapi::proto::finsky::filter_rules::AvailabilityProblem* add_availabilityproblem();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::filter_rules::AvailabilityProblem >&
      availabilityproblem() const;

  // optional .playapi.proto.finsky.filter_rules.Rule rule = 7;
  bool has_rule() const;
  private:
  bool _internal_has_rule() const;
  public:
  void clear_rule();
  const ::playapi::proto::finsky::filter_rules::Rule& rule() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::filter_rules::Rule* release_rule();
  ::playapi::proto::finsky::filter_rules::Rule* mutable_rule();
  void set_allocated_rule(::playapi::proto::finsky::filter_rules::Rule* rule);
  private:
  const ::playapi::proto::finsky::filter_rules::Rule& _internal_rule() const;
  ::playapi::proto::finsky::filter_rules::Rule* _internal_mutable_rule();
  public:
  void unsafe_arena_set_allocated_rule(
      ::playapi::proto::finsky::filter_rules::Rule* rule);
  ::playapi::proto::finsky::filter_rules::Rule* unsafe_arena_release_rule();

  // optional .playapi.proto.finsky.filter_rules.FilterEvaluationInfo filterInfo = 16;
  bool has_filterinfo() const;
  private:
  bool _internal_has_filterinfo() const;
  public:
  void clear_filterinfo();
  const ::playapi::proto::finsky::filter_rules::FilterEvaluationInfo& filterinfo() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::filter_rules::FilterEvaluationInfo* release_filterinfo();
  ::playapi::proto::finsky::filter_rules::FilterEvaluationInfo* mutable_filterinfo();
  void set_allocated_filterinfo(::playapi::proto::finsky::filter_rules::FilterEvaluationInfo* filterinfo);
  private:
  const ::playapi::proto::finsky::filter_rules::FilterEvaluationInfo& _internal_filterinfo() const;
  ::playapi::proto::finsky::filter_rules::FilterEvaluationInfo* _internal_mutable_filterinfo();
  public:
  void unsafe_arena_set_allocated_filterinfo(
      ::playapi::proto::finsky::filter_rules::FilterEvaluationInfo* filterinfo);
  ::playapi::proto::finsky::filter_rules::FilterEvaluationInfo* unsafe_arena_release_filterinfo();

  // optional .playapi.proto.finsky.OwnershipInfo ownershipInfo = 17;
  bool has_ownershipinfo() const;
  private:
  bool _internal_has_ownershipinfo() const;
  public:
  void clear_ownershipinfo();
  const ::playapi::proto::finsky::OwnershipInfo& ownershipinfo() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::OwnershipInfo* release_ownershipinfo();
  ::playapi::proto::finsky::OwnershipInfo* mutable_ownershipinfo();
  void set_allocated_ownershipinfo(::playapi::proto::finsky::OwnershipInfo* ownershipinfo);
  private:
  const ::playapi::proto::finsky::OwnershipInfo& _internal_ownershipinfo() const;
  ::playapi::proto::finsky::OwnershipInfo* _internal_mutable_ownershipinfo();
  public:
  void unsafe_arena_set_allocated_ownershipinfo(
      ::playapi::proto::finsky::OwnershipInfo* ownershipinfo);
  ::playapi::proto::finsky::OwnershipInfo* unsafe_arena_release_ownershipinfo();

  // optional int32 restriction = 5;
  bool has_restriction() const;
  private:
  bool _internal_has_restriction() const;
  public:
  void clear_restriction();
  int32_t restriction() const;
  void set_restriction(int32_t value);
  private:
  int32_t _internal_restriction() const;
  void _internal_set_restriction(int32_t value);
  public:

  // optional int32 offerType = 6;
  bool has_offertype() const;
  private:
  bool _internal_has_offertype() const;
  public:
  void clear_offertype();
  int32_t offertype() const;
  void set_offertype(int32_t value);
  private:
  int32_t _internal_offertype() const;
  void _internal_set_offertype(int32_t value);
  public:

  // optional bool availableIfOwned = 13;
  bool has_availableifowned() const;
  private:
  bool _internal_has_availableifowned() const;
  public:
  void clear_availableifowned();
  bool availableifowned() const;
  void set_availableifowned(bool value);
  private:
  bool _internal_availableifowned() const;
  void _internal_set_availableifowned(bool value);
  public:

  // optional bool hidden = 21;
  bool has_hidden() const;
  private:
  bool _internal_has_hidden() const;
  public:
  void clear_hidden();
  bool hidden() const;
  void set_hidden(bool value);
  private:
  bool _internal_hidden() const;
  void _internal_set_hidden(bool value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.filter_rules.Availability)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::filter_rules::Availability_PerDeviceAvailabilityRestriction > perdeviceavailabilityrestriction_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::download::Install > install_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::filter_rules::AvailabilityProblem > availabilityproblem_;
    ::playapi::proto::finsky::filter_rules::Rule* rule_;
    ::playapi::proto::finsky::filter_rules::FilterEvaluationInfo* filterinfo_;
    ::playapi::proto::finsky::OwnershipInfo* ownershipinfo_;
    int32_t restriction_;
    int32_t offertype_;
    bool availableifowned_;
    bool hidden_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5ffilter_5frules_2eproto;
};
// -------------------------------------------------------------------

class AvailabilityProblem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.filter_rules.AvailabilityProblem) */ {
 public:
  inline AvailabilityProblem() : AvailabilityProblem(nullptr) {}
  ~AvailabilityProblem() override;
  explicit PROTOBUF_CONSTEXPR AvailabilityProblem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AvailabilityProblem(const AvailabilityProblem& from);
  AvailabilityProblem(AvailabilityProblem&& from) noexcept
    : AvailabilityProblem() {
    *this = ::std::move(from);
  }

  inline AvailabilityProblem& operator=(const AvailabilityProblem& from) {
    CopyFrom(from);
    return *this;
  }
  inline AvailabilityProblem& operator=(AvailabilityProblem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AvailabilityProblem& default_instance() {
    return *internal_default_instance();
  }
  static inline const AvailabilityProblem* internal_default_instance() {
    return reinterpret_cast<const AvailabilityProblem*>(
               &_AvailabilityProblem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AvailabilityProblem& a, AvailabilityProblem& b) {
    a.Swap(&b);
  }
  inline void Swap(AvailabilityProblem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AvailabilityProblem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AvailabilityProblem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AvailabilityProblem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AvailabilityProblem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AvailabilityProblem& from) {
    AvailabilityProblem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AvailabilityProblem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.filter_rules.AvailabilityProblem";
  }
  protected:
  explicit AvailabilityProblem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMissingValueFieldNumber = 2,
    kProblemTypeFieldNumber = 1,
  };
  // repeated string missingValue = 2;
  int missingvalue_size() const;
  private:
  int _internal_missingvalue_size() const;
  public:
  void clear_missingvalue();
  const std::string& missingvalue(int index) const;
  std::string* mutable_missingvalue(int index);
  void set_missingvalue(int index, const std::string& value);
  void set_missingvalue(int index, std::string&& value);
  void set_missingvalue(int index, const char* value);
  void set_missingvalue(int index, const char* value, size_t size);
  std::string* add_missingvalue();
  void add_missingvalue(const std::string& value);
  void add_missingvalue(std::string&& value);
  void add_missingvalue(const char* value);
  void add_missingvalue(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& missingvalue() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_missingvalue();
  private:
  const std::string& _internal_missingvalue(int index) const;
  std::string* _internal_add_missingvalue();
  public:

  // optional int32 problemType = 1;
  bool has_problemtype() const;
  private:
  bool _internal_has_problemtype() const;
  public:
  void clear_problemtype();
  int32_t problemtype() const;
  void set_problemtype(int32_t value);
  private:
  int32_t _internal_problemtype() const;
  void _internal_set_problemtype(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.filter_rules.AvailabilityProblem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> missingvalue_;
    int32_t problemtype_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5ffilter_5frules_2eproto;
};
// -------------------------------------------------------------------

class FilterEvaluationInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.filter_rules.FilterEvaluationInfo) */ {
 public:
  inline FilterEvaluationInfo() : FilterEvaluationInfo(nullptr) {}
  ~FilterEvaluationInfo() override;
  explicit PROTOBUF_CONSTEXPR FilterEvaluationInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FilterEvaluationInfo(const FilterEvaluationInfo& from);
  FilterEvaluationInfo(FilterEvaluationInfo&& from) noexcept
    : FilterEvaluationInfo() {
    *this = ::std::move(from);
  }

  inline FilterEvaluationInfo& operator=(const FilterEvaluationInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline FilterEvaluationInfo& operator=(FilterEvaluationInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FilterEvaluationInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const FilterEvaluationInfo* internal_default_instance() {
    return reinterpret_cast<const FilterEvaluationInfo*>(
               &_FilterEvaluationInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(FilterEvaluationInfo& a, FilterEvaluationInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(FilterEvaluationInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FilterEvaluationInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FilterEvaluationInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FilterEvaluationInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FilterEvaluationInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FilterEvaluationInfo& from) {
    FilterEvaluationInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FilterEvaluationInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.filter_rules.FilterEvaluationInfo";
  }
  protected:
  explicit FilterEvaluationInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRuleEvaluationFieldNumber = 1,
  };
  // repeated .playapi.proto.finsky.filter_rules.RuleEvaluation ruleEvaluation = 1;
  int ruleevaluation_size() const;
  private:
  int _internal_ruleevaluation_size() const;
  public:
  void clear_ruleevaluation();
  ::playapi::proto::finsky::filter_rules::RuleEvaluation* mutable_ruleevaluation(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::filter_rules::RuleEvaluation >*
      mutable_ruleevaluation();
  private:
  const ::playapi::proto::finsky::filter_rules::RuleEvaluation& _internal_ruleevaluation(int index) const;
  ::playapi::proto::finsky::filter_rules::RuleEvaluation* _internal_add_ruleevaluation();
  public:
  const ::playapi::proto::finsky::filter_rules::RuleEvaluation& ruleevaluation(int index) const;
  ::playapi::proto::finsky::filter_rules::RuleEvaluation* add_ruleevaluation();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::filter_rules::RuleEvaluation >&
      ruleevaluation() const;

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.filter_rules.FilterEvaluationInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::filter_rules::RuleEvaluation > ruleevaluation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5ffilter_5frules_2eproto;
};
// -------------------------------------------------------------------

class Rule final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.filter_rules.Rule) */ {
 public:
  inline Rule() : Rule(nullptr) {}
  ~Rule() override;
  explicit PROTOBUF_CONSTEXPR Rule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Rule(const Rule& from);
  Rule(Rule&& from) noexcept
    : Rule() {
    *this = ::std::move(from);
  }

  inline Rule& operator=(const Rule& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rule& operator=(Rule&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rule& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rule* internal_default_instance() {
    return reinterpret_cast<const Rule*>(
               &_Rule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Rule& a, Rule& b) {
    a.Swap(&b);
  }
  inline void Swap(Rule* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rule* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rule>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Rule& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Rule& from) {
    Rule::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Rule* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.filter_rules.Rule";
  }
  protected:
  explicit Rule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStringArgFieldNumber = 4,
    kLongArgFieldNumber = 5,
    kDoubleArgFieldNumber = 6,
    kSubruleFieldNumber = 7,
    kStringArgHashFieldNumber = 10,
    kCommentFieldNumber = 9,
    kOperatorFieldNumber = 2,
    kKeyFieldNumber = 3,
    kNegateFieldNumber = 1,
    kIncludeMissingValuesFieldNumber = 13,
    kResponseCodeFieldNumber = 8,
    kAvailabilityProblemTypeFieldNumber = 12,
  };
  // repeated string stringArg = 4;
  int stringarg_size() const;
  private:
  int _internal_stringarg_size() const;
  public:
  void clear_stringarg();
  const std::string& stringarg(int index) const;
  std::string* mutable_stringarg(int index);
  void set_stringarg(int index, const std::string& value);
  void set_stringarg(int index, std::string&& value);
  void set_stringarg(int index, const char* value);
  void set_stringarg(int index, const char* value, size_t size);
  std::string* add_stringarg();
  void add_stringarg(const std::string& value);
  void add_stringarg(std::string&& value);
  void add_stringarg(const char* value);
  void add_stringarg(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& stringarg() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_stringarg();
  private:
  const std::string& _internal_stringarg(int index) const;
  std::string* _internal_add_stringarg();
  public:

  // repeated int64 longArg = 5;
  int longarg_size() const;
  private:
  int _internal_longarg_size() const;
  public:
  void clear_longarg();
  private:
  int64_t _internal_longarg(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_longarg() const;
  void _internal_add_longarg(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_longarg();
  public:
  int64_t longarg(int index) const;
  void set_longarg(int index, int64_t value);
  void add_longarg(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      longarg() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_longarg();

  // repeated double doubleArg = 6;
  int doublearg_size() const;
  private:
  int _internal_doublearg_size() const;
  public:
  void clear_doublearg();
  private:
  double _internal_doublearg(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_doublearg() const;
  void _internal_add_doublearg(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_doublearg();
  public:
  double doublearg(int index) const;
  void set_doublearg(int index, double value);
  void add_doublearg(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      doublearg() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_doublearg();

  // repeated .playapi.proto.finsky.filter_rules.Rule subrule = 7;
  int subrule_size() const;
  private:
  int _internal_subrule_size() const;
  public:
  void clear_subrule();
  ::playapi::proto::finsky::filter_rules::Rule* mutable_subrule(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::filter_rules::Rule >*
      mutable_subrule();
  private:
  const ::playapi::proto::finsky::filter_rules::Rule& _internal_subrule(int index) const;
  ::playapi::proto::finsky::filter_rules::Rule* _internal_add_subrule();
  public:
  const ::playapi::proto::finsky::filter_rules::Rule& subrule(int index) const;
  ::playapi::proto::finsky::filter_rules::Rule* add_subrule();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::filter_rules::Rule >&
      subrule() const;

  // repeated fixed64 stringArgHash = 10;
  int stringarghash_size() const;
  private:
  int _internal_stringarghash_size() const;
  public:
  void clear_stringarghash();
  private:
  uint64_t _internal_stringarghash(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_stringarghash() const;
  void _internal_add_stringarghash(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_stringarghash();
  public:
  uint64_t stringarghash(int index) const;
  void set_stringarghash(int index, uint64_t value);
  void add_stringarghash(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      stringarghash() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_stringarghash();

  // optional string comment = 9;
  bool has_comment() const;
  private:
  bool _internal_has_comment() const;
  public:
  void clear_comment();
  const std::string& comment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comment();
  PROTOBUF_NODISCARD std::string* release_comment();
  void set_allocated_comment(std::string* comment);
  private:
  const std::string& _internal_comment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment(const std::string& value);
  std::string* _internal_mutable_comment();
  public:

  // optional int32 operator = 2;
  bool has_operator_() const;
  private:
  bool _internal_has_operator_() const;
  public:
  void clear_operator_();
  int32_t operator_() const;
  void set_operator_(int32_t value);
  private:
  int32_t _internal_operator_() const;
  void _internal_set_operator_(int32_t value);
  public:

  // optional int32 key = 3;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  int32_t key() const;
  void set_key(int32_t value);
  private:
  int32_t _internal_key() const;
  void _internal_set_key(int32_t value);
  public:

  // optional bool negate = 1;
  bool has_negate() const;
  private:
  bool _internal_has_negate() const;
  public:
  void clear_negate();
  bool negate() const;
  void set_negate(bool value);
  private:
  bool _internal_negate() const;
  void _internal_set_negate(bool value);
  public:

  // optional bool includeMissingValues = 13;
  bool has_includemissingvalues() const;
  private:
  bool _internal_has_includemissingvalues() const;
  public:
  void clear_includemissingvalues();
  bool includemissingvalues() const;
  void set_includemissingvalues(bool value);
  private:
  bool _internal_includemissingvalues() const;
  void _internal_set_includemissingvalues(bool value);
  public:

  // optional int32 responseCode = 8;
  bool has_responsecode() const;
  private:
  bool _internal_has_responsecode() const;
  public:
  void clear_responsecode();
  int32_t responsecode() const;
  void set_responsecode(int32_t value);
  private:
  int32_t _internal_responsecode() const;
  void _internal_set_responsecode(int32_t value);
  public:

  // optional int32 availabilityProblemType = 12;
  bool has_availabilityproblemtype() const;
  private:
  bool _internal_has_availabilityproblemtype() const;
  public:
  void clear_availabilityproblemtype();
  int32_t availabilityproblemtype() const;
  void set_availabilityproblemtype(int32_t value);
  private:
  int32_t _internal_availabilityproblemtype() const;
  void _internal_set_availabilityproblemtype(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.filter_rules.Rule)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> stringarg_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > longarg_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > doublearg_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::filter_rules::Rule > subrule_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > stringarghash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment_;
    int32_t operator__;
    int32_t key_;
    bool negate_;
    bool includemissingvalues_;
    int32_t responsecode_;
    int32_t availabilityproblemtype_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5ffilter_5frules_2eproto;
};
// -------------------------------------------------------------------

class RuleEvaluation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.filter_rules.RuleEvaluation) */ {
 public:
  inline RuleEvaluation() : RuleEvaluation(nullptr) {}
  ~RuleEvaluation() override;
  explicit PROTOBUF_CONSTEXPR RuleEvaluation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RuleEvaluation(const RuleEvaluation& from);
  RuleEvaluation(RuleEvaluation&& from) noexcept
    : RuleEvaluation() {
    *this = ::std::move(from);
  }

  inline RuleEvaluation& operator=(const RuleEvaluation& from) {
    CopyFrom(from);
    return *this;
  }
  inline RuleEvaluation& operator=(RuleEvaluation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RuleEvaluation& default_instance() {
    return *internal_default_instance();
  }
  static inline const RuleEvaluation* internal_default_instance() {
    return reinterpret_cast<const RuleEvaluation*>(
               &_RuleEvaluation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RuleEvaluation& a, RuleEvaluation& b) {
    a.Swap(&b);
  }
  inline void Swap(RuleEvaluation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RuleEvaluation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RuleEvaluation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RuleEvaluation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RuleEvaluation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RuleEvaluation& from) {
    RuleEvaluation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RuleEvaluation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.filter_rules.RuleEvaluation";
  }
  protected:
  explicit RuleEvaluation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActualStringValueFieldNumber = 2,
    kActualLongValueFieldNumber = 3,
    kActualBoolValueFieldNumber = 4,
    kActualDoubleValueFieldNumber = 5,
    kRuleFieldNumber = 1,
  };
  // repeated string actualStringValue = 2;
  int actualstringvalue_size() const;
  private:
  int _internal_actualstringvalue_size() const;
  public:
  void clear_actualstringvalue();
  const std::string& actualstringvalue(int index) const;
  std::string* mutable_actualstringvalue(int index);
  void set_actualstringvalue(int index, const std::string& value);
  void set_actualstringvalue(int index, std::string&& value);
  void set_actualstringvalue(int index, const char* value);
  void set_actualstringvalue(int index, const char* value, size_t size);
  std::string* add_actualstringvalue();
  void add_actualstringvalue(const std::string& value);
  void add_actualstringvalue(std::string&& value);
  void add_actualstringvalue(const char* value);
  void add_actualstringvalue(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& actualstringvalue() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_actualstringvalue();
  private:
  const std::string& _internal_actualstringvalue(int index) const;
  std::string* _internal_add_actualstringvalue();
  public:

  // repeated int64 actualLongValue = 3;
  int actuallongvalue_size() const;
  private:
  int _internal_actuallongvalue_size() const;
  public:
  void clear_actuallongvalue();
  private:
  int64_t _internal_actuallongvalue(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_actuallongvalue() const;
  void _internal_add_actuallongvalue(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_actuallongvalue();
  public:
  int64_t actuallongvalue(int index) const;
  void set_actuallongvalue(int index, int64_t value);
  void add_actuallongvalue(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      actuallongvalue() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_actuallongvalue();

  // repeated bool actualBoolValue = 4;
  int actualboolvalue_size() const;
  private:
  int _internal_actualboolvalue_size() const;
  public:
  void clear_actualboolvalue();
  private:
  bool _internal_actualboolvalue(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      _internal_actualboolvalue() const;
  void _internal_add_actualboolvalue(bool value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      _internal_mutable_actualboolvalue();
  public:
  bool actualboolvalue(int index) const;
  void set_actualboolvalue(int index, bool value);
  void add_actualboolvalue(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      actualboolvalue() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      mutable_actualboolvalue();

  // repeated double actualDoubleValue = 5;
  int actualdoublevalue_size() const;
  private:
  int _internal_actualdoublevalue_size() const;
  public:
  void clear_actualdoublevalue();
  private:
  double _internal_actualdoublevalue(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_actualdoublevalue() const;
  void _internal_add_actualdoublevalue(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_actualdoublevalue();
  public:
  double actualdoublevalue(int index) const;
  void set_actualdoublevalue(int index, double value);
  void add_actualdoublevalue(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      actualdoublevalue() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_actualdoublevalue();

  // optional .playapi.proto.finsky.filter_rules.Rule rule = 1;
  bool has_rule() const;
  private:
  bool _internal_has_rule() const;
  public:
  void clear_rule();
  const ::playapi::proto::finsky::filter_rules::Rule& rule() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::filter_rules::Rule* release_rule();
  ::playapi::proto::finsky::filter_rules::Rule* mutable_rule();
  void set_allocated_rule(::playapi::proto::finsky::filter_rules::Rule* rule);
  private:
  const ::playapi::proto::finsky::filter_rules::Rule& _internal_rule() const;
  ::playapi::proto::finsky::filter_rules::Rule* _internal_mutable_rule();
  public:
  void unsafe_arena_set_allocated_rule(
      ::playapi::proto::finsky::filter_rules::Rule* rule);
  ::playapi::proto::finsky::filter_rules::Rule* unsafe_arena_release_rule();

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.filter_rules.RuleEvaluation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> actualstringvalue_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > actuallongvalue_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool > actualboolvalue_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > actualdoublevalue_;
    ::playapi::proto::finsky::filter_rules::Rule* rule_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5ffilter_5frules_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Availability_PerDeviceAvailabilityRestriction

// optional fixed64 androidId = 10;
inline bool Availability_PerDeviceAvailabilityRestriction::_internal_has_androidid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Availability_PerDeviceAvailabilityRestriction::has_androidid() const {
  return _internal_has_androidid();
}
inline void Availability_PerDeviceAvailabilityRestriction::clear_androidid() {
  _impl_.androidid_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t Availability_PerDeviceAvailabilityRestriction::_internal_androidid() const {
  return _impl_.androidid_;
}
inline uint64_t Availability_PerDeviceAvailabilityRestriction::androidid() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.filter_rules.Availability.PerDeviceAvailabilityRestriction.androidId)
  return _internal_androidid();
}
inline void Availability_PerDeviceAvailabilityRestriction::_internal_set_androidid(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.androidid_ = value;
}
inline void Availability_PerDeviceAvailabilityRestriction::set_androidid(uint64_t value) {
  _internal_set_androidid(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.filter_rules.Availability.PerDeviceAvailabilityRestriction.androidId)
}

// optional int32 deviceRestriction = 11;
inline bool Availability_PerDeviceAvailabilityRestriction::_internal_has_devicerestriction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Availability_PerDeviceAvailabilityRestriction::has_devicerestriction() const {
  return _internal_has_devicerestriction();
}
inline void Availability_PerDeviceAvailabilityRestriction::clear_devicerestriction() {
  _impl_.devicerestriction_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t Availability_PerDeviceAvailabilityRestriction::_internal_devicerestriction() const {
  return _impl_.devicerestriction_;
}
inline int32_t Availability_PerDeviceAvailabilityRestriction::devicerestriction() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.filter_rules.Availability.PerDeviceAvailabilityRestriction.deviceRestriction)
  return _internal_devicerestriction();
}
inline void Availability_PerDeviceAvailabilityRestriction::_internal_set_devicerestriction(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.devicerestriction_ = value;
}
inline void Availability_PerDeviceAvailabilityRestriction::set_devicerestriction(int32_t value) {
  _internal_set_devicerestriction(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.filter_rules.Availability.PerDeviceAvailabilityRestriction.deviceRestriction)
}

// optional int64 channelId = 12;
inline bool Availability_PerDeviceAvailabilityRestriction::_internal_has_channelid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Availability_PerDeviceAvailabilityRestriction::has_channelid() const {
  return _internal_has_channelid();
}
inline void Availability_PerDeviceAvailabilityRestriction::clear_channelid() {
  _impl_.channelid_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t Availability_PerDeviceAvailabilityRestriction::_internal_channelid() const {
  return _impl_.channelid_;
}
inline int64_t Availability_PerDeviceAvailabilityRestriction::channelid() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.filter_rules.Availability.PerDeviceAvailabilityRestriction.channelId)
  return _internal_channelid();
}
inline void Availability_PerDeviceAvailabilityRestriction::_internal_set_channelid(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.channelid_ = value;
}
inline void Availability_PerDeviceAvailabilityRestriction::set_channelid(int64_t value) {
  _internal_set_channelid(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.filter_rules.Availability.PerDeviceAvailabilityRestriction.channelId)
}

// optional .playapi.proto.finsky.filter_rules.FilterEvaluationInfo filterInfo = 15;
inline bool Availability_PerDeviceAvailabilityRestriction::_internal_has_filterinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.filterinfo_ != nullptr);
  return value;
}
inline bool Availability_PerDeviceAvailabilityRestriction::has_filterinfo() const {
  return _internal_has_filterinfo();
}
inline void Availability_PerDeviceAvailabilityRestriction::clear_filterinfo() {
  if (_impl_.filterinfo_ != nullptr) _impl_.filterinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::playapi::proto::finsky::filter_rules::FilterEvaluationInfo& Availability_PerDeviceAvailabilityRestriction::_internal_filterinfo() const {
  const ::playapi::proto::finsky::filter_rules::FilterEvaluationInfo* p = _impl_.filterinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::filter_rules::FilterEvaluationInfo&>(
      ::playapi::proto::finsky::filter_rules::_FilterEvaluationInfo_default_instance_);
}
inline const ::playapi::proto::finsky::filter_rules::FilterEvaluationInfo& Availability_PerDeviceAvailabilityRestriction::filterinfo() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.filter_rules.Availability.PerDeviceAvailabilityRestriction.filterInfo)
  return _internal_filterinfo();
}
inline void Availability_PerDeviceAvailabilityRestriction::unsafe_arena_set_allocated_filterinfo(
    ::playapi::proto::finsky::filter_rules::FilterEvaluationInfo* filterinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.filterinfo_);
  }
  _impl_.filterinfo_ = filterinfo;
  if (filterinfo) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.filter_rules.Availability.PerDeviceAvailabilityRestriction.filterInfo)
}
inline ::playapi::proto::finsky::filter_rules::FilterEvaluationInfo* Availability_PerDeviceAvailabilityRestriction::release_filterinfo() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::playapi::proto::finsky::filter_rules::FilterEvaluationInfo* temp = _impl_.filterinfo_;
  _impl_.filterinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::filter_rules::FilterEvaluationInfo* Availability_PerDeviceAvailabilityRestriction::unsafe_arena_release_filterinfo() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.filter_rules.Availability.PerDeviceAvailabilityRestriction.filterInfo)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::playapi::proto::finsky::filter_rules::FilterEvaluationInfo* temp = _impl_.filterinfo_;
  _impl_.filterinfo_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::filter_rules::FilterEvaluationInfo* Availability_PerDeviceAvailabilityRestriction::_internal_mutable_filterinfo() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.filterinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::filter_rules::FilterEvaluationInfo>(GetArenaForAllocation());
    _impl_.filterinfo_ = p;
  }
  return _impl_.filterinfo_;
}
inline ::playapi::proto::finsky::filter_rules::FilterEvaluationInfo* Availability_PerDeviceAvailabilityRestriction::mutable_filterinfo() {
  ::playapi::proto::finsky::filter_rules::FilterEvaluationInfo* _msg = _internal_mutable_filterinfo();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.filter_rules.Availability.PerDeviceAvailabilityRestriction.filterInfo)
  return _msg;
}
inline void Availability_PerDeviceAvailabilityRestriction::set_allocated_filterinfo(::playapi::proto::finsky::filter_rules::FilterEvaluationInfo* filterinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.filterinfo_;
  }
  if (filterinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(filterinfo);
    if (message_arena != submessage_arena) {
      filterinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, filterinfo, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.filterinfo_ = filterinfo;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.filter_rules.Availability.PerDeviceAvailabilityRestriction.filterInfo)
}

// optional bool availableIfOwned = 22;
inline bool Availability_PerDeviceAvailabilityRestriction::_internal_has_availableifowned() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Availability_PerDeviceAvailabilityRestriction::has_availableifowned() const {
  return _internal_has_availableifowned();
}
inline void Availability_PerDeviceAvailabilityRestriction::clear_availableifowned() {
  _impl_.availableifowned_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool Availability_PerDeviceAvailabilityRestriction::_internal_availableifowned() const {
  return _impl_.availableifowned_;
}
inline bool Availability_PerDeviceAvailabilityRestriction::availableifowned() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.filter_rules.Availability.PerDeviceAvailabilityRestriction.availableIfOwned)
  return _internal_availableifowned();
}
inline void Availability_PerDeviceAvailabilityRestriction::_internal_set_availableifowned(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.availableifowned_ = value;
}
inline void Availability_PerDeviceAvailabilityRestriction::set_availableifowned(bool value) {
  _internal_set_availableifowned(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.filter_rules.Availability.PerDeviceAvailabilityRestriction.availableIfOwned)
}

// -------------------------------------------------------------------

// Availability

// optional int32 restriction = 5;
inline bool Availability::_internal_has_restriction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Availability::has_restriction() const {
  return _internal_has_restriction();
}
inline void Availability::clear_restriction() {
  _impl_.restriction_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t Availability::_internal_restriction() const {
  return _impl_.restriction_;
}
inline int32_t Availability::restriction() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.filter_rules.Availability.restriction)
  return _internal_restriction();
}
inline void Availability::_internal_set_restriction(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.restriction_ = value;
}
inline void Availability::set_restriction(int32_t value) {
  _internal_set_restriction(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.filter_rules.Availability.restriction)
}

// optional int32 offerType = 6;
inline bool Availability::_internal_has_offertype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Availability::has_offertype() const {
  return _internal_has_offertype();
}
inline void Availability::clear_offertype() {
  _impl_.offertype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t Availability::_internal_offertype() const {
  return _impl_.offertype_;
}
inline int32_t Availability::offertype() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.filter_rules.Availability.offerType)
  return _internal_offertype();
}
inline void Availability::_internal_set_offertype(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.offertype_ = value;
}
inline void Availability::set_offertype(int32_t value) {
  _internal_set_offertype(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.filter_rules.Availability.offerType)
}

// optional .playapi.proto.finsky.filter_rules.Rule rule = 7;
inline bool Availability::_internal_has_rule() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rule_ != nullptr);
  return value;
}
inline bool Availability::has_rule() const {
  return _internal_has_rule();
}
inline void Availability::clear_rule() {
  if (_impl_.rule_ != nullptr) _impl_.rule_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::playapi::proto::finsky::filter_rules::Rule& Availability::_internal_rule() const {
  const ::playapi::proto::finsky::filter_rules::Rule* p = _impl_.rule_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::filter_rules::Rule&>(
      ::playapi::proto::finsky::filter_rules::_Rule_default_instance_);
}
inline const ::playapi::proto::finsky::filter_rules::Rule& Availability::rule() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.filter_rules.Availability.rule)
  return _internal_rule();
}
inline void Availability::unsafe_arena_set_allocated_rule(
    ::playapi::proto::finsky::filter_rules::Rule* rule) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rule_);
  }
  _impl_.rule_ = rule;
  if (rule) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.filter_rules.Availability.rule)
}
inline ::playapi::proto::finsky::filter_rules::Rule* Availability::release_rule() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::playapi::proto::finsky::filter_rules::Rule* temp = _impl_.rule_;
  _impl_.rule_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::filter_rules::Rule* Availability::unsafe_arena_release_rule() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.filter_rules.Availability.rule)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::playapi::proto::finsky::filter_rules::Rule* temp = _impl_.rule_;
  _impl_.rule_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::filter_rules::Rule* Availability::_internal_mutable_rule() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.rule_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::filter_rules::Rule>(GetArenaForAllocation());
    _impl_.rule_ = p;
  }
  return _impl_.rule_;
}
inline ::playapi::proto::finsky::filter_rules::Rule* Availability::mutable_rule() {
  ::playapi::proto::finsky::filter_rules::Rule* _msg = _internal_mutable_rule();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.filter_rules.Availability.rule)
  return _msg;
}
inline void Availability::set_allocated_rule(::playapi::proto::finsky::filter_rules::Rule* rule) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rule_;
  }
  if (rule) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rule);
    if (message_arena != submessage_arena) {
      rule = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rule, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.rule_ = rule;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.filter_rules.Availability.rule)
}

// repeated group PerDeviceAvailabilityRestriction = 9 { ... };
inline int Availability::_internal_perdeviceavailabilityrestriction_size() const {
  return _impl_.perdeviceavailabilityrestriction_.size();
}
inline int Availability::perdeviceavailabilityrestriction_size() const {
  return _internal_perdeviceavailabilityrestriction_size();
}
inline void Availability::clear_perdeviceavailabilityrestriction() {
  _impl_.perdeviceavailabilityrestriction_.Clear();
}
inline ::playapi::proto::finsky::filter_rules::Availability_PerDeviceAvailabilityRestriction* Availability::mutable_perdeviceavailabilityrestriction(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.filter_rules.Availability.perdeviceavailabilityrestriction)
  return _impl_.perdeviceavailabilityrestriction_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::filter_rules::Availability_PerDeviceAvailabilityRestriction >*
Availability::mutable_perdeviceavailabilityrestriction() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.filter_rules.Availability.perdeviceavailabilityrestriction)
  return &_impl_.perdeviceavailabilityrestriction_;
}
inline const ::playapi::proto::finsky::filter_rules::Availability_PerDeviceAvailabilityRestriction& Availability::_internal_perdeviceavailabilityrestriction(int index) const {
  return _impl_.perdeviceavailabilityrestriction_.Get(index);
}
inline const ::playapi::proto::finsky::filter_rules::Availability_PerDeviceAvailabilityRestriction& Availability::perdeviceavailabilityrestriction(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.filter_rules.Availability.perdeviceavailabilityrestriction)
  return _internal_perdeviceavailabilityrestriction(index);
}
inline ::playapi::proto::finsky::filter_rules::Availability_PerDeviceAvailabilityRestriction* Availability::_internal_add_perdeviceavailabilityrestriction() {
  return _impl_.perdeviceavailabilityrestriction_.Add();
}
inline ::playapi::proto::finsky::filter_rules::Availability_PerDeviceAvailabilityRestriction* Availability::add_perdeviceavailabilityrestriction() {
  ::playapi::proto::finsky::filter_rules::Availability_PerDeviceAvailabilityRestriction* _add = _internal_add_perdeviceavailabilityrestriction();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.filter_rules.Availability.perdeviceavailabilityrestriction)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::filter_rules::Availability_PerDeviceAvailabilityRestriction >&
Availability::perdeviceavailabilityrestriction() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.filter_rules.Availability.perdeviceavailabilityrestriction)
  return _impl_.perdeviceavailabilityrestriction_;
}

// optional bool availableIfOwned = 13;
inline bool Availability::_internal_has_availableifowned() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Availability::has_availableifowned() const {
  return _internal_has_availableifowned();
}
inline void Availability::clear_availableifowned() {
  _impl_.availableifowned_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool Availability::_internal_availableifowned() const {
  return _impl_.availableifowned_;
}
inline bool Availability::availableifowned() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.filter_rules.Availability.availableIfOwned)
  return _internal_availableifowned();
}
inline void Availability::_internal_set_availableifowned(bool value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.availableifowned_ = value;
}
inline void Availability::set_availableifowned(bool value) {
  _internal_set_availableifowned(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.filter_rules.Availability.availableIfOwned)
}

// repeated .playapi.proto.finsky.download.Install install = 14;
inline int Availability::_internal_install_size() const {
  return _impl_.install_.size();
}
inline int Availability::install_size() const {
  return _internal_install_size();
}
inline ::playapi::proto::finsky::download::Install* Availability::mutable_install(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.filter_rules.Availability.install)
  return _impl_.install_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::download::Install >*
Availability::mutable_install() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.filter_rules.Availability.install)
  return &_impl_.install_;
}
inline const ::playapi::proto::finsky::download::Install& Availability::_internal_install(int index) const {
  return _impl_.install_.Get(index);
}
inline const ::playapi::proto::finsky::download::Install& Availability::install(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.filter_rules.Availability.install)
  return _internal_install(index);
}
inline ::playapi::proto::finsky::download::Install* Availability::_internal_add_install() {
  return _impl_.install_.Add();
}
inline ::playapi::proto::finsky::download::Install* Availability::add_install() {
  ::playapi::proto::finsky::download::Install* _add = _internal_add_install();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.filter_rules.Availability.install)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::download::Install >&
Availability::install() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.filter_rules.Availability.install)
  return _impl_.install_;
}

// optional .playapi.proto.finsky.filter_rules.FilterEvaluationInfo filterInfo = 16;
inline bool Availability::_internal_has_filterinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.filterinfo_ != nullptr);
  return value;
}
inline bool Availability::has_filterinfo() const {
  return _internal_has_filterinfo();
}
inline void Availability::clear_filterinfo() {
  if (_impl_.filterinfo_ != nullptr) _impl_.filterinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::playapi::proto::finsky::filter_rules::FilterEvaluationInfo& Availability::_internal_filterinfo() const {
  const ::playapi::proto::finsky::filter_rules::FilterEvaluationInfo* p = _impl_.filterinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::filter_rules::FilterEvaluationInfo&>(
      ::playapi::proto::finsky::filter_rules::_FilterEvaluationInfo_default_instance_);
}
inline const ::playapi::proto::finsky::filter_rules::FilterEvaluationInfo& Availability::filterinfo() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.filter_rules.Availability.filterInfo)
  return _internal_filterinfo();
}
inline void Availability::unsafe_arena_set_allocated_filterinfo(
    ::playapi::proto::finsky::filter_rules::FilterEvaluationInfo* filterinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.filterinfo_);
  }
  _impl_.filterinfo_ = filterinfo;
  if (filterinfo) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.filter_rules.Availability.filterInfo)
}
inline ::playapi::proto::finsky::filter_rules::FilterEvaluationInfo* Availability::release_filterinfo() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::playapi::proto::finsky::filter_rules::FilterEvaluationInfo* temp = _impl_.filterinfo_;
  _impl_.filterinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::filter_rules::FilterEvaluationInfo* Availability::unsafe_arena_release_filterinfo() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.filter_rules.Availability.filterInfo)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::playapi::proto::finsky::filter_rules::FilterEvaluationInfo* temp = _impl_.filterinfo_;
  _impl_.filterinfo_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::filter_rules::FilterEvaluationInfo* Availability::_internal_mutable_filterinfo() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.filterinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::filter_rules::FilterEvaluationInfo>(GetArenaForAllocation());
    _impl_.filterinfo_ = p;
  }
  return _impl_.filterinfo_;
}
inline ::playapi::proto::finsky::filter_rules::FilterEvaluationInfo* Availability::mutable_filterinfo() {
  ::playapi::proto::finsky::filter_rules::FilterEvaluationInfo* _msg = _internal_mutable_filterinfo();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.filter_rules.Availability.filterInfo)
  return _msg;
}
inline void Availability::set_allocated_filterinfo(::playapi::proto::finsky::filter_rules::FilterEvaluationInfo* filterinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.filterinfo_;
  }
  if (filterinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(filterinfo);
    if (message_arena != submessage_arena) {
      filterinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, filterinfo, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.filterinfo_ = filterinfo;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.filter_rules.Availability.filterInfo)
}

// optional .playapi.proto.finsky.OwnershipInfo ownershipInfo = 17;
inline bool Availability::_internal_has_ownershipinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ownershipinfo_ != nullptr);
  return value;
}
inline bool Availability::has_ownershipinfo() const {
  return _internal_has_ownershipinfo();
}
inline const ::playapi::proto::finsky::OwnershipInfo& Availability::_internal_ownershipinfo() const {
  const ::playapi::proto::finsky::OwnershipInfo* p = _impl_.ownershipinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::OwnershipInfo&>(
      ::playapi::proto::finsky::_OwnershipInfo_default_instance_);
}
inline const ::playapi::proto::finsky::OwnershipInfo& Availability::ownershipinfo() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.filter_rules.Availability.ownershipInfo)
  return _internal_ownershipinfo();
}
inline void Availability::unsafe_arena_set_allocated_ownershipinfo(
    ::playapi::proto::finsky::OwnershipInfo* ownershipinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ownershipinfo_);
  }
  _impl_.ownershipinfo_ = ownershipinfo;
  if (ownershipinfo) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.filter_rules.Availability.ownershipInfo)
}
inline ::playapi::proto::finsky::OwnershipInfo* Availability::release_ownershipinfo() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::playapi::proto::finsky::OwnershipInfo* temp = _impl_.ownershipinfo_;
  _impl_.ownershipinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::OwnershipInfo* Availability::unsafe_arena_release_ownershipinfo() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.filter_rules.Availability.ownershipInfo)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::playapi::proto::finsky::OwnershipInfo* temp = _impl_.ownershipinfo_;
  _impl_.ownershipinfo_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::OwnershipInfo* Availability::_internal_mutable_ownershipinfo() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.ownershipinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::OwnershipInfo>(GetArenaForAllocation());
    _impl_.ownershipinfo_ = p;
  }
  return _impl_.ownershipinfo_;
}
inline ::playapi::proto::finsky::OwnershipInfo* Availability::mutable_ownershipinfo() {
  ::playapi::proto::finsky::OwnershipInfo* _msg = _internal_mutable_ownershipinfo();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.filter_rules.Availability.ownershipInfo)
  return _msg;
}
inline void Availability::set_allocated_ownershipinfo(::playapi::proto::finsky::OwnershipInfo* ownershipinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ownershipinfo_);
  }
  if (ownershipinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ownershipinfo));
    if (message_arena != submessage_arena) {
      ownershipinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ownershipinfo, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.ownershipinfo_ = ownershipinfo;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.filter_rules.Availability.ownershipInfo)
}

// repeated .playapi.proto.finsky.filter_rules.AvailabilityProblem availabilityProblem = 18;
inline int Availability::_internal_availabilityproblem_size() const {
  return _impl_.availabilityproblem_.size();
}
inline int Availability::availabilityproblem_size() const {
  return _internal_availabilityproblem_size();
}
inline void Availability::clear_availabilityproblem() {
  _impl_.availabilityproblem_.Clear();
}
inline ::playapi::proto::finsky::filter_rules::AvailabilityProblem* Availability::mutable_availabilityproblem(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.filter_rules.Availability.availabilityProblem)
  return _impl_.availabilityproblem_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::filter_rules::AvailabilityProblem >*
Availability::mutable_availabilityproblem() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.filter_rules.Availability.availabilityProblem)
  return &_impl_.availabilityproblem_;
}
inline const ::playapi::proto::finsky::filter_rules::AvailabilityProblem& Availability::_internal_availabilityproblem(int index) const {
  return _impl_.availabilityproblem_.Get(index);
}
inline const ::playapi::proto::finsky::filter_rules::AvailabilityProblem& Availability::availabilityproblem(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.filter_rules.Availability.availabilityProblem)
  return _internal_availabilityproblem(index);
}
inline ::playapi::proto::finsky::filter_rules::AvailabilityProblem* Availability::_internal_add_availabilityproblem() {
  return _impl_.availabilityproblem_.Add();
}
inline ::playapi::proto::finsky::filter_rules::AvailabilityProblem* Availability::add_availabilityproblem() {
  ::playapi::proto::finsky::filter_rules::AvailabilityProblem* _add = _internal_add_availabilityproblem();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.filter_rules.Availability.availabilityProblem)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::filter_rules::AvailabilityProblem >&
Availability::availabilityproblem() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.filter_rules.Availability.availabilityProblem)
  return _impl_.availabilityproblem_;
}

// optional bool hidden = 21;
inline bool Availability::_internal_has_hidden() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Availability::has_hidden() const {
  return _internal_has_hidden();
}
inline void Availability::clear_hidden() {
  _impl_.hidden_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool Availability::_internal_hidden() const {
  return _impl_.hidden_;
}
inline bool Availability::hidden() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.filter_rules.Availability.hidden)
  return _internal_hidden();
}
inline void Availability::_internal_set_hidden(bool value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.hidden_ = value;
}
inline void Availability::set_hidden(bool value) {
  _internal_set_hidden(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.filter_rules.Availability.hidden)
}

// -------------------------------------------------------------------

// AvailabilityProblem

// optional int32 problemType = 1;
inline bool AvailabilityProblem::_internal_has_problemtype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AvailabilityProblem::has_problemtype() const {
  return _internal_has_problemtype();
}
inline void AvailabilityProblem::clear_problemtype() {
  _impl_.problemtype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t AvailabilityProblem::_internal_problemtype() const {
  return _impl_.problemtype_;
}
inline int32_t AvailabilityProblem::problemtype() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.filter_rules.AvailabilityProblem.problemType)
  return _internal_problemtype();
}
inline void AvailabilityProblem::_internal_set_problemtype(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.problemtype_ = value;
}
inline void AvailabilityProblem::set_problemtype(int32_t value) {
  _internal_set_problemtype(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.filter_rules.AvailabilityProblem.problemType)
}

// repeated string missingValue = 2;
inline int AvailabilityProblem::_internal_missingvalue_size() const {
  return _impl_.missingvalue_.size();
}
inline int AvailabilityProblem::missingvalue_size() const {
  return _internal_missingvalue_size();
}
inline void AvailabilityProblem::clear_missingvalue() {
  _impl_.missingvalue_.Clear();
}
inline std::string* AvailabilityProblem::add_missingvalue() {
  std::string* _s = _internal_add_missingvalue();
  // @@protoc_insertion_point(field_add_mutable:playapi.proto.finsky.filter_rules.AvailabilityProblem.missingValue)
  return _s;
}
inline const std::string& AvailabilityProblem::_internal_missingvalue(int index) const {
  return _impl_.missingvalue_.Get(index);
}
inline const std::string& AvailabilityProblem::missingvalue(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.filter_rules.AvailabilityProblem.missingValue)
  return _internal_missingvalue(index);
}
inline std::string* AvailabilityProblem::mutable_missingvalue(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.filter_rules.AvailabilityProblem.missingValue)
  return _impl_.missingvalue_.Mutable(index);
}
inline void AvailabilityProblem::set_missingvalue(int index, const std::string& value) {
  _impl_.missingvalue_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.filter_rules.AvailabilityProblem.missingValue)
}
inline void AvailabilityProblem::set_missingvalue(int index, std::string&& value) {
  _impl_.missingvalue_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.filter_rules.AvailabilityProblem.missingValue)
}
inline void AvailabilityProblem::set_missingvalue(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.missingvalue_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:playapi.proto.finsky.filter_rules.AvailabilityProblem.missingValue)
}
inline void AvailabilityProblem::set_missingvalue(int index, const char* value, size_t size) {
  _impl_.missingvalue_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:playapi.proto.finsky.filter_rules.AvailabilityProblem.missingValue)
}
inline std::string* AvailabilityProblem::_internal_add_missingvalue() {
  return _impl_.missingvalue_.Add();
}
inline void AvailabilityProblem::add_missingvalue(const std::string& value) {
  _impl_.missingvalue_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.filter_rules.AvailabilityProblem.missingValue)
}
inline void AvailabilityProblem::add_missingvalue(std::string&& value) {
  _impl_.missingvalue_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.filter_rules.AvailabilityProblem.missingValue)
}
inline void AvailabilityProblem::add_missingvalue(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.missingvalue_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:playapi.proto.finsky.filter_rules.AvailabilityProblem.missingValue)
}
inline void AvailabilityProblem::add_missingvalue(const char* value, size_t size) {
  _impl_.missingvalue_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:playapi.proto.finsky.filter_rules.AvailabilityProblem.missingValue)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AvailabilityProblem::missingvalue() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.filter_rules.AvailabilityProblem.missingValue)
  return _impl_.missingvalue_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AvailabilityProblem::mutable_missingvalue() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.filter_rules.AvailabilityProblem.missingValue)
  return &_impl_.missingvalue_;
}

// -------------------------------------------------------------------

// FilterEvaluationInfo

// repeated .playapi.proto.finsky.filter_rules.RuleEvaluation ruleEvaluation = 1;
inline int FilterEvaluationInfo::_internal_ruleevaluation_size() const {
  return _impl_.ruleevaluation_.size();
}
inline int FilterEvaluationInfo::ruleevaluation_size() const {
  return _internal_ruleevaluation_size();
}
inline void FilterEvaluationInfo::clear_ruleevaluation() {
  _impl_.ruleevaluation_.Clear();
}
inline ::playapi::proto::finsky::filter_rules::RuleEvaluation* FilterEvaluationInfo::mutable_ruleevaluation(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.filter_rules.FilterEvaluationInfo.ruleEvaluation)
  return _impl_.ruleevaluation_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::filter_rules::RuleEvaluation >*
FilterEvaluationInfo::mutable_ruleevaluation() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.filter_rules.FilterEvaluationInfo.ruleEvaluation)
  return &_impl_.ruleevaluation_;
}
inline const ::playapi::proto::finsky::filter_rules::RuleEvaluation& FilterEvaluationInfo::_internal_ruleevaluation(int index) const {
  return _impl_.ruleevaluation_.Get(index);
}
inline const ::playapi::proto::finsky::filter_rules::RuleEvaluation& FilterEvaluationInfo::ruleevaluation(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.filter_rules.FilterEvaluationInfo.ruleEvaluation)
  return _internal_ruleevaluation(index);
}
inline ::playapi::proto::finsky::filter_rules::RuleEvaluation* FilterEvaluationInfo::_internal_add_ruleevaluation() {
  return _impl_.ruleevaluation_.Add();
}
inline ::playapi::proto::finsky::filter_rules::RuleEvaluation* FilterEvaluationInfo::add_ruleevaluation() {
  ::playapi::proto::finsky::filter_rules::RuleEvaluation* _add = _internal_add_ruleevaluation();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.filter_rules.FilterEvaluationInfo.ruleEvaluation)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::filter_rules::RuleEvaluation >&
FilterEvaluationInfo::ruleevaluation() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.filter_rules.FilterEvaluationInfo.ruleEvaluation)
  return _impl_.ruleevaluation_;
}

// -------------------------------------------------------------------

// Rule

// optional bool negate = 1;
inline bool Rule::_internal_has_negate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Rule::has_negate() const {
  return _internal_has_negate();
}
inline void Rule::clear_negate() {
  _impl_.negate_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool Rule::_internal_negate() const {
  return _impl_.negate_;
}
inline bool Rule::negate() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.filter_rules.Rule.negate)
  return _internal_negate();
}
inline void Rule::_internal_set_negate(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.negate_ = value;
}
inline void Rule::set_negate(bool value) {
  _internal_set_negate(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.filter_rules.Rule.negate)
}

// optional int32 operator = 2;
inline bool Rule::_internal_has_operator_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Rule::has_operator_() const {
  return _internal_has_operator_();
}
inline void Rule::clear_operator_() {
  _impl_.operator__ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t Rule::_internal_operator_() const {
  return _impl_.operator__;
}
inline int32_t Rule::operator_() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.filter_rules.Rule.operator)
  return _internal_operator_();
}
inline void Rule::_internal_set_operator_(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.operator__ = value;
}
inline void Rule::set_operator_(int32_t value) {
  _internal_set_operator_(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.filter_rules.Rule.operator)
}

// optional int32 key = 3;
inline bool Rule::_internal_has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Rule::has_key() const {
  return _internal_has_key();
}
inline void Rule::clear_key() {
  _impl_.key_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t Rule::_internal_key() const {
  return _impl_.key_;
}
inline int32_t Rule::key() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.filter_rules.Rule.key)
  return _internal_key();
}
inline void Rule::_internal_set_key(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.key_ = value;
}
inline void Rule::set_key(int32_t value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.filter_rules.Rule.key)
}

// repeated string stringArg = 4;
inline int Rule::_internal_stringarg_size() const {
  return _impl_.stringarg_.size();
}
inline int Rule::stringarg_size() const {
  return _internal_stringarg_size();
}
inline void Rule::clear_stringarg() {
  _impl_.stringarg_.Clear();
}
inline std::string* Rule::add_stringarg() {
  std::string* _s = _internal_add_stringarg();
  // @@protoc_insertion_point(field_add_mutable:playapi.proto.finsky.filter_rules.Rule.stringArg)
  return _s;
}
inline const std::string& Rule::_internal_stringarg(int index) const {
  return _impl_.stringarg_.Get(index);
}
inline const std::string& Rule::stringarg(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.filter_rules.Rule.stringArg)
  return _internal_stringarg(index);
}
inline std::string* Rule::mutable_stringarg(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.filter_rules.Rule.stringArg)
  return _impl_.stringarg_.Mutable(index);
}
inline void Rule::set_stringarg(int index, const std::string& value) {
  _impl_.stringarg_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.filter_rules.Rule.stringArg)
}
inline void Rule::set_stringarg(int index, std::string&& value) {
  _impl_.stringarg_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.filter_rules.Rule.stringArg)
}
inline void Rule::set_stringarg(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.stringarg_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:playapi.proto.finsky.filter_rules.Rule.stringArg)
}
inline void Rule::set_stringarg(int index, const char* value, size_t size) {
  _impl_.stringarg_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:playapi.proto.finsky.filter_rules.Rule.stringArg)
}
inline std::string* Rule::_internal_add_stringarg() {
  return _impl_.stringarg_.Add();
}
inline void Rule::add_stringarg(const std::string& value) {
  _impl_.stringarg_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.filter_rules.Rule.stringArg)
}
inline void Rule::add_stringarg(std::string&& value) {
  _impl_.stringarg_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.filter_rules.Rule.stringArg)
}
inline void Rule::add_stringarg(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.stringarg_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:playapi.proto.finsky.filter_rules.Rule.stringArg)
}
inline void Rule::add_stringarg(const char* value, size_t size) {
  _impl_.stringarg_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:playapi.proto.finsky.filter_rules.Rule.stringArg)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Rule::stringarg() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.filter_rules.Rule.stringArg)
  return _impl_.stringarg_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Rule::mutable_stringarg() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.filter_rules.Rule.stringArg)
  return &_impl_.stringarg_;
}

// repeated int64 longArg = 5;
inline int Rule::_internal_longarg_size() const {
  return _impl_.longarg_.size();
}
inline int Rule::longarg_size() const {
  return _internal_longarg_size();
}
inline void Rule::clear_longarg() {
  _impl_.longarg_.Clear();
}
inline int64_t Rule::_internal_longarg(int index) const {
  return _impl_.longarg_.Get(index);
}
inline int64_t Rule::longarg(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.filter_rules.Rule.longArg)
  return _internal_longarg(index);
}
inline void Rule::set_longarg(int index, int64_t value) {
  _impl_.longarg_.Set(index, value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.filter_rules.Rule.longArg)
}
inline void Rule::_internal_add_longarg(int64_t value) {
  _impl_.longarg_.Add(value);
}
inline void Rule::add_longarg(int64_t value) {
  _internal_add_longarg(value);
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.filter_rules.Rule.longArg)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
Rule::_internal_longarg() const {
  return _impl_.longarg_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
Rule::longarg() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.filter_rules.Rule.longArg)
  return _internal_longarg();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
Rule::_internal_mutable_longarg() {
  return &_impl_.longarg_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
Rule::mutable_longarg() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.filter_rules.Rule.longArg)
  return _internal_mutable_longarg();
}

// repeated double doubleArg = 6;
inline int Rule::_internal_doublearg_size() const {
  return _impl_.doublearg_.size();
}
inline int Rule::doublearg_size() const {
  return _internal_doublearg_size();
}
inline void Rule::clear_doublearg() {
  _impl_.doublearg_.Clear();
}
inline double Rule::_internal_doublearg(int index) const {
  return _impl_.doublearg_.Get(index);
}
inline double Rule::doublearg(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.filter_rules.Rule.doubleArg)
  return _internal_doublearg(index);
}
inline void Rule::set_doublearg(int index, double value) {
  _impl_.doublearg_.Set(index, value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.filter_rules.Rule.doubleArg)
}
inline void Rule::_internal_add_doublearg(double value) {
  _impl_.doublearg_.Add(value);
}
inline void Rule::add_doublearg(double value) {
  _internal_add_doublearg(value);
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.filter_rules.Rule.doubleArg)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Rule::_internal_doublearg() const {
  return _impl_.doublearg_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Rule::doublearg() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.filter_rules.Rule.doubleArg)
  return _internal_doublearg();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Rule::_internal_mutable_doublearg() {
  return &_impl_.doublearg_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Rule::mutable_doublearg() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.filter_rules.Rule.doubleArg)
  return _internal_mutable_doublearg();
}

// repeated .playapi.proto.finsky.filter_rules.Rule subrule = 7;
inline int Rule::_internal_subrule_size() const {
  return _impl_.subrule_.size();
}
inline int Rule::subrule_size() const {
  return _internal_subrule_size();
}
inline void Rule::clear_subrule() {
  _impl_.subrule_.Clear();
}
inline ::playapi::proto::finsky::filter_rules::Rule* Rule::mutable_subrule(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.filter_rules.Rule.subrule)
  return _impl_.subrule_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::filter_rules::Rule >*
Rule::mutable_subrule() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.filter_rules.Rule.subrule)
  return &_impl_.subrule_;
}
inline const ::playapi::proto::finsky::filter_rules::Rule& Rule::_internal_subrule(int index) const {
  return _impl_.subrule_.Get(index);
}
inline const ::playapi::proto::finsky::filter_rules::Rule& Rule::subrule(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.filter_rules.Rule.subrule)
  return _internal_subrule(index);
}
inline ::playapi::proto::finsky::filter_rules::Rule* Rule::_internal_add_subrule() {
  return _impl_.subrule_.Add();
}
inline ::playapi::proto::finsky::filter_rules::Rule* Rule::add_subrule() {
  ::playapi::proto::finsky::filter_rules::Rule* _add = _internal_add_subrule();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.filter_rules.Rule.subrule)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::filter_rules::Rule >&
Rule::subrule() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.filter_rules.Rule.subrule)
  return _impl_.subrule_;
}

// optional int32 responseCode = 8;
inline bool Rule::_internal_has_responsecode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Rule::has_responsecode() const {
  return _internal_has_responsecode();
}
inline void Rule::clear_responsecode() {
  _impl_.responsecode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int32_t Rule::_internal_responsecode() const {
  return _impl_.responsecode_;
}
inline int32_t Rule::responsecode() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.filter_rules.Rule.responseCode)
  return _internal_responsecode();
}
inline void Rule::_internal_set_responsecode(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.responsecode_ = value;
}
inline void Rule::set_responsecode(int32_t value) {
  _internal_set_responsecode(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.filter_rules.Rule.responseCode)
}

// optional string comment = 9;
inline bool Rule::_internal_has_comment() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Rule::has_comment() const {
  return _internal_has_comment();
}
inline void Rule::clear_comment() {
  _impl_.comment_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Rule::comment() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.filter_rules.Rule.comment)
  return _internal_comment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Rule::set_comment(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.comment_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.filter_rules.Rule.comment)
}
inline std::string* Rule::mutable_comment() {
  std::string* _s = _internal_mutable_comment();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.filter_rules.Rule.comment)
  return _s;
}
inline const std::string& Rule::_internal_comment() const {
  return _impl_.comment_.Get();
}
inline void Rule::_internal_set_comment(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.comment_.Set(value, GetArenaForAllocation());
}
inline std::string* Rule::_internal_mutable_comment() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.comment_.Mutable(GetArenaForAllocation());
}
inline std::string* Rule::release_comment() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.filter_rules.Rule.comment)
  if (!_internal_has_comment()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.comment_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comment_.IsDefault()) {
    _impl_.comment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Rule::set_allocated_comment(std::string* comment) {
  if (comment != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.comment_.SetAllocated(comment, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comment_.IsDefault()) {
    _impl_.comment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.filter_rules.Rule.comment)
}

// repeated fixed64 stringArgHash = 10;
inline int Rule::_internal_stringarghash_size() const {
  return _impl_.stringarghash_.size();
}
inline int Rule::stringarghash_size() const {
  return _internal_stringarghash_size();
}
inline void Rule::clear_stringarghash() {
  _impl_.stringarghash_.Clear();
}
inline uint64_t Rule::_internal_stringarghash(int index) const {
  return _impl_.stringarghash_.Get(index);
}
inline uint64_t Rule::stringarghash(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.filter_rules.Rule.stringArgHash)
  return _internal_stringarghash(index);
}
inline void Rule::set_stringarghash(int index, uint64_t value) {
  _impl_.stringarghash_.Set(index, value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.filter_rules.Rule.stringArgHash)
}
inline void Rule::_internal_add_stringarghash(uint64_t value) {
  _impl_.stringarghash_.Add(value);
}
inline void Rule::add_stringarghash(uint64_t value) {
  _internal_add_stringarghash(value);
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.filter_rules.Rule.stringArgHash)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
Rule::_internal_stringarghash() const {
  return _impl_.stringarghash_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
Rule::stringarghash() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.filter_rules.Rule.stringArgHash)
  return _internal_stringarghash();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
Rule::_internal_mutable_stringarghash() {
  return &_impl_.stringarghash_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
Rule::mutable_stringarghash() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.filter_rules.Rule.stringArgHash)
  return _internal_mutable_stringarghash();
}

// optional int32 availabilityProblemType = 12;
inline bool Rule::_internal_has_availabilityproblemtype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Rule::has_availabilityproblemtype() const {
  return _internal_has_availabilityproblemtype();
}
inline void Rule::clear_availabilityproblemtype() {
  _impl_.availabilityproblemtype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int32_t Rule::_internal_availabilityproblemtype() const {
  return _impl_.availabilityproblemtype_;
}
inline int32_t Rule::availabilityproblemtype() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.filter_rules.Rule.availabilityProblemType)
  return _internal_availabilityproblemtype();
}
inline void Rule::_internal_set_availabilityproblemtype(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.availabilityproblemtype_ = value;
}
inline void Rule::set_availabilityproblemtype(int32_t value) {
  _internal_set_availabilityproblemtype(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.filter_rules.Rule.availabilityProblemType)
}

// optional bool includeMissingValues = 13;
inline bool Rule::_internal_has_includemissingvalues() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Rule::has_includemissingvalues() const {
  return _internal_has_includemissingvalues();
}
inline void Rule::clear_includemissingvalues() {
  _impl_.includemissingvalues_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool Rule::_internal_includemissingvalues() const {
  return _impl_.includemissingvalues_;
}
inline bool Rule::includemissingvalues() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.filter_rules.Rule.includeMissingValues)
  return _internal_includemissingvalues();
}
inline void Rule::_internal_set_includemissingvalues(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.includemissingvalues_ = value;
}
inline void Rule::set_includemissingvalues(bool value) {
  _internal_set_includemissingvalues(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.filter_rules.Rule.includeMissingValues)
}

// -------------------------------------------------------------------

// RuleEvaluation

// optional .playapi.proto.finsky.filter_rules.Rule rule = 1;
inline bool RuleEvaluation::_internal_has_rule() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rule_ != nullptr);
  return value;
}
inline bool RuleEvaluation::has_rule() const {
  return _internal_has_rule();
}
inline void RuleEvaluation::clear_rule() {
  if (_impl_.rule_ != nullptr) _impl_.rule_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::playapi::proto::finsky::filter_rules::Rule& RuleEvaluation::_internal_rule() const {
  const ::playapi::proto::finsky::filter_rules::Rule* p = _impl_.rule_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::filter_rules::Rule&>(
      ::playapi::proto::finsky::filter_rules::_Rule_default_instance_);
}
inline const ::playapi::proto::finsky::filter_rules::Rule& RuleEvaluation::rule() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.filter_rules.RuleEvaluation.rule)
  return _internal_rule();
}
inline void RuleEvaluation::unsafe_arena_set_allocated_rule(
    ::playapi::proto::finsky::filter_rules::Rule* rule) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rule_);
  }
  _impl_.rule_ = rule;
  if (rule) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.filter_rules.RuleEvaluation.rule)
}
inline ::playapi::proto::finsky::filter_rules::Rule* RuleEvaluation::release_rule() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::playapi::proto::finsky::filter_rules::Rule* temp = _impl_.rule_;
  _impl_.rule_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::filter_rules::Rule* RuleEvaluation::unsafe_arena_release_rule() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.filter_rules.RuleEvaluation.rule)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::playapi::proto::finsky::filter_rules::Rule* temp = _impl_.rule_;
  _impl_.rule_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::filter_rules::Rule* RuleEvaluation::_internal_mutable_rule() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.rule_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::filter_rules::Rule>(GetArenaForAllocation());
    _impl_.rule_ = p;
  }
  return _impl_.rule_;
}
inline ::playapi::proto::finsky::filter_rules::Rule* RuleEvaluation::mutable_rule() {
  ::playapi::proto::finsky::filter_rules::Rule* _msg = _internal_mutable_rule();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.filter_rules.RuleEvaluation.rule)
  return _msg;
}
inline void RuleEvaluation::set_allocated_rule(::playapi::proto::finsky::filter_rules::Rule* rule) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rule_;
  }
  if (rule) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rule);
    if (message_arena != submessage_arena) {
      rule = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rule, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.rule_ = rule;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.filter_rules.RuleEvaluation.rule)
}

// repeated string actualStringValue = 2;
inline int RuleEvaluation::_internal_actualstringvalue_size() const {
  return _impl_.actualstringvalue_.size();
}
inline int RuleEvaluation::actualstringvalue_size() const {
  return _internal_actualstringvalue_size();
}
inline void RuleEvaluation::clear_actualstringvalue() {
  _impl_.actualstringvalue_.Clear();
}
inline std::string* RuleEvaluation::add_actualstringvalue() {
  std::string* _s = _internal_add_actualstringvalue();
  // @@protoc_insertion_point(field_add_mutable:playapi.proto.finsky.filter_rules.RuleEvaluation.actualStringValue)
  return _s;
}
inline const std::string& RuleEvaluation::_internal_actualstringvalue(int index) const {
  return _impl_.actualstringvalue_.Get(index);
}
inline const std::string& RuleEvaluation::actualstringvalue(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.filter_rules.RuleEvaluation.actualStringValue)
  return _internal_actualstringvalue(index);
}
inline std::string* RuleEvaluation::mutable_actualstringvalue(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.filter_rules.RuleEvaluation.actualStringValue)
  return _impl_.actualstringvalue_.Mutable(index);
}
inline void RuleEvaluation::set_actualstringvalue(int index, const std::string& value) {
  _impl_.actualstringvalue_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.filter_rules.RuleEvaluation.actualStringValue)
}
inline void RuleEvaluation::set_actualstringvalue(int index, std::string&& value) {
  _impl_.actualstringvalue_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.filter_rules.RuleEvaluation.actualStringValue)
}
inline void RuleEvaluation::set_actualstringvalue(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.actualstringvalue_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:playapi.proto.finsky.filter_rules.RuleEvaluation.actualStringValue)
}
inline void RuleEvaluation::set_actualstringvalue(int index, const char* value, size_t size) {
  _impl_.actualstringvalue_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:playapi.proto.finsky.filter_rules.RuleEvaluation.actualStringValue)
}
inline std::string* RuleEvaluation::_internal_add_actualstringvalue() {
  return _impl_.actualstringvalue_.Add();
}
inline void RuleEvaluation::add_actualstringvalue(const std::string& value) {
  _impl_.actualstringvalue_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.filter_rules.RuleEvaluation.actualStringValue)
}
inline void RuleEvaluation::add_actualstringvalue(std::string&& value) {
  _impl_.actualstringvalue_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.filter_rules.RuleEvaluation.actualStringValue)
}
inline void RuleEvaluation::add_actualstringvalue(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.actualstringvalue_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:playapi.proto.finsky.filter_rules.RuleEvaluation.actualStringValue)
}
inline void RuleEvaluation::add_actualstringvalue(const char* value, size_t size) {
  _impl_.actualstringvalue_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:playapi.proto.finsky.filter_rules.RuleEvaluation.actualStringValue)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RuleEvaluation::actualstringvalue() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.filter_rules.RuleEvaluation.actualStringValue)
  return _impl_.actualstringvalue_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
RuleEvaluation::mutable_actualstringvalue() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.filter_rules.RuleEvaluation.actualStringValue)
  return &_impl_.actualstringvalue_;
}

// repeated int64 actualLongValue = 3;
inline int RuleEvaluation::_internal_actuallongvalue_size() const {
  return _impl_.actuallongvalue_.size();
}
inline int RuleEvaluation::actuallongvalue_size() const {
  return _internal_actuallongvalue_size();
}
inline void RuleEvaluation::clear_actuallongvalue() {
  _impl_.actuallongvalue_.Clear();
}
inline int64_t RuleEvaluation::_internal_actuallongvalue(int index) const {
  return _impl_.actuallongvalue_.Get(index);
}
inline int64_t RuleEvaluation::actuallongvalue(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.filter_rules.RuleEvaluation.actualLongValue)
  return _internal_actuallongvalue(index);
}
inline void RuleEvaluation::set_actuallongvalue(int index, int64_t value) {
  _impl_.actuallongvalue_.Set(index, value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.filter_rules.RuleEvaluation.actualLongValue)
}
inline void RuleEvaluation::_internal_add_actuallongvalue(int64_t value) {
  _impl_.actuallongvalue_.Add(value);
}
inline void RuleEvaluation::add_actuallongvalue(int64_t value) {
  _internal_add_actuallongvalue(value);
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.filter_rules.RuleEvaluation.actualLongValue)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
RuleEvaluation::_internal_actuallongvalue() const {
  return _impl_.actuallongvalue_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
RuleEvaluation::actuallongvalue() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.filter_rules.RuleEvaluation.actualLongValue)
  return _internal_actuallongvalue();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
RuleEvaluation::_internal_mutable_actuallongvalue() {
  return &_impl_.actuallongvalue_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
RuleEvaluation::mutable_actuallongvalue() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.filter_rules.RuleEvaluation.actualLongValue)
  return _internal_mutable_actuallongvalue();
}

// repeated bool actualBoolValue = 4;
inline int RuleEvaluation::_internal_actualboolvalue_size() const {
  return _impl_.actualboolvalue_.size();
}
inline int RuleEvaluation::actualboolvalue_size() const {
  return _internal_actualboolvalue_size();
}
inline void RuleEvaluation::clear_actualboolvalue() {
  _impl_.actualboolvalue_.Clear();
}
inline bool RuleEvaluation::_internal_actualboolvalue(int index) const {
  return _impl_.actualboolvalue_.Get(index);
}
inline bool RuleEvaluation::actualboolvalue(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.filter_rules.RuleEvaluation.actualBoolValue)
  return _internal_actualboolvalue(index);
}
inline void RuleEvaluation::set_actualboolvalue(int index, bool value) {
  _impl_.actualboolvalue_.Set(index, value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.filter_rules.RuleEvaluation.actualBoolValue)
}
inline void RuleEvaluation::_internal_add_actualboolvalue(bool value) {
  _impl_.actualboolvalue_.Add(value);
}
inline void RuleEvaluation::add_actualboolvalue(bool value) {
  _internal_add_actualboolvalue(value);
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.filter_rules.RuleEvaluation.actualBoolValue)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
RuleEvaluation::_internal_actualboolvalue() const {
  return _impl_.actualboolvalue_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
RuleEvaluation::actualboolvalue() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.filter_rules.RuleEvaluation.actualBoolValue)
  return _internal_actualboolvalue();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
RuleEvaluation::_internal_mutable_actualboolvalue() {
  return &_impl_.actualboolvalue_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
RuleEvaluation::mutable_actualboolvalue() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.filter_rules.RuleEvaluation.actualBoolValue)
  return _internal_mutable_actualboolvalue();
}

// repeated double actualDoubleValue = 5;
inline int RuleEvaluation::_internal_actualdoublevalue_size() const {
  return _impl_.actualdoublevalue_.size();
}
inline int RuleEvaluation::actualdoublevalue_size() const {
  return _internal_actualdoublevalue_size();
}
inline void RuleEvaluation::clear_actualdoublevalue() {
  _impl_.actualdoublevalue_.Clear();
}
inline double RuleEvaluation::_internal_actualdoublevalue(int index) const {
  return _impl_.actualdoublevalue_.Get(index);
}
inline double RuleEvaluation::actualdoublevalue(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.filter_rules.RuleEvaluation.actualDoubleValue)
  return _internal_actualdoublevalue(index);
}
inline void RuleEvaluation::set_actualdoublevalue(int index, double value) {
  _impl_.actualdoublevalue_.Set(index, value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.filter_rules.RuleEvaluation.actualDoubleValue)
}
inline void RuleEvaluation::_internal_add_actualdoublevalue(double value) {
  _impl_.actualdoublevalue_.Add(value);
}
inline void RuleEvaluation::add_actualdoublevalue(double value) {
  _internal_add_actualdoublevalue(value);
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.filter_rules.RuleEvaluation.actualDoubleValue)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
RuleEvaluation::_internal_actualdoublevalue() const {
  return _impl_.actualdoublevalue_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
RuleEvaluation::actualdoublevalue() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.filter_rules.RuleEvaluation.actualDoubleValue)
  return _internal_actualdoublevalue();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
RuleEvaluation::_internal_mutable_actualdoublevalue() {
  return &_impl_.actualdoublevalue_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
RuleEvaluation::mutable_actualdoublevalue() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.filter_rules.RuleEvaluation.actualDoubleValue)
  return _internal_mutable_actualdoublevalue();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace filter_rules
}  // namespace finsky
}  // namespace proto
}  // namespace playapi

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_play_5ffilter_5frules_2eproto
