// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: play_common.proto

#include "play_common.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace playapi {
namespace proto {
namespace finsky {
PROTOBUF_CONSTEXPR HttpCookie::HttpCookie(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct HttpCookieDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HttpCookieDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HttpCookieDefaultTypeInternal() {}
  union {
    HttpCookie _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HttpCookieDefaultTypeInternal _HttpCookie_default_instance_;
PROTOBUF_CONSTEXPR TimePeriod::TimePeriod(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.unit_)*/0
  , /*decltype(_impl_.count_)*/0} {}
struct TimePeriodDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TimePeriodDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TimePeriodDefaultTypeInternal() {}
  union {
    TimePeriod _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TimePeriodDefaultTypeInternal _TimePeriod_default_instance_;
PROTOBUF_CONSTEXPR MonthAndDay::MonthAndDay(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.month_)*/0
  , /*decltype(_impl_.day_)*/0} {}
struct MonthAndDayDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MonthAndDayDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MonthAndDayDefaultTypeInternal() {}
  union {
    MonthAndDay _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MonthAndDayDefaultTypeInternal _MonthAndDay_default_instance_;
PROTOBUF_CONSTEXPR SignedData::SignedData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.signeddata_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.signature_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct SignedDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SignedDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SignedDataDefaultTypeInternal() {}
  union {
    SignedData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SignedDataDefaultTypeInternal _SignedData_default_instance_;
PROTOBUF_CONSTEXPR Docid::Docid(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.backenddocid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.backend_)*/0} {}
struct DocidDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DocidDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DocidDefaultTypeInternal() {}
  union {
    Docid _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DocidDefaultTypeInternal _Docid_default_instance_;
PROTOBUF_CONSTEXPR Offer::Offer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.convertedprice_)*/{}
  , /*decltype(_impl_.promotionlabel_)*/{}
  , /*decltype(_impl_.offerpayment_)*/{}
  , /*decltype(_impl_.currencycode_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.formattedamount_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.formattedfullamount_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.formattedname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.formatteddescription_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.offerid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.buybuttonlabel_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.rentalterms_)*/nullptr
  , /*decltype(_impl_.subscriptionterms_)*/nullptr
  , /*decltype(_impl_.subscriptioncontentterms_)*/nullptr
  , /*decltype(_impl_.licenseterms_)*/nullptr
  , /*decltype(_impl_.voucherterms_)*/nullptr
  , /*decltype(_impl_.micros_)*/int64_t{0}
  , /*decltype(_impl_.fullpricemicros_)*/int64_t{0}
  , /*decltype(_impl_.onsaledate_)*/int64_t{0}
  , /*decltype(_impl_.offertype_)*/0
  , /*decltype(_impl_.onsaledatedisplaytimezoneoffsetmsec_)*/0
  , /*decltype(_impl_.checkoutflowrequired_)*/false
  , /*decltype(_impl_.preorder_)*/false
  , /*decltype(_impl_.temporarilyfree_)*/false
  , /*decltype(_impl_.repeatlastpayment_)*/false
  , /*decltype(_impl_.licensedoffertype_)*/0
  , /*decltype(_impl_.preorderfulfillmentdisplaydate_)*/int64_t{0}
  , /*decltype(_impl_.instantpurchaseenabled_)*/false} {}
struct OfferDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OfferDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OfferDefaultTypeInternal() {}
  union {
    Offer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OfferDefaultTypeInternal _Offer_default_instance_;
PROTOBUF_CONSTEXPR RentalTerms::RentalTerms(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.grantperiod_)*/nullptr
  , /*decltype(_impl_.activateperiod_)*/nullptr
  , /*decltype(_impl_.deprecatedgrantperiodseconds_)*/0
  , /*decltype(_impl_.deprecatedactivateperiodseconds_)*/0
  , /*decltype(_impl_.grantendtimeseconds_)*/int64_t{0}} {}
struct RentalTermsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RentalTermsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RentalTermsDefaultTypeInternal() {}
  union {
    RentalTerms _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RentalTermsDefaultTypeInternal _RentalTerms_default_instance_;
PROTOBUF_CONSTEXPR OfferPayment::OfferPayment(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.offerpaymentoverride_)*/{}
  , /*decltype(_impl_.currencycode_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.offerpaymentperiod_)*/nullptr
  , /*decltype(_impl_.micros_)*/int64_t{0}} {}
struct OfferPaymentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OfferPaymentDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OfferPaymentDefaultTypeInternal() {}
  union {
    OfferPayment _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OfferPaymentDefaultTypeInternal _OfferPayment_default_instance_;
PROTOBUF_CONSTEXPR OfferPaymentPeriod::OfferPaymentPeriod(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.duration_)*/nullptr
  , /*decltype(_impl_.start_)*/nullptr
  , /*decltype(_impl_.end_)*/nullptr} {}
struct OfferPaymentPeriodDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OfferPaymentPeriodDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OfferPaymentPeriodDefaultTypeInternal() {}
  union {
    OfferPaymentPeriod _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OfferPaymentPeriodDefaultTypeInternal _OfferPaymentPeriod_default_instance_;
PROTOBUF_CONSTEXPR OfferPaymentOverride::OfferPaymentOverride(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.start_)*/nullptr
  , /*decltype(_impl_.end_)*/nullptr
  , /*decltype(_impl_.micros_)*/int64_t{0}} {}
struct OfferPaymentOverrideDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OfferPaymentOverrideDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OfferPaymentOverrideDefaultTypeInternal() {}
  union {
    OfferPaymentOverride _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OfferPaymentOverrideDefaultTypeInternal _OfferPaymentOverride_default_instance_;
PROTOBUF_CONSTEXPR SeasonalSubscriptionInfo_Payment::SeasonalSubscriptionInfo_Payment(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.currencycode_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.formattedamount_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.period_)*/nullptr
  , /*decltype(_impl_.micros_)*/int64_t{0}} {}
struct SeasonalSubscriptionInfo_PaymentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SeasonalSubscriptionInfo_PaymentDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SeasonalSubscriptionInfo_PaymentDefaultTypeInternal() {}
  union {
    SeasonalSubscriptionInfo_Payment _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SeasonalSubscriptionInfo_PaymentDefaultTypeInternal _SeasonalSubscriptionInfo_Payment_default_instance_;
PROTOBUF_CONSTEXPR SeasonalSubscriptionInfo::SeasonalSubscriptionInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.periodstart_)*/nullptr
  , /*decltype(_impl_.periodend_)*/nullptr
  , /*decltype(_impl_.posttrialconversionpayment_)*/nullptr
  , /*decltype(_impl_.prorated_)*/false} {}
struct SeasonalSubscriptionInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SeasonalSubscriptionInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SeasonalSubscriptionInfoDefaultTypeInternal() {}
  union {
    SeasonalSubscriptionInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SeasonalSubscriptionInfoDefaultTypeInternal _SeasonalSubscriptionInfo_default_instance_;
PROTOBUF_CONSTEXPR SubscriptionTerms_SubscriptionReplacement::SubscriptionTerms_SubscriptionReplacement(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.olddocid_)*/{}
  , /*decltype(_impl_.newdocid_)*/nullptr
  , /*decltype(_impl_.keepnextrecurrencetime_)*/false
  , /*decltype(_impl_.replaceonfirstrecurrence_)*/false} {}
struct SubscriptionTerms_SubscriptionReplacementDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SubscriptionTerms_SubscriptionReplacementDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SubscriptionTerms_SubscriptionReplacementDefaultTypeInternal() {}
  union {
    SubscriptionTerms_SubscriptionReplacement _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SubscriptionTerms_SubscriptionReplacementDefaultTypeInternal _SubscriptionTerms_SubscriptionReplacement_default_instance_;
PROTOBUF_CONSTEXPR SubscriptionTerms::SubscriptionTerms(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.replacedocid_)*/{}
  , /*decltype(_impl_.formattedpricewithrecurrenceperiod_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.nextpaymentcurrencycode_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.recurringperiod_)*/nullptr
  , /*decltype(_impl_.trialperiod_)*/nullptr
  , /*decltype(_impl_.seasonalsubscriptioninfo_)*/nullptr
  , /*decltype(_impl_.graceperiod_)*/nullptr
  , /*decltype(_impl_.subscriptionreplacement_)*/nullptr
  , /*decltype(_impl_.initialvaliduntiltimestampmsec_)*/int64_t{0}
  , /*decltype(_impl_.nextpaymentpricemicros_)*/int64_t{0}
  , /*decltype(_impl_.resignup_)*/false
  , /*decltype(_impl_.enableappspecifiedtrialperiod_)*/false} {}
struct SubscriptionTermsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SubscriptionTermsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SubscriptionTermsDefaultTypeInternal() {}
  union {
    SubscriptionTerms _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SubscriptionTermsDefaultTypeInternal _SubscriptionTerms_default_instance_;
PROTOBUF_CONSTEXPR SubscriptionContentTerms::SubscriptionContentTerms(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.requiredsubscription_)*/nullptr} {}
struct SubscriptionContentTermsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SubscriptionContentTermsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SubscriptionContentTermsDefaultTypeInternal() {}
  union {
    SubscriptionContentTerms _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SubscriptionContentTermsDefaultTypeInternal _SubscriptionContentTerms_default_instance_;
PROTOBUF_CONSTEXPR GroupLicenseKey::GroupLicenseKey(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.docid_)*/nullptr
  , /*decltype(_impl_.dashercustomerid_)*/uint64_t{0u}
  , /*decltype(_impl_.licensedoffertype_)*/0
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.rentalperioddays_)*/0} {}
struct GroupLicenseKeyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GroupLicenseKeyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GroupLicenseKeyDefaultTypeInternal() {}
  union {
    GroupLicenseKey _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GroupLicenseKeyDefaultTypeInternal _GroupLicenseKey_default_instance_;
PROTOBUF_CONSTEXPR GroupLicenseInfo::GroupLicenseInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.grouplicensekey_)*/nullptr
  , /*decltype(_impl_.gaiagroupid_)*/uint64_t{0u}
  , /*decltype(_impl_.licensedoffertype_)*/0} {}
struct GroupLicenseInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GroupLicenseInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GroupLicenseInfoDefaultTypeInternal() {}
  union {
    GroupLicenseInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GroupLicenseInfoDefaultTypeInternal _GroupLicenseInfo_default_instance_;
PROTOBUF_CONSTEXPR LicenseTerms::LicenseTerms(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.grouplicensekey_)*/nullptr} {}
struct LicenseTermsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LicenseTermsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LicenseTermsDefaultTypeInternal() {}
  union {
    LicenseTerms _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LicenseTermsDefaultTypeInternal _LicenseTerms_default_instance_;
PROTOBUF_CONSTEXPR LicensedDocumentInfo::LicensedDocumentInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.gaiagroupid_)*/{}
  , /*decltype(_impl_.grouplicensecheckoutorderid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.deprecatedassignmentid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.grouplicensekey_)*/nullptr
  , /*decltype(_impl_.assignedbygaiaid_)*/uint64_t{0u}} {}
struct LicensedDocumentInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LicensedDocumentInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LicensedDocumentInfoDefaultTypeInternal() {}
  union {
    LicensedDocumentInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LicensedDocumentInfoDefaultTypeInternal _LicensedDocumentInfo_default_instance_;
PROTOBUF_CONSTEXPR RedemptionRecordKey::RedemptionRecordKey(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.publisherid_)*/int64_t{0}
  , /*decltype(_impl_.campaignid_)*/int64_t{0}
  , /*decltype(_impl_.codegroupid_)*/int64_t{0}
  , /*decltype(_impl_.recordid_)*/int64_t{0}
  , /*decltype(_impl_.type_)*/0} {}
struct RedemptionRecordKeyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RedemptionRecordKeyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RedemptionRecordKeyDefaultTypeInternal() {}
  union {
    RedemptionRecordKey _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RedemptionRecordKeyDefaultTypeInternal _RedemptionRecordKey_default_instance_;
PROTOBUF_CONSTEXPR VoucherId::VoucherId(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.voucherdocid_)*/nullptr
  , /*decltype(_impl_.key_)*/nullptr} {}
struct VoucherIdDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VoucherIdDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VoucherIdDefaultTypeInternal() {}
  union {
    VoucherId _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VoucherIdDefaultTypeInternal _VoucherId_default_instance_;
PROTOBUF_CONSTEXPR VoucherOfferTerms::VoucherOfferTerms(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.voucherdocid_)*/{}
  , /*decltype(_impl_.voucherformattedamount_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.voucherpricemicros_)*/int64_t{0}} {}
struct VoucherOfferTermsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VoucherOfferTermsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VoucherOfferTermsDefaultTypeInternal() {}
  union {
    VoucherOfferTerms _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VoucherOfferTermsDefaultTypeInternal _VoucherOfferTerms_default_instance_;
PROTOBUF_CONSTEXPR LibraryVoucher::LibraryVoucher(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.voucherid_)*/nullptr} {}
struct LibraryVoucherDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LibraryVoucherDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LibraryVoucherDefaultTypeInternal() {}
  union {
    LibraryVoucher _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LibraryVoucherDefaultTypeInternal _LibraryVoucher_default_instance_;
PROTOBUF_CONSTEXPR OwnershipInfo::OwnershipInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.developerpurchaseinfo_)*/nullptr
  , /*decltype(_impl_.rentalterms_)*/nullptr
  , /*decltype(_impl_.grouplicenseinfo_)*/nullptr
  , /*decltype(_impl_.licenseddocumentinfo_)*/nullptr
  , /*decltype(_impl_.libraryvoucher_)*/nullptr
  , /*decltype(_impl_.bundledocid_)*/nullptr
  , /*decltype(_impl_.initiationtimestampmsec_)*/int64_t{0}
  , /*decltype(_impl_.validuntiltimestampmsec_)*/int64_t{0}
  , /*decltype(_impl_.refundtimeouttimestampmsec_)*/int64_t{0}
  , /*decltype(_impl_.postdeliveryrefundwindowmsec_)*/int64_t{0}
  , /*decltype(_impl_.autorenewing_)*/false
  , /*decltype(_impl_.preordered_)*/false
  , /*decltype(_impl_.hidden_)*/false
  , /*decltype(_impl_.bonus_)*/false
  , /*decltype(_impl_.quantity_)*/0
  , /*decltype(_impl_.libraryexpirationtimestampmsec_)*/int64_t{0}
  , /*decltype(_impl_.storedvaliduntiltimestampmsec_)*/int64_t{0}} {}
struct OwnershipInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OwnershipInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OwnershipInfoDefaultTypeInternal() {}
  union {
    OwnershipInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OwnershipInfoDefaultTypeInternal _OwnershipInfo_default_instance_;
PROTOBUF_CONSTEXPR Image_Dimension::Image_Dimension(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.width_)*/0
  , /*decltype(_impl_.height_)*/0
  , /*decltype(_impl_.aspectratio_)*/0} {}
struct Image_DimensionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Image_DimensionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Image_DimensionDefaultTypeInternal() {}
  union {
    Image_Dimension _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Image_DimensionDefaultTypeInternal _Image_Dimension_default_instance_;
PROTOBUF_CONSTEXPR Image_Citation::Image_Citation(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.titlelocalized_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct Image_CitationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Image_CitationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Image_CitationDefaultTypeInternal() {}
  union {
    Image_Citation _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Image_CitationDefaultTypeInternal _Image_Citation_default_instance_;
PROTOBUF_CONSTEXPR Image::Image(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.imageurl_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.alttextlocalized_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.secureurl_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.fillcolorrgb_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.backgroundcolorrgb_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.dimension_)*/nullptr
  , /*decltype(_impl_.citation_)*/nullptr
  , /*decltype(_impl_.attribution_)*/nullptr
  , /*decltype(_impl_.palette_)*/nullptr
  , /*decltype(_impl_.imagetype_)*/0
  , /*decltype(_impl_.positioninsequence_)*/0
  , /*decltype(_impl_.durationseconds_)*/0
  , /*decltype(_impl_.supportsfifeurloptions_)*/false
  , /*decltype(_impl_.autogen_)*/false
  , /*decltype(_impl_.supportsfifemonogramoption_)*/false
  , /*decltype(_impl_.deviceclass_)*/0} {}
struct ImageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ImageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ImageDefaultTypeInternal() {}
  union {
    Image _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ImageDefaultTypeInternal _Image_default_instance_;
PROTOBUF_CONSTEXPR ImagePalette::ImagePalette(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.lightvibrantrgb_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.vibrantrgb_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.darkvibrantrgb_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.lightmutedrgb_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.mutedrgb_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.darkmutedrgb_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct ImagePaletteDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ImagePaletteDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ImagePaletteDefaultTypeInternal() {}
  union {
    ImagePalette _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ImagePaletteDefaultTypeInternal _ImagePalette_default_instance_;
PROTOBUF_CONSTEXPR Attribution::Attribution(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.sourcetitle_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.sourceurl_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.licensetitle_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.licenseurl_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct AttributionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AttributionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AttributionDefaultTypeInternal() {}
  union {
    Attribution _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AttributionDefaultTypeInternal _Attribution_default_instance_;
PROTOBUF_CONSTEXPR CertificateSet::CertificateSet(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.certificatehash_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CertificateSetDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CertificateSetDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CertificateSetDefaultTypeInternal() {}
  union {
    CertificateSet _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CertificateSetDefaultTypeInternal _CertificateSet_default_instance_;
PROTOBUF_CONSTEXPR EncodedTargets::EncodedTargets(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.supportedtarget_)*/{}
  , /*decltype(_impl_.othertarget_)*/{}
  , /*decltype(_impl_.version_)*/0} {}
struct EncodedTargetsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EncodedTargetsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EncodedTargetsDefaultTypeInternal() {}
  union {
    EncodedTargets _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EncodedTargetsDefaultTypeInternal _EncodedTargets_default_instance_;
}  // namespace finsky
}  // namespace proto
}  // namespace playapi
static ::_pb::Metadata file_level_metadata_play_5fcommon_2eproto[31];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_play_5fcommon_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_play_5fcommon_2eproto = nullptr;

const uint32_t TableStruct_play_5fcommon_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::HttpCookie, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::HttpCookie, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::HttpCookie, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::HttpCookie, _impl_.value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::TimePeriod, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::TimePeriod, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::TimePeriod, _impl_.unit_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::TimePeriod, _impl_.count_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::MonthAndDay, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::MonthAndDay, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::MonthAndDay, _impl_.month_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::MonthAndDay, _impl_.day_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::SignedData, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::SignedData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::SignedData, _impl_.signeddata_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::SignedData, _impl_.signature_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Docid, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Docid, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Docid, _impl_.backenddocid_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Docid, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Docid, _impl_.backend_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Offer, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Offer, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Offer, _impl_.micros_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Offer, _impl_.currencycode_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Offer, _impl_.formattedamount_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Offer, _impl_.convertedprice_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Offer, _impl_.checkoutflowrequired_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Offer, _impl_.fullpricemicros_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Offer, _impl_.formattedfullamount_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Offer, _impl_.offertype_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Offer, _impl_.rentalterms_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Offer, _impl_.onsaledate_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Offer, _impl_.promotionlabel_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Offer, _impl_.subscriptionterms_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Offer, _impl_.formattedname_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Offer, _impl_.formatteddescription_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Offer, _impl_.preorder_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Offer, _impl_.onsaledatedisplaytimezoneoffsetmsec_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Offer, _impl_.licensedoffertype_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Offer, _impl_.subscriptioncontentterms_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Offer, _impl_.offerid_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Offer, _impl_.preorderfulfillmentdisplaydate_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Offer, _impl_.licenseterms_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Offer, _impl_.temporarilyfree_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Offer, _impl_.voucherterms_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Offer, _impl_.offerpayment_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Offer, _impl_.repeatlastpayment_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Offer, _impl_.buybuttonlabel_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Offer, _impl_.instantpurchaseenabled_),
  12,
  0,
  1,
  ~0u,
  17,
  13,
  2,
  15,
  7,
  14,
  ~0u,
  8,
  3,
  4,
  18,
  16,
  21,
  9,
  5,
  22,
  10,
  19,
  11,
  ~0u,
  20,
  6,
  23,
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::RentalTerms, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::RentalTerms, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::RentalTerms, _impl_.deprecatedgrantperiodseconds_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::RentalTerms, _impl_.deprecatedactivateperiodseconds_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::RentalTerms, _impl_.grantperiod_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::RentalTerms, _impl_.activateperiod_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::RentalTerms, _impl_.grantendtimeseconds_),
  2,
  3,
  0,
  1,
  4,
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::OfferPayment, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::OfferPayment, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::OfferPayment, _impl_.micros_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::OfferPayment, _impl_.currencycode_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::OfferPayment, _impl_.offerpaymentperiod_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::OfferPayment, _impl_.offerpaymentoverride_),
  2,
  0,
  1,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::OfferPaymentPeriod, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::OfferPaymentPeriod, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::OfferPaymentPeriod, _impl_.duration_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::OfferPaymentPeriod, _impl_.start_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::OfferPaymentPeriod, _impl_.end_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::OfferPaymentOverride, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::OfferPaymentOverride, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::OfferPaymentOverride, _impl_.micros_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::OfferPaymentOverride, _impl_.start_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::OfferPaymentOverride, _impl_.end_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::SeasonalSubscriptionInfo_Payment, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::SeasonalSubscriptionInfo_Payment, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::SeasonalSubscriptionInfo_Payment, _impl_.micros_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::SeasonalSubscriptionInfo_Payment, _impl_.currencycode_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::SeasonalSubscriptionInfo_Payment, _impl_.formattedamount_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::SeasonalSubscriptionInfo_Payment, _impl_.period_),
  3,
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::SeasonalSubscriptionInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::SeasonalSubscriptionInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::SeasonalSubscriptionInfo, _impl_.periodstart_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::SeasonalSubscriptionInfo, _impl_.periodend_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::SeasonalSubscriptionInfo, _impl_.prorated_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::SeasonalSubscriptionInfo, _impl_.posttrialconversionpayment_),
  0,
  1,
  3,
  2,
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::SubscriptionTerms_SubscriptionReplacement, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::SubscriptionTerms_SubscriptionReplacement, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::SubscriptionTerms_SubscriptionReplacement, _impl_.newdocid_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::SubscriptionTerms_SubscriptionReplacement, _impl_.olddocid_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::SubscriptionTerms_SubscriptionReplacement, _impl_.keepnextrecurrencetime_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::SubscriptionTerms_SubscriptionReplacement, _impl_.replaceonfirstrecurrence_),
  0,
  ~0u,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::SubscriptionTerms, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::SubscriptionTerms, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::SubscriptionTerms, _impl_.recurringperiod_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::SubscriptionTerms, _impl_.trialperiod_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::SubscriptionTerms, _impl_.formattedpricewithrecurrenceperiod_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::SubscriptionTerms, _impl_.seasonalsubscriptioninfo_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::SubscriptionTerms, _impl_.replacedocid_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::SubscriptionTerms, _impl_.graceperiod_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::SubscriptionTerms, _impl_.resignup_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::SubscriptionTerms, _impl_.initialvaliduntiltimestampmsec_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::SubscriptionTerms, _impl_.nextpaymentcurrencycode_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::SubscriptionTerms, _impl_.nextpaymentpricemicros_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::SubscriptionTerms, _impl_.enableappspecifiedtrialperiod_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::SubscriptionTerms, _impl_.subscriptionreplacement_),
  2,
  3,
  0,
  4,
  ~0u,
  5,
  9,
  7,
  1,
  8,
  10,
  6,
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::SubscriptionContentTerms, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::SubscriptionContentTerms, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::SubscriptionContentTerms, _impl_.requiredsubscription_),
  0,
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::GroupLicenseKey, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::GroupLicenseKey, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::GroupLicenseKey, _impl_.dashercustomerid_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::GroupLicenseKey, _impl_.docid_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::GroupLicenseKey, _impl_.licensedoffertype_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::GroupLicenseKey, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::GroupLicenseKey, _impl_.rentalperioddays_),
  1,
  0,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::GroupLicenseInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::GroupLicenseInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::GroupLicenseInfo, _impl_.licensedoffertype_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::GroupLicenseInfo, _impl_.gaiagroupid_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::GroupLicenseInfo, _impl_.grouplicensekey_),
  2,
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::LicenseTerms, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::LicenseTerms, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::LicenseTerms, _impl_.grouplicensekey_),
  0,
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::LicensedDocumentInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::LicensedDocumentInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::LicensedDocumentInfo, _impl_.gaiagroupid_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::LicensedDocumentInfo, _impl_.grouplicensecheckoutorderid_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::LicensedDocumentInfo, _impl_.grouplicensekey_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::LicensedDocumentInfo, _impl_.assignedbygaiaid_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::LicensedDocumentInfo, _impl_.deprecatedassignmentid_),
  ~0u,
  0,
  2,
  3,
  1,
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::RedemptionRecordKey, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::RedemptionRecordKey, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::RedemptionRecordKey, _impl_.publisherid_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::RedemptionRecordKey, _impl_.campaignid_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::RedemptionRecordKey, _impl_.codegroupid_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::RedemptionRecordKey, _impl_.recordid_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::RedemptionRecordKey, _impl_.type_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::VoucherId, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::VoucherId, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::VoucherId, _impl_.voucherdocid_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::VoucherId, _impl_.key_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::VoucherOfferTerms, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::VoucherOfferTerms, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::VoucherOfferTerms, _impl_.voucherdocid_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::VoucherOfferTerms, _impl_.voucherpricemicros_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::VoucherOfferTerms, _impl_.voucherformattedamount_),
  ~0u,
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::LibraryVoucher, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::LibraryVoucher, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::LibraryVoucher, _impl_.voucherid_),
  0,
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::OwnershipInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::OwnershipInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::OwnershipInfo, _impl_.initiationtimestampmsec_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::OwnershipInfo, _impl_.validuntiltimestampmsec_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::OwnershipInfo, _impl_.autorenewing_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::OwnershipInfo, _impl_.refundtimeouttimestampmsec_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::OwnershipInfo, _impl_.postdeliveryrefundwindowmsec_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::OwnershipInfo, _impl_.developerpurchaseinfo_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::OwnershipInfo, _impl_.preordered_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::OwnershipInfo, _impl_.hidden_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::OwnershipInfo, _impl_.rentalterms_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::OwnershipInfo, _impl_.grouplicenseinfo_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::OwnershipInfo, _impl_.licenseddocumentinfo_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::OwnershipInfo, _impl_.quantity_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::OwnershipInfo, _impl_.libraryexpirationtimestampmsec_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::OwnershipInfo, _impl_.libraryvoucher_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::OwnershipInfo, _impl_.bundledocid_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::OwnershipInfo, _impl_.bonus_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::OwnershipInfo, _impl_.storedvaliduntiltimestampmsec_),
  6,
  7,
  10,
  8,
  9,
  0,
  11,
  12,
  1,
  2,
  3,
  14,
  15,
  4,
  5,
  13,
  16,
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Image_Dimension, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Image_Dimension, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Image_Dimension, _impl_.width_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Image_Dimension, _impl_.height_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Image_Dimension, _impl_.aspectratio_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Image_Citation, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Image_Citation, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Image_Citation, _impl_.titlelocalized_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Image_Citation, _impl_.url_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Image, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Image, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Image, _impl_.imagetype_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Image, _impl_.dimension_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Image, _impl_.imageurl_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Image, _impl_.alttextlocalized_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Image, _impl_.secureurl_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Image, _impl_.positioninsequence_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Image, _impl_.supportsfifeurloptions_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Image, _impl_.citation_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Image, _impl_.durationseconds_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Image, _impl_.fillcolorrgb_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Image, _impl_.autogen_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Image, _impl_.attribution_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Image, _impl_.backgroundcolorrgb_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Image, _impl_.palette_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Image, _impl_.deviceclass_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Image, _impl_.supportsfifemonogramoption_),
  9,
  5,
  0,
  1,
  2,
  10,
  12,
  6,
  11,
  3,
  13,
  7,
  4,
  8,
  15,
  14,
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::ImagePalette, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::ImagePalette, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::ImagePalette, _impl_.lightvibrantrgb_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::ImagePalette, _impl_.vibrantrgb_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::ImagePalette, _impl_.darkvibrantrgb_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::ImagePalette, _impl_.lightmutedrgb_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::ImagePalette, _impl_.mutedrgb_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::ImagePalette, _impl_.darkmutedrgb_),
  0,
  1,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Attribution, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Attribution, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Attribution, _impl_.sourcetitle_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Attribution, _impl_.sourceurl_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Attribution, _impl_.licensetitle_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::Attribution, _impl_.licenseurl_),
  0,
  1,
  2,
  3,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::CertificateSet, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::CertificateSet, _impl_.certificatehash_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::EncodedTargets, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::EncodedTargets, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::EncodedTargets, _impl_.version_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::EncodedTargets, _impl_.supportedtarget_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::EncodedTargets, _impl_.othertarget_),
  0,
  ~0u,
  ~0u,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, -1, sizeof(::playapi::proto::finsky::HttpCookie)},
  { 10, 18, -1, sizeof(::playapi::proto::finsky::TimePeriod)},
  { 20, 28, -1, sizeof(::playapi::proto::finsky::MonthAndDay)},
  { 30, 38, -1, sizeof(::playapi::proto::finsky::SignedData)},
  { 40, 49, -1, sizeof(::playapi::proto::finsky::Docid)},
  { 52, 85, -1, sizeof(::playapi::proto::finsky::Offer)},
  { 112, 123, -1, sizeof(::playapi::proto::finsky::RentalTerms)},
  { 128, 138, -1, sizeof(::playapi::proto::finsky::OfferPayment)},
  { 142, 151, -1, sizeof(::playapi::proto::finsky::OfferPaymentPeriod)},
  { 154, 163, -1, sizeof(::playapi::proto::finsky::OfferPaymentOverride)},
  { 166, 176, -1, sizeof(::playapi::proto::finsky::SeasonalSubscriptionInfo_Payment)},
  { 180, 190, -1, sizeof(::playapi::proto::finsky::SeasonalSubscriptionInfo)},
  { 194, 204, -1, sizeof(::playapi::proto::finsky::SubscriptionTerms_SubscriptionReplacement)},
  { 208, 226, -1, sizeof(::playapi::proto::finsky::SubscriptionTerms)},
  { 238, 245, -1, sizeof(::playapi::proto::finsky::SubscriptionContentTerms)},
  { 246, 257, -1, sizeof(::playapi::proto::finsky::GroupLicenseKey)},
  { 262, 271, -1, sizeof(::playapi::proto::finsky::GroupLicenseInfo)},
  { 274, 281, -1, sizeof(::playapi::proto::finsky::LicenseTerms)},
  { 282, 293, -1, sizeof(::playapi::proto::finsky::LicensedDocumentInfo)},
  { 298, 309, -1, sizeof(::playapi::proto::finsky::RedemptionRecordKey)},
  { 314, 322, -1, sizeof(::playapi::proto::finsky::VoucherId)},
  { 324, 333, -1, sizeof(::playapi::proto::finsky::VoucherOfferTerms)},
  { 336, 343, -1, sizeof(::playapi::proto::finsky::LibraryVoucher)},
  { 344, 367, -1, sizeof(::playapi::proto::finsky::OwnershipInfo)},
  { 384, 393, -1, sizeof(::playapi::proto::finsky::Image_Dimension)},
  { 396, 404, -1, sizeof(::playapi::proto::finsky::Image_Citation)},
  { 406, 428, -1, sizeof(::playapi::proto::finsky::Image)},
  { 444, 456, -1, sizeof(::playapi::proto::finsky::ImagePalette)},
  { 462, 472, -1, sizeof(::playapi::proto::finsky::Attribution)},
  { 476, -1, -1, sizeof(::playapi::proto::finsky::CertificateSet)},
  { 483, 492, -1, sizeof(::playapi::proto::finsky::EncodedTargets)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::playapi::proto::finsky::_HttpCookie_default_instance_._instance,
  &::playapi::proto::finsky::_TimePeriod_default_instance_._instance,
  &::playapi::proto::finsky::_MonthAndDay_default_instance_._instance,
  &::playapi::proto::finsky::_SignedData_default_instance_._instance,
  &::playapi::proto::finsky::_Docid_default_instance_._instance,
  &::playapi::proto::finsky::_Offer_default_instance_._instance,
  &::playapi::proto::finsky::_RentalTerms_default_instance_._instance,
  &::playapi::proto::finsky::_OfferPayment_default_instance_._instance,
  &::playapi::proto::finsky::_OfferPaymentPeriod_default_instance_._instance,
  &::playapi::proto::finsky::_OfferPaymentOverride_default_instance_._instance,
  &::playapi::proto::finsky::_SeasonalSubscriptionInfo_Payment_default_instance_._instance,
  &::playapi::proto::finsky::_SeasonalSubscriptionInfo_default_instance_._instance,
  &::playapi::proto::finsky::_SubscriptionTerms_SubscriptionReplacement_default_instance_._instance,
  &::playapi::proto::finsky::_SubscriptionTerms_default_instance_._instance,
  &::playapi::proto::finsky::_SubscriptionContentTerms_default_instance_._instance,
  &::playapi::proto::finsky::_GroupLicenseKey_default_instance_._instance,
  &::playapi::proto::finsky::_GroupLicenseInfo_default_instance_._instance,
  &::playapi::proto::finsky::_LicenseTerms_default_instance_._instance,
  &::playapi::proto::finsky::_LicensedDocumentInfo_default_instance_._instance,
  &::playapi::proto::finsky::_RedemptionRecordKey_default_instance_._instance,
  &::playapi::proto::finsky::_VoucherId_default_instance_._instance,
  &::playapi::proto::finsky::_VoucherOfferTerms_default_instance_._instance,
  &::playapi::proto::finsky::_LibraryVoucher_default_instance_._instance,
  &::playapi::proto::finsky::_OwnershipInfo_default_instance_._instance,
  &::playapi::proto::finsky::_Image_Dimension_default_instance_._instance,
  &::playapi::proto::finsky::_Image_Citation_default_instance_._instance,
  &::playapi::proto::finsky::_Image_default_instance_._instance,
  &::playapi::proto::finsky::_ImagePalette_default_instance_._instance,
  &::playapi::proto::finsky::_Attribution_default_instance_._instance,
  &::playapi::proto::finsky::_CertificateSet_default_instance_._instance,
  &::playapi::proto::finsky::_EncodedTargets_default_instance_._instance,
};

const char descriptor_table_protodef_play_5fcommon_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\021play_common.proto\022\024playapi.proto.finsk"
  "y\")\n\nHttpCookie\022\014\n\004name\030\001 \001(\t\022\r\n\005value\030\002"
  " \001(\t\")\n\nTimePeriod\022\014\n\004unit\030\001 \001(\005\022\r\n\005coun"
  "t\030\002 \001(\005\")\n\013MonthAndDay\022\r\n\005month\030\001 \001(\005\022\013\n"
  "\003day\030\002 \001(\005\"3\n\nSignedData\022\022\n\nsignedData\030\001"
  " \001(\t\022\021\n\tsignature\030\002 \001(\t\"<\n\005Docid\022\024\n\014back"
  "endDocid\030\001 \001(\t\022\014\n\004type\030\002 \001(\005\022\017\n\007backend\030"
  "\003 \001(\005\"\303\007\n\005Offer\022\016\n\006micros\030\001 \001(\003\022\024\n\014curre"
  "ncyCode\030\002 \001(\t\022\027\n\017formattedAmount\030\003 \001(\t\0223"
  "\n\016convertedPrice\030\004 \003(\0132\033.playapi.proto.f"
  "insky.Offer\022\034\n\024checkoutFlowRequired\030\005 \001("
  "\010\022\027\n\017fullPriceMicros\030\006 \001(\003\022\033\n\023formattedF"
  "ullAmount\030\007 \001(\t\022\021\n\tofferType\030\010 \001(\005\0226\n\013re"
  "ntalTerms\030\t \001(\0132!.playapi.proto.finsky.R"
  "entalTerms\022\022\n\nonSaleDate\030\n \001(\003\022\026\n\016promot"
  "ionLabel\030\013 \003(\t\022B\n\021subscriptionTerms\030\014 \001("
  "\0132\'.playapi.proto.finsky.SubscriptionTer"
  "ms\022\025\n\rformattedName\030\r \001(\t\022\034\n\024formattedDe"
  "scription\030\016 \001(\t\022\020\n\010preorder\030\017 \001(\010\022+\n#onS"
  "aleDateDisplayTimeZoneOffsetMsec\030\020 \001(\005\022\031"
  "\n\021licensedOfferType\030\021 \001(\005\022P\n\030subscriptio"
  "nContentTerms\030\022 \001(\0132..playapi.proto.fins"
  "ky.SubscriptionContentTerms\022\017\n\007offerId\030\023"
  " \001(\t\022&\n\036preorderFulfillmentDisplayDate\030\024"
  " \001(\003\0228\n\014licenseTerms\030\025 \001(\0132\".playapi.pro"
  "to.finsky.LicenseTerms\022\027\n\017temporarilyFre"
  "e\030\026 \001(\010\022=\n\014voucherTerms\030\027 \001(\0132\'.playapi."
  "proto.finsky.VoucherOfferTerms\0228\n\014offerP"
  "ayment\030\030 \003(\0132\".playapi.proto.finsky.Offe"
  "rPayment\022\031\n\021repeatLastPayment\030\031 \001(\010\022\026\n\016b"
  "uyButtonLabel\030\032 \001(\t\022\036\n\026instantPurchaseEn"
  "abled\030\033 \001(\010\"\352\001\n\013RentalTerms\022$\n\034DEPRECATE"
  "DGrantPeriodSeconds\030\001 \001(\005\022\'\n\037DEPRECATEDA"
  "ctivatePeriodSeconds\030\002 \001(\005\0225\n\013grantPerio"
  "d\030\003 \001(\0132 .playapi.proto.finsky.TimePerio"
  "d\0228\n\016activatePeriod\030\004 \001(\0132 .playapi.prot"
  "o.finsky.TimePeriod\022\033\n\023grantEndTimeSecon"
  "ds\030\005 \001(\003\"\304\001\n\014OfferPayment\022\016\n\006micros\030\001 \001("
  "\003\022\024\n\014currencyCode\030\002 \001(\t\022D\n\022offerPaymentP"
  "eriod\030\003 \001(\0132(.playapi.proto.finsky.Offer"
  "PaymentPeriod\022H\n\024offerPaymentOverride\030\004 "
  "\003(\0132*.playapi.proto.finsky.OfferPaymentO"
  "verride\"\252\001\n\022OfferPaymentPeriod\0222\n\010durati"
  "on\030\001 \001(\0132 .playapi.proto.finsky.TimePeri"
  "od\0220\n\005start\030\002 \001(\0132!.playapi.proto.finsky"
  ".MonthAndDay\022.\n\003end\030\003 \001(\0132!.playapi.prot"
  "o.finsky.MonthAndDay\"\210\001\n\024OfferPaymentOve"
  "rride\022\016\n\006micros\030\001 \001(\003\0220\n\005start\030\002 \001(\0132!.p"
  "layapi.proto.finsky.MonthAndDay\022.\n\003end\030\003"
  " \001(\0132!.playapi.proto.finsky.MonthAndDay\""
  "\362\002\n\030SeasonalSubscriptionInfo\0226\n\013periodSt"
  "art\030\001 \001(\0132!.playapi.proto.finsky.MonthAn"
  "dDay\0224\n\tperiodEnd\030\002 \001(\0132!.playapi.proto."
  "finsky.MonthAndDay\022\020\n\010prorated\030\004 \001(\010\022Z\n\032"
  "postTrialConversionPayment\030\005 \001(\01326.playa"
  "pi.proto.finsky.SeasonalSubscriptionInfo"
  ".Payment\032z\n\007Payment\022\016\n\006micros\030\001 \001(\003\022\024\n\014c"
  "urrencyCode\030\002 \001(\t\022\027\n\017formattedAmount\030\003 \001"
  "(\t\0220\n\006period\030\004 \001(\0132 .playapi.proto.finsk"
  "y.TimePeriod\"\255\006\n\021SubscriptionTerms\0229\n\017re"
  "curringPeriod\030\001 \001(\0132 .playapi.proto.fins"
  "ky.TimePeriod\0225\n\013trialPeriod\030\002 \001(\0132 .pla"
  "yapi.proto.finsky.TimePeriod\022*\n\"formatte"
  "dPriceWithRecurrencePeriod\030\003 \001(\t\022P\n\030seas"
  "onalSubscriptionInfo\030\004 \001(\0132..playapi.pro"
  "to.finsky.SeasonalSubscriptionInfo\0221\n\014re"
  "placeDocid\030\005 \003(\0132\033.playapi.proto.finsky."
  "Docid\0225\n\013gracePeriod\030\006 \001(\0132 .playapi.pro"
  "to.finsky.TimePeriod\022\020\n\010resignup\030\007 \001(\010\022&"
  "\n\036initialValidUntilTimestampMsec\030\010 \001(\003\022\037"
  "\n\027nextPaymentCurrencyCode\030\t \001(\t\022\036\n\026nextP"
  "aymentPriceMicros\030\n \001(\003\022%\n\035enableAppSpec"
  "ifiedTrialPeriod\030\013 \001(\010\022`\n\027subscriptionRe"
  "placement\030\014 \001(\0132\?.playapi.proto.finsky.S"
  "ubscriptionTerms.SubscriptionReplacement"
  "\032\271\001\n\027SubscriptionReplacement\022-\n\010newDocid"
  "\030\001 \001(\0132\033.playapi.proto.finsky.Docid\022-\n\010o"
  "ldDocid\030\002 \003(\0132\033.playapi.proto.finsky.Doc"
  "id\022\036\n\026keepNextRecurrenceTime\030\003 \001(\010\022 \n\030re"
  "placeOnFirstRecurrence\030\004 \001(\010\"U\n\030Subscrip"
  "tionContentTerms\0229\n\024requiredSubscription"
  "\030\001 \001(\0132\033.playapi.proto.finsky.Docid\"\232\001\n\017"
  "GroupLicenseKey\022\030\n\020dasherCustomerId\030\001 \001("
  "\006\022*\n\005docid\030\002 \001(\0132\033.playapi.proto.finsky."
  "Docid\022\031\n\021licensedOfferType\030\003 \001(\005\022\014\n\004type"
  "\030\004 \001(\005\022\030\n\020rentalPeriodDays\030\005 \001(\005\"\202\001\n\020Gro"
  "upLicenseInfo\022\031\n\021licensedOfferType\030\001 \001(\005"
  "\022\023\n\013gaiaGroupId\030\002 \001(\006\022>\n\017groupLicenseKey"
  "\030\003 \001(\0132%.playapi.proto.finsky.GroupLicen"
  "seKey\"N\n\014LicenseTerms\022>\n\017groupLicenseKey"
  "\030\001 \001(\0132%.playapi.proto.finsky.GroupLicen"
  "seKey\"\312\001\n\024LicensedDocumentInfo\022\023\n\013gaiaGr"
  "oupId\030\001 \003(\006\022#\n\033groupLicenseCheckoutOrder"
  "Id\030\002 \001(\t\022>\n\017groupLicenseKey\030\003 \001(\0132%.play"
  "api.proto.finsky.GroupLicenseKey\022\030\n\020assi"
  "gnedByGaiaId\030\004 \001(\006\022\036\n\026DEPRECATEDAssignme"
  "ntId\030\005 \001(\t\"s\n\023RedemptionRecordKey\022\023\n\013pub"
  "lisherId\030\001 \001(\003\022\022\n\ncampaignId\030\002 \001(\003\022\023\n\013co"
  "deGroupId\030\003 \001(\003\022\020\n\010recordId\030\004 \001(\003\022\014\n\004typ"
  "e\030\005 \001(\005\"v\n\tVoucherId\0221\n\014voucherDocid\030\001 \001"
  "(\0132\033.playapi.proto.finsky.Docid\0226\n\003key\030\002"
  " \001(\0132).playapi.proto.finsky.RedemptionRe"
  "cordKey\"\202\001\n\021VoucherOfferTerms\0221\n\014voucher"
  "Docid\030\001 \003(\0132\033.playapi.proto.finsky.Docid"
  "\022\032\n\022voucherPriceMicros\030\002 \001(\003\022\036\n\026voucherF"
  "ormattedAmount\030\003 \001(\t\"D\n\016LibraryVoucher\0222"
  "\n\tvoucherId\030\001 \001(\0132\037.playapi.proto.finsky"
  ".VoucherId\"\272\005\n\rOwnershipInfo\022\037\n\027initiati"
  "onTimestampMsec\030\001 \001(\003\022\037\n\027validUntilTimes"
  "tampMsec\030\002 \001(\003\022\024\n\014autoRenewing\030\003 \001(\010\022\"\n\032"
  "refundTimeoutTimestampMsec\030\004 \001(\003\022$\n\034post"
  "DeliveryRefundWindowMsec\030\005 \001(\003\022\?\n\025develo"
  "perPurchaseInfo\030\006 \001(\0132 .playapi.proto.fi"
  "nsky.SignedData\022\022\n\npreordered\030\007 \001(\010\022\016\n\006h"
  "idden\030\010 \001(\010\0226\n\013rentalTerms\030\t \001(\0132!.playa"
  "pi.proto.finsky.RentalTerms\022@\n\020groupLice"
  "nseInfo\030\n \001(\0132&.playapi.proto.finsky.Gro"
  "upLicenseInfo\022H\n\024licensedDocumentInfo\030\013 "
  "\001(\0132*.playapi.proto.finsky.LicensedDocum"
  "entInfo\022\020\n\010quantity\030\014 \001(\005\022&\n\036libraryExpi"
  "rationTimestampMsec\030\016 \001(\003\022<\n\016libraryVouc"
  "her\030\017 \001(\0132$.playapi.proto.finsky.Library"
  "Voucher\0220\n\013bundleDocid\030\020 \001(\0132\033.playapi.p"
  "roto.finsky.Docid\022\r\n\005bonus\030\021 \001(\010\022%\n\035stor"
  "edValidUntilTimestampMsec\030\022 \001(\003\"\373\004\n\005Imag"
  "e\022\021\n\timageType\030\001 \001(\005\0228\n\tdimension\030\002 \001(\n2"
  "%.playapi.proto.finsky.Image.Dimension\022\020"
  "\n\010imageUrl\030\005 \001(\t\022\030\n\020altTextLocalized\030\006 \001"
  "(\t\022\021\n\tsecureUrl\030\007 \001(\t\022\032\n\022positionInSeque"
  "nce\030\010 \001(\005\022\036\n\026supportsFifeUrlOptions\030\t \001("
  "\010\0226\n\010citation\030\n \001(\n2$.playapi.proto.fins"
  "ky.Image.Citation\022\027\n\017durationSeconds\030\016 \001"
  "(\005\022\024\n\014fillColorRgb\030\017 \001(\t\022\017\n\007autogen\030\020 \001("
  "\010\0226\n\013attribution\030\021 \001(\0132!.playapi.proto.f"
  "insky.Attribution\022\032\n\022backgroundColorRgb\030"
  "\023 \001(\t\0223\n\007palette\030\024 \001(\0132\".playapi.proto.f"
  "insky.ImagePalette\022\023\n\013deviceClass\030\025 \001(\005\022"
  "\"\n\032supportsFifeMonogramOption\030\026 \001(\010\032\?\n\tD"
  "imension\022\r\n\005width\030\003 \001(\005\022\016\n\006height\030\004 \001(\005\022"
  "\023\n\013aspectRatio\030\022 \001(\005\032/\n\010Citation\022\026\n\016titl"
  "eLocalized\030\013 \001(\t\022\013\n\003url\030\014 \001(\t\"\222\001\n\014ImageP"
  "alette\022\027\n\017lightVibrantRgb\030\001 \001(\t\022\022\n\nvibra"
  "ntRgb\030\002 \001(\t\022\026\n\016darkVibrantRgb\030\003 \001(\t\022\025\n\rl"
  "ightMutedRgb\030\004 \001(\t\022\020\n\010mutedRgb\030\005 \001(\t\022\024\n\014"
  "darkMutedRgb\030\006 \001(\t\"_\n\013Attribution\022\023\n\013sou"
  "rceTitle\030\001 \001(\t\022\021\n\tsourceUrl\030\002 \001(\t\022\024\n\014lic"
  "enseTitle\030\003 \001(\t\022\022\n\nlicenseUrl\030\004 \001(\t\")\n\016C"
  "ertificateSet\022\027\n\017certificateHash\030\001 \003(\t\"O"
  "\n\016EncodedTargets\022\017\n\007version\030\001 \001(\005\022\027\n\017sup"
  "portedTarget\030\002 \003(\003\022\023\n\013otherTarget\030\003 \003(\003"
  ;
static ::_pbi::once_flag descriptor_table_play_5fcommon_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_play_5fcommon_2eproto = {
    false, false, 5999, descriptor_table_protodef_play_5fcommon_2eproto,
    "play_common.proto",
    &descriptor_table_play_5fcommon_2eproto_once, nullptr, 0, 31,
    schemas, file_default_instances, TableStruct_play_5fcommon_2eproto::offsets,
    file_level_metadata_play_5fcommon_2eproto, file_level_enum_descriptors_play_5fcommon_2eproto,
    file_level_service_descriptors_play_5fcommon_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_play_5fcommon_2eproto_getter() {
  return &descriptor_table_play_5fcommon_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_play_5fcommon_2eproto(&descriptor_table_play_5fcommon_2eproto);
namespace playapi {
namespace proto {
namespace finsky {

// ===================================================================

class HttpCookie::_Internal {
 public:
  using HasBits = decltype(std::declval<HttpCookie>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

HttpCookie::HttpCookie(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:playapi.proto.finsky.HttpCookie)
}
HttpCookie::HttpCookie(const HttpCookie& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  HttpCookie* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.value_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_value()) {
    _this->_impl_.value_.Set(from._internal_value(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:playapi.proto.finsky.HttpCookie)
}

inline void HttpCookie::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.value_){}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

HttpCookie::~HttpCookie() {
  // @@protoc_insertion_point(destructor:playapi.proto.finsky.HttpCookie)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HttpCookie::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.value_.Destroy();
}

void HttpCookie::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void HttpCookie::Clear() {
// @@protoc_insertion_point(message_clear_start:playapi.proto.finsky.HttpCookie)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.value_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* HttpCookie::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "playapi.proto.finsky.HttpCookie.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "playapi.proto.finsky.HttpCookie.value");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HttpCookie::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:playapi.proto.finsky.HttpCookie)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "playapi.proto.finsky.HttpCookie.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional string value = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_value().data(), static_cast<int>(this->_internal_value().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "playapi.proto.finsky.HttpCookie.value");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:playapi.proto.finsky.HttpCookie)
  return target;
}

size_t HttpCookie::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:playapi.proto.finsky.HttpCookie)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string value = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_value());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HttpCookie::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    HttpCookie::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HttpCookie::GetClassData() const { return &_class_data_; }


void HttpCookie::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<HttpCookie*>(&to_msg);
  auto& from = static_cast<const HttpCookie&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:playapi.proto.finsky.HttpCookie)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_value(from._internal_value());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void HttpCookie::CopyFrom(const HttpCookie& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:playapi.proto.finsky.HttpCookie)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HttpCookie::IsInitialized() const {
  return true;
}

void HttpCookie::InternalSwap(HttpCookie* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata HttpCookie::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_play_5fcommon_2eproto_getter, &descriptor_table_play_5fcommon_2eproto_once,
      file_level_metadata_play_5fcommon_2eproto[0]);
}

// ===================================================================

class TimePeriod::_Internal {
 public:
  using HasBits = decltype(std::declval<TimePeriod>()._impl_._has_bits_);
  static void set_has_unit(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

TimePeriod::TimePeriod(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:playapi.proto.finsky.TimePeriod)
}
TimePeriod::TimePeriod(const TimePeriod& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TimePeriod* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.unit_){}
    , decltype(_impl_.count_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.unit_, &from._impl_.unit_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.count_) -
    reinterpret_cast<char*>(&_impl_.unit_)) + sizeof(_impl_.count_));
  // @@protoc_insertion_point(copy_constructor:playapi.proto.finsky.TimePeriod)
}

inline void TimePeriod::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.unit_){0}
    , decltype(_impl_.count_){0}
  };
}

TimePeriod::~TimePeriod() {
  // @@protoc_insertion_point(destructor:playapi.proto.finsky.TimePeriod)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TimePeriod::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TimePeriod::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TimePeriod::Clear() {
// @@protoc_insertion_point(message_clear_start:playapi.proto.finsky.TimePeriod)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.unit_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.count_) -
        reinterpret_cast<char*>(&_impl_.unit_)) + sizeof(_impl_.count_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TimePeriod::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 unit = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_unit(&has_bits);
          _impl_.unit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_count(&has_bits);
          _impl_.count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TimePeriod::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:playapi.proto.finsky.TimePeriod)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 unit = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_unit(), target);
  }

  // optional int32 count = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:playapi.proto.finsky.TimePeriod)
  return target;
}

size_t TimePeriod::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:playapi.proto.finsky.TimePeriod)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 unit = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_unit());
    }

    // optional int32 count = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_count());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TimePeriod::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TimePeriod::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TimePeriod::GetClassData() const { return &_class_data_; }


void TimePeriod::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TimePeriod*>(&to_msg);
  auto& from = static_cast<const TimePeriod&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:playapi.proto.finsky.TimePeriod)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.unit_ = from._impl_.unit_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.count_ = from._impl_.count_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TimePeriod::CopyFrom(const TimePeriod& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:playapi.proto.finsky.TimePeriod)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TimePeriod::IsInitialized() const {
  return true;
}

void TimePeriod::InternalSwap(TimePeriod* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TimePeriod, _impl_.count_)
      + sizeof(TimePeriod::_impl_.count_)
      - PROTOBUF_FIELD_OFFSET(TimePeriod, _impl_.unit_)>(
          reinterpret_cast<char*>(&_impl_.unit_),
          reinterpret_cast<char*>(&other->_impl_.unit_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TimePeriod::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_play_5fcommon_2eproto_getter, &descriptor_table_play_5fcommon_2eproto_once,
      file_level_metadata_play_5fcommon_2eproto[1]);
}

// ===================================================================

class MonthAndDay::_Internal {
 public:
  using HasBits = decltype(std::declval<MonthAndDay>()._impl_._has_bits_);
  static void set_has_month(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_day(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

MonthAndDay::MonthAndDay(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:playapi.proto.finsky.MonthAndDay)
}
MonthAndDay::MonthAndDay(const MonthAndDay& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MonthAndDay* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.month_){}
    , decltype(_impl_.day_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.month_, &from._impl_.month_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.day_) -
    reinterpret_cast<char*>(&_impl_.month_)) + sizeof(_impl_.day_));
  // @@protoc_insertion_point(copy_constructor:playapi.proto.finsky.MonthAndDay)
}

inline void MonthAndDay::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.month_){0}
    , decltype(_impl_.day_){0}
  };
}

MonthAndDay::~MonthAndDay() {
  // @@protoc_insertion_point(destructor:playapi.proto.finsky.MonthAndDay)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MonthAndDay::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MonthAndDay::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MonthAndDay::Clear() {
// @@protoc_insertion_point(message_clear_start:playapi.proto.finsky.MonthAndDay)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.month_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.day_) -
        reinterpret_cast<char*>(&_impl_.month_)) + sizeof(_impl_.day_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MonthAndDay::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 month = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_month(&has_bits);
          _impl_.month_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 day = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_day(&has_bits);
          _impl_.day_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MonthAndDay::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:playapi.proto.finsky.MonthAndDay)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 month = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_month(), target);
  }

  // optional int32 day = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_day(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:playapi.proto.finsky.MonthAndDay)
  return target;
}

size_t MonthAndDay::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:playapi.proto.finsky.MonthAndDay)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 month = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_month());
    }

    // optional int32 day = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_day());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MonthAndDay::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MonthAndDay::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MonthAndDay::GetClassData() const { return &_class_data_; }


void MonthAndDay::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MonthAndDay*>(&to_msg);
  auto& from = static_cast<const MonthAndDay&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:playapi.proto.finsky.MonthAndDay)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.month_ = from._impl_.month_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.day_ = from._impl_.day_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MonthAndDay::CopyFrom(const MonthAndDay& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:playapi.proto.finsky.MonthAndDay)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MonthAndDay::IsInitialized() const {
  return true;
}

void MonthAndDay::InternalSwap(MonthAndDay* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MonthAndDay, _impl_.day_)
      + sizeof(MonthAndDay::_impl_.day_)
      - PROTOBUF_FIELD_OFFSET(MonthAndDay, _impl_.month_)>(
          reinterpret_cast<char*>(&_impl_.month_),
          reinterpret_cast<char*>(&other->_impl_.month_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MonthAndDay::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_play_5fcommon_2eproto_getter, &descriptor_table_play_5fcommon_2eproto_once,
      file_level_metadata_play_5fcommon_2eproto[2]);
}

// ===================================================================

class SignedData::_Internal {
 public:
  using HasBits = decltype(std::declval<SignedData>()._impl_._has_bits_);
  static void set_has_signeddata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_signature(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

SignedData::SignedData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:playapi.proto.finsky.SignedData)
}
SignedData::SignedData(const SignedData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SignedData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.signeddata_){}
    , decltype(_impl_.signature_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.signeddata_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signeddata_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_signeddata()) {
    _this->_impl_.signeddata_.Set(from._internal_signeddata(), 
      _this->GetArenaForAllocation());
  }
  _impl_.signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_signature()) {
    _this->_impl_.signature_.Set(from._internal_signature(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:playapi.proto.finsky.SignedData)
}

inline void SignedData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.signeddata_){}
    , decltype(_impl_.signature_){}
  };
  _impl_.signeddata_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signeddata_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.signature_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signature_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SignedData::~SignedData() {
  // @@protoc_insertion_point(destructor:playapi.proto.finsky.SignedData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SignedData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.signeddata_.Destroy();
  _impl_.signature_.Destroy();
}

void SignedData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SignedData::Clear() {
// @@protoc_insertion_point(message_clear_start:playapi.proto.finsky.SignedData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.signeddata_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.signature_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SignedData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string signedData = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_signeddata();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "playapi.proto.finsky.SignedData.signedData");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string signature = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_signature();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "playapi.proto.finsky.SignedData.signature");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SignedData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:playapi.proto.finsky.SignedData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string signedData = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_signeddata().data(), static_cast<int>(this->_internal_signeddata().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "playapi.proto.finsky.SignedData.signedData");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_signeddata(), target);
  }

  // optional string signature = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_signature().data(), static_cast<int>(this->_internal_signature().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "playapi.proto.finsky.SignedData.signature");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_signature(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:playapi.proto.finsky.SignedData)
  return target;
}

size_t SignedData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:playapi.proto.finsky.SignedData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string signedData = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_signeddata());
    }

    // optional string signature = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_signature());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SignedData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SignedData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SignedData::GetClassData() const { return &_class_data_; }


void SignedData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SignedData*>(&to_msg);
  auto& from = static_cast<const SignedData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:playapi.proto.finsky.SignedData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_signeddata(from._internal_signeddata());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_signature(from._internal_signature());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SignedData::CopyFrom(const SignedData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:playapi.proto.finsky.SignedData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignedData::IsInitialized() const {
  return true;
}

void SignedData::InternalSwap(SignedData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.signeddata_, lhs_arena,
      &other->_impl_.signeddata_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.signature_, lhs_arena,
      &other->_impl_.signature_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata SignedData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_play_5fcommon_2eproto_getter, &descriptor_table_play_5fcommon_2eproto_once,
      file_level_metadata_play_5fcommon_2eproto[3]);
}

// ===================================================================

class Docid::_Internal {
 public:
  using HasBits = decltype(std::declval<Docid>()._impl_._has_bits_);
  static void set_has_backenddocid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_backend(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Docid::Docid(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:playapi.proto.finsky.Docid)
}
Docid::Docid(const Docid& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Docid* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.backenddocid_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.backend_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.backenddocid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.backenddocid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_backenddocid()) {
    _this->_impl_.backenddocid_.Set(from._internal_backenddocid(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.backend_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.backend_));
  // @@protoc_insertion_point(copy_constructor:playapi.proto.finsky.Docid)
}

inline void Docid::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.backenddocid_){}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.backend_){0}
  };
  _impl_.backenddocid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.backenddocid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Docid::~Docid() {
  // @@protoc_insertion_point(destructor:playapi.proto.finsky.Docid)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Docid::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.backenddocid_.Destroy();
}

void Docid::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Docid::Clear() {
// @@protoc_insertion_point(message_clear_start:playapi.proto.finsky.Docid)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.backenddocid_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.backend_) -
        reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.backend_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Docid::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string backendDocid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_backenddocid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "playapi.proto.finsky.Docid.backendDocid");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional int32 type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_type(&has_bits);
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 backend = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_backend(&has_bits);
          _impl_.backend_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Docid::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:playapi.proto.finsky.Docid)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string backendDocid = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_backenddocid().data(), static_cast<int>(this->_internal_backenddocid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "playapi.proto.finsky.Docid.backendDocid");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_backenddocid(), target);
  }

  // optional int32 type = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_type(), target);
  }

  // optional int32 backend = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_backend(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:playapi.proto.finsky.Docid)
  return target;
}

size_t Docid::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:playapi.proto.finsky.Docid)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string backendDocid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_backenddocid());
    }

    // optional int32 type = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_type());
    }

    // optional int32 backend = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_backend());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Docid::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Docid::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Docid::GetClassData() const { return &_class_data_; }


void Docid::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Docid*>(&to_msg);
  auto& from = static_cast<const Docid&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:playapi.proto.finsky.Docid)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_backenddocid(from._internal_backenddocid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.backend_ = from._impl_.backend_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Docid::CopyFrom(const Docid& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:playapi.proto.finsky.Docid)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Docid::IsInitialized() const {
  return true;
}

void Docid::InternalSwap(Docid* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.backenddocid_, lhs_arena,
      &other->_impl_.backenddocid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Docid, _impl_.backend_)
      + sizeof(Docid::_impl_.backend_)
      - PROTOBUF_FIELD_OFFSET(Docid, _impl_.type_)>(
          reinterpret_cast<char*>(&_impl_.type_),
          reinterpret_cast<char*>(&other->_impl_.type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Docid::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_play_5fcommon_2eproto_getter, &descriptor_table_play_5fcommon_2eproto_once,
      file_level_metadata_play_5fcommon_2eproto[4]);
}

// ===================================================================

class Offer::_Internal {
 public:
  using HasBits = decltype(std::declval<Offer>()._impl_._has_bits_);
  static void set_has_micros(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_currencycode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_formattedamount(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_checkoutflowrequired(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_fullpricemicros(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_formattedfullamount(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_offertype(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static const ::playapi::proto::finsky::RentalTerms& rentalterms(const Offer* msg);
  static void set_has_rentalterms(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_onsaledate(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static const ::playapi::proto::finsky::SubscriptionTerms& subscriptionterms(const Offer* msg);
  static void set_has_subscriptionterms(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_formattedname(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_formatteddescription(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_preorder(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_onsaledatedisplaytimezoneoffsetmsec(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_licensedoffertype(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static const ::playapi::proto::finsky::SubscriptionContentTerms& subscriptioncontentterms(const Offer* msg);
  static void set_has_subscriptioncontentterms(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_offerid(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_preorderfulfillmentdisplaydate(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static const ::playapi::proto::finsky::LicenseTerms& licenseterms(const Offer* msg);
  static void set_has_licenseterms(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_temporarilyfree(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static const ::playapi::proto::finsky::VoucherOfferTerms& voucherterms(const Offer* msg);
  static void set_has_voucherterms(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_repeatlastpayment(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_buybuttonlabel(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_instantpurchaseenabled(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
};

const ::playapi::proto::finsky::RentalTerms&
Offer::_Internal::rentalterms(const Offer* msg) {
  return *msg->_impl_.rentalterms_;
}
const ::playapi::proto::finsky::SubscriptionTerms&
Offer::_Internal::subscriptionterms(const Offer* msg) {
  return *msg->_impl_.subscriptionterms_;
}
const ::playapi::proto::finsky::SubscriptionContentTerms&
Offer::_Internal::subscriptioncontentterms(const Offer* msg) {
  return *msg->_impl_.subscriptioncontentterms_;
}
const ::playapi::proto::finsky::LicenseTerms&
Offer::_Internal::licenseterms(const Offer* msg) {
  return *msg->_impl_.licenseterms_;
}
const ::playapi::proto::finsky::VoucherOfferTerms&
Offer::_Internal::voucherterms(const Offer* msg) {
  return *msg->_impl_.voucherterms_;
}
Offer::Offer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:playapi.proto.finsky.Offer)
}
Offer::Offer(const Offer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Offer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.convertedprice_){from._impl_.convertedprice_}
    , decltype(_impl_.promotionlabel_){from._impl_.promotionlabel_}
    , decltype(_impl_.offerpayment_){from._impl_.offerpayment_}
    , decltype(_impl_.currencycode_){}
    , decltype(_impl_.formattedamount_){}
    , decltype(_impl_.formattedfullamount_){}
    , decltype(_impl_.formattedname_){}
    , decltype(_impl_.formatteddescription_){}
    , decltype(_impl_.offerid_){}
    , decltype(_impl_.buybuttonlabel_){}
    , decltype(_impl_.rentalterms_){nullptr}
    , decltype(_impl_.subscriptionterms_){nullptr}
    , decltype(_impl_.subscriptioncontentterms_){nullptr}
    , decltype(_impl_.licenseterms_){nullptr}
    , decltype(_impl_.voucherterms_){nullptr}
    , decltype(_impl_.micros_){}
    , decltype(_impl_.fullpricemicros_){}
    , decltype(_impl_.onsaledate_){}
    , decltype(_impl_.offertype_){}
    , decltype(_impl_.onsaledatedisplaytimezoneoffsetmsec_){}
    , decltype(_impl_.checkoutflowrequired_){}
    , decltype(_impl_.preorder_){}
    , decltype(_impl_.temporarilyfree_){}
    , decltype(_impl_.repeatlastpayment_){}
    , decltype(_impl_.licensedoffertype_){}
    , decltype(_impl_.preorderfulfillmentdisplaydate_){}
    , decltype(_impl_.instantpurchaseenabled_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.currencycode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.currencycode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_currencycode()) {
    _this->_impl_.currencycode_.Set(from._internal_currencycode(), 
      _this->GetArenaForAllocation());
  }
  _impl_.formattedamount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.formattedamount_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_formattedamount()) {
    _this->_impl_.formattedamount_.Set(from._internal_formattedamount(), 
      _this->GetArenaForAllocation());
  }
  _impl_.formattedfullamount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.formattedfullamount_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_formattedfullamount()) {
    _this->_impl_.formattedfullamount_.Set(from._internal_formattedfullamount(), 
      _this->GetArenaForAllocation());
  }
  _impl_.formattedname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.formattedname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_formattedname()) {
    _this->_impl_.formattedname_.Set(from._internal_formattedname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.formatteddescription_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.formatteddescription_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_formatteddescription()) {
    _this->_impl_.formatteddescription_.Set(from._internal_formatteddescription(), 
      _this->GetArenaForAllocation());
  }
  _impl_.offerid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.offerid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_offerid()) {
    _this->_impl_.offerid_.Set(from._internal_offerid(), 
      _this->GetArenaForAllocation());
  }
  _impl_.buybuttonlabel_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.buybuttonlabel_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_buybuttonlabel()) {
    _this->_impl_.buybuttonlabel_.Set(from._internal_buybuttonlabel(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_rentalterms()) {
    _this->_impl_.rentalterms_ = new ::playapi::proto::finsky::RentalTerms(*from._impl_.rentalterms_);
  }
  if (from._internal_has_subscriptionterms()) {
    _this->_impl_.subscriptionterms_ = new ::playapi::proto::finsky::SubscriptionTerms(*from._impl_.subscriptionterms_);
  }
  if (from._internal_has_subscriptioncontentterms()) {
    _this->_impl_.subscriptioncontentterms_ = new ::playapi::proto::finsky::SubscriptionContentTerms(*from._impl_.subscriptioncontentterms_);
  }
  if (from._internal_has_licenseterms()) {
    _this->_impl_.licenseterms_ = new ::playapi::proto::finsky::LicenseTerms(*from._impl_.licenseterms_);
  }
  if (from._internal_has_voucherterms()) {
    _this->_impl_.voucherterms_ = new ::playapi::proto::finsky::VoucherOfferTerms(*from._impl_.voucherterms_);
  }
  ::memcpy(&_impl_.micros_, &from._impl_.micros_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.instantpurchaseenabled_) -
    reinterpret_cast<char*>(&_impl_.micros_)) + sizeof(_impl_.instantpurchaseenabled_));
  // @@protoc_insertion_point(copy_constructor:playapi.proto.finsky.Offer)
}

inline void Offer::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.convertedprice_){arena}
    , decltype(_impl_.promotionlabel_){arena}
    , decltype(_impl_.offerpayment_){arena}
    , decltype(_impl_.currencycode_){}
    , decltype(_impl_.formattedamount_){}
    , decltype(_impl_.formattedfullamount_){}
    , decltype(_impl_.formattedname_){}
    , decltype(_impl_.formatteddescription_){}
    , decltype(_impl_.offerid_){}
    , decltype(_impl_.buybuttonlabel_){}
    , decltype(_impl_.rentalterms_){nullptr}
    , decltype(_impl_.subscriptionterms_){nullptr}
    , decltype(_impl_.subscriptioncontentterms_){nullptr}
    , decltype(_impl_.licenseterms_){nullptr}
    , decltype(_impl_.voucherterms_){nullptr}
    , decltype(_impl_.micros_){int64_t{0}}
    , decltype(_impl_.fullpricemicros_){int64_t{0}}
    , decltype(_impl_.onsaledate_){int64_t{0}}
    , decltype(_impl_.offertype_){0}
    , decltype(_impl_.onsaledatedisplaytimezoneoffsetmsec_){0}
    , decltype(_impl_.checkoutflowrequired_){false}
    , decltype(_impl_.preorder_){false}
    , decltype(_impl_.temporarilyfree_){false}
    , decltype(_impl_.repeatlastpayment_){false}
    , decltype(_impl_.licensedoffertype_){0}
    , decltype(_impl_.preorderfulfillmentdisplaydate_){int64_t{0}}
    , decltype(_impl_.instantpurchaseenabled_){false}
  };
  _impl_.currencycode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.currencycode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.formattedamount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.formattedamount_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.formattedfullamount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.formattedfullamount_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.formattedname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.formattedname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.formatteddescription_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.formatteddescription_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.offerid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.offerid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.buybuttonlabel_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.buybuttonlabel_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Offer::~Offer() {
  // @@protoc_insertion_point(destructor:playapi.proto.finsky.Offer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Offer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.convertedprice_.~RepeatedPtrField();
  _impl_.promotionlabel_.~RepeatedPtrField();
  _impl_.offerpayment_.~RepeatedPtrField();
  _impl_.currencycode_.Destroy();
  _impl_.formattedamount_.Destroy();
  _impl_.formattedfullamount_.Destroy();
  _impl_.formattedname_.Destroy();
  _impl_.formatteddescription_.Destroy();
  _impl_.offerid_.Destroy();
  _impl_.buybuttonlabel_.Destroy();
  if (this != internal_default_instance()) delete _impl_.rentalterms_;
  if (this != internal_default_instance()) delete _impl_.subscriptionterms_;
  if (this != internal_default_instance()) delete _impl_.subscriptioncontentterms_;
  if (this != internal_default_instance()) delete _impl_.licenseterms_;
  if (this != internal_default_instance()) delete _impl_.voucherterms_;
}

void Offer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Offer::Clear() {
// @@protoc_insertion_point(message_clear_start:playapi.proto.finsky.Offer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.convertedprice_.Clear();
  _impl_.promotionlabel_.Clear();
  _impl_.offerpayment_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.currencycode_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.formattedamount_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.formattedfullamount_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.formattedname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.formatteddescription_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.offerid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      _impl_.buybuttonlabel_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.rentalterms_ != nullptr);
      _impl_.rentalterms_->Clear();
    }
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(_impl_.subscriptionterms_ != nullptr);
      _impl_.subscriptionterms_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(_impl_.subscriptioncontentterms_ != nullptr);
      _impl_.subscriptioncontentterms_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(_impl_.licenseterms_ != nullptr);
      _impl_.licenseterms_->Clear();
    }
    if (cached_has_bits & 0x00000800u) {
      GOOGLE_DCHECK(_impl_.voucherterms_ != nullptr);
      _impl_.voucherterms_->Clear();
    }
  }
  if (cached_has_bits & 0x0000f000u) {
    ::memset(&_impl_.micros_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.offertype_) -
        reinterpret_cast<char*>(&_impl_.micros_)) + sizeof(_impl_.offertype_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&_impl_.onsaledatedisplaytimezoneoffsetmsec_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.instantpurchaseenabled_) -
        reinterpret_cast<char*>(&_impl_.onsaledatedisplaytimezoneoffsetmsec_)) + sizeof(_impl_.instantpurchaseenabled_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Offer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 micros = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_micros(&has_bits);
          _impl_.micros_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string currencyCode = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_currencycode();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "playapi.proto.finsky.Offer.currencyCode");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string formattedAmount = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_formattedamount();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "playapi.proto.finsky.Offer.formattedAmount");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated .playapi.proto.finsky.Offer convertedPrice = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_convertedprice(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool checkoutFlowRequired = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_checkoutflowrequired(&has_bits);
          _impl_.checkoutflowrequired_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 fullPriceMicros = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_fullpricemicros(&has_bits);
          _impl_.fullpricemicros_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string formattedFullAmount = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_formattedfullamount();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "playapi.proto.finsky.Offer.formattedFullAmount");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional int32 offerType = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_offertype(&has_bits);
          _impl_.offertype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .playapi.proto.finsky.RentalTerms rentalTerms = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_rentalterms(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 onSaleDate = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_onsaledate(&has_bits);
          _impl_.onsaledate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string promotionLabel = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_promotionlabel();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "playapi.proto.finsky.Offer.promotionLabel");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .playapi.proto.finsky.SubscriptionTerms subscriptionTerms = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_subscriptionterms(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string formattedName = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          auto str = _internal_mutable_formattedname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "playapi.proto.finsky.Offer.formattedName");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string formattedDescription = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          auto str = _internal_mutable_formatteddescription();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "playapi.proto.finsky.Offer.formattedDescription");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool preorder = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_preorder(&has_bits);
          _impl_.preorder_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 onSaleDateDisplayTimeZoneOffsetMsec = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_onsaledatedisplaytimezoneoffsetmsec(&has_bits);
          _impl_.onsaledatedisplaytimezoneoffsetmsec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 licensedOfferType = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_licensedoffertype(&has_bits);
          _impl_.licensedoffertype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .playapi.proto.finsky.SubscriptionContentTerms subscriptionContentTerms = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_subscriptioncontentterms(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string offerId = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          auto str = _internal_mutable_offerid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "playapi.proto.finsky.Offer.offerId");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional int64 preorderFulfillmentDisplayDate = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_preorderfulfillmentdisplaydate(&has_bits);
          _impl_.preorderfulfillmentdisplaydate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .playapi.proto.finsky.LicenseTerms licenseTerms = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_licenseterms(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool temporarilyFree = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _Internal::set_has_temporarilyfree(&has_bits);
          _impl_.temporarilyfree_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .playapi.proto.finsky.VoucherOfferTerms voucherTerms = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          ptr = ctx->ParseMessage(_internal_mutable_voucherterms(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .playapi.proto.finsky.OfferPayment offerPayment = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_offerpayment(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<194>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool repeatLastPayment = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
          _Internal::set_has_repeatlastpayment(&has_bits);
          _impl_.repeatlastpayment_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string buyButtonLabel = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 210)) {
          auto str = _internal_mutable_buybuttonlabel();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "playapi.proto.finsky.Offer.buyButtonLabel");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool instantPurchaseEnabled = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 216)) {
          _Internal::set_has_instantpurchaseenabled(&has_bits);
          _impl_.instantpurchaseenabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Offer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:playapi.proto.finsky.Offer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 micros = 1;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_micros(), target);
  }

  // optional string currencyCode = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_currencycode().data(), static_cast<int>(this->_internal_currencycode().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "playapi.proto.finsky.Offer.currencyCode");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_currencycode(), target);
  }

  // optional string formattedAmount = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_formattedamount().data(), static_cast<int>(this->_internal_formattedamount().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "playapi.proto.finsky.Offer.formattedAmount");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_formattedamount(), target);
  }

  // repeated .playapi.proto.finsky.Offer convertedPrice = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_convertedprice_size()); i < n; i++) {
    const auto& repfield = this->_internal_convertedprice(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool checkoutFlowRequired = 5;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_checkoutflowrequired(), target);
  }

  // optional int64 fullPriceMicros = 6;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(6, this->_internal_fullpricemicros(), target);
  }

  // optional string formattedFullAmount = 7;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_formattedfullamount().data(), static_cast<int>(this->_internal_formattedfullamount().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "playapi.proto.finsky.Offer.formattedFullAmount");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_formattedfullamount(), target);
  }

  // optional int32 offerType = 8;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_offertype(), target);
  }

  // optional .playapi.proto.finsky.RentalTerms rentalTerms = 9;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::rentalterms(this),
        _Internal::rentalterms(this).GetCachedSize(), target, stream);
  }

  // optional int64 onSaleDate = 10;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(10, this->_internal_onsaledate(), target);
  }

  // repeated string promotionLabel = 11;
  for (int i = 0, n = this->_internal_promotionlabel_size(); i < n; i++) {
    const auto& s = this->_internal_promotionlabel(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "playapi.proto.finsky.Offer.promotionLabel");
    target = stream->WriteString(11, s, target);
  }

  // optional .playapi.proto.finsky.SubscriptionTerms subscriptionTerms = 12;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::subscriptionterms(this),
        _Internal::subscriptionterms(this).GetCachedSize(), target, stream);
  }

  // optional string formattedName = 13;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_formattedname().data(), static_cast<int>(this->_internal_formattedname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "playapi.proto.finsky.Offer.formattedName");
    target = stream->WriteStringMaybeAliased(
        13, this->_internal_formattedname(), target);
  }

  // optional string formattedDescription = 14;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_formatteddescription().data(), static_cast<int>(this->_internal_formatteddescription().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "playapi.proto.finsky.Offer.formattedDescription");
    target = stream->WriteStringMaybeAliased(
        14, this->_internal_formatteddescription(), target);
  }

  // optional bool preorder = 15;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(15, this->_internal_preorder(), target);
  }

  // optional int32 onSaleDateDisplayTimeZoneOffsetMsec = 16;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(16, this->_internal_onsaledatedisplaytimezoneoffsetmsec(), target);
  }

  // optional int32 licensedOfferType = 17;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(17, this->_internal_licensedoffertype(), target);
  }

  // optional .playapi.proto.finsky.SubscriptionContentTerms subscriptionContentTerms = 18;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(18, _Internal::subscriptioncontentterms(this),
        _Internal::subscriptioncontentterms(this).GetCachedSize(), target, stream);
  }

  // optional string offerId = 19;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_offerid().data(), static_cast<int>(this->_internal_offerid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "playapi.proto.finsky.Offer.offerId");
    target = stream->WriteStringMaybeAliased(
        19, this->_internal_offerid(), target);
  }

  // optional int64 preorderFulfillmentDisplayDate = 20;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(20, this->_internal_preorderfulfillmentdisplaydate(), target);
  }

  // optional .playapi.proto.finsky.LicenseTerms licenseTerms = 21;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(21, _Internal::licenseterms(this),
        _Internal::licenseterms(this).GetCachedSize(), target, stream);
  }

  // optional bool temporarilyFree = 22;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(22, this->_internal_temporarilyfree(), target);
  }

  // optional .playapi.proto.finsky.VoucherOfferTerms voucherTerms = 23;
  if (cached_has_bits & 0x00000800u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(23, _Internal::voucherterms(this),
        _Internal::voucherterms(this).GetCachedSize(), target, stream);
  }

  // repeated .playapi.proto.finsky.OfferPayment offerPayment = 24;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_offerpayment_size()); i < n; i++) {
    const auto& repfield = this->_internal_offerpayment(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(24, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool repeatLastPayment = 25;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(25, this->_internal_repeatlastpayment(), target);
  }

  // optional string buyButtonLabel = 26;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_buybuttonlabel().data(), static_cast<int>(this->_internal_buybuttonlabel().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "playapi.proto.finsky.Offer.buyButtonLabel");
    target = stream->WriteStringMaybeAliased(
        26, this->_internal_buybuttonlabel(), target);
  }

  // optional bool instantPurchaseEnabled = 27;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(27, this->_internal_instantpurchaseenabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:playapi.proto.finsky.Offer)
  return target;
}

size_t Offer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:playapi.proto.finsky.Offer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .playapi.proto.finsky.Offer convertedPrice = 4;
  total_size += 1UL * this->_internal_convertedprice_size();
  for (const auto& msg : this->_impl_.convertedprice_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string promotionLabel = 11;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.promotionlabel_.size());
  for (int i = 0, n = _impl_.promotionlabel_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.promotionlabel_.Get(i));
  }

  // repeated .playapi.proto.finsky.OfferPayment offerPayment = 24;
  total_size += 2UL * this->_internal_offerpayment_size();
  for (const auto& msg : this->_impl_.offerpayment_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string currencyCode = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_currencycode());
    }

    // optional string formattedAmount = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_formattedamount());
    }

    // optional string formattedFullAmount = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_formattedfullamount());
    }

    // optional string formattedName = 13;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_formattedname());
    }

    // optional string formattedDescription = 14;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_formatteddescription());
    }

    // optional string offerId = 19;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_offerid());
    }

    // optional string buyButtonLabel = 26;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_buybuttonlabel());
    }

    // optional .playapi.proto.finsky.RentalTerms rentalTerms = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.rentalterms_);
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional .playapi.proto.finsky.SubscriptionTerms subscriptionTerms = 12;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.subscriptionterms_);
    }

    // optional .playapi.proto.finsky.SubscriptionContentTerms subscriptionContentTerms = 18;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.subscriptioncontentterms_);
    }

    // optional .playapi.proto.finsky.LicenseTerms licenseTerms = 21;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.licenseterms_);
    }

    // optional .playapi.proto.finsky.VoucherOfferTerms voucherTerms = 23;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.voucherterms_);
    }

    // optional int64 micros = 1;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_micros());
    }

    // optional int64 fullPriceMicros = 6;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_fullpricemicros());
    }

    // optional int64 onSaleDate = 10;
    if (cached_has_bits & 0x00004000u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_onsaledate());
    }

    // optional int32 offerType = 8;
    if (cached_has_bits & 0x00008000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_offertype());
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional int32 onSaleDateDisplayTimeZoneOffsetMsec = 16;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_onsaledatedisplaytimezoneoffsetmsec());
    }

    // optional bool checkoutFlowRequired = 5;
    if (cached_has_bits & 0x00020000u) {
      total_size += 1 + 1;
    }

    // optional bool preorder = 15;
    if (cached_has_bits & 0x00040000u) {
      total_size += 1 + 1;
    }

    // optional bool temporarilyFree = 22;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 + 1;
    }

    // optional bool repeatLastPayment = 25;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 + 1;
    }

    // optional int32 licensedOfferType = 17;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_licensedoffertype());
    }

    // optional int64 preorderFulfillmentDisplayDate = 20;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int64Size(
          this->_internal_preorderfulfillmentdisplaydate());
    }

    // optional bool instantPurchaseEnabled = 27;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Offer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Offer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Offer::GetClassData() const { return &_class_data_; }


void Offer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Offer*>(&to_msg);
  auto& from = static_cast<const Offer&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:playapi.proto.finsky.Offer)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.convertedprice_.MergeFrom(from._impl_.convertedprice_);
  _this->_impl_.promotionlabel_.MergeFrom(from._impl_.promotionlabel_);
  _this->_impl_.offerpayment_.MergeFrom(from._impl_.offerpayment_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_currencycode(from._internal_currencycode());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_formattedamount(from._internal_formattedamount());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_formattedfullamount(from._internal_formattedfullamount());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_formattedname(from._internal_formattedname());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_formatteddescription(from._internal_formatteddescription());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_offerid(from._internal_offerid());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_set_buybuttonlabel(from._internal_buybuttonlabel());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_rentalterms()->::playapi::proto::finsky::RentalTerms::MergeFrom(
          from._internal_rentalterms());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_mutable_subscriptionterms()->::playapi::proto::finsky::SubscriptionTerms::MergeFrom(
          from._internal_subscriptionterms());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_internal_mutable_subscriptioncontentterms()->::playapi::proto::finsky::SubscriptionContentTerms::MergeFrom(
          from._internal_subscriptioncontentterms());
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_internal_mutable_licenseterms()->::playapi::proto::finsky::LicenseTerms::MergeFrom(
          from._internal_licenseterms());
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_internal_mutable_voucherterms()->::playapi::proto::finsky::VoucherOfferTerms::MergeFrom(
          from._internal_voucherterms());
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.micros_ = from._impl_.micros_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.fullpricemicros_ = from._impl_.fullpricemicros_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.onsaledate_ = from._impl_.onsaledate_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.offertype_ = from._impl_.offertype_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.onsaledatedisplaytimezoneoffsetmsec_ = from._impl_.onsaledatedisplaytimezoneoffsetmsec_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.checkoutflowrequired_ = from._impl_.checkoutflowrequired_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.preorder_ = from._impl_.preorder_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.temporarilyfree_ = from._impl_.temporarilyfree_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.repeatlastpayment_ = from._impl_.repeatlastpayment_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.licensedoffertype_ = from._impl_.licensedoffertype_;
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_impl_.preorderfulfillmentdisplaydate_ = from._impl_.preorderfulfillmentdisplaydate_;
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_impl_.instantpurchaseenabled_ = from._impl_.instantpurchaseenabled_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Offer::CopyFrom(const Offer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:playapi.proto.finsky.Offer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Offer::IsInitialized() const {
  return true;
}

void Offer::InternalSwap(Offer* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.convertedprice_.InternalSwap(&other->_impl_.convertedprice_);
  _impl_.promotionlabel_.InternalSwap(&other->_impl_.promotionlabel_);
  _impl_.offerpayment_.InternalSwap(&other->_impl_.offerpayment_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.currencycode_, lhs_arena,
      &other->_impl_.currencycode_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.formattedamount_, lhs_arena,
      &other->_impl_.formattedamount_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.formattedfullamount_, lhs_arena,
      &other->_impl_.formattedfullamount_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.formattedname_, lhs_arena,
      &other->_impl_.formattedname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.formatteddescription_, lhs_arena,
      &other->_impl_.formatteddescription_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.offerid_, lhs_arena,
      &other->_impl_.offerid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.buybuttonlabel_, lhs_arena,
      &other->_impl_.buybuttonlabel_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Offer, _impl_.instantpurchaseenabled_)
      + sizeof(Offer::_impl_.instantpurchaseenabled_)
      - PROTOBUF_FIELD_OFFSET(Offer, _impl_.rentalterms_)>(
          reinterpret_cast<char*>(&_impl_.rentalterms_),
          reinterpret_cast<char*>(&other->_impl_.rentalterms_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Offer::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_play_5fcommon_2eproto_getter, &descriptor_table_play_5fcommon_2eproto_once,
      file_level_metadata_play_5fcommon_2eproto[5]);
}

// ===================================================================

class RentalTerms::_Internal {
 public:
  using HasBits = decltype(std::declval<RentalTerms>()._impl_._has_bits_);
  static void set_has_deprecatedgrantperiodseconds(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_deprecatedactivateperiodseconds(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::playapi::proto::finsky::TimePeriod& grantperiod(const RentalTerms* msg);
  static void set_has_grantperiod(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::playapi::proto::finsky::TimePeriod& activateperiod(const RentalTerms* msg);
  static void set_has_activateperiod(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_grantendtimeseconds(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::playapi::proto::finsky::TimePeriod&
RentalTerms::_Internal::grantperiod(const RentalTerms* msg) {
  return *msg->_impl_.grantperiod_;
}
const ::playapi::proto::finsky::TimePeriod&
RentalTerms::_Internal::activateperiod(const RentalTerms* msg) {
  return *msg->_impl_.activateperiod_;
}
RentalTerms::RentalTerms(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:playapi.proto.finsky.RentalTerms)
}
RentalTerms::RentalTerms(const RentalTerms& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RentalTerms* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.grantperiod_){nullptr}
    , decltype(_impl_.activateperiod_){nullptr}
    , decltype(_impl_.deprecatedgrantperiodseconds_){}
    , decltype(_impl_.deprecatedactivateperiodseconds_){}
    , decltype(_impl_.grantendtimeseconds_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_grantperiod()) {
    _this->_impl_.grantperiod_ = new ::playapi::proto::finsky::TimePeriod(*from._impl_.grantperiod_);
  }
  if (from._internal_has_activateperiod()) {
    _this->_impl_.activateperiod_ = new ::playapi::proto::finsky::TimePeriod(*from._impl_.activateperiod_);
  }
  ::memcpy(&_impl_.deprecatedgrantperiodseconds_, &from._impl_.deprecatedgrantperiodseconds_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.grantendtimeseconds_) -
    reinterpret_cast<char*>(&_impl_.deprecatedgrantperiodseconds_)) + sizeof(_impl_.grantendtimeseconds_));
  // @@protoc_insertion_point(copy_constructor:playapi.proto.finsky.RentalTerms)
}

inline void RentalTerms::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.grantperiod_){nullptr}
    , decltype(_impl_.activateperiod_){nullptr}
    , decltype(_impl_.deprecatedgrantperiodseconds_){0}
    , decltype(_impl_.deprecatedactivateperiodseconds_){0}
    , decltype(_impl_.grantendtimeseconds_){int64_t{0}}
  };
}

RentalTerms::~RentalTerms() {
  // @@protoc_insertion_point(destructor:playapi.proto.finsky.RentalTerms)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RentalTerms::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.grantperiod_;
  if (this != internal_default_instance()) delete _impl_.activateperiod_;
}

void RentalTerms::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RentalTerms::Clear() {
// @@protoc_insertion_point(message_clear_start:playapi.proto.finsky.RentalTerms)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.grantperiod_ != nullptr);
      _impl_.grantperiod_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.activateperiod_ != nullptr);
      _impl_.activateperiod_->Clear();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.deprecatedgrantperiodseconds_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.grantendtimeseconds_) -
        reinterpret_cast<char*>(&_impl_.deprecatedgrantperiodseconds_)) + sizeof(_impl_.grantendtimeseconds_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RentalTerms::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 DEPRECATEDGrantPeriodSeconds = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_deprecatedgrantperiodseconds(&has_bits);
          _impl_.deprecatedgrantperiodseconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 DEPRECATEDActivatePeriodSeconds = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_deprecatedactivateperiodseconds(&has_bits);
          _impl_.deprecatedactivateperiodseconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .playapi.proto.finsky.TimePeriod grantPeriod = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_grantperiod(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .playapi.proto.finsky.TimePeriod activatePeriod = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_activateperiod(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 grantEndTimeSeconds = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_grantendtimeseconds(&has_bits);
          _impl_.grantendtimeseconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RentalTerms::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:playapi.proto.finsky.RentalTerms)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 DEPRECATEDGrantPeriodSeconds = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_deprecatedgrantperiodseconds(), target);
  }

  // optional int32 DEPRECATEDActivatePeriodSeconds = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_deprecatedactivateperiodseconds(), target);
  }

  // optional .playapi.proto.finsky.TimePeriod grantPeriod = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::grantperiod(this),
        _Internal::grantperiod(this).GetCachedSize(), target, stream);
  }

  // optional .playapi.proto.finsky.TimePeriod activatePeriod = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::activateperiod(this),
        _Internal::activateperiod(this).GetCachedSize(), target, stream);
  }

  // optional int64 grantEndTimeSeconds = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_grantendtimeseconds(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:playapi.proto.finsky.RentalTerms)
  return target;
}

size_t RentalTerms::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:playapi.proto.finsky.RentalTerms)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .playapi.proto.finsky.TimePeriod grantPeriod = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.grantperiod_);
    }

    // optional .playapi.proto.finsky.TimePeriod activatePeriod = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.activateperiod_);
    }

    // optional int32 DEPRECATEDGrantPeriodSeconds = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_deprecatedgrantperiodseconds());
    }

    // optional int32 DEPRECATEDActivatePeriodSeconds = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_deprecatedactivateperiodseconds());
    }

    // optional int64 grantEndTimeSeconds = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_grantendtimeseconds());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RentalTerms::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RentalTerms::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RentalTerms::GetClassData() const { return &_class_data_; }


void RentalTerms::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RentalTerms*>(&to_msg);
  auto& from = static_cast<const RentalTerms&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:playapi.proto.finsky.RentalTerms)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_grantperiod()->::playapi::proto::finsky::TimePeriod::MergeFrom(
          from._internal_grantperiod());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_activateperiod()->::playapi::proto::finsky::TimePeriod::MergeFrom(
          from._internal_activateperiod());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.deprecatedgrantperiodseconds_ = from._impl_.deprecatedgrantperiodseconds_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.deprecatedactivateperiodseconds_ = from._impl_.deprecatedactivateperiodseconds_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.grantendtimeseconds_ = from._impl_.grantendtimeseconds_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RentalTerms::CopyFrom(const RentalTerms& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:playapi.proto.finsky.RentalTerms)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RentalTerms::IsInitialized() const {
  return true;
}

void RentalTerms::InternalSwap(RentalTerms* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RentalTerms, _impl_.grantendtimeseconds_)
      + sizeof(RentalTerms::_impl_.grantendtimeseconds_)
      - PROTOBUF_FIELD_OFFSET(RentalTerms, _impl_.grantperiod_)>(
          reinterpret_cast<char*>(&_impl_.grantperiod_),
          reinterpret_cast<char*>(&other->_impl_.grantperiod_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RentalTerms::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_play_5fcommon_2eproto_getter, &descriptor_table_play_5fcommon_2eproto_once,
      file_level_metadata_play_5fcommon_2eproto[6]);
}

// ===================================================================

class OfferPayment::_Internal {
 public:
  using HasBits = decltype(std::declval<OfferPayment>()._impl_._has_bits_);
  static void set_has_micros(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_currencycode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::playapi::proto::finsky::OfferPaymentPeriod& offerpaymentperiod(const OfferPayment* msg);
  static void set_has_offerpaymentperiod(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::playapi::proto::finsky::OfferPaymentPeriod&
OfferPayment::_Internal::offerpaymentperiod(const OfferPayment* msg) {
  return *msg->_impl_.offerpaymentperiod_;
}
OfferPayment::OfferPayment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:playapi.proto.finsky.OfferPayment)
}
OfferPayment::OfferPayment(const OfferPayment& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OfferPayment* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.offerpaymentoverride_){from._impl_.offerpaymentoverride_}
    , decltype(_impl_.currencycode_){}
    , decltype(_impl_.offerpaymentperiod_){nullptr}
    , decltype(_impl_.micros_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.currencycode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.currencycode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_currencycode()) {
    _this->_impl_.currencycode_.Set(from._internal_currencycode(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_offerpaymentperiod()) {
    _this->_impl_.offerpaymentperiod_ = new ::playapi::proto::finsky::OfferPaymentPeriod(*from._impl_.offerpaymentperiod_);
  }
  _this->_impl_.micros_ = from._impl_.micros_;
  // @@protoc_insertion_point(copy_constructor:playapi.proto.finsky.OfferPayment)
}

inline void OfferPayment::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.offerpaymentoverride_){arena}
    , decltype(_impl_.currencycode_){}
    , decltype(_impl_.offerpaymentperiod_){nullptr}
    , decltype(_impl_.micros_){int64_t{0}}
  };
  _impl_.currencycode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.currencycode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

OfferPayment::~OfferPayment() {
  // @@protoc_insertion_point(destructor:playapi.proto.finsky.OfferPayment)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OfferPayment::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.offerpaymentoverride_.~RepeatedPtrField();
  _impl_.currencycode_.Destroy();
  if (this != internal_default_instance()) delete _impl_.offerpaymentperiod_;
}

void OfferPayment::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OfferPayment::Clear() {
// @@protoc_insertion_point(message_clear_start:playapi.proto.finsky.OfferPayment)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.offerpaymentoverride_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.currencycode_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.offerpaymentperiod_ != nullptr);
      _impl_.offerpaymentperiod_->Clear();
    }
  }
  _impl_.micros_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OfferPayment::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 micros = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_micros(&has_bits);
          _impl_.micros_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string currencyCode = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_currencycode();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "playapi.proto.finsky.OfferPayment.currencyCode");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .playapi.proto.finsky.OfferPaymentPeriod offerPaymentPeriod = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_offerpaymentperiod(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .playapi.proto.finsky.OfferPaymentOverride offerPaymentOverride = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_offerpaymentoverride(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OfferPayment::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:playapi.proto.finsky.OfferPayment)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 micros = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_micros(), target);
  }

  // optional string currencyCode = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_currencycode().data(), static_cast<int>(this->_internal_currencycode().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "playapi.proto.finsky.OfferPayment.currencyCode");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_currencycode(), target);
  }

  // optional .playapi.proto.finsky.OfferPaymentPeriod offerPaymentPeriod = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::offerpaymentperiod(this),
        _Internal::offerpaymentperiod(this).GetCachedSize(), target, stream);
  }

  // repeated .playapi.proto.finsky.OfferPaymentOverride offerPaymentOverride = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_offerpaymentoverride_size()); i < n; i++) {
    const auto& repfield = this->_internal_offerpaymentoverride(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:playapi.proto.finsky.OfferPayment)
  return target;
}

size_t OfferPayment::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:playapi.proto.finsky.OfferPayment)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .playapi.proto.finsky.OfferPaymentOverride offerPaymentOverride = 4;
  total_size += 1UL * this->_internal_offerpaymentoverride_size();
  for (const auto& msg : this->_impl_.offerpaymentoverride_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string currencyCode = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_currencycode());
    }

    // optional .playapi.proto.finsky.OfferPaymentPeriod offerPaymentPeriod = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.offerpaymentperiod_);
    }

    // optional int64 micros = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_micros());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OfferPayment::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OfferPayment::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OfferPayment::GetClassData() const { return &_class_data_; }


void OfferPayment::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OfferPayment*>(&to_msg);
  auto& from = static_cast<const OfferPayment&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:playapi.proto.finsky.OfferPayment)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.offerpaymentoverride_.MergeFrom(from._impl_.offerpaymentoverride_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_currencycode(from._internal_currencycode());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_offerpaymentperiod()->::playapi::proto::finsky::OfferPaymentPeriod::MergeFrom(
          from._internal_offerpaymentperiod());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.micros_ = from._impl_.micros_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OfferPayment::CopyFrom(const OfferPayment& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:playapi.proto.finsky.OfferPayment)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OfferPayment::IsInitialized() const {
  return true;
}

void OfferPayment::InternalSwap(OfferPayment* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.offerpaymentoverride_.InternalSwap(&other->_impl_.offerpaymentoverride_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.currencycode_, lhs_arena,
      &other->_impl_.currencycode_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OfferPayment, _impl_.micros_)
      + sizeof(OfferPayment::_impl_.micros_)
      - PROTOBUF_FIELD_OFFSET(OfferPayment, _impl_.offerpaymentperiod_)>(
          reinterpret_cast<char*>(&_impl_.offerpaymentperiod_),
          reinterpret_cast<char*>(&other->_impl_.offerpaymentperiod_));
}

::PROTOBUF_NAMESPACE_ID::Metadata OfferPayment::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_play_5fcommon_2eproto_getter, &descriptor_table_play_5fcommon_2eproto_once,
      file_level_metadata_play_5fcommon_2eproto[7]);
}

// ===================================================================

class OfferPaymentPeriod::_Internal {
 public:
  using HasBits = decltype(std::declval<OfferPaymentPeriod>()._impl_._has_bits_);
  static const ::playapi::proto::finsky::TimePeriod& duration(const OfferPaymentPeriod* msg);
  static void set_has_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::playapi::proto::finsky::MonthAndDay& start(const OfferPaymentPeriod* msg);
  static void set_has_start(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::playapi::proto::finsky::MonthAndDay& end(const OfferPaymentPeriod* msg);
  static void set_has_end(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::playapi::proto::finsky::TimePeriod&
OfferPaymentPeriod::_Internal::duration(const OfferPaymentPeriod* msg) {
  return *msg->_impl_.duration_;
}
const ::playapi::proto::finsky::MonthAndDay&
OfferPaymentPeriod::_Internal::start(const OfferPaymentPeriod* msg) {
  return *msg->_impl_.start_;
}
const ::playapi::proto::finsky::MonthAndDay&
OfferPaymentPeriod::_Internal::end(const OfferPaymentPeriod* msg) {
  return *msg->_impl_.end_;
}
OfferPaymentPeriod::OfferPaymentPeriod(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:playapi.proto.finsky.OfferPaymentPeriod)
}
OfferPaymentPeriod::OfferPaymentPeriod(const OfferPaymentPeriod& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OfferPaymentPeriod* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.duration_){nullptr}
    , decltype(_impl_.start_){nullptr}
    , decltype(_impl_.end_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_duration()) {
    _this->_impl_.duration_ = new ::playapi::proto::finsky::TimePeriod(*from._impl_.duration_);
  }
  if (from._internal_has_start()) {
    _this->_impl_.start_ = new ::playapi::proto::finsky::MonthAndDay(*from._impl_.start_);
  }
  if (from._internal_has_end()) {
    _this->_impl_.end_ = new ::playapi::proto::finsky::MonthAndDay(*from._impl_.end_);
  }
  // @@protoc_insertion_point(copy_constructor:playapi.proto.finsky.OfferPaymentPeriod)
}

inline void OfferPaymentPeriod::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.duration_){nullptr}
    , decltype(_impl_.start_){nullptr}
    , decltype(_impl_.end_){nullptr}
  };
}

OfferPaymentPeriod::~OfferPaymentPeriod() {
  // @@protoc_insertion_point(destructor:playapi.proto.finsky.OfferPaymentPeriod)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OfferPaymentPeriod::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.duration_;
  if (this != internal_default_instance()) delete _impl_.start_;
  if (this != internal_default_instance()) delete _impl_.end_;
}

void OfferPaymentPeriod::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OfferPaymentPeriod::Clear() {
// @@protoc_insertion_point(message_clear_start:playapi.proto.finsky.OfferPaymentPeriod)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.duration_ != nullptr);
      _impl_.duration_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.start_ != nullptr);
      _impl_.start_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.end_ != nullptr);
      _impl_.end_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OfferPaymentPeriod::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .playapi.proto.finsky.TimePeriod duration = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_duration(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .playapi.proto.finsky.MonthAndDay start = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_start(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .playapi.proto.finsky.MonthAndDay end = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_end(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OfferPaymentPeriod::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:playapi.proto.finsky.OfferPaymentPeriod)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .playapi.proto.finsky.TimePeriod duration = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::duration(this),
        _Internal::duration(this).GetCachedSize(), target, stream);
  }

  // optional .playapi.proto.finsky.MonthAndDay start = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::start(this),
        _Internal::start(this).GetCachedSize(), target, stream);
  }

  // optional .playapi.proto.finsky.MonthAndDay end = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::end(this),
        _Internal::end(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:playapi.proto.finsky.OfferPaymentPeriod)
  return target;
}

size_t OfferPaymentPeriod::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:playapi.proto.finsky.OfferPaymentPeriod)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .playapi.proto.finsky.TimePeriod duration = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.duration_);
    }

    // optional .playapi.proto.finsky.MonthAndDay start = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.start_);
    }

    // optional .playapi.proto.finsky.MonthAndDay end = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.end_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OfferPaymentPeriod::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OfferPaymentPeriod::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OfferPaymentPeriod::GetClassData() const { return &_class_data_; }


void OfferPaymentPeriod::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OfferPaymentPeriod*>(&to_msg);
  auto& from = static_cast<const OfferPaymentPeriod&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:playapi.proto.finsky.OfferPaymentPeriod)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_duration()->::playapi::proto::finsky::TimePeriod::MergeFrom(
          from._internal_duration());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_start()->::playapi::proto::finsky::MonthAndDay::MergeFrom(
          from._internal_start());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_end()->::playapi::proto::finsky::MonthAndDay::MergeFrom(
          from._internal_end());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OfferPaymentPeriod::CopyFrom(const OfferPaymentPeriod& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:playapi.proto.finsky.OfferPaymentPeriod)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OfferPaymentPeriod::IsInitialized() const {
  return true;
}

void OfferPaymentPeriod::InternalSwap(OfferPaymentPeriod* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OfferPaymentPeriod, _impl_.end_)
      + sizeof(OfferPaymentPeriod::_impl_.end_)
      - PROTOBUF_FIELD_OFFSET(OfferPaymentPeriod, _impl_.duration_)>(
          reinterpret_cast<char*>(&_impl_.duration_),
          reinterpret_cast<char*>(&other->_impl_.duration_));
}

::PROTOBUF_NAMESPACE_ID::Metadata OfferPaymentPeriod::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_play_5fcommon_2eproto_getter, &descriptor_table_play_5fcommon_2eproto_once,
      file_level_metadata_play_5fcommon_2eproto[8]);
}

// ===================================================================

class OfferPaymentOverride::_Internal {
 public:
  using HasBits = decltype(std::declval<OfferPaymentOverride>()._impl_._has_bits_);
  static void set_has_micros(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::playapi::proto::finsky::MonthAndDay& start(const OfferPaymentOverride* msg);
  static void set_has_start(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::playapi::proto::finsky::MonthAndDay& end(const OfferPaymentOverride* msg);
  static void set_has_end(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::playapi::proto::finsky::MonthAndDay&
OfferPaymentOverride::_Internal::start(const OfferPaymentOverride* msg) {
  return *msg->_impl_.start_;
}
const ::playapi::proto::finsky::MonthAndDay&
OfferPaymentOverride::_Internal::end(const OfferPaymentOverride* msg) {
  return *msg->_impl_.end_;
}
OfferPaymentOverride::OfferPaymentOverride(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:playapi.proto.finsky.OfferPaymentOverride)
}
OfferPaymentOverride::OfferPaymentOverride(const OfferPaymentOverride& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OfferPaymentOverride* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.start_){nullptr}
    , decltype(_impl_.end_){nullptr}
    , decltype(_impl_.micros_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_start()) {
    _this->_impl_.start_ = new ::playapi::proto::finsky::MonthAndDay(*from._impl_.start_);
  }
  if (from._internal_has_end()) {
    _this->_impl_.end_ = new ::playapi::proto::finsky::MonthAndDay(*from._impl_.end_);
  }
  _this->_impl_.micros_ = from._impl_.micros_;
  // @@protoc_insertion_point(copy_constructor:playapi.proto.finsky.OfferPaymentOverride)
}

inline void OfferPaymentOverride::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.start_){nullptr}
    , decltype(_impl_.end_){nullptr}
    , decltype(_impl_.micros_){int64_t{0}}
  };
}

OfferPaymentOverride::~OfferPaymentOverride() {
  // @@protoc_insertion_point(destructor:playapi.proto.finsky.OfferPaymentOverride)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OfferPaymentOverride::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.start_;
  if (this != internal_default_instance()) delete _impl_.end_;
}

void OfferPaymentOverride::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OfferPaymentOverride::Clear() {
// @@protoc_insertion_point(message_clear_start:playapi.proto.finsky.OfferPaymentOverride)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.start_ != nullptr);
      _impl_.start_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.end_ != nullptr);
      _impl_.end_->Clear();
    }
  }
  _impl_.micros_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OfferPaymentOverride::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 micros = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_micros(&has_bits);
          _impl_.micros_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .playapi.proto.finsky.MonthAndDay start = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_start(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .playapi.proto.finsky.MonthAndDay end = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_end(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OfferPaymentOverride::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:playapi.proto.finsky.OfferPaymentOverride)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 micros = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_micros(), target);
  }

  // optional .playapi.proto.finsky.MonthAndDay start = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::start(this),
        _Internal::start(this).GetCachedSize(), target, stream);
  }

  // optional .playapi.proto.finsky.MonthAndDay end = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::end(this),
        _Internal::end(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:playapi.proto.finsky.OfferPaymentOverride)
  return target;
}

size_t OfferPaymentOverride::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:playapi.proto.finsky.OfferPaymentOverride)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .playapi.proto.finsky.MonthAndDay start = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.start_);
    }

    // optional .playapi.proto.finsky.MonthAndDay end = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.end_);
    }

    // optional int64 micros = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_micros());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OfferPaymentOverride::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OfferPaymentOverride::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OfferPaymentOverride::GetClassData() const { return &_class_data_; }


void OfferPaymentOverride::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OfferPaymentOverride*>(&to_msg);
  auto& from = static_cast<const OfferPaymentOverride&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:playapi.proto.finsky.OfferPaymentOverride)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_start()->::playapi::proto::finsky::MonthAndDay::MergeFrom(
          from._internal_start());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_end()->::playapi::proto::finsky::MonthAndDay::MergeFrom(
          from._internal_end());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.micros_ = from._impl_.micros_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OfferPaymentOverride::CopyFrom(const OfferPaymentOverride& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:playapi.proto.finsky.OfferPaymentOverride)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OfferPaymentOverride::IsInitialized() const {
  return true;
}

void OfferPaymentOverride::InternalSwap(OfferPaymentOverride* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OfferPaymentOverride, _impl_.micros_)
      + sizeof(OfferPaymentOverride::_impl_.micros_)
      - PROTOBUF_FIELD_OFFSET(OfferPaymentOverride, _impl_.start_)>(
          reinterpret_cast<char*>(&_impl_.start_),
          reinterpret_cast<char*>(&other->_impl_.start_));
}

::PROTOBUF_NAMESPACE_ID::Metadata OfferPaymentOverride::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_play_5fcommon_2eproto_getter, &descriptor_table_play_5fcommon_2eproto_once,
      file_level_metadata_play_5fcommon_2eproto[9]);
}

// ===================================================================

class SeasonalSubscriptionInfo_Payment::_Internal {
 public:
  using HasBits = decltype(std::declval<SeasonalSubscriptionInfo_Payment>()._impl_._has_bits_);
  static void set_has_micros(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_currencycode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_formattedamount(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::playapi::proto::finsky::TimePeriod& period(const SeasonalSubscriptionInfo_Payment* msg);
  static void set_has_period(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::playapi::proto::finsky::TimePeriod&
SeasonalSubscriptionInfo_Payment::_Internal::period(const SeasonalSubscriptionInfo_Payment* msg) {
  return *msg->_impl_.period_;
}
SeasonalSubscriptionInfo_Payment::SeasonalSubscriptionInfo_Payment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:playapi.proto.finsky.SeasonalSubscriptionInfo.Payment)
}
SeasonalSubscriptionInfo_Payment::SeasonalSubscriptionInfo_Payment(const SeasonalSubscriptionInfo_Payment& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SeasonalSubscriptionInfo_Payment* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.currencycode_){}
    , decltype(_impl_.formattedamount_){}
    , decltype(_impl_.period_){nullptr}
    , decltype(_impl_.micros_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.currencycode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.currencycode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_currencycode()) {
    _this->_impl_.currencycode_.Set(from._internal_currencycode(), 
      _this->GetArenaForAllocation());
  }
  _impl_.formattedamount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.formattedamount_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_formattedamount()) {
    _this->_impl_.formattedamount_.Set(from._internal_formattedamount(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_period()) {
    _this->_impl_.period_ = new ::playapi::proto::finsky::TimePeriod(*from._impl_.period_);
  }
  _this->_impl_.micros_ = from._impl_.micros_;
  // @@protoc_insertion_point(copy_constructor:playapi.proto.finsky.SeasonalSubscriptionInfo.Payment)
}

inline void SeasonalSubscriptionInfo_Payment::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.currencycode_){}
    , decltype(_impl_.formattedamount_){}
    , decltype(_impl_.period_){nullptr}
    , decltype(_impl_.micros_){int64_t{0}}
  };
  _impl_.currencycode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.currencycode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.formattedamount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.formattedamount_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SeasonalSubscriptionInfo_Payment::~SeasonalSubscriptionInfo_Payment() {
  // @@protoc_insertion_point(destructor:playapi.proto.finsky.SeasonalSubscriptionInfo.Payment)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SeasonalSubscriptionInfo_Payment::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.currencycode_.Destroy();
  _impl_.formattedamount_.Destroy();
  if (this != internal_default_instance()) delete _impl_.period_;
}

void SeasonalSubscriptionInfo_Payment::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SeasonalSubscriptionInfo_Payment::Clear() {
// @@protoc_insertion_point(message_clear_start:playapi.proto.finsky.SeasonalSubscriptionInfo.Payment)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.currencycode_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.formattedamount_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.period_ != nullptr);
      _impl_.period_->Clear();
    }
  }
  _impl_.micros_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SeasonalSubscriptionInfo_Payment::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 micros = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_micros(&has_bits);
          _impl_.micros_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string currencyCode = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_currencycode();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "playapi.proto.finsky.SeasonalSubscriptionInfo.Payment.currencyCode");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string formattedAmount = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_formattedamount();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "playapi.proto.finsky.SeasonalSubscriptionInfo.Payment.formattedAmount");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .playapi.proto.finsky.TimePeriod period = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_period(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SeasonalSubscriptionInfo_Payment::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:playapi.proto.finsky.SeasonalSubscriptionInfo.Payment)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 micros = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_micros(), target);
  }

  // optional string currencyCode = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_currencycode().data(), static_cast<int>(this->_internal_currencycode().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "playapi.proto.finsky.SeasonalSubscriptionInfo.Payment.currencyCode");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_currencycode(), target);
  }

  // optional string formattedAmount = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_formattedamount().data(), static_cast<int>(this->_internal_formattedamount().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "playapi.proto.finsky.SeasonalSubscriptionInfo.Payment.formattedAmount");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_formattedamount(), target);
  }

  // optional .playapi.proto.finsky.TimePeriod period = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::period(this),
        _Internal::period(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:playapi.proto.finsky.SeasonalSubscriptionInfo.Payment)
  return target;
}

size_t SeasonalSubscriptionInfo_Payment::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:playapi.proto.finsky.SeasonalSubscriptionInfo.Payment)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string currencyCode = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_currencycode());
    }

    // optional string formattedAmount = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_formattedamount());
    }

    // optional .playapi.proto.finsky.TimePeriod period = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.period_);
    }

    // optional int64 micros = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_micros());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SeasonalSubscriptionInfo_Payment::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SeasonalSubscriptionInfo_Payment::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SeasonalSubscriptionInfo_Payment::GetClassData() const { return &_class_data_; }


void SeasonalSubscriptionInfo_Payment::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SeasonalSubscriptionInfo_Payment*>(&to_msg);
  auto& from = static_cast<const SeasonalSubscriptionInfo_Payment&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:playapi.proto.finsky.SeasonalSubscriptionInfo.Payment)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_currencycode(from._internal_currencycode());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_formattedamount(from._internal_formattedamount());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_period()->::playapi::proto::finsky::TimePeriod::MergeFrom(
          from._internal_period());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.micros_ = from._impl_.micros_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SeasonalSubscriptionInfo_Payment::CopyFrom(const SeasonalSubscriptionInfo_Payment& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:playapi.proto.finsky.SeasonalSubscriptionInfo.Payment)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SeasonalSubscriptionInfo_Payment::IsInitialized() const {
  return true;
}

void SeasonalSubscriptionInfo_Payment::InternalSwap(SeasonalSubscriptionInfo_Payment* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.currencycode_, lhs_arena,
      &other->_impl_.currencycode_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.formattedamount_, lhs_arena,
      &other->_impl_.formattedamount_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SeasonalSubscriptionInfo_Payment, _impl_.micros_)
      + sizeof(SeasonalSubscriptionInfo_Payment::_impl_.micros_)
      - PROTOBUF_FIELD_OFFSET(SeasonalSubscriptionInfo_Payment, _impl_.period_)>(
          reinterpret_cast<char*>(&_impl_.period_),
          reinterpret_cast<char*>(&other->_impl_.period_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SeasonalSubscriptionInfo_Payment::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_play_5fcommon_2eproto_getter, &descriptor_table_play_5fcommon_2eproto_once,
      file_level_metadata_play_5fcommon_2eproto[10]);
}

// ===================================================================

class SeasonalSubscriptionInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<SeasonalSubscriptionInfo>()._impl_._has_bits_);
  static const ::playapi::proto::finsky::MonthAndDay& periodstart(const SeasonalSubscriptionInfo* msg);
  static void set_has_periodstart(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::playapi::proto::finsky::MonthAndDay& periodend(const SeasonalSubscriptionInfo* msg);
  static void set_has_periodend(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_prorated(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::playapi::proto::finsky::SeasonalSubscriptionInfo_Payment& posttrialconversionpayment(const SeasonalSubscriptionInfo* msg);
  static void set_has_posttrialconversionpayment(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::playapi::proto::finsky::MonthAndDay&
SeasonalSubscriptionInfo::_Internal::periodstart(const SeasonalSubscriptionInfo* msg) {
  return *msg->_impl_.periodstart_;
}
const ::playapi::proto::finsky::MonthAndDay&
SeasonalSubscriptionInfo::_Internal::periodend(const SeasonalSubscriptionInfo* msg) {
  return *msg->_impl_.periodend_;
}
const ::playapi::proto::finsky::SeasonalSubscriptionInfo_Payment&
SeasonalSubscriptionInfo::_Internal::posttrialconversionpayment(const SeasonalSubscriptionInfo* msg) {
  return *msg->_impl_.posttrialconversionpayment_;
}
SeasonalSubscriptionInfo::SeasonalSubscriptionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:playapi.proto.finsky.SeasonalSubscriptionInfo)
}
SeasonalSubscriptionInfo::SeasonalSubscriptionInfo(const SeasonalSubscriptionInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SeasonalSubscriptionInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.periodstart_){nullptr}
    , decltype(_impl_.periodend_){nullptr}
    , decltype(_impl_.posttrialconversionpayment_){nullptr}
    , decltype(_impl_.prorated_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_periodstart()) {
    _this->_impl_.periodstart_ = new ::playapi::proto::finsky::MonthAndDay(*from._impl_.periodstart_);
  }
  if (from._internal_has_periodend()) {
    _this->_impl_.periodend_ = new ::playapi::proto::finsky::MonthAndDay(*from._impl_.periodend_);
  }
  if (from._internal_has_posttrialconversionpayment()) {
    _this->_impl_.posttrialconversionpayment_ = new ::playapi::proto::finsky::SeasonalSubscriptionInfo_Payment(*from._impl_.posttrialconversionpayment_);
  }
  _this->_impl_.prorated_ = from._impl_.prorated_;
  // @@protoc_insertion_point(copy_constructor:playapi.proto.finsky.SeasonalSubscriptionInfo)
}

inline void SeasonalSubscriptionInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.periodstart_){nullptr}
    , decltype(_impl_.periodend_){nullptr}
    , decltype(_impl_.posttrialconversionpayment_){nullptr}
    , decltype(_impl_.prorated_){false}
  };
}

SeasonalSubscriptionInfo::~SeasonalSubscriptionInfo() {
  // @@protoc_insertion_point(destructor:playapi.proto.finsky.SeasonalSubscriptionInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SeasonalSubscriptionInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.periodstart_;
  if (this != internal_default_instance()) delete _impl_.periodend_;
  if (this != internal_default_instance()) delete _impl_.posttrialconversionpayment_;
}

void SeasonalSubscriptionInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SeasonalSubscriptionInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:playapi.proto.finsky.SeasonalSubscriptionInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.periodstart_ != nullptr);
      _impl_.periodstart_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.periodend_ != nullptr);
      _impl_.periodend_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.posttrialconversionpayment_ != nullptr);
      _impl_.posttrialconversionpayment_->Clear();
    }
  }
  _impl_.prorated_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SeasonalSubscriptionInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .playapi.proto.finsky.MonthAndDay periodStart = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_periodstart(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .playapi.proto.finsky.MonthAndDay periodEnd = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_periodend(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool prorated = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_prorated(&has_bits);
          _impl_.prorated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .playapi.proto.finsky.SeasonalSubscriptionInfo.Payment postTrialConversionPayment = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_posttrialconversionpayment(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SeasonalSubscriptionInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:playapi.proto.finsky.SeasonalSubscriptionInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .playapi.proto.finsky.MonthAndDay periodStart = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::periodstart(this),
        _Internal::periodstart(this).GetCachedSize(), target, stream);
  }

  // optional .playapi.proto.finsky.MonthAndDay periodEnd = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::periodend(this),
        _Internal::periodend(this).GetCachedSize(), target, stream);
  }

  // optional bool prorated = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_prorated(), target);
  }

  // optional .playapi.proto.finsky.SeasonalSubscriptionInfo.Payment postTrialConversionPayment = 5;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::posttrialconversionpayment(this),
        _Internal::posttrialconversionpayment(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:playapi.proto.finsky.SeasonalSubscriptionInfo)
  return target;
}

size_t SeasonalSubscriptionInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:playapi.proto.finsky.SeasonalSubscriptionInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .playapi.proto.finsky.MonthAndDay periodStart = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.periodstart_);
    }

    // optional .playapi.proto.finsky.MonthAndDay periodEnd = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.periodend_);
    }

    // optional .playapi.proto.finsky.SeasonalSubscriptionInfo.Payment postTrialConversionPayment = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.posttrialconversionpayment_);
    }

    // optional bool prorated = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SeasonalSubscriptionInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SeasonalSubscriptionInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SeasonalSubscriptionInfo::GetClassData() const { return &_class_data_; }


void SeasonalSubscriptionInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SeasonalSubscriptionInfo*>(&to_msg);
  auto& from = static_cast<const SeasonalSubscriptionInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:playapi.proto.finsky.SeasonalSubscriptionInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_periodstart()->::playapi::proto::finsky::MonthAndDay::MergeFrom(
          from._internal_periodstart());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_periodend()->::playapi::proto::finsky::MonthAndDay::MergeFrom(
          from._internal_periodend());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_posttrialconversionpayment()->::playapi::proto::finsky::SeasonalSubscriptionInfo_Payment::MergeFrom(
          from._internal_posttrialconversionpayment());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.prorated_ = from._impl_.prorated_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SeasonalSubscriptionInfo::CopyFrom(const SeasonalSubscriptionInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:playapi.proto.finsky.SeasonalSubscriptionInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SeasonalSubscriptionInfo::IsInitialized() const {
  return true;
}

void SeasonalSubscriptionInfo::InternalSwap(SeasonalSubscriptionInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SeasonalSubscriptionInfo, _impl_.prorated_)
      + sizeof(SeasonalSubscriptionInfo::_impl_.prorated_)
      - PROTOBUF_FIELD_OFFSET(SeasonalSubscriptionInfo, _impl_.periodstart_)>(
          reinterpret_cast<char*>(&_impl_.periodstart_),
          reinterpret_cast<char*>(&other->_impl_.periodstart_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SeasonalSubscriptionInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_play_5fcommon_2eproto_getter, &descriptor_table_play_5fcommon_2eproto_once,
      file_level_metadata_play_5fcommon_2eproto[11]);
}

// ===================================================================

class SubscriptionTerms_SubscriptionReplacement::_Internal {
 public:
  using HasBits = decltype(std::declval<SubscriptionTerms_SubscriptionReplacement>()._impl_._has_bits_);
  static const ::playapi::proto::finsky::Docid& newdocid(const SubscriptionTerms_SubscriptionReplacement* msg);
  static void set_has_newdocid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_keepnextrecurrencetime(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_replaceonfirstrecurrence(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::playapi::proto::finsky::Docid&
SubscriptionTerms_SubscriptionReplacement::_Internal::newdocid(const SubscriptionTerms_SubscriptionReplacement* msg) {
  return *msg->_impl_.newdocid_;
}
SubscriptionTerms_SubscriptionReplacement::SubscriptionTerms_SubscriptionReplacement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:playapi.proto.finsky.SubscriptionTerms.SubscriptionReplacement)
}
SubscriptionTerms_SubscriptionReplacement::SubscriptionTerms_SubscriptionReplacement(const SubscriptionTerms_SubscriptionReplacement& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SubscriptionTerms_SubscriptionReplacement* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.olddocid_){from._impl_.olddocid_}
    , decltype(_impl_.newdocid_){nullptr}
    , decltype(_impl_.keepnextrecurrencetime_){}
    , decltype(_impl_.replaceonfirstrecurrence_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_newdocid()) {
    _this->_impl_.newdocid_ = new ::playapi::proto::finsky::Docid(*from._impl_.newdocid_);
  }
  ::memcpy(&_impl_.keepnextrecurrencetime_, &from._impl_.keepnextrecurrencetime_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.replaceonfirstrecurrence_) -
    reinterpret_cast<char*>(&_impl_.keepnextrecurrencetime_)) + sizeof(_impl_.replaceonfirstrecurrence_));
  // @@protoc_insertion_point(copy_constructor:playapi.proto.finsky.SubscriptionTerms.SubscriptionReplacement)
}

inline void SubscriptionTerms_SubscriptionReplacement::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.olddocid_){arena}
    , decltype(_impl_.newdocid_){nullptr}
    , decltype(_impl_.keepnextrecurrencetime_){false}
    , decltype(_impl_.replaceonfirstrecurrence_){false}
  };
}

SubscriptionTerms_SubscriptionReplacement::~SubscriptionTerms_SubscriptionReplacement() {
  // @@protoc_insertion_point(destructor:playapi.proto.finsky.SubscriptionTerms.SubscriptionReplacement)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SubscriptionTerms_SubscriptionReplacement::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.olddocid_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.newdocid_;
}

void SubscriptionTerms_SubscriptionReplacement::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SubscriptionTerms_SubscriptionReplacement::Clear() {
// @@protoc_insertion_point(message_clear_start:playapi.proto.finsky.SubscriptionTerms.SubscriptionReplacement)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.olddocid_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.newdocid_ != nullptr);
    _impl_.newdocid_->Clear();
  }
  ::memset(&_impl_.keepnextrecurrencetime_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.replaceonfirstrecurrence_) -
      reinterpret_cast<char*>(&_impl_.keepnextrecurrencetime_)) + sizeof(_impl_.replaceonfirstrecurrence_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SubscriptionTerms_SubscriptionReplacement::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .playapi.proto.finsky.Docid newDocid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_newdocid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .playapi.proto.finsky.Docid oldDocid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_olddocid(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool keepNextRecurrenceTime = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_keepnextrecurrencetime(&has_bits);
          _impl_.keepnextrecurrencetime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool replaceOnFirstRecurrence = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_replaceonfirstrecurrence(&has_bits);
          _impl_.replaceonfirstrecurrence_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SubscriptionTerms_SubscriptionReplacement::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:playapi.proto.finsky.SubscriptionTerms.SubscriptionReplacement)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .playapi.proto.finsky.Docid newDocid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::newdocid(this),
        _Internal::newdocid(this).GetCachedSize(), target, stream);
  }

  // repeated .playapi.proto.finsky.Docid oldDocid = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_olddocid_size()); i < n; i++) {
    const auto& repfield = this->_internal_olddocid(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool keepNextRecurrenceTime = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_keepnextrecurrencetime(), target);
  }

  // optional bool replaceOnFirstRecurrence = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_replaceonfirstrecurrence(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:playapi.proto.finsky.SubscriptionTerms.SubscriptionReplacement)
  return target;
}

size_t SubscriptionTerms_SubscriptionReplacement::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:playapi.proto.finsky.SubscriptionTerms.SubscriptionReplacement)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .playapi.proto.finsky.Docid oldDocid = 2;
  total_size += 1UL * this->_internal_olddocid_size();
  for (const auto& msg : this->_impl_.olddocid_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .playapi.proto.finsky.Docid newDocid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.newdocid_);
    }

    // optional bool keepNextRecurrenceTime = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool replaceOnFirstRecurrence = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SubscriptionTerms_SubscriptionReplacement::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SubscriptionTerms_SubscriptionReplacement::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SubscriptionTerms_SubscriptionReplacement::GetClassData() const { return &_class_data_; }


void SubscriptionTerms_SubscriptionReplacement::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SubscriptionTerms_SubscriptionReplacement*>(&to_msg);
  auto& from = static_cast<const SubscriptionTerms_SubscriptionReplacement&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:playapi.proto.finsky.SubscriptionTerms.SubscriptionReplacement)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.olddocid_.MergeFrom(from._impl_.olddocid_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_newdocid()->::playapi::proto::finsky::Docid::MergeFrom(
          from._internal_newdocid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.keepnextrecurrencetime_ = from._impl_.keepnextrecurrencetime_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.replaceonfirstrecurrence_ = from._impl_.replaceonfirstrecurrence_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SubscriptionTerms_SubscriptionReplacement::CopyFrom(const SubscriptionTerms_SubscriptionReplacement& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:playapi.proto.finsky.SubscriptionTerms.SubscriptionReplacement)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubscriptionTerms_SubscriptionReplacement::IsInitialized() const {
  return true;
}

void SubscriptionTerms_SubscriptionReplacement::InternalSwap(SubscriptionTerms_SubscriptionReplacement* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.olddocid_.InternalSwap(&other->_impl_.olddocid_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SubscriptionTerms_SubscriptionReplacement, _impl_.replaceonfirstrecurrence_)
      + sizeof(SubscriptionTerms_SubscriptionReplacement::_impl_.replaceonfirstrecurrence_)
      - PROTOBUF_FIELD_OFFSET(SubscriptionTerms_SubscriptionReplacement, _impl_.newdocid_)>(
          reinterpret_cast<char*>(&_impl_.newdocid_),
          reinterpret_cast<char*>(&other->_impl_.newdocid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SubscriptionTerms_SubscriptionReplacement::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_play_5fcommon_2eproto_getter, &descriptor_table_play_5fcommon_2eproto_once,
      file_level_metadata_play_5fcommon_2eproto[12]);
}

// ===================================================================

class SubscriptionTerms::_Internal {
 public:
  using HasBits = decltype(std::declval<SubscriptionTerms>()._impl_._has_bits_);
  static const ::playapi::proto::finsky::TimePeriod& recurringperiod(const SubscriptionTerms* msg);
  static void set_has_recurringperiod(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::playapi::proto::finsky::TimePeriod& trialperiod(const SubscriptionTerms* msg);
  static void set_has_trialperiod(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_formattedpricewithrecurrenceperiod(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::playapi::proto::finsky::SeasonalSubscriptionInfo& seasonalsubscriptioninfo(const SubscriptionTerms* msg);
  static void set_has_seasonalsubscriptioninfo(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::playapi::proto::finsky::TimePeriod& graceperiod(const SubscriptionTerms* msg);
  static void set_has_graceperiod(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_resignup(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_initialvaliduntiltimestampmsec(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_nextpaymentcurrencycode(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_nextpaymentpricemicros(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_enableappspecifiedtrialperiod(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::playapi::proto::finsky::SubscriptionTerms_SubscriptionReplacement& subscriptionreplacement(const SubscriptionTerms* msg);
  static void set_has_subscriptionreplacement(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

const ::playapi::proto::finsky::TimePeriod&
SubscriptionTerms::_Internal::recurringperiod(const SubscriptionTerms* msg) {
  return *msg->_impl_.recurringperiod_;
}
const ::playapi::proto::finsky::TimePeriod&
SubscriptionTerms::_Internal::trialperiod(const SubscriptionTerms* msg) {
  return *msg->_impl_.trialperiod_;
}
const ::playapi::proto::finsky::SeasonalSubscriptionInfo&
SubscriptionTerms::_Internal::seasonalsubscriptioninfo(const SubscriptionTerms* msg) {
  return *msg->_impl_.seasonalsubscriptioninfo_;
}
const ::playapi::proto::finsky::TimePeriod&
SubscriptionTerms::_Internal::graceperiod(const SubscriptionTerms* msg) {
  return *msg->_impl_.graceperiod_;
}
const ::playapi::proto::finsky::SubscriptionTerms_SubscriptionReplacement&
SubscriptionTerms::_Internal::subscriptionreplacement(const SubscriptionTerms* msg) {
  return *msg->_impl_.subscriptionreplacement_;
}
SubscriptionTerms::SubscriptionTerms(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:playapi.proto.finsky.SubscriptionTerms)
}
SubscriptionTerms::SubscriptionTerms(const SubscriptionTerms& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SubscriptionTerms* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.replacedocid_){from._impl_.replacedocid_}
    , decltype(_impl_.formattedpricewithrecurrenceperiod_){}
    , decltype(_impl_.nextpaymentcurrencycode_){}
    , decltype(_impl_.recurringperiod_){nullptr}
    , decltype(_impl_.trialperiod_){nullptr}
    , decltype(_impl_.seasonalsubscriptioninfo_){nullptr}
    , decltype(_impl_.graceperiod_){nullptr}
    , decltype(_impl_.subscriptionreplacement_){nullptr}
    , decltype(_impl_.initialvaliduntiltimestampmsec_){}
    , decltype(_impl_.nextpaymentpricemicros_){}
    , decltype(_impl_.resignup_){}
    , decltype(_impl_.enableappspecifiedtrialperiod_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.formattedpricewithrecurrenceperiod_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.formattedpricewithrecurrenceperiod_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_formattedpricewithrecurrenceperiod()) {
    _this->_impl_.formattedpricewithrecurrenceperiod_.Set(from._internal_formattedpricewithrecurrenceperiod(), 
      _this->GetArenaForAllocation());
  }
  _impl_.nextpaymentcurrencycode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nextpaymentcurrencycode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_nextpaymentcurrencycode()) {
    _this->_impl_.nextpaymentcurrencycode_.Set(from._internal_nextpaymentcurrencycode(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_recurringperiod()) {
    _this->_impl_.recurringperiod_ = new ::playapi::proto::finsky::TimePeriod(*from._impl_.recurringperiod_);
  }
  if (from._internal_has_trialperiod()) {
    _this->_impl_.trialperiod_ = new ::playapi::proto::finsky::TimePeriod(*from._impl_.trialperiod_);
  }
  if (from._internal_has_seasonalsubscriptioninfo()) {
    _this->_impl_.seasonalsubscriptioninfo_ = new ::playapi::proto::finsky::SeasonalSubscriptionInfo(*from._impl_.seasonalsubscriptioninfo_);
  }
  if (from._internal_has_graceperiod()) {
    _this->_impl_.graceperiod_ = new ::playapi::proto::finsky::TimePeriod(*from._impl_.graceperiod_);
  }
  if (from._internal_has_subscriptionreplacement()) {
    _this->_impl_.subscriptionreplacement_ = new ::playapi::proto::finsky::SubscriptionTerms_SubscriptionReplacement(*from._impl_.subscriptionreplacement_);
  }
  ::memcpy(&_impl_.initialvaliduntiltimestampmsec_, &from._impl_.initialvaliduntiltimestampmsec_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.enableappspecifiedtrialperiod_) -
    reinterpret_cast<char*>(&_impl_.initialvaliduntiltimestampmsec_)) + sizeof(_impl_.enableappspecifiedtrialperiod_));
  // @@protoc_insertion_point(copy_constructor:playapi.proto.finsky.SubscriptionTerms)
}

inline void SubscriptionTerms::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.replacedocid_){arena}
    , decltype(_impl_.formattedpricewithrecurrenceperiod_){}
    , decltype(_impl_.nextpaymentcurrencycode_){}
    , decltype(_impl_.recurringperiod_){nullptr}
    , decltype(_impl_.trialperiod_){nullptr}
    , decltype(_impl_.seasonalsubscriptioninfo_){nullptr}
    , decltype(_impl_.graceperiod_){nullptr}
    , decltype(_impl_.subscriptionreplacement_){nullptr}
    , decltype(_impl_.initialvaliduntiltimestampmsec_){int64_t{0}}
    , decltype(_impl_.nextpaymentpricemicros_){int64_t{0}}
    , decltype(_impl_.resignup_){false}
    , decltype(_impl_.enableappspecifiedtrialperiod_){false}
  };
  _impl_.formattedpricewithrecurrenceperiod_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.formattedpricewithrecurrenceperiod_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.nextpaymentcurrencycode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nextpaymentcurrencycode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SubscriptionTerms::~SubscriptionTerms() {
  // @@protoc_insertion_point(destructor:playapi.proto.finsky.SubscriptionTerms)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SubscriptionTerms::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.replacedocid_.~RepeatedPtrField();
  _impl_.formattedpricewithrecurrenceperiod_.Destroy();
  _impl_.nextpaymentcurrencycode_.Destroy();
  if (this != internal_default_instance()) delete _impl_.recurringperiod_;
  if (this != internal_default_instance()) delete _impl_.trialperiod_;
  if (this != internal_default_instance()) delete _impl_.seasonalsubscriptioninfo_;
  if (this != internal_default_instance()) delete _impl_.graceperiod_;
  if (this != internal_default_instance()) delete _impl_.subscriptionreplacement_;
}

void SubscriptionTerms::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SubscriptionTerms::Clear() {
// @@protoc_insertion_point(message_clear_start:playapi.proto.finsky.SubscriptionTerms)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.replacedocid_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.formattedpricewithrecurrenceperiod_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.nextpaymentcurrencycode_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.recurringperiod_ != nullptr);
      _impl_.recurringperiod_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.trialperiod_ != nullptr);
      _impl_.trialperiod_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.seasonalsubscriptioninfo_ != nullptr);
      _impl_.seasonalsubscriptioninfo_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.graceperiod_ != nullptr);
      _impl_.graceperiod_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.subscriptionreplacement_ != nullptr);
      _impl_.subscriptionreplacement_->Clear();
    }
  }
  _impl_.initialvaliduntiltimestampmsec_ = int64_t{0};
  if (cached_has_bits & 0x00000700u) {
    ::memset(&_impl_.nextpaymentpricemicros_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.enableappspecifiedtrialperiod_) -
        reinterpret_cast<char*>(&_impl_.nextpaymentpricemicros_)) + sizeof(_impl_.enableappspecifiedtrialperiod_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SubscriptionTerms::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .playapi.proto.finsky.TimePeriod recurringPeriod = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_recurringperiod(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .playapi.proto.finsky.TimePeriod trialPeriod = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_trialperiod(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string formattedPriceWithRecurrencePeriod = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_formattedpricewithrecurrenceperiod();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "playapi.proto.finsky.SubscriptionTerms.formattedPriceWithRecurrencePeriod");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .playapi.proto.finsky.SeasonalSubscriptionInfo seasonalSubscriptionInfo = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_seasonalsubscriptioninfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .playapi.proto.finsky.Docid replaceDocid = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_replacedocid(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .playapi.proto.finsky.TimePeriod gracePeriod = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_graceperiod(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool resignup = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_resignup(&has_bits);
          _impl_.resignup_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 initialValidUntilTimestampMsec = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_initialvaliduntiltimestampmsec(&has_bits);
          _impl_.initialvaliduntiltimestampmsec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string nextPaymentCurrencyCode = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_nextpaymentcurrencycode();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "playapi.proto.finsky.SubscriptionTerms.nextPaymentCurrencyCode");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional int64 nextPaymentPriceMicros = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_nextpaymentpricemicros(&has_bits);
          _impl_.nextpaymentpricemicros_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool enableAppSpecifiedTrialPeriod = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_enableappspecifiedtrialperiod(&has_bits);
          _impl_.enableappspecifiedtrialperiod_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .playapi.proto.finsky.SubscriptionTerms.SubscriptionReplacement subscriptionReplacement = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_subscriptionreplacement(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SubscriptionTerms::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:playapi.proto.finsky.SubscriptionTerms)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .playapi.proto.finsky.TimePeriod recurringPeriod = 1;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::recurringperiod(this),
        _Internal::recurringperiod(this).GetCachedSize(), target, stream);
  }

  // optional .playapi.proto.finsky.TimePeriod trialPeriod = 2;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::trialperiod(this),
        _Internal::trialperiod(this).GetCachedSize(), target, stream);
  }

  // optional string formattedPriceWithRecurrencePeriod = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_formattedpricewithrecurrenceperiod().data(), static_cast<int>(this->_internal_formattedpricewithrecurrenceperiod().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "playapi.proto.finsky.SubscriptionTerms.formattedPriceWithRecurrencePeriod");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_formattedpricewithrecurrenceperiod(), target);
  }

  // optional .playapi.proto.finsky.SeasonalSubscriptionInfo seasonalSubscriptionInfo = 4;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::seasonalsubscriptioninfo(this),
        _Internal::seasonalsubscriptioninfo(this).GetCachedSize(), target, stream);
  }

  // repeated .playapi.proto.finsky.Docid replaceDocid = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_replacedocid_size()); i < n; i++) {
    const auto& repfield = this->_internal_replacedocid(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .playapi.proto.finsky.TimePeriod gracePeriod = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::graceperiod(this),
        _Internal::graceperiod(this).GetCachedSize(), target, stream);
  }

  // optional bool resignup = 7;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_resignup(), target);
  }

  // optional int64 initialValidUntilTimestampMsec = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(8, this->_internal_initialvaliduntiltimestampmsec(), target);
  }

  // optional string nextPaymentCurrencyCode = 9;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_nextpaymentcurrencycode().data(), static_cast<int>(this->_internal_nextpaymentcurrencycode().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "playapi.proto.finsky.SubscriptionTerms.nextPaymentCurrencyCode");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_nextpaymentcurrencycode(), target);
  }

  // optional int64 nextPaymentPriceMicros = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(10, this->_internal_nextpaymentpricemicros(), target);
  }

  // optional bool enableAppSpecifiedTrialPeriod = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_enableappspecifiedtrialperiod(), target);
  }

  // optional .playapi.proto.finsky.SubscriptionTerms.SubscriptionReplacement subscriptionReplacement = 12;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::subscriptionreplacement(this),
        _Internal::subscriptionreplacement(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:playapi.proto.finsky.SubscriptionTerms)
  return target;
}

size_t SubscriptionTerms::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:playapi.proto.finsky.SubscriptionTerms)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .playapi.proto.finsky.Docid replaceDocid = 5;
  total_size += 1UL * this->_internal_replacedocid_size();
  for (const auto& msg : this->_impl_.replacedocid_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string formattedPriceWithRecurrencePeriod = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_formattedpricewithrecurrenceperiod());
    }

    // optional string nextPaymentCurrencyCode = 9;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_nextpaymentcurrencycode());
    }

    // optional .playapi.proto.finsky.TimePeriod recurringPeriod = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.recurringperiod_);
    }

    // optional .playapi.proto.finsky.TimePeriod trialPeriod = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.trialperiod_);
    }

    // optional .playapi.proto.finsky.SeasonalSubscriptionInfo seasonalSubscriptionInfo = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.seasonalsubscriptioninfo_);
    }

    // optional .playapi.proto.finsky.TimePeriod gracePeriod = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.graceperiod_);
    }

    // optional .playapi.proto.finsky.SubscriptionTerms.SubscriptionReplacement subscriptionReplacement = 12;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.subscriptionreplacement_);
    }

    // optional int64 initialValidUntilTimestampMsec = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_initialvaliduntiltimestampmsec());
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional int64 nextPaymentPriceMicros = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_nextpaymentpricemicros());
    }

    // optional bool resignup = 7;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional bool enableAppSpecifiedTrialPeriod = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SubscriptionTerms::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SubscriptionTerms::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SubscriptionTerms::GetClassData() const { return &_class_data_; }


void SubscriptionTerms::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SubscriptionTerms*>(&to_msg);
  auto& from = static_cast<const SubscriptionTerms&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:playapi.proto.finsky.SubscriptionTerms)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.replacedocid_.MergeFrom(from._impl_.replacedocid_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_formattedpricewithrecurrenceperiod(from._internal_formattedpricewithrecurrenceperiod());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_nextpaymentcurrencycode(from._internal_nextpaymentcurrencycode());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_recurringperiod()->::playapi::proto::finsky::TimePeriod::MergeFrom(
          from._internal_recurringperiod());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_trialperiod()->::playapi::proto::finsky::TimePeriod::MergeFrom(
          from._internal_trialperiod());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_seasonalsubscriptioninfo()->::playapi::proto::finsky::SeasonalSubscriptionInfo::MergeFrom(
          from._internal_seasonalsubscriptioninfo());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_graceperiod()->::playapi::proto::finsky::TimePeriod::MergeFrom(
          from._internal_graceperiod());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_subscriptionreplacement()->::playapi::proto::finsky::SubscriptionTerms_SubscriptionReplacement::MergeFrom(
          from._internal_subscriptionreplacement());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.initialvaliduntiltimestampmsec_ = from._impl_.initialvaliduntiltimestampmsec_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.nextpaymentpricemicros_ = from._impl_.nextpaymentpricemicros_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.resignup_ = from._impl_.resignup_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.enableappspecifiedtrialperiod_ = from._impl_.enableappspecifiedtrialperiod_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SubscriptionTerms::CopyFrom(const SubscriptionTerms& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:playapi.proto.finsky.SubscriptionTerms)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubscriptionTerms::IsInitialized() const {
  return true;
}

void SubscriptionTerms::InternalSwap(SubscriptionTerms* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.replacedocid_.InternalSwap(&other->_impl_.replacedocid_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.formattedpricewithrecurrenceperiod_, lhs_arena,
      &other->_impl_.formattedpricewithrecurrenceperiod_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.nextpaymentcurrencycode_, lhs_arena,
      &other->_impl_.nextpaymentcurrencycode_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SubscriptionTerms, _impl_.enableappspecifiedtrialperiod_)
      + sizeof(SubscriptionTerms::_impl_.enableappspecifiedtrialperiod_)
      - PROTOBUF_FIELD_OFFSET(SubscriptionTerms, _impl_.recurringperiod_)>(
          reinterpret_cast<char*>(&_impl_.recurringperiod_),
          reinterpret_cast<char*>(&other->_impl_.recurringperiod_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SubscriptionTerms::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_play_5fcommon_2eproto_getter, &descriptor_table_play_5fcommon_2eproto_once,
      file_level_metadata_play_5fcommon_2eproto[13]);
}

// ===================================================================

class SubscriptionContentTerms::_Internal {
 public:
  using HasBits = decltype(std::declval<SubscriptionContentTerms>()._impl_._has_bits_);
  static const ::playapi::proto::finsky::Docid& requiredsubscription(const SubscriptionContentTerms* msg);
  static void set_has_requiredsubscription(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::playapi::proto::finsky::Docid&
SubscriptionContentTerms::_Internal::requiredsubscription(const SubscriptionContentTerms* msg) {
  return *msg->_impl_.requiredsubscription_;
}
SubscriptionContentTerms::SubscriptionContentTerms(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:playapi.proto.finsky.SubscriptionContentTerms)
}
SubscriptionContentTerms::SubscriptionContentTerms(const SubscriptionContentTerms& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SubscriptionContentTerms* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.requiredsubscription_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_requiredsubscription()) {
    _this->_impl_.requiredsubscription_ = new ::playapi::proto::finsky::Docid(*from._impl_.requiredsubscription_);
  }
  // @@protoc_insertion_point(copy_constructor:playapi.proto.finsky.SubscriptionContentTerms)
}

inline void SubscriptionContentTerms::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.requiredsubscription_){nullptr}
  };
}

SubscriptionContentTerms::~SubscriptionContentTerms() {
  // @@protoc_insertion_point(destructor:playapi.proto.finsky.SubscriptionContentTerms)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SubscriptionContentTerms::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.requiredsubscription_;
}

void SubscriptionContentTerms::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SubscriptionContentTerms::Clear() {
// @@protoc_insertion_point(message_clear_start:playapi.proto.finsky.SubscriptionContentTerms)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.requiredsubscription_ != nullptr);
    _impl_.requiredsubscription_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SubscriptionContentTerms::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .playapi.proto.finsky.Docid requiredSubscription = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_requiredsubscription(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SubscriptionContentTerms::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:playapi.proto.finsky.SubscriptionContentTerms)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .playapi.proto.finsky.Docid requiredSubscription = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::requiredsubscription(this),
        _Internal::requiredsubscription(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:playapi.proto.finsky.SubscriptionContentTerms)
  return target;
}

size_t SubscriptionContentTerms::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:playapi.proto.finsky.SubscriptionContentTerms)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .playapi.proto.finsky.Docid requiredSubscription = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.requiredsubscription_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SubscriptionContentTerms::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SubscriptionContentTerms::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SubscriptionContentTerms::GetClassData() const { return &_class_data_; }


void SubscriptionContentTerms::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SubscriptionContentTerms*>(&to_msg);
  auto& from = static_cast<const SubscriptionContentTerms&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:playapi.proto.finsky.SubscriptionContentTerms)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_requiredsubscription()) {
    _this->_internal_mutable_requiredsubscription()->::playapi::proto::finsky::Docid::MergeFrom(
        from._internal_requiredsubscription());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SubscriptionContentTerms::CopyFrom(const SubscriptionContentTerms& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:playapi.proto.finsky.SubscriptionContentTerms)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SubscriptionContentTerms::IsInitialized() const {
  return true;
}

void SubscriptionContentTerms::InternalSwap(SubscriptionContentTerms* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.requiredsubscription_, other->_impl_.requiredsubscription_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SubscriptionContentTerms::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_play_5fcommon_2eproto_getter, &descriptor_table_play_5fcommon_2eproto_once,
      file_level_metadata_play_5fcommon_2eproto[14]);
}

// ===================================================================

class GroupLicenseKey::_Internal {
 public:
  using HasBits = decltype(std::declval<GroupLicenseKey>()._impl_._has_bits_);
  static void set_has_dashercustomerid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::playapi::proto::finsky::Docid& docid(const GroupLicenseKey* msg);
  static void set_has_docid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_licensedoffertype(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_rentalperioddays(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::playapi::proto::finsky::Docid&
GroupLicenseKey::_Internal::docid(const GroupLicenseKey* msg) {
  return *msg->_impl_.docid_;
}
GroupLicenseKey::GroupLicenseKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:playapi.proto.finsky.GroupLicenseKey)
}
GroupLicenseKey::GroupLicenseKey(const GroupLicenseKey& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GroupLicenseKey* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.docid_){nullptr}
    , decltype(_impl_.dashercustomerid_){}
    , decltype(_impl_.licensedoffertype_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.rentalperioddays_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_docid()) {
    _this->_impl_.docid_ = new ::playapi::proto::finsky::Docid(*from._impl_.docid_);
  }
  ::memcpy(&_impl_.dashercustomerid_, &from._impl_.dashercustomerid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.rentalperioddays_) -
    reinterpret_cast<char*>(&_impl_.dashercustomerid_)) + sizeof(_impl_.rentalperioddays_));
  // @@protoc_insertion_point(copy_constructor:playapi.proto.finsky.GroupLicenseKey)
}

inline void GroupLicenseKey::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.docid_){nullptr}
    , decltype(_impl_.dashercustomerid_){uint64_t{0u}}
    , decltype(_impl_.licensedoffertype_){0}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.rentalperioddays_){0}
  };
}

GroupLicenseKey::~GroupLicenseKey() {
  // @@protoc_insertion_point(destructor:playapi.proto.finsky.GroupLicenseKey)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GroupLicenseKey::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.docid_;
}

void GroupLicenseKey::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GroupLicenseKey::Clear() {
// @@protoc_insertion_point(message_clear_start:playapi.proto.finsky.GroupLicenseKey)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.docid_ != nullptr);
    _impl_.docid_->Clear();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.dashercustomerid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.rentalperioddays_) -
        reinterpret_cast<char*>(&_impl_.dashercustomerid_)) + sizeof(_impl_.rentalperioddays_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GroupLicenseKey::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 dasherCustomerId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_dashercustomerid(&has_bits);
          _impl_.dashercustomerid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional .playapi.proto.finsky.Docid docid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_docid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 licensedOfferType = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_licensedoffertype(&has_bits);
          _impl_.licensedoffertype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_type(&has_bits);
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 rentalPeriodDays = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_rentalperioddays(&has_bits);
          _impl_.rentalperioddays_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GroupLicenseKey::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:playapi.proto.finsky.GroupLicenseKey)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 dasherCustomerId = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_dashercustomerid(), target);
  }

  // optional .playapi.proto.finsky.Docid docid = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::docid(this),
        _Internal::docid(this).GetCachedSize(), target, stream);
  }

  // optional int32 licensedOfferType = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_licensedoffertype(), target);
  }

  // optional int32 type = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_type(), target);
  }

  // optional int32 rentalPeriodDays = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_rentalperioddays(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:playapi.proto.finsky.GroupLicenseKey)
  return target;
}

size_t GroupLicenseKey::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:playapi.proto.finsky.GroupLicenseKey)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .playapi.proto.finsky.Docid docid = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.docid_);
    }

    // optional fixed64 dasherCustomerId = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional int32 licensedOfferType = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_licensedoffertype());
    }

    // optional int32 type = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_type());
    }

    // optional int32 rentalPeriodDays = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_rentalperioddays());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GroupLicenseKey::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GroupLicenseKey::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GroupLicenseKey::GetClassData() const { return &_class_data_; }


void GroupLicenseKey::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GroupLicenseKey*>(&to_msg);
  auto& from = static_cast<const GroupLicenseKey&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:playapi.proto.finsky.GroupLicenseKey)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_docid()->::playapi::proto::finsky::Docid::MergeFrom(
          from._internal_docid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.dashercustomerid_ = from._impl_.dashercustomerid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.licensedoffertype_ = from._impl_.licensedoffertype_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.rentalperioddays_ = from._impl_.rentalperioddays_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GroupLicenseKey::CopyFrom(const GroupLicenseKey& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:playapi.proto.finsky.GroupLicenseKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupLicenseKey::IsInitialized() const {
  return true;
}

void GroupLicenseKey::InternalSwap(GroupLicenseKey* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GroupLicenseKey, _impl_.rentalperioddays_)
      + sizeof(GroupLicenseKey::_impl_.rentalperioddays_)
      - PROTOBUF_FIELD_OFFSET(GroupLicenseKey, _impl_.docid_)>(
          reinterpret_cast<char*>(&_impl_.docid_),
          reinterpret_cast<char*>(&other->_impl_.docid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GroupLicenseKey::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_play_5fcommon_2eproto_getter, &descriptor_table_play_5fcommon_2eproto_once,
      file_level_metadata_play_5fcommon_2eproto[15]);
}

// ===================================================================

class GroupLicenseInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<GroupLicenseInfo>()._impl_._has_bits_);
  static void set_has_licensedoffertype(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_gaiagroupid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::playapi::proto::finsky::GroupLicenseKey& grouplicensekey(const GroupLicenseInfo* msg);
  static void set_has_grouplicensekey(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::playapi::proto::finsky::GroupLicenseKey&
GroupLicenseInfo::_Internal::grouplicensekey(const GroupLicenseInfo* msg) {
  return *msg->_impl_.grouplicensekey_;
}
GroupLicenseInfo::GroupLicenseInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:playapi.proto.finsky.GroupLicenseInfo)
}
GroupLicenseInfo::GroupLicenseInfo(const GroupLicenseInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GroupLicenseInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.grouplicensekey_){nullptr}
    , decltype(_impl_.gaiagroupid_){}
    , decltype(_impl_.licensedoffertype_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_grouplicensekey()) {
    _this->_impl_.grouplicensekey_ = new ::playapi::proto::finsky::GroupLicenseKey(*from._impl_.grouplicensekey_);
  }
  ::memcpy(&_impl_.gaiagroupid_, &from._impl_.gaiagroupid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.licensedoffertype_) -
    reinterpret_cast<char*>(&_impl_.gaiagroupid_)) + sizeof(_impl_.licensedoffertype_));
  // @@protoc_insertion_point(copy_constructor:playapi.proto.finsky.GroupLicenseInfo)
}

inline void GroupLicenseInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.grouplicensekey_){nullptr}
    , decltype(_impl_.gaiagroupid_){uint64_t{0u}}
    , decltype(_impl_.licensedoffertype_){0}
  };
}

GroupLicenseInfo::~GroupLicenseInfo() {
  // @@protoc_insertion_point(destructor:playapi.proto.finsky.GroupLicenseInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GroupLicenseInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.grouplicensekey_;
}

void GroupLicenseInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GroupLicenseInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:playapi.proto.finsky.GroupLicenseInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.grouplicensekey_ != nullptr);
    _impl_.grouplicensekey_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.gaiagroupid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.licensedoffertype_) -
        reinterpret_cast<char*>(&_impl_.gaiagroupid_)) + sizeof(_impl_.licensedoffertype_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GroupLicenseInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 licensedOfferType = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_licensedoffertype(&has_bits);
          _impl_.licensedoffertype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 gaiaGroupId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_gaiagroupid(&has_bits);
          _impl_.gaiagroupid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional .playapi.proto.finsky.GroupLicenseKey groupLicenseKey = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_grouplicensekey(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GroupLicenseInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:playapi.proto.finsky.GroupLicenseInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 licensedOfferType = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_licensedoffertype(), target);
  }

  // optional fixed64 gaiaGroupId = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(2, this->_internal_gaiagroupid(), target);
  }

  // optional .playapi.proto.finsky.GroupLicenseKey groupLicenseKey = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::grouplicensekey(this),
        _Internal::grouplicensekey(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:playapi.proto.finsky.GroupLicenseInfo)
  return target;
}

size_t GroupLicenseInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:playapi.proto.finsky.GroupLicenseInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .playapi.proto.finsky.GroupLicenseKey groupLicenseKey = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.grouplicensekey_);
    }

    // optional fixed64 gaiaGroupId = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional int32 licensedOfferType = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_licensedoffertype());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GroupLicenseInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GroupLicenseInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GroupLicenseInfo::GetClassData() const { return &_class_data_; }


void GroupLicenseInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GroupLicenseInfo*>(&to_msg);
  auto& from = static_cast<const GroupLicenseInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:playapi.proto.finsky.GroupLicenseInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_grouplicensekey()->::playapi::proto::finsky::GroupLicenseKey::MergeFrom(
          from._internal_grouplicensekey());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.gaiagroupid_ = from._impl_.gaiagroupid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.licensedoffertype_ = from._impl_.licensedoffertype_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GroupLicenseInfo::CopyFrom(const GroupLicenseInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:playapi.proto.finsky.GroupLicenseInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupLicenseInfo::IsInitialized() const {
  return true;
}

void GroupLicenseInfo::InternalSwap(GroupLicenseInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GroupLicenseInfo, _impl_.licensedoffertype_)
      + sizeof(GroupLicenseInfo::_impl_.licensedoffertype_)
      - PROTOBUF_FIELD_OFFSET(GroupLicenseInfo, _impl_.grouplicensekey_)>(
          reinterpret_cast<char*>(&_impl_.grouplicensekey_),
          reinterpret_cast<char*>(&other->_impl_.grouplicensekey_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GroupLicenseInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_play_5fcommon_2eproto_getter, &descriptor_table_play_5fcommon_2eproto_once,
      file_level_metadata_play_5fcommon_2eproto[16]);
}

// ===================================================================

class LicenseTerms::_Internal {
 public:
  using HasBits = decltype(std::declval<LicenseTerms>()._impl_._has_bits_);
  static const ::playapi::proto::finsky::GroupLicenseKey& grouplicensekey(const LicenseTerms* msg);
  static void set_has_grouplicensekey(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::playapi::proto::finsky::GroupLicenseKey&
LicenseTerms::_Internal::grouplicensekey(const LicenseTerms* msg) {
  return *msg->_impl_.grouplicensekey_;
}
LicenseTerms::LicenseTerms(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:playapi.proto.finsky.LicenseTerms)
}
LicenseTerms::LicenseTerms(const LicenseTerms& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LicenseTerms* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.grouplicensekey_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_grouplicensekey()) {
    _this->_impl_.grouplicensekey_ = new ::playapi::proto::finsky::GroupLicenseKey(*from._impl_.grouplicensekey_);
  }
  // @@protoc_insertion_point(copy_constructor:playapi.proto.finsky.LicenseTerms)
}

inline void LicenseTerms::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.grouplicensekey_){nullptr}
  };
}

LicenseTerms::~LicenseTerms() {
  // @@protoc_insertion_point(destructor:playapi.proto.finsky.LicenseTerms)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LicenseTerms::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.grouplicensekey_;
}

void LicenseTerms::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LicenseTerms::Clear() {
// @@protoc_insertion_point(message_clear_start:playapi.proto.finsky.LicenseTerms)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.grouplicensekey_ != nullptr);
    _impl_.grouplicensekey_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LicenseTerms::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .playapi.proto.finsky.GroupLicenseKey groupLicenseKey = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_grouplicensekey(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LicenseTerms::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:playapi.proto.finsky.LicenseTerms)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .playapi.proto.finsky.GroupLicenseKey groupLicenseKey = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::grouplicensekey(this),
        _Internal::grouplicensekey(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:playapi.proto.finsky.LicenseTerms)
  return target;
}

size_t LicenseTerms::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:playapi.proto.finsky.LicenseTerms)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .playapi.proto.finsky.GroupLicenseKey groupLicenseKey = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.grouplicensekey_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LicenseTerms::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LicenseTerms::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LicenseTerms::GetClassData() const { return &_class_data_; }


void LicenseTerms::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LicenseTerms*>(&to_msg);
  auto& from = static_cast<const LicenseTerms&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:playapi.proto.finsky.LicenseTerms)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_grouplicensekey()) {
    _this->_internal_mutable_grouplicensekey()->::playapi::proto::finsky::GroupLicenseKey::MergeFrom(
        from._internal_grouplicensekey());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LicenseTerms::CopyFrom(const LicenseTerms& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:playapi.proto.finsky.LicenseTerms)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LicenseTerms::IsInitialized() const {
  return true;
}

void LicenseTerms::InternalSwap(LicenseTerms* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.grouplicensekey_, other->_impl_.grouplicensekey_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LicenseTerms::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_play_5fcommon_2eproto_getter, &descriptor_table_play_5fcommon_2eproto_once,
      file_level_metadata_play_5fcommon_2eproto[17]);
}

// ===================================================================

class LicensedDocumentInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<LicensedDocumentInfo>()._impl_._has_bits_);
  static void set_has_grouplicensecheckoutorderid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::playapi::proto::finsky::GroupLicenseKey& grouplicensekey(const LicensedDocumentInfo* msg);
  static void set_has_grouplicensekey(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_assignedbygaiaid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_deprecatedassignmentid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::playapi::proto::finsky::GroupLicenseKey&
LicensedDocumentInfo::_Internal::grouplicensekey(const LicensedDocumentInfo* msg) {
  return *msg->_impl_.grouplicensekey_;
}
LicensedDocumentInfo::LicensedDocumentInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:playapi.proto.finsky.LicensedDocumentInfo)
}
LicensedDocumentInfo::LicensedDocumentInfo(const LicensedDocumentInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LicensedDocumentInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gaiagroupid_){from._impl_.gaiagroupid_}
    , decltype(_impl_.grouplicensecheckoutorderid_){}
    , decltype(_impl_.deprecatedassignmentid_){}
    , decltype(_impl_.grouplicensekey_){nullptr}
    , decltype(_impl_.assignedbygaiaid_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.grouplicensecheckoutorderid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.grouplicensecheckoutorderid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_grouplicensecheckoutorderid()) {
    _this->_impl_.grouplicensecheckoutorderid_.Set(from._internal_grouplicensecheckoutorderid(), 
      _this->GetArenaForAllocation());
  }
  _impl_.deprecatedassignmentid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.deprecatedassignmentid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_deprecatedassignmentid()) {
    _this->_impl_.deprecatedassignmentid_.Set(from._internal_deprecatedassignmentid(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_grouplicensekey()) {
    _this->_impl_.grouplicensekey_ = new ::playapi::proto::finsky::GroupLicenseKey(*from._impl_.grouplicensekey_);
  }
  _this->_impl_.assignedbygaiaid_ = from._impl_.assignedbygaiaid_;
  // @@protoc_insertion_point(copy_constructor:playapi.proto.finsky.LicensedDocumentInfo)
}

inline void LicensedDocumentInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gaiagroupid_){arena}
    , decltype(_impl_.grouplicensecheckoutorderid_){}
    , decltype(_impl_.deprecatedassignmentid_){}
    , decltype(_impl_.grouplicensekey_){nullptr}
    , decltype(_impl_.assignedbygaiaid_){uint64_t{0u}}
  };
  _impl_.grouplicensecheckoutorderid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.grouplicensecheckoutorderid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.deprecatedassignmentid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.deprecatedassignmentid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LicensedDocumentInfo::~LicensedDocumentInfo() {
  // @@protoc_insertion_point(destructor:playapi.proto.finsky.LicensedDocumentInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LicensedDocumentInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.gaiagroupid_.~RepeatedField();
  _impl_.grouplicensecheckoutorderid_.Destroy();
  _impl_.deprecatedassignmentid_.Destroy();
  if (this != internal_default_instance()) delete _impl_.grouplicensekey_;
}

void LicensedDocumentInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LicensedDocumentInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:playapi.proto.finsky.LicensedDocumentInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.gaiagroupid_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.grouplicensecheckoutorderid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.deprecatedassignmentid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.grouplicensekey_ != nullptr);
      _impl_.grouplicensekey_->Clear();
    }
  }
  _impl_.assignedbygaiaid_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LicensedDocumentInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated fixed64 gaiaGroupId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_gaiagroupid(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr));
            ptr += sizeof(uint64_t);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<9>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFixed64Parser(_internal_mutable_gaiagroupid(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string groupLicenseCheckoutOrderId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_grouplicensecheckoutorderid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "playapi.proto.finsky.LicensedDocumentInfo.groupLicenseCheckoutOrderId");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .playapi.proto.finsky.GroupLicenseKey groupLicenseKey = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_grouplicensekey(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 assignedByGaiaId = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_assignedbygaiaid(&has_bits);
          _impl_.assignedbygaiaid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional string DEPRECATEDAssignmentId = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_deprecatedassignmentid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "playapi.proto.finsky.LicensedDocumentInfo.DEPRECATEDAssignmentId");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LicensedDocumentInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:playapi.proto.finsky.LicensedDocumentInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated fixed64 gaiaGroupId = 1;
  for (int i = 0, n = this->_internal_gaiagroupid_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_gaiagroupid(i), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional string groupLicenseCheckoutOrderId = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_grouplicensecheckoutorderid().data(), static_cast<int>(this->_internal_grouplicensecheckoutorderid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "playapi.proto.finsky.LicensedDocumentInfo.groupLicenseCheckoutOrderId");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_grouplicensecheckoutorderid(), target);
  }

  // optional .playapi.proto.finsky.GroupLicenseKey groupLicenseKey = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::grouplicensekey(this),
        _Internal::grouplicensekey(this).GetCachedSize(), target, stream);
  }

  // optional fixed64 assignedByGaiaId = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(4, this->_internal_assignedbygaiaid(), target);
  }

  // optional string DEPRECATEDAssignmentId = 5;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_deprecatedassignmentid().data(), static_cast<int>(this->_internal_deprecatedassignmentid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "playapi.proto.finsky.LicensedDocumentInfo.DEPRECATEDAssignmentId");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_deprecatedassignmentid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:playapi.proto.finsky.LicensedDocumentInfo)
  return target;
}

size_t LicensedDocumentInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:playapi.proto.finsky.LicensedDocumentInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated fixed64 gaiaGroupId = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_gaiagroupid_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_gaiagroupid_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string groupLicenseCheckoutOrderId = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_grouplicensecheckoutorderid());
    }

    // optional string DEPRECATEDAssignmentId = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_deprecatedassignmentid());
    }

    // optional .playapi.proto.finsky.GroupLicenseKey groupLicenseKey = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.grouplicensekey_);
    }

    // optional fixed64 assignedByGaiaId = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LicensedDocumentInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LicensedDocumentInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LicensedDocumentInfo::GetClassData() const { return &_class_data_; }


void LicensedDocumentInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LicensedDocumentInfo*>(&to_msg);
  auto& from = static_cast<const LicensedDocumentInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:playapi.proto.finsky.LicensedDocumentInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.gaiagroupid_.MergeFrom(from._impl_.gaiagroupid_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_grouplicensecheckoutorderid(from._internal_grouplicensecheckoutorderid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_deprecatedassignmentid(from._internal_deprecatedassignmentid());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_grouplicensekey()->::playapi::proto::finsky::GroupLicenseKey::MergeFrom(
          from._internal_grouplicensekey());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.assignedbygaiaid_ = from._impl_.assignedbygaiaid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LicensedDocumentInfo::CopyFrom(const LicensedDocumentInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:playapi.proto.finsky.LicensedDocumentInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LicensedDocumentInfo::IsInitialized() const {
  return true;
}

void LicensedDocumentInfo::InternalSwap(LicensedDocumentInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.gaiagroupid_.InternalSwap(&other->_impl_.gaiagroupid_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.grouplicensecheckoutorderid_, lhs_arena,
      &other->_impl_.grouplicensecheckoutorderid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.deprecatedassignmentid_, lhs_arena,
      &other->_impl_.deprecatedassignmentid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LicensedDocumentInfo, _impl_.assignedbygaiaid_)
      + sizeof(LicensedDocumentInfo::_impl_.assignedbygaiaid_)
      - PROTOBUF_FIELD_OFFSET(LicensedDocumentInfo, _impl_.grouplicensekey_)>(
          reinterpret_cast<char*>(&_impl_.grouplicensekey_),
          reinterpret_cast<char*>(&other->_impl_.grouplicensekey_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LicensedDocumentInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_play_5fcommon_2eproto_getter, &descriptor_table_play_5fcommon_2eproto_once,
      file_level_metadata_play_5fcommon_2eproto[18]);
}

// ===================================================================

class RedemptionRecordKey::_Internal {
 public:
  using HasBits = decltype(std::declval<RedemptionRecordKey>()._impl_._has_bits_);
  static void set_has_publisherid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_campaignid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_codegroupid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_recordid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

RedemptionRecordKey::RedemptionRecordKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:playapi.proto.finsky.RedemptionRecordKey)
}
RedemptionRecordKey::RedemptionRecordKey(const RedemptionRecordKey& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RedemptionRecordKey* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.publisherid_){}
    , decltype(_impl_.campaignid_){}
    , decltype(_impl_.codegroupid_){}
    , decltype(_impl_.recordid_){}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.publisherid_, &from._impl_.publisherid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.type_) -
    reinterpret_cast<char*>(&_impl_.publisherid_)) + sizeof(_impl_.type_));
  // @@protoc_insertion_point(copy_constructor:playapi.proto.finsky.RedemptionRecordKey)
}

inline void RedemptionRecordKey::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.publisherid_){int64_t{0}}
    , decltype(_impl_.campaignid_){int64_t{0}}
    , decltype(_impl_.codegroupid_){int64_t{0}}
    , decltype(_impl_.recordid_){int64_t{0}}
    , decltype(_impl_.type_){0}
  };
}

RedemptionRecordKey::~RedemptionRecordKey() {
  // @@protoc_insertion_point(destructor:playapi.proto.finsky.RedemptionRecordKey)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RedemptionRecordKey::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RedemptionRecordKey::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RedemptionRecordKey::Clear() {
// @@protoc_insertion_point(message_clear_start:playapi.proto.finsky.RedemptionRecordKey)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.publisherid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.type_) -
        reinterpret_cast<char*>(&_impl_.publisherid_)) + sizeof(_impl_.type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RedemptionRecordKey::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 publisherId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_publisherid(&has_bits);
          _impl_.publisherid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 campaignId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_campaignid(&has_bits);
          _impl_.campaignid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 codeGroupId = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_codegroupid(&has_bits);
          _impl_.codegroupid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 recordId = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_recordid(&has_bits);
          _impl_.recordid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 type = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_type(&has_bits);
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RedemptionRecordKey::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:playapi.proto.finsky.RedemptionRecordKey)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 publisherId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_publisherid(), target);
  }

  // optional int64 campaignId = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_campaignid(), target);
  }

  // optional int64 codeGroupId = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_codegroupid(), target);
  }

  // optional int64 recordId = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_recordid(), target);
  }

  // optional int32 type = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:playapi.proto.finsky.RedemptionRecordKey)
  return target;
}

size_t RedemptionRecordKey::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:playapi.proto.finsky.RedemptionRecordKey)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional int64 publisherId = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_publisherid());
    }

    // optional int64 campaignId = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_campaignid());
    }

    // optional int64 codeGroupId = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_codegroupid());
    }

    // optional int64 recordId = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_recordid());
    }

    // optional int32 type = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RedemptionRecordKey::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RedemptionRecordKey::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RedemptionRecordKey::GetClassData() const { return &_class_data_; }


void RedemptionRecordKey::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RedemptionRecordKey*>(&to_msg);
  auto& from = static_cast<const RedemptionRecordKey&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:playapi.proto.finsky.RedemptionRecordKey)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.publisherid_ = from._impl_.publisherid_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.campaignid_ = from._impl_.campaignid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.codegroupid_ = from._impl_.codegroupid_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.recordid_ = from._impl_.recordid_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RedemptionRecordKey::CopyFrom(const RedemptionRecordKey& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:playapi.proto.finsky.RedemptionRecordKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RedemptionRecordKey::IsInitialized() const {
  return true;
}

void RedemptionRecordKey::InternalSwap(RedemptionRecordKey* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RedemptionRecordKey, _impl_.type_)
      + sizeof(RedemptionRecordKey::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(RedemptionRecordKey, _impl_.publisherid_)>(
          reinterpret_cast<char*>(&_impl_.publisherid_),
          reinterpret_cast<char*>(&other->_impl_.publisherid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RedemptionRecordKey::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_play_5fcommon_2eproto_getter, &descriptor_table_play_5fcommon_2eproto_once,
      file_level_metadata_play_5fcommon_2eproto[19]);
}

// ===================================================================

class VoucherId::_Internal {
 public:
  using HasBits = decltype(std::declval<VoucherId>()._impl_._has_bits_);
  static const ::playapi::proto::finsky::Docid& voucherdocid(const VoucherId* msg);
  static void set_has_voucherdocid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::playapi::proto::finsky::RedemptionRecordKey& key(const VoucherId* msg);
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::playapi::proto::finsky::Docid&
VoucherId::_Internal::voucherdocid(const VoucherId* msg) {
  return *msg->_impl_.voucherdocid_;
}
const ::playapi::proto::finsky::RedemptionRecordKey&
VoucherId::_Internal::key(const VoucherId* msg) {
  return *msg->_impl_.key_;
}
VoucherId::VoucherId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:playapi.proto.finsky.VoucherId)
}
VoucherId::VoucherId(const VoucherId& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VoucherId* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.voucherdocid_){nullptr}
    , decltype(_impl_.key_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_voucherdocid()) {
    _this->_impl_.voucherdocid_ = new ::playapi::proto::finsky::Docid(*from._impl_.voucherdocid_);
  }
  if (from._internal_has_key()) {
    _this->_impl_.key_ = new ::playapi::proto::finsky::RedemptionRecordKey(*from._impl_.key_);
  }
  // @@protoc_insertion_point(copy_constructor:playapi.proto.finsky.VoucherId)
}

inline void VoucherId::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.voucherdocid_){nullptr}
    , decltype(_impl_.key_){nullptr}
  };
}

VoucherId::~VoucherId() {
  // @@protoc_insertion_point(destructor:playapi.proto.finsky.VoucherId)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VoucherId::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.voucherdocid_;
  if (this != internal_default_instance()) delete _impl_.key_;
}

void VoucherId::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VoucherId::Clear() {
// @@protoc_insertion_point(message_clear_start:playapi.proto.finsky.VoucherId)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.voucherdocid_ != nullptr);
      _impl_.voucherdocid_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.key_ != nullptr);
      _impl_.key_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VoucherId::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .playapi.proto.finsky.Docid voucherDocid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_voucherdocid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .playapi.proto.finsky.RedemptionRecordKey key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_key(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VoucherId::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:playapi.proto.finsky.VoucherId)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .playapi.proto.finsky.Docid voucherDocid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::voucherdocid(this),
        _Internal::voucherdocid(this).GetCachedSize(), target, stream);
  }

  // optional .playapi.proto.finsky.RedemptionRecordKey key = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::key(this),
        _Internal::key(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:playapi.proto.finsky.VoucherId)
  return target;
}

size_t VoucherId::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:playapi.proto.finsky.VoucherId)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .playapi.proto.finsky.Docid voucherDocid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.voucherdocid_);
    }

    // optional .playapi.proto.finsky.RedemptionRecordKey key = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.key_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VoucherId::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VoucherId::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VoucherId::GetClassData() const { return &_class_data_; }


void VoucherId::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VoucherId*>(&to_msg);
  auto& from = static_cast<const VoucherId&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:playapi.proto.finsky.VoucherId)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_voucherdocid()->::playapi::proto::finsky::Docid::MergeFrom(
          from._internal_voucherdocid());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_key()->::playapi::proto::finsky::RedemptionRecordKey::MergeFrom(
          from._internal_key());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VoucherId::CopyFrom(const VoucherId& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:playapi.proto.finsky.VoucherId)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VoucherId::IsInitialized() const {
  return true;
}

void VoucherId::InternalSwap(VoucherId* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VoucherId, _impl_.key_)
      + sizeof(VoucherId::_impl_.key_)
      - PROTOBUF_FIELD_OFFSET(VoucherId, _impl_.voucherdocid_)>(
          reinterpret_cast<char*>(&_impl_.voucherdocid_),
          reinterpret_cast<char*>(&other->_impl_.voucherdocid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VoucherId::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_play_5fcommon_2eproto_getter, &descriptor_table_play_5fcommon_2eproto_once,
      file_level_metadata_play_5fcommon_2eproto[20]);
}

// ===================================================================

class VoucherOfferTerms::_Internal {
 public:
  using HasBits = decltype(std::declval<VoucherOfferTerms>()._impl_._has_bits_);
  static void set_has_voucherpricemicros(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_voucherformattedamount(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

VoucherOfferTerms::VoucherOfferTerms(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:playapi.proto.finsky.VoucherOfferTerms)
}
VoucherOfferTerms::VoucherOfferTerms(const VoucherOfferTerms& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VoucherOfferTerms* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.voucherdocid_){from._impl_.voucherdocid_}
    , decltype(_impl_.voucherformattedamount_){}
    , decltype(_impl_.voucherpricemicros_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.voucherformattedamount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.voucherformattedamount_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_voucherformattedamount()) {
    _this->_impl_.voucherformattedamount_.Set(from._internal_voucherformattedamount(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.voucherpricemicros_ = from._impl_.voucherpricemicros_;
  // @@protoc_insertion_point(copy_constructor:playapi.proto.finsky.VoucherOfferTerms)
}

inline void VoucherOfferTerms::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.voucherdocid_){arena}
    , decltype(_impl_.voucherformattedamount_){}
    , decltype(_impl_.voucherpricemicros_){int64_t{0}}
  };
  _impl_.voucherformattedamount_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.voucherformattedamount_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

VoucherOfferTerms::~VoucherOfferTerms() {
  // @@protoc_insertion_point(destructor:playapi.proto.finsky.VoucherOfferTerms)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VoucherOfferTerms::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.voucherdocid_.~RepeatedPtrField();
  _impl_.voucherformattedamount_.Destroy();
}

void VoucherOfferTerms::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VoucherOfferTerms::Clear() {
// @@protoc_insertion_point(message_clear_start:playapi.proto.finsky.VoucherOfferTerms)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.voucherdocid_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.voucherformattedamount_.ClearNonDefaultToEmpty();
  }
  _impl_.voucherpricemicros_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VoucherOfferTerms::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .playapi.proto.finsky.Docid voucherDocid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_voucherdocid(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int64 voucherPriceMicros = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_voucherpricemicros(&has_bits);
          _impl_.voucherpricemicros_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string voucherFormattedAmount = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_voucherformattedamount();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "playapi.proto.finsky.VoucherOfferTerms.voucherFormattedAmount");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VoucherOfferTerms::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:playapi.proto.finsky.VoucherOfferTerms)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .playapi.proto.finsky.Docid voucherDocid = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_voucherdocid_size()); i < n; i++) {
    const auto& repfield = this->_internal_voucherdocid(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 voucherPriceMicros = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_voucherpricemicros(), target);
  }

  // optional string voucherFormattedAmount = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_voucherformattedamount().data(), static_cast<int>(this->_internal_voucherformattedamount().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "playapi.proto.finsky.VoucherOfferTerms.voucherFormattedAmount");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_voucherformattedamount(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:playapi.proto.finsky.VoucherOfferTerms)
  return target;
}

size_t VoucherOfferTerms::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:playapi.proto.finsky.VoucherOfferTerms)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .playapi.proto.finsky.Docid voucherDocid = 1;
  total_size += 1UL * this->_internal_voucherdocid_size();
  for (const auto& msg : this->_impl_.voucherdocid_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string voucherFormattedAmount = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_voucherformattedamount());
    }

    // optional int64 voucherPriceMicros = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_voucherpricemicros());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VoucherOfferTerms::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VoucherOfferTerms::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VoucherOfferTerms::GetClassData() const { return &_class_data_; }


void VoucherOfferTerms::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VoucherOfferTerms*>(&to_msg);
  auto& from = static_cast<const VoucherOfferTerms&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:playapi.proto.finsky.VoucherOfferTerms)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.voucherdocid_.MergeFrom(from._impl_.voucherdocid_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_voucherformattedamount(from._internal_voucherformattedamount());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.voucherpricemicros_ = from._impl_.voucherpricemicros_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VoucherOfferTerms::CopyFrom(const VoucherOfferTerms& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:playapi.proto.finsky.VoucherOfferTerms)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VoucherOfferTerms::IsInitialized() const {
  return true;
}

void VoucherOfferTerms::InternalSwap(VoucherOfferTerms* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.voucherdocid_.InternalSwap(&other->_impl_.voucherdocid_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.voucherformattedamount_, lhs_arena,
      &other->_impl_.voucherformattedamount_, rhs_arena
  );
  swap(_impl_.voucherpricemicros_, other->_impl_.voucherpricemicros_);
}

::PROTOBUF_NAMESPACE_ID::Metadata VoucherOfferTerms::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_play_5fcommon_2eproto_getter, &descriptor_table_play_5fcommon_2eproto_once,
      file_level_metadata_play_5fcommon_2eproto[21]);
}

// ===================================================================

class LibraryVoucher::_Internal {
 public:
  using HasBits = decltype(std::declval<LibraryVoucher>()._impl_._has_bits_);
  static const ::playapi::proto::finsky::VoucherId& voucherid(const LibraryVoucher* msg);
  static void set_has_voucherid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::playapi::proto::finsky::VoucherId&
LibraryVoucher::_Internal::voucherid(const LibraryVoucher* msg) {
  return *msg->_impl_.voucherid_;
}
LibraryVoucher::LibraryVoucher(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:playapi.proto.finsky.LibraryVoucher)
}
LibraryVoucher::LibraryVoucher(const LibraryVoucher& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LibraryVoucher* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.voucherid_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_voucherid()) {
    _this->_impl_.voucherid_ = new ::playapi::proto::finsky::VoucherId(*from._impl_.voucherid_);
  }
  // @@protoc_insertion_point(copy_constructor:playapi.proto.finsky.LibraryVoucher)
}

inline void LibraryVoucher::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.voucherid_){nullptr}
  };
}

LibraryVoucher::~LibraryVoucher() {
  // @@protoc_insertion_point(destructor:playapi.proto.finsky.LibraryVoucher)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LibraryVoucher::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.voucherid_;
}

void LibraryVoucher::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LibraryVoucher::Clear() {
// @@protoc_insertion_point(message_clear_start:playapi.proto.finsky.LibraryVoucher)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.voucherid_ != nullptr);
    _impl_.voucherid_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LibraryVoucher::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .playapi.proto.finsky.VoucherId voucherId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_voucherid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LibraryVoucher::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:playapi.proto.finsky.LibraryVoucher)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .playapi.proto.finsky.VoucherId voucherId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::voucherid(this),
        _Internal::voucherid(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:playapi.proto.finsky.LibraryVoucher)
  return target;
}

size_t LibraryVoucher::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:playapi.proto.finsky.LibraryVoucher)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .playapi.proto.finsky.VoucherId voucherId = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.voucherid_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LibraryVoucher::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LibraryVoucher::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LibraryVoucher::GetClassData() const { return &_class_data_; }


void LibraryVoucher::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LibraryVoucher*>(&to_msg);
  auto& from = static_cast<const LibraryVoucher&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:playapi.proto.finsky.LibraryVoucher)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_voucherid()) {
    _this->_internal_mutable_voucherid()->::playapi::proto::finsky::VoucherId::MergeFrom(
        from._internal_voucherid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LibraryVoucher::CopyFrom(const LibraryVoucher& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:playapi.proto.finsky.LibraryVoucher)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LibraryVoucher::IsInitialized() const {
  return true;
}

void LibraryVoucher::InternalSwap(LibraryVoucher* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.voucherid_, other->_impl_.voucherid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LibraryVoucher::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_play_5fcommon_2eproto_getter, &descriptor_table_play_5fcommon_2eproto_once,
      file_level_metadata_play_5fcommon_2eproto[22]);
}

// ===================================================================

class OwnershipInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<OwnershipInfo>()._impl_._has_bits_);
  static void set_has_initiationtimestampmsec(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_validuntiltimestampmsec(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_autorenewing(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_refundtimeouttimestampmsec(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_postdeliveryrefundwindowmsec(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::playapi::proto::finsky::SignedData& developerpurchaseinfo(const OwnershipInfo* msg);
  static void set_has_developerpurchaseinfo(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_preordered(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_hidden(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static const ::playapi::proto::finsky::RentalTerms& rentalterms(const OwnershipInfo* msg);
  static void set_has_rentalterms(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::playapi::proto::finsky::GroupLicenseInfo& grouplicenseinfo(const OwnershipInfo* msg);
  static void set_has_grouplicenseinfo(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::playapi::proto::finsky::LicensedDocumentInfo& licenseddocumentinfo(const OwnershipInfo* msg);
  static void set_has_licenseddocumentinfo(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_quantity(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_libraryexpirationtimestampmsec(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static const ::playapi::proto::finsky::LibraryVoucher& libraryvoucher(const OwnershipInfo* msg);
  static void set_has_libraryvoucher(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::playapi::proto::finsky::Docid& bundledocid(const OwnershipInfo* msg);
  static void set_has_bundledocid(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_bonus(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_storedvaliduntiltimestampmsec(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
};

const ::playapi::proto::finsky::SignedData&
OwnershipInfo::_Internal::developerpurchaseinfo(const OwnershipInfo* msg) {
  return *msg->_impl_.developerpurchaseinfo_;
}
const ::playapi::proto::finsky::RentalTerms&
OwnershipInfo::_Internal::rentalterms(const OwnershipInfo* msg) {
  return *msg->_impl_.rentalterms_;
}
const ::playapi::proto::finsky::GroupLicenseInfo&
OwnershipInfo::_Internal::grouplicenseinfo(const OwnershipInfo* msg) {
  return *msg->_impl_.grouplicenseinfo_;
}
const ::playapi::proto::finsky::LicensedDocumentInfo&
OwnershipInfo::_Internal::licenseddocumentinfo(const OwnershipInfo* msg) {
  return *msg->_impl_.licenseddocumentinfo_;
}
const ::playapi::proto::finsky::LibraryVoucher&
OwnershipInfo::_Internal::libraryvoucher(const OwnershipInfo* msg) {
  return *msg->_impl_.libraryvoucher_;
}
const ::playapi::proto::finsky::Docid&
OwnershipInfo::_Internal::bundledocid(const OwnershipInfo* msg) {
  return *msg->_impl_.bundledocid_;
}
OwnershipInfo::OwnershipInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:playapi.proto.finsky.OwnershipInfo)
}
OwnershipInfo::OwnershipInfo(const OwnershipInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  OwnershipInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.developerpurchaseinfo_){nullptr}
    , decltype(_impl_.rentalterms_){nullptr}
    , decltype(_impl_.grouplicenseinfo_){nullptr}
    , decltype(_impl_.licenseddocumentinfo_){nullptr}
    , decltype(_impl_.libraryvoucher_){nullptr}
    , decltype(_impl_.bundledocid_){nullptr}
    , decltype(_impl_.initiationtimestampmsec_){}
    , decltype(_impl_.validuntiltimestampmsec_){}
    , decltype(_impl_.refundtimeouttimestampmsec_){}
    , decltype(_impl_.postdeliveryrefundwindowmsec_){}
    , decltype(_impl_.autorenewing_){}
    , decltype(_impl_.preordered_){}
    , decltype(_impl_.hidden_){}
    , decltype(_impl_.bonus_){}
    , decltype(_impl_.quantity_){}
    , decltype(_impl_.libraryexpirationtimestampmsec_){}
    , decltype(_impl_.storedvaliduntiltimestampmsec_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_developerpurchaseinfo()) {
    _this->_impl_.developerpurchaseinfo_ = new ::playapi::proto::finsky::SignedData(*from._impl_.developerpurchaseinfo_);
  }
  if (from._internal_has_rentalterms()) {
    _this->_impl_.rentalterms_ = new ::playapi::proto::finsky::RentalTerms(*from._impl_.rentalterms_);
  }
  if (from._internal_has_grouplicenseinfo()) {
    _this->_impl_.grouplicenseinfo_ = new ::playapi::proto::finsky::GroupLicenseInfo(*from._impl_.grouplicenseinfo_);
  }
  if (from._internal_has_licenseddocumentinfo()) {
    _this->_impl_.licenseddocumentinfo_ = new ::playapi::proto::finsky::LicensedDocumentInfo(*from._impl_.licenseddocumentinfo_);
  }
  if (from._internal_has_libraryvoucher()) {
    _this->_impl_.libraryvoucher_ = new ::playapi::proto::finsky::LibraryVoucher(*from._impl_.libraryvoucher_);
  }
  if (from._internal_has_bundledocid()) {
    _this->_impl_.bundledocid_ = new ::playapi::proto::finsky::Docid(*from._impl_.bundledocid_);
  }
  ::memcpy(&_impl_.initiationtimestampmsec_, &from._impl_.initiationtimestampmsec_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.storedvaliduntiltimestampmsec_) -
    reinterpret_cast<char*>(&_impl_.initiationtimestampmsec_)) + sizeof(_impl_.storedvaliduntiltimestampmsec_));
  // @@protoc_insertion_point(copy_constructor:playapi.proto.finsky.OwnershipInfo)
}

inline void OwnershipInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.developerpurchaseinfo_){nullptr}
    , decltype(_impl_.rentalterms_){nullptr}
    , decltype(_impl_.grouplicenseinfo_){nullptr}
    , decltype(_impl_.licenseddocumentinfo_){nullptr}
    , decltype(_impl_.libraryvoucher_){nullptr}
    , decltype(_impl_.bundledocid_){nullptr}
    , decltype(_impl_.initiationtimestampmsec_){int64_t{0}}
    , decltype(_impl_.validuntiltimestampmsec_){int64_t{0}}
    , decltype(_impl_.refundtimeouttimestampmsec_){int64_t{0}}
    , decltype(_impl_.postdeliveryrefundwindowmsec_){int64_t{0}}
    , decltype(_impl_.autorenewing_){false}
    , decltype(_impl_.preordered_){false}
    , decltype(_impl_.hidden_){false}
    , decltype(_impl_.bonus_){false}
    , decltype(_impl_.quantity_){0}
    , decltype(_impl_.libraryexpirationtimestampmsec_){int64_t{0}}
    , decltype(_impl_.storedvaliduntiltimestampmsec_){int64_t{0}}
  };
}

OwnershipInfo::~OwnershipInfo() {
  // @@protoc_insertion_point(destructor:playapi.proto.finsky.OwnershipInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OwnershipInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.developerpurchaseinfo_;
  if (this != internal_default_instance()) delete _impl_.rentalterms_;
  if (this != internal_default_instance()) delete _impl_.grouplicenseinfo_;
  if (this != internal_default_instance()) delete _impl_.licenseddocumentinfo_;
  if (this != internal_default_instance()) delete _impl_.libraryvoucher_;
  if (this != internal_default_instance()) delete _impl_.bundledocid_;
}

void OwnershipInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OwnershipInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:playapi.proto.finsky.OwnershipInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.developerpurchaseinfo_ != nullptr);
      _impl_.developerpurchaseinfo_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.rentalterms_ != nullptr);
      _impl_.rentalterms_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.grouplicenseinfo_ != nullptr);
      _impl_.grouplicenseinfo_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.licenseddocumentinfo_ != nullptr);
      _impl_.licenseddocumentinfo_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.libraryvoucher_ != nullptr);
      _impl_.libraryvoucher_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.bundledocid_ != nullptr);
      _impl_.bundledocid_->Clear();
    }
  }
  if (cached_has_bits & 0x000000c0u) {
    ::memset(&_impl_.initiationtimestampmsec_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.validuntiltimestampmsec_) -
        reinterpret_cast<char*>(&_impl_.initiationtimestampmsec_)) + sizeof(_impl_.validuntiltimestampmsec_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.refundtimeouttimestampmsec_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.libraryexpirationtimestampmsec_) -
        reinterpret_cast<char*>(&_impl_.refundtimeouttimestampmsec_)) + sizeof(_impl_.libraryexpirationtimestampmsec_));
  }
  _impl_.storedvaliduntiltimestampmsec_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OwnershipInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 initiationTimestampMsec = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_initiationtimestampmsec(&has_bits);
          _impl_.initiationtimestampmsec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 validUntilTimestampMsec = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_validuntiltimestampmsec(&has_bits);
          _impl_.validuntiltimestampmsec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool autoRenewing = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_autorenewing(&has_bits);
          _impl_.autorenewing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 refundTimeoutTimestampMsec = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_refundtimeouttimestampmsec(&has_bits);
          _impl_.refundtimeouttimestampmsec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 postDeliveryRefundWindowMsec = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_postdeliveryrefundwindowmsec(&has_bits);
          _impl_.postdeliveryrefundwindowmsec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .playapi.proto.finsky.SignedData developerPurchaseInfo = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_developerpurchaseinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool preordered = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_preordered(&has_bits);
          _impl_.preordered_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool hidden = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_hidden(&has_bits);
          _impl_.hidden_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .playapi.proto.finsky.RentalTerms rentalTerms = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_rentalterms(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .playapi.proto.finsky.GroupLicenseInfo groupLicenseInfo = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_grouplicenseinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .playapi.proto.finsky.LicensedDocumentInfo licensedDocumentInfo = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_licenseddocumentinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 quantity = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_quantity(&has_bits);
          _impl_.quantity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 libraryExpirationTimestampMsec = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_libraryexpirationtimestampmsec(&has_bits);
          _impl_.libraryexpirationtimestampmsec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .playapi.proto.finsky.LibraryVoucher libraryVoucher = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_libraryvoucher(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .playapi.proto.finsky.Docid bundleDocid = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_bundledocid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool bonus = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_bonus(&has_bits);
          _impl_.bonus_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 storedValidUntilTimestampMsec = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_storedvaliduntiltimestampmsec(&has_bits);
          _impl_.storedvaliduntiltimestampmsec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OwnershipInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:playapi.proto.finsky.OwnershipInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 initiationTimestampMsec = 1;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_initiationtimestampmsec(), target);
  }

  // optional int64 validUntilTimestampMsec = 2;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_validuntiltimestampmsec(), target);
  }

  // optional bool autoRenewing = 3;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_autorenewing(), target);
  }

  // optional int64 refundTimeoutTimestampMsec = 4;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_refundtimeouttimestampmsec(), target);
  }

  // optional int64 postDeliveryRefundWindowMsec = 5;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_postdeliveryrefundwindowmsec(), target);
  }

  // optional .playapi.proto.finsky.SignedData developerPurchaseInfo = 6;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::developerpurchaseinfo(this),
        _Internal::developerpurchaseinfo(this).GetCachedSize(), target, stream);
  }

  // optional bool preordered = 7;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_preordered(), target);
  }

  // optional bool hidden = 8;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_hidden(), target);
  }

  // optional .playapi.proto.finsky.RentalTerms rentalTerms = 9;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::rentalterms(this),
        _Internal::rentalterms(this).GetCachedSize(), target, stream);
  }

  // optional .playapi.proto.finsky.GroupLicenseInfo groupLicenseInfo = 10;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::grouplicenseinfo(this),
        _Internal::grouplicenseinfo(this).GetCachedSize(), target, stream);
  }

  // optional .playapi.proto.finsky.LicensedDocumentInfo licensedDocumentInfo = 11;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::licenseddocumentinfo(this),
        _Internal::licenseddocumentinfo(this).GetCachedSize(), target, stream);
  }

  // optional int32 quantity = 12;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(12, this->_internal_quantity(), target);
  }

  // optional int64 libraryExpirationTimestampMsec = 14;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(14, this->_internal_libraryexpirationtimestampmsec(), target);
  }

  // optional .playapi.proto.finsky.LibraryVoucher libraryVoucher = 15;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::libraryvoucher(this),
        _Internal::libraryvoucher(this).GetCachedSize(), target, stream);
  }

  // optional .playapi.proto.finsky.Docid bundleDocid = 16;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(16, _Internal::bundledocid(this),
        _Internal::bundledocid(this).GetCachedSize(), target, stream);
  }

  // optional bool bonus = 17;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(17, this->_internal_bonus(), target);
  }

  // optional int64 storedValidUntilTimestampMsec = 18;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(18, this->_internal_storedvaliduntiltimestampmsec(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:playapi.proto.finsky.OwnershipInfo)
  return target;
}

size_t OwnershipInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:playapi.proto.finsky.OwnershipInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .playapi.proto.finsky.SignedData developerPurchaseInfo = 6;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.developerpurchaseinfo_);
    }

    // optional .playapi.proto.finsky.RentalTerms rentalTerms = 9;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.rentalterms_);
    }

    // optional .playapi.proto.finsky.GroupLicenseInfo groupLicenseInfo = 10;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.grouplicenseinfo_);
    }

    // optional .playapi.proto.finsky.LicensedDocumentInfo licensedDocumentInfo = 11;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.licenseddocumentinfo_);
    }

    // optional .playapi.proto.finsky.LibraryVoucher libraryVoucher = 15;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.libraryvoucher_);
    }

    // optional .playapi.proto.finsky.Docid bundleDocid = 16;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.bundledocid_);
    }

    // optional int64 initiationTimestampMsec = 1;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_initiationtimestampmsec());
    }

    // optional int64 validUntilTimestampMsec = 2;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_validuntiltimestampmsec());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional int64 refundTimeoutTimestampMsec = 4;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_refundtimeouttimestampmsec());
    }

    // optional int64 postDeliveryRefundWindowMsec = 5;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_postdeliveryrefundwindowmsec());
    }

    // optional bool autoRenewing = 3;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional bool preordered = 7;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

    // optional bool hidden = 8;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 1;
    }

    // optional bool bonus = 17;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 + 1;
    }

    // optional int32 quantity = 12;
    if (cached_has_bits & 0x00004000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_quantity());
    }

    // optional int64 libraryExpirationTimestampMsec = 14;
    if (cached_has_bits & 0x00008000u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_libraryexpirationtimestampmsec());
    }

  }
  // optional int64 storedValidUntilTimestampMsec = 18;
  if (cached_has_bits & 0x00010000u) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int64Size(
        this->_internal_storedvaliduntiltimestampmsec());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OwnershipInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    OwnershipInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OwnershipInfo::GetClassData() const { return &_class_data_; }


void OwnershipInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<OwnershipInfo*>(&to_msg);
  auto& from = static_cast<const OwnershipInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:playapi.proto.finsky.OwnershipInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_developerpurchaseinfo()->::playapi::proto::finsky::SignedData::MergeFrom(
          from._internal_developerpurchaseinfo());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_rentalterms()->::playapi::proto::finsky::RentalTerms::MergeFrom(
          from._internal_rentalterms());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_grouplicenseinfo()->::playapi::proto::finsky::GroupLicenseInfo::MergeFrom(
          from._internal_grouplicenseinfo());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_licenseddocumentinfo()->::playapi::proto::finsky::LicensedDocumentInfo::MergeFrom(
          from._internal_licenseddocumentinfo());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_libraryvoucher()->::playapi::proto::finsky::LibraryVoucher::MergeFrom(
          from._internal_libraryvoucher());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_bundledocid()->::playapi::proto::finsky::Docid::MergeFrom(
          from._internal_bundledocid());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.initiationtimestampmsec_ = from._impl_.initiationtimestampmsec_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.validuntiltimestampmsec_ = from._impl_.validuntiltimestampmsec_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.refundtimeouttimestampmsec_ = from._impl_.refundtimeouttimestampmsec_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.postdeliveryrefundwindowmsec_ = from._impl_.postdeliveryrefundwindowmsec_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.autorenewing_ = from._impl_.autorenewing_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.preordered_ = from._impl_.preordered_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.hidden_ = from._impl_.hidden_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.bonus_ = from._impl_.bonus_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.quantity_ = from._impl_.quantity_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.libraryexpirationtimestampmsec_ = from._impl_.libraryexpirationtimestampmsec_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00010000u) {
    _this->_internal_set_storedvaliduntiltimestampmsec(from._internal_storedvaliduntiltimestampmsec());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OwnershipInfo::CopyFrom(const OwnershipInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:playapi.proto.finsky.OwnershipInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OwnershipInfo::IsInitialized() const {
  return true;
}

void OwnershipInfo::InternalSwap(OwnershipInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OwnershipInfo, _impl_.storedvaliduntiltimestampmsec_)
      + sizeof(OwnershipInfo::_impl_.storedvaliduntiltimestampmsec_)
      - PROTOBUF_FIELD_OFFSET(OwnershipInfo, _impl_.developerpurchaseinfo_)>(
          reinterpret_cast<char*>(&_impl_.developerpurchaseinfo_),
          reinterpret_cast<char*>(&other->_impl_.developerpurchaseinfo_));
}

::PROTOBUF_NAMESPACE_ID::Metadata OwnershipInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_play_5fcommon_2eproto_getter, &descriptor_table_play_5fcommon_2eproto_once,
      file_level_metadata_play_5fcommon_2eproto[23]);
}

// ===================================================================

class Image_Dimension::_Internal {
 public:
  using HasBits = decltype(std::declval<Image_Dimension>()._impl_._has_bits_);
  static void set_has_width(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_height(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_aspectratio(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Image_Dimension::Image_Dimension(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:playapi.proto.finsky.Image.Dimension)
}
Image_Dimension::Image_Dimension(const Image_Dimension& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Image_Dimension* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.width_){}
    , decltype(_impl_.height_){}
    , decltype(_impl_.aspectratio_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.width_, &from._impl_.width_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.aspectratio_) -
    reinterpret_cast<char*>(&_impl_.width_)) + sizeof(_impl_.aspectratio_));
  // @@protoc_insertion_point(copy_constructor:playapi.proto.finsky.Image.Dimension)
}

inline void Image_Dimension::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.width_){0}
    , decltype(_impl_.height_){0}
    , decltype(_impl_.aspectratio_){0}
  };
}

Image_Dimension::~Image_Dimension() {
  // @@protoc_insertion_point(destructor:playapi.proto.finsky.Image.Dimension)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Image_Dimension::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Image_Dimension::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Image_Dimension::Clear() {
// @@protoc_insertion_point(message_clear_start:playapi.proto.finsky.Image.Dimension)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.width_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.aspectratio_) -
        reinterpret_cast<char*>(&_impl_.width_)) + sizeof(_impl_.aspectratio_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Image_Dimension::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 width = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_width(&has_bits);
          _impl_.width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 height = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_height(&has_bits);
          _impl_.height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 aspectRatio = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_aspectratio(&has_bits);
          _impl_.aspectratio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Image_Dimension::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:playapi.proto.finsky.Image.Dimension)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 width = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_width(), target);
  }

  // optional int32 height = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_height(), target);
  }

  // optional int32 aspectRatio = 18;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(18, this->_internal_aspectratio(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:playapi.proto.finsky.Image.Dimension)
  return target;
}

size_t Image_Dimension::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:playapi.proto.finsky.Image.Dimension)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional int32 width = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_width());
    }

    // optional int32 height = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_height());
    }

    // optional int32 aspectRatio = 18;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_aspectratio());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Image_Dimension::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Image_Dimension::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Image_Dimension::GetClassData() const { return &_class_data_; }


void Image_Dimension::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Image_Dimension*>(&to_msg);
  auto& from = static_cast<const Image_Dimension&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:playapi.proto.finsky.Image.Dimension)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.width_ = from._impl_.width_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.height_ = from._impl_.height_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.aspectratio_ = from._impl_.aspectratio_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Image_Dimension::CopyFrom(const Image_Dimension& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:playapi.proto.finsky.Image.Dimension)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Image_Dimension::IsInitialized() const {
  return true;
}

void Image_Dimension::InternalSwap(Image_Dimension* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Image_Dimension, _impl_.aspectratio_)
      + sizeof(Image_Dimension::_impl_.aspectratio_)
      - PROTOBUF_FIELD_OFFSET(Image_Dimension, _impl_.width_)>(
          reinterpret_cast<char*>(&_impl_.width_),
          reinterpret_cast<char*>(&other->_impl_.width_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Image_Dimension::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_play_5fcommon_2eproto_getter, &descriptor_table_play_5fcommon_2eproto_once,
      file_level_metadata_play_5fcommon_2eproto[24]);
}

// ===================================================================

class Image_Citation::_Internal {
 public:
  using HasBits = decltype(std::declval<Image_Citation>()._impl_._has_bits_);
  static void set_has_titlelocalized(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_url(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Image_Citation::Image_Citation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:playapi.proto.finsky.Image.Citation)
}
Image_Citation::Image_Citation(const Image_Citation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Image_Citation* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.titlelocalized_){}
    , decltype(_impl_.url_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.titlelocalized_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.titlelocalized_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_titlelocalized()) {
    _this->_impl_.titlelocalized_.Set(from._internal_titlelocalized(), 
      _this->GetArenaForAllocation());
  }
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_url()) {
    _this->_impl_.url_.Set(from._internal_url(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:playapi.proto.finsky.Image.Citation)
}

inline void Image_Citation::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.titlelocalized_){}
    , decltype(_impl_.url_){}
  };
  _impl_.titlelocalized_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.titlelocalized_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Image_Citation::~Image_Citation() {
  // @@protoc_insertion_point(destructor:playapi.proto.finsky.Image.Citation)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Image_Citation::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.titlelocalized_.Destroy();
  _impl_.url_.Destroy();
}

void Image_Citation::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Image_Citation::Clear() {
// @@protoc_insertion_point(message_clear_start:playapi.proto.finsky.Image.Citation)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.titlelocalized_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.url_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Image_Citation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string titleLocalized = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_titlelocalized();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "playapi.proto.finsky.Image.Citation.titleLocalized");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string url = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "playapi.proto.finsky.Image.Citation.url");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Image_Citation::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:playapi.proto.finsky.Image.Citation)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string titleLocalized = 11;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_titlelocalized().data(), static_cast<int>(this->_internal_titlelocalized().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "playapi.proto.finsky.Image.Citation.titleLocalized");
    target = stream->WriteStringMaybeAliased(
        11, this->_internal_titlelocalized(), target);
  }

  // optional string url = 12;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_url().data(), static_cast<int>(this->_internal_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "playapi.proto.finsky.Image.Citation.url");
    target = stream->WriteStringMaybeAliased(
        12, this->_internal_url(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:playapi.proto.finsky.Image.Citation)
  return target;
}

size_t Image_Citation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:playapi.proto.finsky.Image.Citation)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string titleLocalized = 11;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_titlelocalized());
    }

    // optional string url = 12;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_url());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Image_Citation::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Image_Citation::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Image_Citation::GetClassData() const { return &_class_data_; }


void Image_Citation::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Image_Citation*>(&to_msg);
  auto& from = static_cast<const Image_Citation&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:playapi.proto.finsky.Image.Citation)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_titlelocalized(from._internal_titlelocalized());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_url(from._internal_url());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Image_Citation::CopyFrom(const Image_Citation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:playapi.proto.finsky.Image.Citation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Image_Citation::IsInitialized() const {
  return true;
}

void Image_Citation::InternalSwap(Image_Citation* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.titlelocalized_, lhs_arena,
      &other->_impl_.titlelocalized_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.url_, lhs_arena,
      &other->_impl_.url_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata Image_Citation::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_play_5fcommon_2eproto_getter, &descriptor_table_play_5fcommon_2eproto_once,
      file_level_metadata_play_5fcommon_2eproto[25]);
}

// ===================================================================

class Image::_Internal {
 public:
  using HasBits = decltype(std::declval<Image>()._impl_._has_bits_);
  static void set_has_imagetype(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::playapi::proto::finsky::Image_Dimension& dimension(const Image* msg);
  static void set_has_dimension(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_imageurl(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_alttextlocalized(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_secureurl(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_positioninsequence(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_supportsfifeurloptions(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static const ::playapi::proto::finsky::Image_Citation& citation(const Image* msg);
  static void set_has_citation(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_durationseconds(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_fillcolorrgb(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_autogen(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static const ::playapi::proto::finsky::Attribution& attribution(const Image* msg);
  static void set_has_attribution(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_backgroundcolorrgb(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::playapi::proto::finsky::ImagePalette& palette(const Image* msg);
  static void set_has_palette(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_deviceclass(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_supportsfifemonogramoption(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
};

const ::playapi::proto::finsky::Image_Dimension&
Image::_Internal::dimension(const Image* msg) {
  return *msg->_impl_.dimension_;
}
const ::playapi::proto::finsky::Image_Citation&
Image::_Internal::citation(const Image* msg) {
  return *msg->_impl_.citation_;
}
const ::playapi::proto::finsky::Attribution&
Image::_Internal::attribution(const Image* msg) {
  return *msg->_impl_.attribution_;
}
const ::playapi::proto::finsky::ImagePalette&
Image::_Internal::palette(const Image* msg) {
  return *msg->_impl_.palette_;
}
Image::Image(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:playapi.proto.finsky.Image)
}
Image::Image(const Image& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Image* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.imageurl_){}
    , decltype(_impl_.alttextlocalized_){}
    , decltype(_impl_.secureurl_){}
    , decltype(_impl_.fillcolorrgb_){}
    , decltype(_impl_.backgroundcolorrgb_){}
    , decltype(_impl_.dimension_){nullptr}
    , decltype(_impl_.citation_){nullptr}
    , decltype(_impl_.attribution_){nullptr}
    , decltype(_impl_.palette_){nullptr}
    , decltype(_impl_.imagetype_){}
    , decltype(_impl_.positioninsequence_){}
    , decltype(_impl_.durationseconds_){}
    , decltype(_impl_.supportsfifeurloptions_){}
    , decltype(_impl_.autogen_){}
    , decltype(_impl_.supportsfifemonogramoption_){}
    , decltype(_impl_.deviceclass_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.imageurl_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.imageurl_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_imageurl()) {
    _this->_impl_.imageurl_.Set(from._internal_imageurl(), 
      _this->GetArenaForAllocation());
  }
  _impl_.alttextlocalized_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.alttextlocalized_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_alttextlocalized()) {
    _this->_impl_.alttextlocalized_.Set(from._internal_alttextlocalized(), 
      _this->GetArenaForAllocation());
  }
  _impl_.secureurl_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.secureurl_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_secureurl()) {
    _this->_impl_.secureurl_.Set(from._internal_secureurl(), 
      _this->GetArenaForAllocation());
  }
  _impl_.fillcolorrgb_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fillcolorrgb_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_fillcolorrgb()) {
    _this->_impl_.fillcolorrgb_.Set(from._internal_fillcolorrgb(), 
      _this->GetArenaForAllocation());
  }
  _impl_.backgroundcolorrgb_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.backgroundcolorrgb_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_backgroundcolorrgb()) {
    _this->_impl_.backgroundcolorrgb_.Set(from._internal_backgroundcolorrgb(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_dimension()) {
    _this->_impl_.dimension_ = new ::playapi::proto::finsky::Image_Dimension(*from._impl_.dimension_);
  }
  if (from._internal_has_citation()) {
    _this->_impl_.citation_ = new ::playapi::proto::finsky::Image_Citation(*from._impl_.citation_);
  }
  if (from._internal_has_attribution()) {
    _this->_impl_.attribution_ = new ::playapi::proto::finsky::Attribution(*from._impl_.attribution_);
  }
  if (from._internal_has_palette()) {
    _this->_impl_.palette_ = new ::playapi::proto::finsky::ImagePalette(*from._impl_.palette_);
  }
  ::memcpy(&_impl_.imagetype_, &from._impl_.imagetype_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.deviceclass_) -
    reinterpret_cast<char*>(&_impl_.imagetype_)) + sizeof(_impl_.deviceclass_));
  // @@protoc_insertion_point(copy_constructor:playapi.proto.finsky.Image)
}

inline void Image::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.imageurl_){}
    , decltype(_impl_.alttextlocalized_){}
    , decltype(_impl_.secureurl_){}
    , decltype(_impl_.fillcolorrgb_){}
    , decltype(_impl_.backgroundcolorrgb_){}
    , decltype(_impl_.dimension_){nullptr}
    , decltype(_impl_.citation_){nullptr}
    , decltype(_impl_.attribution_){nullptr}
    , decltype(_impl_.palette_){nullptr}
    , decltype(_impl_.imagetype_){0}
    , decltype(_impl_.positioninsequence_){0}
    , decltype(_impl_.durationseconds_){0}
    , decltype(_impl_.supportsfifeurloptions_){false}
    , decltype(_impl_.autogen_){false}
    , decltype(_impl_.supportsfifemonogramoption_){false}
    , decltype(_impl_.deviceclass_){0}
  };
  _impl_.imageurl_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.imageurl_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.alttextlocalized_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.alttextlocalized_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.secureurl_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.secureurl_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fillcolorrgb_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fillcolorrgb_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.backgroundcolorrgb_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.backgroundcolorrgb_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Image::~Image() {
  // @@protoc_insertion_point(destructor:playapi.proto.finsky.Image)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Image::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.imageurl_.Destroy();
  _impl_.alttextlocalized_.Destroy();
  _impl_.secureurl_.Destroy();
  _impl_.fillcolorrgb_.Destroy();
  _impl_.backgroundcolorrgb_.Destroy();
  if (this != internal_default_instance()) delete _impl_.dimension_;
  if (this != internal_default_instance()) delete _impl_.citation_;
  if (this != internal_default_instance()) delete _impl_.attribution_;
  if (this != internal_default_instance()) delete _impl_.palette_;
}

void Image::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Image::Clear() {
// @@protoc_insertion_point(message_clear_start:playapi.proto.finsky.Image)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.imageurl_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.alttextlocalized_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.secureurl_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.fillcolorrgb_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.backgroundcolorrgb_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.dimension_ != nullptr);
      _impl_.dimension_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.citation_ != nullptr);
      _impl_.citation_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.attribution_ != nullptr);
      _impl_.attribution_->Clear();
    }
  }
  if (cached_has_bits & 0x00000100u) {
    GOOGLE_DCHECK(_impl_.palette_ != nullptr);
    _impl_.palette_->Clear();
  }
  if (cached_has_bits & 0x0000fe00u) {
    ::memset(&_impl_.imagetype_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.deviceclass_) -
        reinterpret_cast<char*>(&_impl_.imagetype_)) + sizeof(_impl_.deviceclass_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Image::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 imageType = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_imagetype(&has_bits);
          _impl_.imagetype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional group Dimension = 2 { ... };
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 19)) {
          ptr = ctx->ParseGroup(_internal_mutable_dimension(), ptr, 19);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string imageUrl = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_imageurl();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "playapi.proto.finsky.Image.imageUrl");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string altTextLocalized = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_alttextlocalized();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "playapi.proto.finsky.Image.altTextLocalized");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string secureUrl = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_secureurl();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "playapi.proto.finsky.Image.secureUrl");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional int32 positionInSequence = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_positioninsequence(&has_bits);
          _impl_.positioninsequence_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool supportsFifeUrlOptions = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_supportsfifeurloptions(&has_bits);
          _impl_.supportsfifeurloptions_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional group Citation = 10 { ... };
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 83)) {
          ptr = ctx->ParseGroup(_internal_mutable_citation(), ptr, 83);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 durationSeconds = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_durationseconds(&has_bits);
          _impl_.durationseconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string fillColorRgb = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          auto str = _internal_mutable_fillcolorrgb();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "playapi.proto.finsky.Image.fillColorRgb");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool autogen = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_autogen(&has_bits);
          _impl_.autogen_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .playapi.proto.finsky.Attribution attribution = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_attribution(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string backgroundColorRgb = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          auto str = _internal_mutable_backgroundcolorrgb();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "playapi.proto.finsky.Image.backgroundColorRgb");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .playapi.proto.finsky.ImagePalette palette = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_palette(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 deviceClass = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_deviceclass(&has_bits);
          _impl_.deviceclass_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool supportsFifeMonogramOption = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _Internal::set_has_supportsfifemonogramoption(&has_bits);
          _impl_.supportsfifemonogramoption_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Image::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:playapi.proto.finsky.Image)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 imageType = 1;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_imagetype(), target);
  }

  // optional group Dimension = 2 { ... };
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteGroup(
        2, _Internal::dimension(this), target, stream);
  }

  // optional string imageUrl = 5;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_imageurl().data(), static_cast<int>(this->_internal_imageurl().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "playapi.proto.finsky.Image.imageUrl");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_imageurl(), target);
  }

  // optional string altTextLocalized = 6;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_alttextlocalized().data(), static_cast<int>(this->_internal_alttextlocalized().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "playapi.proto.finsky.Image.altTextLocalized");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_alttextlocalized(), target);
  }

  // optional string secureUrl = 7;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_secureurl().data(), static_cast<int>(this->_internal_secureurl().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "playapi.proto.finsky.Image.secureUrl");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_secureurl(), target);
  }

  // optional int32 positionInSequence = 8;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_positioninsequence(), target);
  }

  // optional bool supportsFifeUrlOptions = 9;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_supportsfifeurloptions(), target);
  }

  // optional group Citation = 10 { ... };
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteGroup(
        10, _Internal::citation(this), target, stream);
  }

  // optional int32 durationSeconds = 14;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(14, this->_internal_durationseconds(), target);
  }

  // optional string fillColorRgb = 15;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_fillcolorrgb().data(), static_cast<int>(this->_internal_fillcolorrgb().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "playapi.proto.finsky.Image.fillColorRgb");
    target = stream->WriteStringMaybeAliased(
        15, this->_internal_fillcolorrgb(), target);
  }

  // optional bool autogen = 16;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(16, this->_internal_autogen(), target);
  }

  // optional .playapi.proto.finsky.Attribution attribution = 17;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(17, _Internal::attribution(this),
        _Internal::attribution(this).GetCachedSize(), target, stream);
  }

  // optional string backgroundColorRgb = 19;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_backgroundcolorrgb().data(), static_cast<int>(this->_internal_backgroundcolorrgb().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "playapi.proto.finsky.Image.backgroundColorRgb");
    target = stream->WriteStringMaybeAliased(
        19, this->_internal_backgroundcolorrgb(), target);
  }

  // optional .playapi.proto.finsky.ImagePalette palette = 20;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(20, _Internal::palette(this),
        _Internal::palette(this).GetCachedSize(), target, stream);
  }

  // optional int32 deviceClass = 21;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(21, this->_internal_deviceclass(), target);
  }

  // optional bool supportsFifeMonogramOption = 22;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(22, this->_internal_supportsfifemonogramoption(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:playapi.proto.finsky.Image)
  return target;
}

size_t Image::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:playapi.proto.finsky.Image)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string imageUrl = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_imageurl());
    }

    // optional string altTextLocalized = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_alttextlocalized());
    }

    // optional string secureUrl = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_secureurl());
    }

    // optional string fillColorRgb = 15;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_fillcolorrgb());
    }

    // optional string backgroundColorRgb = 19;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_backgroundcolorrgb());
    }

    // optional group Dimension = 2 { ... };
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GroupSize(
          *_impl_.dimension_);
    }

    // optional group Citation = 10 { ... };
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GroupSize(
          *_impl_.citation_);
    }

    // optional .playapi.proto.finsky.Attribution attribution = 17;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.attribution_);
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional .playapi.proto.finsky.ImagePalette palette = 20;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.palette_);
    }

    // optional int32 imageType = 1;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_imagetype());
    }

    // optional int32 positionInSequence = 8;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_positioninsequence());
    }

    // optional int32 durationSeconds = 14;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_durationseconds());
    }

    // optional bool supportsFifeUrlOptions = 9;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 1;
    }

    // optional bool autogen = 16;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 + 1;
    }

    // optional bool supportsFifeMonogramOption = 22;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 + 1;
    }

    // optional int32 deviceClass = 21;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_deviceclass());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Image::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Image::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Image::GetClassData() const { return &_class_data_; }


void Image::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Image*>(&to_msg);
  auto& from = static_cast<const Image&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:playapi.proto.finsky.Image)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_imageurl(from._internal_imageurl());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_alttextlocalized(from._internal_alttextlocalized());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_secureurl(from._internal_secureurl());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_fillcolorrgb(from._internal_fillcolorrgb());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_backgroundcolorrgb(from._internal_backgroundcolorrgb());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_dimension()->::playapi::proto::finsky::Image_Dimension::MergeFrom(
          from._internal_dimension());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_citation()->::playapi::proto::finsky::Image_Citation::MergeFrom(
          from._internal_citation());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_attribution()->::playapi::proto::finsky::Attribution::MergeFrom(
          from._internal_attribution());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_mutable_palette()->::playapi::proto::finsky::ImagePalette::MergeFrom(
          from._internal_palette());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.imagetype_ = from._impl_.imagetype_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.positioninsequence_ = from._impl_.positioninsequence_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.durationseconds_ = from._impl_.durationseconds_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.supportsfifeurloptions_ = from._impl_.supportsfifeurloptions_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.autogen_ = from._impl_.autogen_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.supportsfifemonogramoption_ = from._impl_.supportsfifemonogramoption_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.deviceclass_ = from._impl_.deviceclass_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Image::CopyFrom(const Image& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:playapi.proto.finsky.Image)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Image::IsInitialized() const {
  return true;
}

void Image::InternalSwap(Image* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.imageurl_, lhs_arena,
      &other->_impl_.imageurl_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.alttextlocalized_, lhs_arena,
      &other->_impl_.alttextlocalized_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.secureurl_, lhs_arena,
      &other->_impl_.secureurl_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.fillcolorrgb_, lhs_arena,
      &other->_impl_.fillcolorrgb_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.backgroundcolorrgb_, lhs_arena,
      &other->_impl_.backgroundcolorrgb_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Image, _impl_.deviceclass_)
      + sizeof(Image::_impl_.deviceclass_)
      - PROTOBUF_FIELD_OFFSET(Image, _impl_.dimension_)>(
          reinterpret_cast<char*>(&_impl_.dimension_),
          reinterpret_cast<char*>(&other->_impl_.dimension_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Image::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_play_5fcommon_2eproto_getter, &descriptor_table_play_5fcommon_2eproto_once,
      file_level_metadata_play_5fcommon_2eproto[26]);
}

// ===================================================================

class ImagePalette::_Internal {
 public:
  using HasBits = decltype(std::declval<ImagePalette>()._impl_._has_bits_);
  static void set_has_lightvibrantrgb(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_vibrantrgb(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_darkvibrantrgb(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_lightmutedrgb(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_mutedrgb(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_darkmutedrgb(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

ImagePalette::ImagePalette(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:playapi.proto.finsky.ImagePalette)
}
ImagePalette::ImagePalette(const ImagePalette& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ImagePalette* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.lightvibrantrgb_){}
    , decltype(_impl_.vibrantrgb_){}
    , decltype(_impl_.darkvibrantrgb_){}
    , decltype(_impl_.lightmutedrgb_){}
    , decltype(_impl_.mutedrgb_){}
    , decltype(_impl_.darkmutedrgb_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.lightvibrantrgb_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.lightvibrantrgb_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_lightvibrantrgb()) {
    _this->_impl_.lightvibrantrgb_.Set(from._internal_lightvibrantrgb(), 
      _this->GetArenaForAllocation());
  }
  _impl_.vibrantrgb_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vibrantrgb_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_vibrantrgb()) {
    _this->_impl_.vibrantrgb_.Set(from._internal_vibrantrgb(), 
      _this->GetArenaForAllocation());
  }
  _impl_.darkvibrantrgb_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.darkvibrantrgb_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_darkvibrantrgb()) {
    _this->_impl_.darkvibrantrgb_.Set(from._internal_darkvibrantrgb(), 
      _this->GetArenaForAllocation());
  }
  _impl_.lightmutedrgb_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.lightmutedrgb_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_lightmutedrgb()) {
    _this->_impl_.lightmutedrgb_.Set(from._internal_lightmutedrgb(), 
      _this->GetArenaForAllocation());
  }
  _impl_.mutedrgb_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mutedrgb_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_mutedrgb()) {
    _this->_impl_.mutedrgb_.Set(from._internal_mutedrgb(), 
      _this->GetArenaForAllocation());
  }
  _impl_.darkmutedrgb_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.darkmutedrgb_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_darkmutedrgb()) {
    _this->_impl_.darkmutedrgb_.Set(from._internal_darkmutedrgb(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:playapi.proto.finsky.ImagePalette)
}

inline void ImagePalette::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.lightvibrantrgb_){}
    , decltype(_impl_.vibrantrgb_){}
    , decltype(_impl_.darkvibrantrgb_){}
    , decltype(_impl_.lightmutedrgb_){}
    , decltype(_impl_.mutedrgb_){}
    , decltype(_impl_.darkmutedrgb_){}
  };
  _impl_.lightvibrantrgb_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.lightvibrantrgb_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.vibrantrgb_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vibrantrgb_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.darkvibrantrgb_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.darkvibrantrgb_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.lightmutedrgb_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.lightmutedrgb_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.mutedrgb_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mutedrgb_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.darkmutedrgb_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.darkmutedrgb_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ImagePalette::~ImagePalette() {
  // @@protoc_insertion_point(destructor:playapi.proto.finsky.ImagePalette)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ImagePalette::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.lightvibrantrgb_.Destroy();
  _impl_.vibrantrgb_.Destroy();
  _impl_.darkvibrantrgb_.Destroy();
  _impl_.lightmutedrgb_.Destroy();
  _impl_.mutedrgb_.Destroy();
  _impl_.darkmutedrgb_.Destroy();
}

void ImagePalette::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ImagePalette::Clear() {
// @@protoc_insertion_point(message_clear_start:playapi.proto.finsky.ImagePalette)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.lightvibrantrgb_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.vibrantrgb_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.darkvibrantrgb_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.lightmutedrgb_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.mutedrgb_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.darkmutedrgb_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ImagePalette::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string lightVibrantRgb = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_lightvibrantrgb();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "playapi.proto.finsky.ImagePalette.lightVibrantRgb");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string vibrantRgb = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_vibrantrgb();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "playapi.proto.finsky.ImagePalette.vibrantRgb");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string darkVibrantRgb = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_darkvibrantrgb();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "playapi.proto.finsky.ImagePalette.darkVibrantRgb");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string lightMutedRgb = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_lightmutedrgb();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "playapi.proto.finsky.ImagePalette.lightMutedRgb");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string mutedRgb = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_mutedrgb();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "playapi.proto.finsky.ImagePalette.mutedRgb");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string darkMutedRgb = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_darkmutedrgb();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "playapi.proto.finsky.ImagePalette.darkMutedRgb");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ImagePalette::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:playapi.proto.finsky.ImagePalette)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string lightVibrantRgb = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_lightvibrantrgb().data(), static_cast<int>(this->_internal_lightvibrantrgb().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "playapi.proto.finsky.ImagePalette.lightVibrantRgb");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_lightvibrantrgb(), target);
  }

  // optional string vibrantRgb = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_vibrantrgb().data(), static_cast<int>(this->_internal_vibrantrgb().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "playapi.proto.finsky.ImagePalette.vibrantRgb");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_vibrantrgb(), target);
  }

  // optional string darkVibrantRgb = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_darkvibrantrgb().data(), static_cast<int>(this->_internal_darkvibrantrgb().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "playapi.proto.finsky.ImagePalette.darkVibrantRgb");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_darkvibrantrgb(), target);
  }

  // optional string lightMutedRgb = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_lightmutedrgb().data(), static_cast<int>(this->_internal_lightmutedrgb().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "playapi.proto.finsky.ImagePalette.lightMutedRgb");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_lightmutedrgb(), target);
  }

  // optional string mutedRgb = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_mutedrgb().data(), static_cast<int>(this->_internal_mutedrgb().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "playapi.proto.finsky.ImagePalette.mutedRgb");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_mutedrgb(), target);
  }

  // optional string darkMutedRgb = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_darkmutedrgb().data(), static_cast<int>(this->_internal_darkmutedrgb().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "playapi.proto.finsky.ImagePalette.darkMutedRgb");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_darkmutedrgb(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:playapi.proto.finsky.ImagePalette)
  return target;
}

size_t ImagePalette::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:playapi.proto.finsky.ImagePalette)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string lightVibrantRgb = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_lightvibrantrgb());
    }

    // optional string vibrantRgb = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_vibrantrgb());
    }

    // optional string darkVibrantRgb = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_darkvibrantrgb());
    }

    // optional string lightMutedRgb = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_lightmutedrgb());
    }

    // optional string mutedRgb = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_mutedrgb());
    }

    // optional string darkMutedRgb = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_darkmutedrgb());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ImagePalette::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ImagePalette::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ImagePalette::GetClassData() const { return &_class_data_; }


void ImagePalette::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ImagePalette*>(&to_msg);
  auto& from = static_cast<const ImagePalette&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:playapi.proto.finsky.ImagePalette)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_lightvibrantrgb(from._internal_lightvibrantrgb());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_vibrantrgb(from._internal_vibrantrgb());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_darkvibrantrgb(from._internal_darkvibrantrgb());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_lightmutedrgb(from._internal_lightmutedrgb());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_mutedrgb(from._internal_mutedrgb());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_darkmutedrgb(from._internal_darkmutedrgb());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ImagePalette::CopyFrom(const ImagePalette& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:playapi.proto.finsky.ImagePalette)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImagePalette::IsInitialized() const {
  return true;
}

void ImagePalette::InternalSwap(ImagePalette* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.lightvibrantrgb_, lhs_arena,
      &other->_impl_.lightvibrantrgb_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.vibrantrgb_, lhs_arena,
      &other->_impl_.vibrantrgb_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.darkvibrantrgb_, lhs_arena,
      &other->_impl_.darkvibrantrgb_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.lightmutedrgb_, lhs_arena,
      &other->_impl_.lightmutedrgb_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.mutedrgb_, lhs_arena,
      &other->_impl_.mutedrgb_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.darkmutedrgb_, lhs_arena,
      &other->_impl_.darkmutedrgb_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ImagePalette::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_play_5fcommon_2eproto_getter, &descriptor_table_play_5fcommon_2eproto_once,
      file_level_metadata_play_5fcommon_2eproto[27]);
}

// ===================================================================

class Attribution::_Internal {
 public:
  using HasBits = decltype(std::declval<Attribution>()._impl_._has_bits_);
  static void set_has_sourcetitle(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_sourceurl(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_licensetitle(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_licenseurl(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

Attribution::Attribution(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:playapi.proto.finsky.Attribution)
}
Attribution::Attribution(const Attribution& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Attribution* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sourcetitle_){}
    , decltype(_impl_.sourceurl_){}
    , decltype(_impl_.licensetitle_){}
    , decltype(_impl_.licenseurl_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.sourcetitle_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sourcetitle_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sourcetitle()) {
    _this->_impl_.sourcetitle_.Set(from._internal_sourcetitle(), 
      _this->GetArenaForAllocation());
  }
  _impl_.sourceurl_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sourceurl_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sourceurl()) {
    _this->_impl_.sourceurl_.Set(from._internal_sourceurl(), 
      _this->GetArenaForAllocation());
  }
  _impl_.licensetitle_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.licensetitle_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_licensetitle()) {
    _this->_impl_.licensetitle_.Set(from._internal_licensetitle(), 
      _this->GetArenaForAllocation());
  }
  _impl_.licenseurl_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.licenseurl_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_licenseurl()) {
    _this->_impl_.licenseurl_.Set(from._internal_licenseurl(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:playapi.proto.finsky.Attribution)
}

inline void Attribution::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sourcetitle_){}
    , decltype(_impl_.sourceurl_){}
    , decltype(_impl_.licensetitle_){}
    , decltype(_impl_.licenseurl_){}
  };
  _impl_.sourcetitle_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sourcetitle_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.sourceurl_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sourceurl_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.licensetitle_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.licensetitle_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.licenseurl_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.licenseurl_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Attribution::~Attribution() {
  // @@protoc_insertion_point(destructor:playapi.proto.finsky.Attribution)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Attribution::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.sourcetitle_.Destroy();
  _impl_.sourceurl_.Destroy();
  _impl_.licensetitle_.Destroy();
  _impl_.licenseurl_.Destroy();
}

void Attribution::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Attribution::Clear() {
// @@protoc_insertion_point(message_clear_start:playapi.proto.finsky.Attribution)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.sourcetitle_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.sourceurl_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.licensetitle_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.licenseurl_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Attribution::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string sourceTitle = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_sourcetitle();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "playapi.proto.finsky.Attribution.sourceTitle");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string sourceUrl = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_sourceurl();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "playapi.proto.finsky.Attribution.sourceUrl");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string licenseTitle = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_licensetitle();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "playapi.proto.finsky.Attribution.licenseTitle");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string licenseUrl = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_licenseurl();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "playapi.proto.finsky.Attribution.licenseUrl");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Attribution::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:playapi.proto.finsky.Attribution)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string sourceTitle = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_sourcetitle().data(), static_cast<int>(this->_internal_sourcetitle().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "playapi.proto.finsky.Attribution.sourceTitle");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_sourcetitle(), target);
  }

  // optional string sourceUrl = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_sourceurl().data(), static_cast<int>(this->_internal_sourceurl().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "playapi.proto.finsky.Attribution.sourceUrl");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_sourceurl(), target);
  }

  // optional string licenseTitle = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_licensetitle().data(), static_cast<int>(this->_internal_licensetitle().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "playapi.proto.finsky.Attribution.licenseTitle");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_licensetitle(), target);
  }

  // optional string licenseUrl = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_licenseurl().data(), static_cast<int>(this->_internal_licenseurl().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "playapi.proto.finsky.Attribution.licenseUrl");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_licenseurl(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:playapi.proto.finsky.Attribution)
  return target;
}

size_t Attribution::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:playapi.proto.finsky.Attribution)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string sourceTitle = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_sourcetitle());
    }

    // optional string sourceUrl = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_sourceurl());
    }

    // optional string licenseTitle = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_licensetitle());
    }

    // optional string licenseUrl = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_licenseurl());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Attribution::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Attribution::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Attribution::GetClassData() const { return &_class_data_; }


void Attribution::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Attribution*>(&to_msg);
  auto& from = static_cast<const Attribution&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:playapi.proto.finsky.Attribution)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_sourcetitle(from._internal_sourcetitle());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_sourceurl(from._internal_sourceurl());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_licensetitle(from._internal_licensetitle());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_licenseurl(from._internal_licenseurl());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Attribution::CopyFrom(const Attribution& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:playapi.proto.finsky.Attribution)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Attribution::IsInitialized() const {
  return true;
}

void Attribution::InternalSwap(Attribution* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.sourcetitle_, lhs_arena,
      &other->_impl_.sourcetitle_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.sourceurl_, lhs_arena,
      &other->_impl_.sourceurl_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.licensetitle_, lhs_arena,
      &other->_impl_.licensetitle_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.licenseurl_, lhs_arena,
      &other->_impl_.licenseurl_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata Attribution::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_play_5fcommon_2eproto_getter, &descriptor_table_play_5fcommon_2eproto_once,
      file_level_metadata_play_5fcommon_2eproto[28]);
}

// ===================================================================

class CertificateSet::_Internal {
 public:
};

CertificateSet::CertificateSet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:playapi.proto.finsky.CertificateSet)
}
CertificateSet::CertificateSet(const CertificateSet& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CertificateSet* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.certificatehash_){from._impl_.certificatehash_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:playapi.proto.finsky.CertificateSet)
}

inline void CertificateSet::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.certificatehash_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CertificateSet::~CertificateSet() {
  // @@protoc_insertion_point(destructor:playapi.proto.finsky.CertificateSet)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CertificateSet::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.certificatehash_.~RepeatedPtrField();
}

void CertificateSet::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CertificateSet::Clear() {
// @@protoc_insertion_point(message_clear_start:playapi.proto.finsky.CertificateSet)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.certificatehash_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CertificateSet::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string certificateHash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_certificatehash();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "playapi.proto.finsky.CertificateSet.certificateHash");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CertificateSet::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:playapi.proto.finsky.CertificateSet)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string certificateHash = 1;
  for (int i = 0, n = this->_internal_certificatehash_size(); i < n; i++) {
    const auto& s = this->_internal_certificatehash(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "playapi.proto.finsky.CertificateSet.certificateHash");
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:playapi.proto.finsky.CertificateSet)
  return target;
}

size_t CertificateSet::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:playapi.proto.finsky.CertificateSet)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string certificateHash = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.certificatehash_.size());
  for (int i = 0, n = _impl_.certificatehash_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.certificatehash_.Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CertificateSet::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CertificateSet::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CertificateSet::GetClassData() const { return &_class_data_; }


void CertificateSet::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CertificateSet*>(&to_msg);
  auto& from = static_cast<const CertificateSet&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:playapi.proto.finsky.CertificateSet)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.certificatehash_.MergeFrom(from._impl_.certificatehash_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CertificateSet::CopyFrom(const CertificateSet& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:playapi.proto.finsky.CertificateSet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CertificateSet::IsInitialized() const {
  return true;
}

void CertificateSet::InternalSwap(CertificateSet* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.certificatehash_.InternalSwap(&other->_impl_.certificatehash_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CertificateSet::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_play_5fcommon_2eproto_getter, &descriptor_table_play_5fcommon_2eproto_once,
      file_level_metadata_play_5fcommon_2eproto[29]);
}

// ===================================================================

class EncodedTargets::_Internal {
 public:
  using HasBits = decltype(std::declval<EncodedTargets>()._impl_._has_bits_);
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

EncodedTargets::EncodedTargets(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:playapi.proto.finsky.EncodedTargets)
}
EncodedTargets::EncodedTargets(const EncodedTargets& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EncodedTargets* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.supportedtarget_){from._impl_.supportedtarget_}
    , decltype(_impl_.othertarget_){from._impl_.othertarget_}
    , decltype(_impl_.version_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.version_ = from._impl_.version_;
  // @@protoc_insertion_point(copy_constructor:playapi.proto.finsky.EncodedTargets)
}

inline void EncodedTargets::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.supportedtarget_){arena}
    , decltype(_impl_.othertarget_){arena}
    , decltype(_impl_.version_){0}
  };
}

EncodedTargets::~EncodedTargets() {
  // @@protoc_insertion_point(destructor:playapi.proto.finsky.EncodedTargets)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EncodedTargets::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.supportedtarget_.~RepeatedField();
  _impl_.othertarget_.~RepeatedField();
}

void EncodedTargets::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EncodedTargets::Clear() {
// @@protoc_insertion_point(message_clear_start:playapi.proto.finsky.EncodedTargets)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.supportedtarget_.Clear();
  _impl_.othertarget_.Clear();
  _impl_.version_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EncodedTargets::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_version(&has_bits);
          _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int64 supportedTarget = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_supportedtarget(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_supportedtarget(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int64 otherTarget = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_othertarget(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_othertarget(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EncodedTargets::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:playapi.proto.finsky.EncodedTargets)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 version = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_version(), target);
  }

  // repeated int64 supportedTarget = 2;
  for (int i = 0, n = this->_internal_supportedtarget_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_supportedtarget(i), target);
  }

  // repeated int64 otherTarget = 3;
  for (int i = 0, n = this->_internal_othertarget_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_othertarget(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:playapi.proto.finsky.EncodedTargets)
  return target;
}

size_t EncodedTargets::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:playapi.proto.finsky.EncodedTargets)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 supportedTarget = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int64Size(this->_impl_.supportedtarget_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_supportedtarget_size());
    total_size += data_size;
  }

  // repeated int64 otherTarget = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int64Size(this->_impl_.othertarget_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_othertarget_size());
    total_size += data_size;
  }

  // optional int32 version = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_version());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EncodedTargets::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EncodedTargets::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EncodedTargets::GetClassData() const { return &_class_data_; }


void EncodedTargets::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EncodedTargets*>(&to_msg);
  auto& from = static_cast<const EncodedTargets&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:playapi.proto.finsky.EncodedTargets)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.supportedtarget_.MergeFrom(from._impl_.supportedtarget_);
  _this->_impl_.othertarget_.MergeFrom(from._impl_.othertarget_);
  if (from._internal_has_version()) {
    _this->_internal_set_version(from._internal_version());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EncodedTargets::CopyFrom(const EncodedTargets& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:playapi.proto.finsky.EncodedTargets)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EncodedTargets::IsInitialized() const {
  return true;
}

void EncodedTargets::InternalSwap(EncodedTargets* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.supportedtarget_.InternalSwap(&other->_impl_.supportedtarget_);
  _impl_.othertarget_.InternalSwap(&other->_impl_.othertarget_);
  swap(_impl_.version_, other->_impl_.version_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EncodedTargets::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_play_5fcommon_2eproto_getter, &descriptor_table_play_5fcommon_2eproto_once,
      file_level_metadata_play_5fcommon_2eproto[30]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace finsky
}  // namespace proto
}  // namespace playapi
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::playapi::proto::finsky::HttpCookie*
Arena::CreateMaybeMessage< ::playapi::proto::finsky::HttpCookie >(Arena* arena) {
  return Arena::CreateMessageInternal< ::playapi::proto::finsky::HttpCookie >(arena);
}
template<> PROTOBUF_NOINLINE ::playapi::proto::finsky::TimePeriod*
Arena::CreateMaybeMessage< ::playapi::proto::finsky::TimePeriod >(Arena* arena) {
  return Arena::CreateMessageInternal< ::playapi::proto::finsky::TimePeriod >(arena);
}
template<> PROTOBUF_NOINLINE ::playapi::proto::finsky::MonthAndDay*
Arena::CreateMaybeMessage< ::playapi::proto::finsky::MonthAndDay >(Arena* arena) {
  return Arena::CreateMessageInternal< ::playapi::proto::finsky::MonthAndDay >(arena);
}
template<> PROTOBUF_NOINLINE ::playapi::proto::finsky::SignedData*
Arena::CreateMaybeMessage< ::playapi::proto::finsky::SignedData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::playapi::proto::finsky::SignedData >(arena);
}
template<> PROTOBUF_NOINLINE ::playapi::proto::finsky::Docid*
Arena::CreateMaybeMessage< ::playapi::proto::finsky::Docid >(Arena* arena) {
  return Arena::CreateMessageInternal< ::playapi::proto::finsky::Docid >(arena);
}
template<> PROTOBUF_NOINLINE ::playapi::proto::finsky::Offer*
Arena::CreateMaybeMessage< ::playapi::proto::finsky::Offer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::playapi::proto::finsky::Offer >(arena);
}
template<> PROTOBUF_NOINLINE ::playapi::proto::finsky::RentalTerms*
Arena::CreateMaybeMessage< ::playapi::proto::finsky::RentalTerms >(Arena* arena) {
  return Arena::CreateMessageInternal< ::playapi::proto::finsky::RentalTerms >(arena);
}
template<> PROTOBUF_NOINLINE ::playapi::proto::finsky::OfferPayment*
Arena::CreateMaybeMessage< ::playapi::proto::finsky::OfferPayment >(Arena* arena) {
  return Arena::CreateMessageInternal< ::playapi::proto::finsky::OfferPayment >(arena);
}
template<> PROTOBUF_NOINLINE ::playapi::proto::finsky::OfferPaymentPeriod*
Arena::CreateMaybeMessage< ::playapi::proto::finsky::OfferPaymentPeriod >(Arena* arena) {
  return Arena::CreateMessageInternal< ::playapi::proto::finsky::OfferPaymentPeriod >(arena);
}
template<> PROTOBUF_NOINLINE ::playapi::proto::finsky::OfferPaymentOverride*
Arena::CreateMaybeMessage< ::playapi::proto::finsky::OfferPaymentOverride >(Arena* arena) {
  return Arena::CreateMessageInternal< ::playapi::proto::finsky::OfferPaymentOverride >(arena);
}
template<> PROTOBUF_NOINLINE ::playapi::proto::finsky::SeasonalSubscriptionInfo_Payment*
Arena::CreateMaybeMessage< ::playapi::proto::finsky::SeasonalSubscriptionInfo_Payment >(Arena* arena) {
  return Arena::CreateMessageInternal< ::playapi::proto::finsky::SeasonalSubscriptionInfo_Payment >(arena);
}
template<> PROTOBUF_NOINLINE ::playapi::proto::finsky::SeasonalSubscriptionInfo*
Arena::CreateMaybeMessage< ::playapi::proto::finsky::SeasonalSubscriptionInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::playapi::proto::finsky::SeasonalSubscriptionInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::playapi::proto::finsky::SubscriptionTerms_SubscriptionReplacement*
Arena::CreateMaybeMessage< ::playapi::proto::finsky::SubscriptionTerms_SubscriptionReplacement >(Arena* arena) {
  return Arena::CreateMessageInternal< ::playapi::proto::finsky::SubscriptionTerms_SubscriptionReplacement >(arena);
}
template<> PROTOBUF_NOINLINE ::playapi::proto::finsky::SubscriptionTerms*
Arena::CreateMaybeMessage< ::playapi::proto::finsky::SubscriptionTerms >(Arena* arena) {
  return Arena::CreateMessageInternal< ::playapi::proto::finsky::SubscriptionTerms >(arena);
}
template<> PROTOBUF_NOINLINE ::playapi::proto::finsky::SubscriptionContentTerms*
Arena::CreateMaybeMessage< ::playapi::proto::finsky::SubscriptionContentTerms >(Arena* arena) {
  return Arena::CreateMessageInternal< ::playapi::proto::finsky::SubscriptionContentTerms >(arena);
}
template<> PROTOBUF_NOINLINE ::playapi::proto::finsky::GroupLicenseKey*
Arena::CreateMaybeMessage< ::playapi::proto::finsky::GroupLicenseKey >(Arena* arena) {
  return Arena::CreateMessageInternal< ::playapi::proto::finsky::GroupLicenseKey >(arena);
}
template<> PROTOBUF_NOINLINE ::playapi::proto::finsky::GroupLicenseInfo*
Arena::CreateMaybeMessage< ::playapi::proto::finsky::GroupLicenseInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::playapi::proto::finsky::GroupLicenseInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::playapi::proto::finsky::LicenseTerms*
Arena::CreateMaybeMessage< ::playapi::proto::finsky::LicenseTerms >(Arena* arena) {
  return Arena::CreateMessageInternal< ::playapi::proto::finsky::LicenseTerms >(arena);
}
template<> PROTOBUF_NOINLINE ::playapi::proto::finsky::LicensedDocumentInfo*
Arena::CreateMaybeMessage< ::playapi::proto::finsky::LicensedDocumentInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::playapi::proto::finsky::LicensedDocumentInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::playapi::proto::finsky::RedemptionRecordKey*
Arena::CreateMaybeMessage< ::playapi::proto::finsky::RedemptionRecordKey >(Arena* arena) {
  return Arena::CreateMessageInternal< ::playapi::proto::finsky::RedemptionRecordKey >(arena);
}
template<> PROTOBUF_NOINLINE ::playapi::proto::finsky::VoucherId*
Arena::CreateMaybeMessage< ::playapi::proto::finsky::VoucherId >(Arena* arena) {
  return Arena::CreateMessageInternal< ::playapi::proto::finsky::VoucherId >(arena);
}
template<> PROTOBUF_NOINLINE ::playapi::proto::finsky::VoucherOfferTerms*
Arena::CreateMaybeMessage< ::playapi::proto::finsky::VoucherOfferTerms >(Arena* arena) {
  return Arena::CreateMessageInternal< ::playapi::proto::finsky::VoucherOfferTerms >(arena);
}
template<> PROTOBUF_NOINLINE ::playapi::proto::finsky::LibraryVoucher*
Arena::CreateMaybeMessage< ::playapi::proto::finsky::LibraryVoucher >(Arena* arena) {
  return Arena::CreateMessageInternal< ::playapi::proto::finsky::LibraryVoucher >(arena);
}
template<> PROTOBUF_NOINLINE ::playapi::proto::finsky::OwnershipInfo*
Arena::CreateMaybeMessage< ::playapi::proto::finsky::OwnershipInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::playapi::proto::finsky::OwnershipInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::playapi::proto::finsky::Image_Dimension*
Arena::CreateMaybeMessage< ::playapi::proto::finsky::Image_Dimension >(Arena* arena) {
  return Arena::CreateMessageInternal< ::playapi::proto::finsky::Image_Dimension >(arena);
}
template<> PROTOBUF_NOINLINE ::playapi::proto::finsky::Image_Citation*
Arena::CreateMaybeMessage< ::playapi::proto::finsky::Image_Citation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::playapi::proto::finsky::Image_Citation >(arena);
}
template<> PROTOBUF_NOINLINE ::playapi::proto::finsky::Image*
Arena::CreateMaybeMessage< ::playapi::proto::finsky::Image >(Arena* arena) {
  return Arena::CreateMessageInternal< ::playapi::proto::finsky::Image >(arena);
}
template<> PROTOBUF_NOINLINE ::playapi::proto::finsky::ImagePalette*
Arena::CreateMaybeMessage< ::playapi::proto::finsky::ImagePalette >(Arena* arena) {
  return Arena::CreateMessageInternal< ::playapi::proto::finsky::ImagePalette >(arena);
}
template<> PROTOBUF_NOINLINE ::playapi::proto::finsky::Attribution*
Arena::CreateMaybeMessage< ::playapi::proto::finsky::Attribution >(Arena* arena) {
  return Arena::CreateMessageInternal< ::playapi::proto::finsky::Attribution >(arena);
}
template<> PROTOBUF_NOINLINE ::playapi::proto::finsky::CertificateSet*
Arena::CreateMaybeMessage< ::playapi::proto::finsky::CertificateSet >(Arena* arena) {
  return Arena::CreateMessageInternal< ::playapi::proto::finsky::CertificateSet >(arena);
}
template<> PROTOBUF_NOINLINE ::playapi::proto::finsky::EncodedTargets*
Arena::CreateMaybeMessage< ::playapi::proto::finsky::EncodedTargets >(Arena* arena) {
  return Arena::CreateMessageInternal< ::playapi::proto::finsky::EncodedTargets >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
