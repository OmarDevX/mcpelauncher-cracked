// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: play_common.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_play_5fcommon_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_play_5fcommon_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_play_5fcommon_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_play_5fcommon_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_play_5fcommon_2eproto;
namespace playapi {
namespace proto {
namespace finsky {
class Attribution;
struct AttributionDefaultTypeInternal;
extern AttributionDefaultTypeInternal _Attribution_default_instance_;
class CertificateSet;
struct CertificateSetDefaultTypeInternal;
extern CertificateSetDefaultTypeInternal _CertificateSet_default_instance_;
class Docid;
struct DocidDefaultTypeInternal;
extern DocidDefaultTypeInternal _Docid_default_instance_;
class EncodedTargets;
struct EncodedTargetsDefaultTypeInternal;
extern EncodedTargetsDefaultTypeInternal _EncodedTargets_default_instance_;
class GroupLicenseInfo;
struct GroupLicenseInfoDefaultTypeInternal;
extern GroupLicenseInfoDefaultTypeInternal _GroupLicenseInfo_default_instance_;
class GroupLicenseKey;
struct GroupLicenseKeyDefaultTypeInternal;
extern GroupLicenseKeyDefaultTypeInternal _GroupLicenseKey_default_instance_;
class HttpCookie;
struct HttpCookieDefaultTypeInternal;
extern HttpCookieDefaultTypeInternal _HttpCookie_default_instance_;
class Image;
struct ImageDefaultTypeInternal;
extern ImageDefaultTypeInternal _Image_default_instance_;
class ImagePalette;
struct ImagePaletteDefaultTypeInternal;
extern ImagePaletteDefaultTypeInternal _ImagePalette_default_instance_;
class Image_Citation;
struct Image_CitationDefaultTypeInternal;
extern Image_CitationDefaultTypeInternal _Image_Citation_default_instance_;
class Image_Dimension;
struct Image_DimensionDefaultTypeInternal;
extern Image_DimensionDefaultTypeInternal _Image_Dimension_default_instance_;
class LibraryVoucher;
struct LibraryVoucherDefaultTypeInternal;
extern LibraryVoucherDefaultTypeInternal _LibraryVoucher_default_instance_;
class LicenseTerms;
struct LicenseTermsDefaultTypeInternal;
extern LicenseTermsDefaultTypeInternal _LicenseTerms_default_instance_;
class LicensedDocumentInfo;
struct LicensedDocumentInfoDefaultTypeInternal;
extern LicensedDocumentInfoDefaultTypeInternal _LicensedDocumentInfo_default_instance_;
class MonthAndDay;
struct MonthAndDayDefaultTypeInternal;
extern MonthAndDayDefaultTypeInternal _MonthAndDay_default_instance_;
class Offer;
struct OfferDefaultTypeInternal;
extern OfferDefaultTypeInternal _Offer_default_instance_;
class OfferPayment;
struct OfferPaymentDefaultTypeInternal;
extern OfferPaymentDefaultTypeInternal _OfferPayment_default_instance_;
class OfferPaymentOverride;
struct OfferPaymentOverrideDefaultTypeInternal;
extern OfferPaymentOverrideDefaultTypeInternal _OfferPaymentOverride_default_instance_;
class OfferPaymentPeriod;
struct OfferPaymentPeriodDefaultTypeInternal;
extern OfferPaymentPeriodDefaultTypeInternal _OfferPaymentPeriod_default_instance_;
class OwnershipInfo;
struct OwnershipInfoDefaultTypeInternal;
extern OwnershipInfoDefaultTypeInternal _OwnershipInfo_default_instance_;
class RedemptionRecordKey;
struct RedemptionRecordKeyDefaultTypeInternal;
extern RedemptionRecordKeyDefaultTypeInternal _RedemptionRecordKey_default_instance_;
class RentalTerms;
struct RentalTermsDefaultTypeInternal;
extern RentalTermsDefaultTypeInternal _RentalTerms_default_instance_;
class SeasonalSubscriptionInfo;
struct SeasonalSubscriptionInfoDefaultTypeInternal;
extern SeasonalSubscriptionInfoDefaultTypeInternal _SeasonalSubscriptionInfo_default_instance_;
class SeasonalSubscriptionInfo_Payment;
struct SeasonalSubscriptionInfo_PaymentDefaultTypeInternal;
extern SeasonalSubscriptionInfo_PaymentDefaultTypeInternal _SeasonalSubscriptionInfo_Payment_default_instance_;
class SignedData;
struct SignedDataDefaultTypeInternal;
extern SignedDataDefaultTypeInternal _SignedData_default_instance_;
class SubscriptionContentTerms;
struct SubscriptionContentTermsDefaultTypeInternal;
extern SubscriptionContentTermsDefaultTypeInternal _SubscriptionContentTerms_default_instance_;
class SubscriptionTerms;
struct SubscriptionTermsDefaultTypeInternal;
extern SubscriptionTermsDefaultTypeInternal _SubscriptionTerms_default_instance_;
class SubscriptionTerms_SubscriptionReplacement;
struct SubscriptionTerms_SubscriptionReplacementDefaultTypeInternal;
extern SubscriptionTerms_SubscriptionReplacementDefaultTypeInternal _SubscriptionTerms_SubscriptionReplacement_default_instance_;
class TimePeriod;
struct TimePeriodDefaultTypeInternal;
extern TimePeriodDefaultTypeInternal _TimePeriod_default_instance_;
class VoucherId;
struct VoucherIdDefaultTypeInternal;
extern VoucherIdDefaultTypeInternal _VoucherId_default_instance_;
class VoucherOfferTerms;
struct VoucherOfferTermsDefaultTypeInternal;
extern VoucherOfferTermsDefaultTypeInternal _VoucherOfferTerms_default_instance_;
}  // namespace finsky
}  // namespace proto
}  // namespace playapi
PROTOBUF_NAMESPACE_OPEN
template<> ::playapi::proto::finsky::Attribution* Arena::CreateMaybeMessage<::playapi::proto::finsky::Attribution>(Arena*);
template<> ::playapi::proto::finsky::CertificateSet* Arena::CreateMaybeMessage<::playapi::proto::finsky::CertificateSet>(Arena*);
template<> ::playapi::proto::finsky::Docid* Arena::CreateMaybeMessage<::playapi::proto::finsky::Docid>(Arena*);
template<> ::playapi::proto::finsky::EncodedTargets* Arena::CreateMaybeMessage<::playapi::proto::finsky::EncodedTargets>(Arena*);
template<> ::playapi::proto::finsky::GroupLicenseInfo* Arena::CreateMaybeMessage<::playapi::proto::finsky::GroupLicenseInfo>(Arena*);
template<> ::playapi::proto::finsky::GroupLicenseKey* Arena::CreateMaybeMessage<::playapi::proto::finsky::GroupLicenseKey>(Arena*);
template<> ::playapi::proto::finsky::HttpCookie* Arena::CreateMaybeMessage<::playapi::proto::finsky::HttpCookie>(Arena*);
template<> ::playapi::proto::finsky::Image* Arena::CreateMaybeMessage<::playapi::proto::finsky::Image>(Arena*);
template<> ::playapi::proto::finsky::ImagePalette* Arena::CreateMaybeMessage<::playapi::proto::finsky::ImagePalette>(Arena*);
template<> ::playapi::proto::finsky::Image_Citation* Arena::CreateMaybeMessage<::playapi::proto::finsky::Image_Citation>(Arena*);
template<> ::playapi::proto::finsky::Image_Dimension* Arena::CreateMaybeMessage<::playapi::proto::finsky::Image_Dimension>(Arena*);
template<> ::playapi::proto::finsky::LibraryVoucher* Arena::CreateMaybeMessage<::playapi::proto::finsky::LibraryVoucher>(Arena*);
template<> ::playapi::proto::finsky::LicenseTerms* Arena::CreateMaybeMessage<::playapi::proto::finsky::LicenseTerms>(Arena*);
template<> ::playapi::proto::finsky::LicensedDocumentInfo* Arena::CreateMaybeMessage<::playapi::proto::finsky::LicensedDocumentInfo>(Arena*);
template<> ::playapi::proto::finsky::MonthAndDay* Arena::CreateMaybeMessage<::playapi::proto::finsky::MonthAndDay>(Arena*);
template<> ::playapi::proto::finsky::Offer* Arena::CreateMaybeMessage<::playapi::proto::finsky::Offer>(Arena*);
template<> ::playapi::proto::finsky::OfferPayment* Arena::CreateMaybeMessage<::playapi::proto::finsky::OfferPayment>(Arena*);
template<> ::playapi::proto::finsky::OfferPaymentOverride* Arena::CreateMaybeMessage<::playapi::proto::finsky::OfferPaymentOverride>(Arena*);
template<> ::playapi::proto::finsky::OfferPaymentPeriod* Arena::CreateMaybeMessage<::playapi::proto::finsky::OfferPaymentPeriod>(Arena*);
template<> ::playapi::proto::finsky::OwnershipInfo* Arena::CreateMaybeMessage<::playapi::proto::finsky::OwnershipInfo>(Arena*);
template<> ::playapi::proto::finsky::RedemptionRecordKey* Arena::CreateMaybeMessage<::playapi::proto::finsky::RedemptionRecordKey>(Arena*);
template<> ::playapi::proto::finsky::RentalTerms* Arena::CreateMaybeMessage<::playapi::proto::finsky::RentalTerms>(Arena*);
template<> ::playapi::proto::finsky::SeasonalSubscriptionInfo* Arena::CreateMaybeMessage<::playapi::proto::finsky::SeasonalSubscriptionInfo>(Arena*);
template<> ::playapi::proto::finsky::SeasonalSubscriptionInfo_Payment* Arena::CreateMaybeMessage<::playapi::proto::finsky::SeasonalSubscriptionInfo_Payment>(Arena*);
template<> ::playapi::proto::finsky::SignedData* Arena::CreateMaybeMessage<::playapi::proto::finsky::SignedData>(Arena*);
template<> ::playapi::proto::finsky::SubscriptionContentTerms* Arena::CreateMaybeMessage<::playapi::proto::finsky::SubscriptionContentTerms>(Arena*);
template<> ::playapi::proto::finsky::SubscriptionTerms* Arena::CreateMaybeMessage<::playapi::proto::finsky::SubscriptionTerms>(Arena*);
template<> ::playapi::proto::finsky::SubscriptionTerms_SubscriptionReplacement* Arena::CreateMaybeMessage<::playapi::proto::finsky::SubscriptionTerms_SubscriptionReplacement>(Arena*);
template<> ::playapi::proto::finsky::TimePeriod* Arena::CreateMaybeMessage<::playapi::proto::finsky::TimePeriod>(Arena*);
template<> ::playapi::proto::finsky::VoucherId* Arena::CreateMaybeMessage<::playapi::proto::finsky::VoucherId>(Arena*);
template<> ::playapi::proto::finsky::VoucherOfferTerms* Arena::CreateMaybeMessage<::playapi::proto::finsky::VoucherOfferTerms>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace playapi {
namespace proto {
namespace finsky {

// ===================================================================

class HttpCookie final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.HttpCookie) */ {
 public:
  inline HttpCookie() : HttpCookie(nullptr) {}
  ~HttpCookie() override;
  explicit PROTOBUF_CONSTEXPR HttpCookie(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HttpCookie(const HttpCookie& from);
  HttpCookie(HttpCookie&& from) noexcept
    : HttpCookie() {
    *this = ::std::move(from);
  }

  inline HttpCookie& operator=(const HttpCookie& from) {
    CopyFrom(from);
    return *this;
  }
  inline HttpCookie& operator=(HttpCookie&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HttpCookie& default_instance() {
    return *internal_default_instance();
  }
  static inline const HttpCookie* internal_default_instance() {
    return reinterpret_cast<const HttpCookie*>(
               &_HttpCookie_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(HttpCookie& a, HttpCookie& b) {
    a.Swap(&b);
  }
  inline void Swap(HttpCookie* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HttpCookie* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HttpCookie* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HttpCookie>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HttpCookie& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HttpCookie& from) {
    HttpCookie::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HttpCookie* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.HttpCookie";
  }
  protected:
  explicit HttpCookie(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.HttpCookie)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class TimePeriod final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.TimePeriod) */ {
 public:
  inline TimePeriod() : TimePeriod(nullptr) {}
  ~TimePeriod() override;
  explicit PROTOBUF_CONSTEXPR TimePeriod(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TimePeriod(const TimePeriod& from);
  TimePeriod(TimePeriod&& from) noexcept
    : TimePeriod() {
    *this = ::std::move(from);
  }

  inline TimePeriod& operator=(const TimePeriod& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimePeriod& operator=(TimePeriod&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TimePeriod& default_instance() {
    return *internal_default_instance();
  }
  static inline const TimePeriod* internal_default_instance() {
    return reinterpret_cast<const TimePeriod*>(
               &_TimePeriod_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TimePeriod& a, TimePeriod& b) {
    a.Swap(&b);
  }
  inline void Swap(TimePeriod* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimePeriod* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TimePeriod* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TimePeriod>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TimePeriod& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TimePeriod& from) {
    TimePeriod::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TimePeriod* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.TimePeriod";
  }
  protected:
  explicit TimePeriod(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUnitFieldNumber = 1,
    kCountFieldNumber = 2,
  };
  // optional int32 unit = 1;
  bool has_unit() const;
  private:
  bool _internal_has_unit() const;
  public:
  void clear_unit();
  int32_t unit() const;
  void set_unit(int32_t value);
  private:
  int32_t _internal_unit() const;
  void _internal_set_unit(int32_t value);
  public:

  // optional int32 count = 2;
  bool has_count() const;
  private:
  bool _internal_has_count() const;
  public:
  void clear_count();
  int32_t count() const;
  void set_count(int32_t value);
  private:
  int32_t _internal_count() const;
  void _internal_set_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.TimePeriod)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t unit_;
    int32_t count_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class MonthAndDay final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.MonthAndDay) */ {
 public:
  inline MonthAndDay() : MonthAndDay(nullptr) {}
  ~MonthAndDay() override;
  explicit PROTOBUF_CONSTEXPR MonthAndDay(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MonthAndDay(const MonthAndDay& from);
  MonthAndDay(MonthAndDay&& from) noexcept
    : MonthAndDay() {
    *this = ::std::move(from);
  }

  inline MonthAndDay& operator=(const MonthAndDay& from) {
    CopyFrom(from);
    return *this;
  }
  inline MonthAndDay& operator=(MonthAndDay&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MonthAndDay& default_instance() {
    return *internal_default_instance();
  }
  static inline const MonthAndDay* internal_default_instance() {
    return reinterpret_cast<const MonthAndDay*>(
               &_MonthAndDay_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MonthAndDay& a, MonthAndDay& b) {
    a.Swap(&b);
  }
  inline void Swap(MonthAndDay* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MonthAndDay* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MonthAndDay* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MonthAndDay>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MonthAndDay& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MonthAndDay& from) {
    MonthAndDay::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MonthAndDay* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.MonthAndDay";
  }
  protected:
  explicit MonthAndDay(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMonthFieldNumber = 1,
    kDayFieldNumber = 2,
  };
  // optional int32 month = 1;
  bool has_month() const;
  private:
  bool _internal_has_month() const;
  public:
  void clear_month();
  int32_t month() const;
  void set_month(int32_t value);
  private:
  int32_t _internal_month() const;
  void _internal_set_month(int32_t value);
  public:

  // optional int32 day = 2;
  bool has_day() const;
  private:
  bool _internal_has_day() const;
  public:
  void clear_day();
  int32_t day() const;
  void set_day(int32_t value);
  private:
  int32_t _internal_day() const;
  void _internal_set_day(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.MonthAndDay)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t month_;
    int32_t day_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class SignedData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.SignedData) */ {
 public:
  inline SignedData() : SignedData(nullptr) {}
  ~SignedData() override;
  explicit PROTOBUF_CONSTEXPR SignedData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignedData(const SignedData& from);
  SignedData(SignedData&& from) noexcept
    : SignedData() {
    *this = ::std::move(from);
  }

  inline SignedData& operator=(const SignedData& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignedData& operator=(SignedData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignedData& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignedData* internal_default_instance() {
    return reinterpret_cast<const SignedData*>(
               &_SignedData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SignedData& a, SignedData& b) {
    a.Swap(&b);
  }
  inline void Swap(SignedData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignedData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignedData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignedData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SignedData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SignedData& from) {
    SignedData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignedData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.SignedData";
  }
  protected:
  explicit SignedData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignedDataFieldNumber = 1,
    kSignatureFieldNumber = 2,
  };
  // optional string signedData = 1;
  bool has_signeddata() const;
  private:
  bool _internal_has_signeddata() const;
  public:
  void clear_signeddata();
  const std::string& signeddata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signeddata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signeddata();
  PROTOBUF_NODISCARD std::string* release_signeddata();
  void set_allocated_signeddata(std::string* signeddata);
  private:
  const std::string& _internal_signeddata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signeddata(const std::string& value);
  std::string* _internal_mutable_signeddata();
  public:

  // optional string signature = 2;
  bool has_signature() const;
  private:
  bool _internal_has_signature() const;
  public:
  void clear_signature();
  const std::string& signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature();
  PROTOBUF_NODISCARD std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.SignedData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signeddata_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class Docid final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.Docid) */ {
 public:
  inline Docid() : Docid(nullptr) {}
  ~Docid() override;
  explicit PROTOBUF_CONSTEXPR Docid(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Docid(const Docid& from);
  Docid(Docid&& from) noexcept
    : Docid() {
    *this = ::std::move(from);
  }

  inline Docid& operator=(const Docid& from) {
    CopyFrom(from);
    return *this;
  }
  inline Docid& operator=(Docid&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Docid& default_instance() {
    return *internal_default_instance();
  }
  static inline const Docid* internal_default_instance() {
    return reinterpret_cast<const Docid*>(
               &_Docid_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Docid& a, Docid& b) {
    a.Swap(&b);
  }
  inline void Swap(Docid* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Docid* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Docid* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Docid>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Docid& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Docid& from) {
    Docid::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Docid* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.Docid";
  }
  protected:
  explicit Docid(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBackendDocidFieldNumber = 1,
    kTypeFieldNumber = 2,
    kBackendFieldNumber = 3,
  };
  // optional string backendDocid = 1;
  bool has_backenddocid() const;
  private:
  bool _internal_has_backenddocid() const;
  public:
  void clear_backenddocid();
  const std::string& backenddocid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_backenddocid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_backenddocid();
  PROTOBUF_NODISCARD std::string* release_backenddocid();
  void set_allocated_backenddocid(std::string* backenddocid);
  private:
  const std::string& _internal_backenddocid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_backenddocid(const std::string& value);
  std::string* _internal_mutable_backenddocid();
  public:

  // optional int32 type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  int32_t type() const;
  void set_type(int32_t value);
  private:
  int32_t _internal_type() const;
  void _internal_set_type(int32_t value);
  public:

  // optional int32 backend = 3;
  bool has_backend() const;
  private:
  bool _internal_has_backend() const;
  public:
  void clear_backend();
  int32_t backend() const;
  void set_backend(int32_t value);
  private:
  int32_t _internal_backend() const;
  void _internal_set_backend(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.Docid)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr backenddocid_;
    int32_t type_;
    int32_t backend_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class Offer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.Offer) */ {
 public:
  inline Offer() : Offer(nullptr) {}
  ~Offer() override;
  explicit PROTOBUF_CONSTEXPR Offer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Offer(const Offer& from);
  Offer(Offer&& from) noexcept
    : Offer() {
    *this = ::std::move(from);
  }

  inline Offer& operator=(const Offer& from) {
    CopyFrom(from);
    return *this;
  }
  inline Offer& operator=(Offer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Offer& default_instance() {
    return *internal_default_instance();
  }
  static inline const Offer* internal_default_instance() {
    return reinterpret_cast<const Offer*>(
               &_Offer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Offer& a, Offer& b) {
    a.Swap(&b);
  }
  inline void Swap(Offer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Offer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Offer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Offer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Offer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Offer& from) {
    Offer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Offer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.Offer";
  }
  protected:
  explicit Offer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConvertedPriceFieldNumber = 4,
    kPromotionLabelFieldNumber = 11,
    kOfferPaymentFieldNumber = 24,
    kCurrencyCodeFieldNumber = 2,
    kFormattedAmountFieldNumber = 3,
    kFormattedFullAmountFieldNumber = 7,
    kFormattedNameFieldNumber = 13,
    kFormattedDescriptionFieldNumber = 14,
    kOfferIdFieldNumber = 19,
    kBuyButtonLabelFieldNumber = 26,
    kRentalTermsFieldNumber = 9,
    kSubscriptionTermsFieldNumber = 12,
    kSubscriptionContentTermsFieldNumber = 18,
    kLicenseTermsFieldNumber = 21,
    kVoucherTermsFieldNumber = 23,
    kMicrosFieldNumber = 1,
    kFullPriceMicrosFieldNumber = 6,
    kOnSaleDateFieldNumber = 10,
    kOfferTypeFieldNumber = 8,
    kOnSaleDateDisplayTimeZoneOffsetMsecFieldNumber = 16,
    kCheckoutFlowRequiredFieldNumber = 5,
    kPreorderFieldNumber = 15,
    kTemporarilyFreeFieldNumber = 22,
    kRepeatLastPaymentFieldNumber = 25,
    kLicensedOfferTypeFieldNumber = 17,
    kPreorderFulfillmentDisplayDateFieldNumber = 20,
    kInstantPurchaseEnabledFieldNumber = 27,
  };
  // repeated .playapi.proto.finsky.Offer convertedPrice = 4;
  int convertedprice_size() const;
  private:
  int _internal_convertedprice_size() const;
  public:
  void clear_convertedprice();
  ::playapi::proto::finsky::Offer* mutable_convertedprice(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Offer >*
      mutable_convertedprice();
  private:
  const ::playapi::proto::finsky::Offer& _internal_convertedprice(int index) const;
  ::playapi::proto::finsky::Offer* _internal_add_convertedprice();
  public:
  const ::playapi::proto::finsky::Offer& convertedprice(int index) const;
  ::playapi::proto::finsky::Offer* add_convertedprice();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Offer >&
      convertedprice() const;

  // repeated string promotionLabel = 11;
  int promotionlabel_size() const;
  private:
  int _internal_promotionlabel_size() const;
  public:
  void clear_promotionlabel();
  const std::string& promotionlabel(int index) const;
  std::string* mutable_promotionlabel(int index);
  void set_promotionlabel(int index, const std::string& value);
  void set_promotionlabel(int index, std::string&& value);
  void set_promotionlabel(int index, const char* value);
  void set_promotionlabel(int index, const char* value, size_t size);
  std::string* add_promotionlabel();
  void add_promotionlabel(const std::string& value);
  void add_promotionlabel(std::string&& value);
  void add_promotionlabel(const char* value);
  void add_promotionlabel(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& promotionlabel() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_promotionlabel();
  private:
  const std::string& _internal_promotionlabel(int index) const;
  std::string* _internal_add_promotionlabel();
  public:

  // repeated .playapi.proto.finsky.OfferPayment offerPayment = 24;
  int offerpayment_size() const;
  private:
  int _internal_offerpayment_size() const;
  public:
  void clear_offerpayment();
  ::playapi::proto::finsky::OfferPayment* mutable_offerpayment(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::OfferPayment >*
      mutable_offerpayment();
  private:
  const ::playapi::proto::finsky::OfferPayment& _internal_offerpayment(int index) const;
  ::playapi::proto::finsky::OfferPayment* _internal_add_offerpayment();
  public:
  const ::playapi::proto::finsky::OfferPayment& offerpayment(int index) const;
  ::playapi::proto::finsky::OfferPayment* add_offerpayment();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::OfferPayment >&
      offerpayment() const;

  // optional string currencyCode = 2;
  bool has_currencycode() const;
  private:
  bool _internal_has_currencycode() const;
  public:
  void clear_currencycode();
  const std::string& currencycode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_currencycode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_currencycode();
  PROTOBUF_NODISCARD std::string* release_currencycode();
  void set_allocated_currencycode(std::string* currencycode);
  private:
  const std::string& _internal_currencycode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_currencycode(const std::string& value);
  std::string* _internal_mutable_currencycode();
  public:

  // optional string formattedAmount = 3;
  bool has_formattedamount() const;
  private:
  bool _internal_has_formattedamount() const;
  public:
  void clear_formattedamount();
  const std::string& formattedamount() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_formattedamount(ArgT0&& arg0, ArgT... args);
  std::string* mutable_formattedamount();
  PROTOBUF_NODISCARD std::string* release_formattedamount();
  void set_allocated_formattedamount(std::string* formattedamount);
  private:
  const std::string& _internal_formattedamount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_formattedamount(const std::string& value);
  std::string* _internal_mutable_formattedamount();
  public:

  // optional string formattedFullAmount = 7;
  bool has_formattedfullamount() const;
  private:
  bool _internal_has_formattedfullamount() const;
  public:
  void clear_formattedfullamount();
  const std::string& formattedfullamount() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_formattedfullamount(ArgT0&& arg0, ArgT... args);
  std::string* mutable_formattedfullamount();
  PROTOBUF_NODISCARD std::string* release_formattedfullamount();
  void set_allocated_formattedfullamount(std::string* formattedfullamount);
  private:
  const std::string& _internal_formattedfullamount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_formattedfullamount(const std::string& value);
  std::string* _internal_mutable_formattedfullamount();
  public:

  // optional string formattedName = 13;
  bool has_formattedname() const;
  private:
  bool _internal_has_formattedname() const;
  public:
  void clear_formattedname();
  const std::string& formattedname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_formattedname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_formattedname();
  PROTOBUF_NODISCARD std::string* release_formattedname();
  void set_allocated_formattedname(std::string* formattedname);
  private:
  const std::string& _internal_formattedname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_formattedname(const std::string& value);
  std::string* _internal_mutable_formattedname();
  public:

  // optional string formattedDescription = 14;
  bool has_formatteddescription() const;
  private:
  bool _internal_has_formatteddescription() const;
  public:
  void clear_formatteddescription();
  const std::string& formatteddescription() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_formatteddescription(ArgT0&& arg0, ArgT... args);
  std::string* mutable_formatteddescription();
  PROTOBUF_NODISCARD std::string* release_formatteddescription();
  void set_allocated_formatteddescription(std::string* formatteddescription);
  private:
  const std::string& _internal_formatteddescription() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_formatteddescription(const std::string& value);
  std::string* _internal_mutable_formatteddescription();
  public:

  // optional string offerId = 19;
  bool has_offerid() const;
  private:
  bool _internal_has_offerid() const;
  public:
  void clear_offerid();
  const std::string& offerid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_offerid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_offerid();
  PROTOBUF_NODISCARD std::string* release_offerid();
  void set_allocated_offerid(std::string* offerid);
  private:
  const std::string& _internal_offerid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_offerid(const std::string& value);
  std::string* _internal_mutable_offerid();
  public:

  // optional string buyButtonLabel = 26;
  bool has_buybuttonlabel() const;
  private:
  bool _internal_has_buybuttonlabel() const;
  public:
  void clear_buybuttonlabel();
  const std::string& buybuttonlabel() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_buybuttonlabel(ArgT0&& arg0, ArgT... args);
  std::string* mutable_buybuttonlabel();
  PROTOBUF_NODISCARD std::string* release_buybuttonlabel();
  void set_allocated_buybuttonlabel(std::string* buybuttonlabel);
  private:
  const std::string& _internal_buybuttonlabel() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_buybuttonlabel(const std::string& value);
  std::string* _internal_mutable_buybuttonlabel();
  public:

  // optional .playapi.proto.finsky.RentalTerms rentalTerms = 9;
  bool has_rentalterms() const;
  private:
  bool _internal_has_rentalterms() const;
  public:
  void clear_rentalterms();
  const ::playapi::proto::finsky::RentalTerms& rentalterms() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::RentalTerms* release_rentalterms();
  ::playapi::proto::finsky::RentalTerms* mutable_rentalterms();
  void set_allocated_rentalterms(::playapi::proto::finsky::RentalTerms* rentalterms);
  private:
  const ::playapi::proto::finsky::RentalTerms& _internal_rentalterms() const;
  ::playapi::proto::finsky::RentalTerms* _internal_mutable_rentalterms();
  public:
  void unsafe_arena_set_allocated_rentalterms(
      ::playapi::proto::finsky::RentalTerms* rentalterms);
  ::playapi::proto::finsky::RentalTerms* unsafe_arena_release_rentalterms();

  // optional .playapi.proto.finsky.SubscriptionTerms subscriptionTerms = 12;
  bool has_subscriptionterms() const;
  private:
  bool _internal_has_subscriptionterms() const;
  public:
  void clear_subscriptionterms();
  const ::playapi::proto::finsky::SubscriptionTerms& subscriptionterms() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::SubscriptionTerms* release_subscriptionterms();
  ::playapi::proto::finsky::SubscriptionTerms* mutable_subscriptionterms();
  void set_allocated_subscriptionterms(::playapi::proto::finsky::SubscriptionTerms* subscriptionterms);
  private:
  const ::playapi::proto::finsky::SubscriptionTerms& _internal_subscriptionterms() const;
  ::playapi::proto::finsky::SubscriptionTerms* _internal_mutable_subscriptionterms();
  public:
  void unsafe_arena_set_allocated_subscriptionterms(
      ::playapi::proto::finsky::SubscriptionTerms* subscriptionterms);
  ::playapi::proto::finsky::SubscriptionTerms* unsafe_arena_release_subscriptionterms();

  // optional .playapi.proto.finsky.SubscriptionContentTerms subscriptionContentTerms = 18;
  bool has_subscriptioncontentterms() const;
  private:
  bool _internal_has_subscriptioncontentterms() const;
  public:
  void clear_subscriptioncontentterms();
  const ::playapi::proto::finsky::SubscriptionContentTerms& subscriptioncontentterms() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::SubscriptionContentTerms* release_subscriptioncontentterms();
  ::playapi::proto::finsky::SubscriptionContentTerms* mutable_subscriptioncontentterms();
  void set_allocated_subscriptioncontentterms(::playapi::proto::finsky::SubscriptionContentTerms* subscriptioncontentterms);
  private:
  const ::playapi::proto::finsky::SubscriptionContentTerms& _internal_subscriptioncontentterms() const;
  ::playapi::proto::finsky::SubscriptionContentTerms* _internal_mutable_subscriptioncontentterms();
  public:
  void unsafe_arena_set_allocated_subscriptioncontentterms(
      ::playapi::proto::finsky::SubscriptionContentTerms* subscriptioncontentterms);
  ::playapi::proto::finsky::SubscriptionContentTerms* unsafe_arena_release_subscriptioncontentterms();

  // optional .playapi.proto.finsky.LicenseTerms licenseTerms = 21;
  bool has_licenseterms() const;
  private:
  bool _internal_has_licenseterms() const;
  public:
  void clear_licenseterms();
  const ::playapi::proto::finsky::LicenseTerms& licenseterms() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::LicenseTerms* release_licenseterms();
  ::playapi::proto::finsky::LicenseTerms* mutable_licenseterms();
  void set_allocated_licenseterms(::playapi::proto::finsky::LicenseTerms* licenseterms);
  private:
  const ::playapi::proto::finsky::LicenseTerms& _internal_licenseterms() const;
  ::playapi::proto::finsky::LicenseTerms* _internal_mutable_licenseterms();
  public:
  void unsafe_arena_set_allocated_licenseterms(
      ::playapi::proto::finsky::LicenseTerms* licenseterms);
  ::playapi::proto::finsky::LicenseTerms* unsafe_arena_release_licenseterms();

  // optional .playapi.proto.finsky.VoucherOfferTerms voucherTerms = 23;
  bool has_voucherterms() const;
  private:
  bool _internal_has_voucherterms() const;
  public:
  void clear_voucherterms();
  const ::playapi::proto::finsky::VoucherOfferTerms& voucherterms() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::VoucherOfferTerms* release_voucherterms();
  ::playapi::proto::finsky::VoucherOfferTerms* mutable_voucherterms();
  void set_allocated_voucherterms(::playapi::proto::finsky::VoucherOfferTerms* voucherterms);
  private:
  const ::playapi::proto::finsky::VoucherOfferTerms& _internal_voucherterms() const;
  ::playapi::proto::finsky::VoucherOfferTerms* _internal_mutable_voucherterms();
  public:
  void unsafe_arena_set_allocated_voucherterms(
      ::playapi::proto::finsky::VoucherOfferTerms* voucherterms);
  ::playapi::proto::finsky::VoucherOfferTerms* unsafe_arena_release_voucherterms();

  // optional int64 micros = 1;
  bool has_micros() const;
  private:
  bool _internal_has_micros() const;
  public:
  void clear_micros();
  int64_t micros() const;
  void set_micros(int64_t value);
  private:
  int64_t _internal_micros() const;
  void _internal_set_micros(int64_t value);
  public:

  // optional int64 fullPriceMicros = 6;
  bool has_fullpricemicros() const;
  private:
  bool _internal_has_fullpricemicros() const;
  public:
  void clear_fullpricemicros();
  int64_t fullpricemicros() const;
  void set_fullpricemicros(int64_t value);
  private:
  int64_t _internal_fullpricemicros() const;
  void _internal_set_fullpricemicros(int64_t value);
  public:

  // optional int64 onSaleDate = 10;
  bool has_onsaledate() const;
  private:
  bool _internal_has_onsaledate() const;
  public:
  void clear_onsaledate();
  int64_t onsaledate() const;
  void set_onsaledate(int64_t value);
  private:
  int64_t _internal_onsaledate() const;
  void _internal_set_onsaledate(int64_t value);
  public:

  // optional int32 offerType = 8;
  bool has_offertype() const;
  private:
  bool _internal_has_offertype() const;
  public:
  void clear_offertype();
  int32_t offertype() const;
  void set_offertype(int32_t value);
  private:
  int32_t _internal_offertype() const;
  void _internal_set_offertype(int32_t value);
  public:

  // optional int32 onSaleDateDisplayTimeZoneOffsetMsec = 16;
  bool has_onsaledatedisplaytimezoneoffsetmsec() const;
  private:
  bool _internal_has_onsaledatedisplaytimezoneoffsetmsec() const;
  public:
  void clear_onsaledatedisplaytimezoneoffsetmsec();
  int32_t onsaledatedisplaytimezoneoffsetmsec() const;
  void set_onsaledatedisplaytimezoneoffsetmsec(int32_t value);
  private:
  int32_t _internal_onsaledatedisplaytimezoneoffsetmsec() const;
  void _internal_set_onsaledatedisplaytimezoneoffsetmsec(int32_t value);
  public:

  // optional bool checkoutFlowRequired = 5;
  bool has_checkoutflowrequired() const;
  private:
  bool _internal_has_checkoutflowrequired() const;
  public:
  void clear_checkoutflowrequired();
  bool checkoutflowrequired() const;
  void set_checkoutflowrequired(bool value);
  private:
  bool _internal_checkoutflowrequired() const;
  void _internal_set_checkoutflowrequired(bool value);
  public:

  // optional bool preorder = 15;
  bool has_preorder() const;
  private:
  bool _internal_has_preorder() const;
  public:
  void clear_preorder();
  bool preorder() const;
  void set_preorder(bool value);
  private:
  bool _internal_preorder() const;
  void _internal_set_preorder(bool value);
  public:

  // optional bool temporarilyFree = 22;
  bool has_temporarilyfree() const;
  private:
  bool _internal_has_temporarilyfree() const;
  public:
  void clear_temporarilyfree();
  bool temporarilyfree() const;
  void set_temporarilyfree(bool value);
  private:
  bool _internal_temporarilyfree() const;
  void _internal_set_temporarilyfree(bool value);
  public:

  // optional bool repeatLastPayment = 25;
  bool has_repeatlastpayment() const;
  private:
  bool _internal_has_repeatlastpayment() const;
  public:
  void clear_repeatlastpayment();
  bool repeatlastpayment() const;
  void set_repeatlastpayment(bool value);
  private:
  bool _internal_repeatlastpayment() const;
  void _internal_set_repeatlastpayment(bool value);
  public:

  // optional int32 licensedOfferType = 17;
  bool has_licensedoffertype() const;
  private:
  bool _internal_has_licensedoffertype() const;
  public:
  void clear_licensedoffertype();
  int32_t licensedoffertype() const;
  void set_licensedoffertype(int32_t value);
  private:
  int32_t _internal_licensedoffertype() const;
  void _internal_set_licensedoffertype(int32_t value);
  public:

  // optional int64 preorderFulfillmentDisplayDate = 20;
  bool has_preorderfulfillmentdisplaydate() const;
  private:
  bool _internal_has_preorderfulfillmentdisplaydate() const;
  public:
  void clear_preorderfulfillmentdisplaydate();
  int64_t preorderfulfillmentdisplaydate() const;
  void set_preorderfulfillmentdisplaydate(int64_t value);
  private:
  int64_t _internal_preorderfulfillmentdisplaydate() const;
  void _internal_set_preorderfulfillmentdisplaydate(int64_t value);
  public:

  // optional bool instantPurchaseEnabled = 27;
  bool has_instantpurchaseenabled() const;
  private:
  bool _internal_has_instantpurchaseenabled() const;
  public:
  void clear_instantpurchaseenabled();
  bool instantpurchaseenabled() const;
  void set_instantpurchaseenabled(bool value);
  private:
  bool _internal_instantpurchaseenabled() const;
  void _internal_set_instantpurchaseenabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.Offer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Offer > convertedprice_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> promotionlabel_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::OfferPayment > offerpayment_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr currencycode_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr formattedamount_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr formattedfullamount_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr formattedname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr formatteddescription_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr offerid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr buybuttonlabel_;
    ::playapi::proto::finsky::RentalTerms* rentalterms_;
    ::playapi::proto::finsky::SubscriptionTerms* subscriptionterms_;
    ::playapi::proto::finsky::SubscriptionContentTerms* subscriptioncontentterms_;
    ::playapi::proto::finsky::LicenseTerms* licenseterms_;
    ::playapi::proto::finsky::VoucherOfferTerms* voucherterms_;
    int64_t micros_;
    int64_t fullpricemicros_;
    int64_t onsaledate_;
    int32_t offertype_;
    int32_t onsaledatedisplaytimezoneoffsetmsec_;
    bool checkoutflowrequired_;
    bool preorder_;
    bool temporarilyfree_;
    bool repeatlastpayment_;
    int32_t licensedoffertype_;
    int64_t preorderfulfillmentdisplaydate_;
    bool instantpurchaseenabled_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class RentalTerms final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.RentalTerms) */ {
 public:
  inline RentalTerms() : RentalTerms(nullptr) {}
  ~RentalTerms() override;
  explicit PROTOBUF_CONSTEXPR RentalTerms(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RentalTerms(const RentalTerms& from);
  RentalTerms(RentalTerms&& from) noexcept
    : RentalTerms() {
    *this = ::std::move(from);
  }

  inline RentalTerms& operator=(const RentalTerms& from) {
    CopyFrom(from);
    return *this;
  }
  inline RentalTerms& operator=(RentalTerms&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RentalTerms& default_instance() {
    return *internal_default_instance();
  }
  static inline const RentalTerms* internal_default_instance() {
    return reinterpret_cast<const RentalTerms*>(
               &_RentalTerms_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RentalTerms& a, RentalTerms& b) {
    a.Swap(&b);
  }
  inline void Swap(RentalTerms* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RentalTerms* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RentalTerms* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RentalTerms>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RentalTerms& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RentalTerms& from) {
    RentalTerms::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RentalTerms* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.RentalTerms";
  }
  protected:
  explicit RentalTerms(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGrantPeriodFieldNumber = 3,
    kActivatePeriodFieldNumber = 4,
    kDEPRECATEDGrantPeriodSecondsFieldNumber = 1,
    kDEPRECATEDActivatePeriodSecondsFieldNumber = 2,
    kGrantEndTimeSecondsFieldNumber = 5,
  };
  // optional .playapi.proto.finsky.TimePeriod grantPeriod = 3;
  bool has_grantperiod() const;
  private:
  bool _internal_has_grantperiod() const;
  public:
  void clear_grantperiod();
  const ::playapi::proto::finsky::TimePeriod& grantperiod() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::TimePeriod* release_grantperiod();
  ::playapi::proto::finsky::TimePeriod* mutable_grantperiod();
  void set_allocated_grantperiod(::playapi::proto::finsky::TimePeriod* grantperiod);
  private:
  const ::playapi::proto::finsky::TimePeriod& _internal_grantperiod() const;
  ::playapi::proto::finsky::TimePeriod* _internal_mutable_grantperiod();
  public:
  void unsafe_arena_set_allocated_grantperiod(
      ::playapi::proto::finsky::TimePeriod* grantperiod);
  ::playapi::proto::finsky::TimePeriod* unsafe_arena_release_grantperiod();

  // optional .playapi.proto.finsky.TimePeriod activatePeriod = 4;
  bool has_activateperiod() const;
  private:
  bool _internal_has_activateperiod() const;
  public:
  void clear_activateperiod();
  const ::playapi::proto::finsky::TimePeriod& activateperiod() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::TimePeriod* release_activateperiod();
  ::playapi::proto::finsky::TimePeriod* mutable_activateperiod();
  void set_allocated_activateperiod(::playapi::proto::finsky::TimePeriod* activateperiod);
  private:
  const ::playapi::proto::finsky::TimePeriod& _internal_activateperiod() const;
  ::playapi::proto::finsky::TimePeriod* _internal_mutable_activateperiod();
  public:
  void unsafe_arena_set_allocated_activateperiod(
      ::playapi::proto::finsky::TimePeriod* activateperiod);
  ::playapi::proto::finsky::TimePeriod* unsafe_arena_release_activateperiod();

  // optional int32 DEPRECATEDGrantPeriodSeconds = 1;
  bool has_deprecatedgrantperiodseconds() const;
  private:
  bool _internal_has_deprecatedgrantperiodseconds() const;
  public:
  void clear_deprecatedgrantperiodseconds();
  int32_t deprecatedgrantperiodseconds() const;
  void set_deprecatedgrantperiodseconds(int32_t value);
  private:
  int32_t _internal_deprecatedgrantperiodseconds() const;
  void _internal_set_deprecatedgrantperiodseconds(int32_t value);
  public:

  // optional int32 DEPRECATEDActivatePeriodSeconds = 2;
  bool has_deprecatedactivateperiodseconds() const;
  private:
  bool _internal_has_deprecatedactivateperiodseconds() const;
  public:
  void clear_deprecatedactivateperiodseconds();
  int32_t deprecatedactivateperiodseconds() const;
  void set_deprecatedactivateperiodseconds(int32_t value);
  private:
  int32_t _internal_deprecatedactivateperiodseconds() const;
  void _internal_set_deprecatedactivateperiodseconds(int32_t value);
  public:

  // optional int64 grantEndTimeSeconds = 5;
  bool has_grantendtimeseconds() const;
  private:
  bool _internal_has_grantendtimeseconds() const;
  public:
  void clear_grantendtimeseconds();
  int64_t grantendtimeseconds() const;
  void set_grantendtimeseconds(int64_t value);
  private:
  int64_t _internal_grantendtimeseconds() const;
  void _internal_set_grantendtimeseconds(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.RentalTerms)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::playapi::proto::finsky::TimePeriod* grantperiod_;
    ::playapi::proto::finsky::TimePeriod* activateperiod_;
    int32_t deprecatedgrantperiodseconds_;
    int32_t deprecatedactivateperiodseconds_;
    int64_t grantendtimeseconds_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class OfferPayment final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.OfferPayment) */ {
 public:
  inline OfferPayment() : OfferPayment(nullptr) {}
  ~OfferPayment() override;
  explicit PROTOBUF_CONSTEXPR OfferPayment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OfferPayment(const OfferPayment& from);
  OfferPayment(OfferPayment&& from) noexcept
    : OfferPayment() {
    *this = ::std::move(from);
  }

  inline OfferPayment& operator=(const OfferPayment& from) {
    CopyFrom(from);
    return *this;
  }
  inline OfferPayment& operator=(OfferPayment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OfferPayment& default_instance() {
    return *internal_default_instance();
  }
  static inline const OfferPayment* internal_default_instance() {
    return reinterpret_cast<const OfferPayment*>(
               &_OfferPayment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(OfferPayment& a, OfferPayment& b) {
    a.Swap(&b);
  }
  inline void Swap(OfferPayment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OfferPayment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OfferPayment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OfferPayment>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OfferPayment& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OfferPayment& from) {
    OfferPayment::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OfferPayment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.OfferPayment";
  }
  protected:
  explicit OfferPayment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOfferPaymentOverrideFieldNumber = 4,
    kCurrencyCodeFieldNumber = 2,
    kOfferPaymentPeriodFieldNumber = 3,
    kMicrosFieldNumber = 1,
  };
  // repeated .playapi.proto.finsky.OfferPaymentOverride offerPaymentOverride = 4;
  int offerpaymentoverride_size() const;
  private:
  int _internal_offerpaymentoverride_size() const;
  public:
  void clear_offerpaymentoverride();
  ::playapi::proto::finsky::OfferPaymentOverride* mutable_offerpaymentoverride(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::OfferPaymentOverride >*
      mutable_offerpaymentoverride();
  private:
  const ::playapi::proto::finsky::OfferPaymentOverride& _internal_offerpaymentoverride(int index) const;
  ::playapi::proto::finsky::OfferPaymentOverride* _internal_add_offerpaymentoverride();
  public:
  const ::playapi::proto::finsky::OfferPaymentOverride& offerpaymentoverride(int index) const;
  ::playapi::proto::finsky::OfferPaymentOverride* add_offerpaymentoverride();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::OfferPaymentOverride >&
      offerpaymentoverride() const;

  // optional string currencyCode = 2;
  bool has_currencycode() const;
  private:
  bool _internal_has_currencycode() const;
  public:
  void clear_currencycode();
  const std::string& currencycode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_currencycode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_currencycode();
  PROTOBUF_NODISCARD std::string* release_currencycode();
  void set_allocated_currencycode(std::string* currencycode);
  private:
  const std::string& _internal_currencycode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_currencycode(const std::string& value);
  std::string* _internal_mutable_currencycode();
  public:

  // optional .playapi.proto.finsky.OfferPaymentPeriod offerPaymentPeriod = 3;
  bool has_offerpaymentperiod() const;
  private:
  bool _internal_has_offerpaymentperiod() const;
  public:
  void clear_offerpaymentperiod();
  const ::playapi::proto::finsky::OfferPaymentPeriod& offerpaymentperiod() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::OfferPaymentPeriod* release_offerpaymentperiod();
  ::playapi::proto::finsky::OfferPaymentPeriod* mutable_offerpaymentperiod();
  void set_allocated_offerpaymentperiod(::playapi::proto::finsky::OfferPaymentPeriod* offerpaymentperiod);
  private:
  const ::playapi::proto::finsky::OfferPaymentPeriod& _internal_offerpaymentperiod() const;
  ::playapi::proto::finsky::OfferPaymentPeriod* _internal_mutable_offerpaymentperiod();
  public:
  void unsafe_arena_set_allocated_offerpaymentperiod(
      ::playapi::proto::finsky::OfferPaymentPeriod* offerpaymentperiod);
  ::playapi::proto::finsky::OfferPaymentPeriod* unsafe_arena_release_offerpaymentperiod();

  // optional int64 micros = 1;
  bool has_micros() const;
  private:
  bool _internal_has_micros() const;
  public:
  void clear_micros();
  int64_t micros() const;
  void set_micros(int64_t value);
  private:
  int64_t _internal_micros() const;
  void _internal_set_micros(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.OfferPayment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::OfferPaymentOverride > offerpaymentoverride_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr currencycode_;
    ::playapi::proto::finsky::OfferPaymentPeriod* offerpaymentperiod_;
    int64_t micros_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class OfferPaymentPeriod final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.OfferPaymentPeriod) */ {
 public:
  inline OfferPaymentPeriod() : OfferPaymentPeriod(nullptr) {}
  ~OfferPaymentPeriod() override;
  explicit PROTOBUF_CONSTEXPR OfferPaymentPeriod(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OfferPaymentPeriod(const OfferPaymentPeriod& from);
  OfferPaymentPeriod(OfferPaymentPeriod&& from) noexcept
    : OfferPaymentPeriod() {
    *this = ::std::move(from);
  }

  inline OfferPaymentPeriod& operator=(const OfferPaymentPeriod& from) {
    CopyFrom(from);
    return *this;
  }
  inline OfferPaymentPeriod& operator=(OfferPaymentPeriod&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OfferPaymentPeriod& default_instance() {
    return *internal_default_instance();
  }
  static inline const OfferPaymentPeriod* internal_default_instance() {
    return reinterpret_cast<const OfferPaymentPeriod*>(
               &_OfferPaymentPeriod_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(OfferPaymentPeriod& a, OfferPaymentPeriod& b) {
    a.Swap(&b);
  }
  inline void Swap(OfferPaymentPeriod* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OfferPaymentPeriod* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OfferPaymentPeriod* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OfferPaymentPeriod>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OfferPaymentPeriod& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OfferPaymentPeriod& from) {
    OfferPaymentPeriod::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OfferPaymentPeriod* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.OfferPaymentPeriod";
  }
  protected:
  explicit OfferPaymentPeriod(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDurationFieldNumber = 1,
    kStartFieldNumber = 2,
    kEndFieldNumber = 3,
  };
  // optional .playapi.proto.finsky.TimePeriod duration = 1;
  bool has_duration() const;
  private:
  bool _internal_has_duration() const;
  public:
  void clear_duration();
  const ::playapi::proto::finsky::TimePeriod& duration() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::TimePeriod* release_duration();
  ::playapi::proto::finsky::TimePeriod* mutable_duration();
  void set_allocated_duration(::playapi::proto::finsky::TimePeriod* duration);
  private:
  const ::playapi::proto::finsky::TimePeriod& _internal_duration() const;
  ::playapi::proto::finsky::TimePeriod* _internal_mutable_duration();
  public:
  void unsafe_arena_set_allocated_duration(
      ::playapi::proto::finsky::TimePeriod* duration);
  ::playapi::proto::finsky::TimePeriod* unsafe_arena_release_duration();

  // optional .playapi.proto.finsky.MonthAndDay start = 2;
  bool has_start() const;
  private:
  bool _internal_has_start() const;
  public:
  void clear_start();
  const ::playapi::proto::finsky::MonthAndDay& start() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::MonthAndDay* release_start();
  ::playapi::proto::finsky::MonthAndDay* mutable_start();
  void set_allocated_start(::playapi::proto::finsky::MonthAndDay* start);
  private:
  const ::playapi::proto::finsky::MonthAndDay& _internal_start() const;
  ::playapi::proto::finsky::MonthAndDay* _internal_mutable_start();
  public:
  void unsafe_arena_set_allocated_start(
      ::playapi::proto::finsky::MonthAndDay* start);
  ::playapi::proto::finsky::MonthAndDay* unsafe_arena_release_start();

  // optional .playapi.proto.finsky.MonthAndDay end = 3;
  bool has_end() const;
  private:
  bool _internal_has_end() const;
  public:
  void clear_end();
  const ::playapi::proto::finsky::MonthAndDay& end() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::MonthAndDay* release_end();
  ::playapi::proto::finsky::MonthAndDay* mutable_end();
  void set_allocated_end(::playapi::proto::finsky::MonthAndDay* end);
  private:
  const ::playapi::proto::finsky::MonthAndDay& _internal_end() const;
  ::playapi::proto::finsky::MonthAndDay* _internal_mutable_end();
  public:
  void unsafe_arena_set_allocated_end(
      ::playapi::proto::finsky::MonthAndDay* end);
  ::playapi::proto::finsky::MonthAndDay* unsafe_arena_release_end();

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.OfferPaymentPeriod)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::playapi::proto::finsky::TimePeriod* duration_;
    ::playapi::proto::finsky::MonthAndDay* start_;
    ::playapi::proto::finsky::MonthAndDay* end_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class OfferPaymentOverride final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.OfferPaymentOverride) */ {
 public:
  inline OfferPaymentOverride() : OfferPaymentOverride(nullptr) {}
  ~OfferPaymentOverride() override;
  explicit PROTOBUF_CONSTEXPR OfferPaymentOverride(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OfferPaymentOverride(const OfferPaymentOverride& from);
  OfferPaymentOverride(OfferPaymentOverride&& from) noexcept
    : OfferPaymentOverride() {
    *this = ::std::move(from);
  }

  inline OfferPaymentOverride& operator=(const OfferPaymentOverride& from) {
    CopyFrom(from);
    return *this;
  }
  inline OfferPaymentOverride& operator=(OfferPaymentOverride&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OfferPaymentOverride& default_instance() {
    return *internal_default_instance();
  }
  static inline const OfferPaymentOverride* internal_default_instance() {
    return reinterpret_cast<const OfferPaymentOverride*>(
               &_OfferPaymentOverride_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(OfferPaymentOverride& a, OfferPaymentOverride& b) {
    a.Swap(&b);
  }
  inline void Swap(OfferPaymentOverride* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OfferPaymentOverride* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OfferPaymentOverride* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OfferPaymentOverride>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OfferPaymentOverride& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OfferPaymentOverride& from) {
    OfferPaymentOverride::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OfferPaymentOverride* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.OfferPaymentOverride";
  }
  protected:
  explicit OfferPaymentOverride(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartFieldNumber = 2,
    kEndFieldNumber = 3,
    kMicrosFieldNumber = 1,
  };
  // optional .playapi.proto.finsky.MonthAndDay start = 2;
  bool has_start() const;
  private:
  bool _internal_has_start() const;
  public:
  void clear_start();
  const ::playapi::proto::finsky::MonthAndDay& start() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::MonthAndDay* release_start();
  ::playapi::proto::finsky::MonthAndDay* mutable_start();
  void set_allocated_start(::playapi::proto::finsky::MonthAndDay* start);
  private:
  const ::playapi::proto::finsky::MonthAndDay& _internal_start() const;
  ::playapi::proto::finsky::MonthAndDay* _internal_mutable_start();
  public:
  void unsafe_arena_set_allocated_start(
      ::playapi::proto::finsky::MonthAndDay* start);
  ::playapi::proto::finsky::MonthAndDay* unsafe_arena_release_start();

  // optional .playapi.proto.finsky.MonthAndDay end = 3;
  bool has_end() const;
  private:
  bool _internal_has_end() const;
  public:
  void clear_end();
  const ::playapi::proto::finsky::MonthAndDay& end() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::MonthAndDay* release_end();
  ::playapi::proto::finsky::MonthAndDay* mutable_end();
  void set_allocated_end(::playapi::proto::finsky::MonthAndDay* end);
  private:
  const ::playapi::proto::finsky::MonthAndDay& _internal_end() const;
  ::playapi::proto::finsky::MonthAndDay* _internal_mutable_end();
  public:
  void unsafe_arena_set_allocated_end(
      ::playapi::proto::finsky::MonthAndDay* end);
  ::playapi::proto::finsky::MonthAndDay* unsafe_arena_release_end();

  // optional int64 micros = 1;
  bool has_micros() const;
  private:
  bool _internal_has_micros() const;
  public:
  void clear_micros();
  int64_t micros() const;
  void set_micros(int64_t value);
  private:
  int64_t _internal_micros() const;
  void _internal_set_micros(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.OfferPaymentOverride)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::playapi::proto::finsky::MonthAndDay* start_;
    ::playapi::proto::finsky::MonthAndDay* end_;
    int64_t micros_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class SeasonalSubscriptionInfo_Payment final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.SeasonalSubscriptionInfo.Payment) */ {
 public:
  inline SeasonalSubscriptionInfo_Payment() : SeasonalSubscriptionInfo_Payment(nullptr) {}
  ~SeasonalSubscriptionInfo_Payment() override;
  explicit PROTOBUF_CONSTEXPR SeasonalSubscriptionInfo_Payment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SeasonalSubscriptionInfo_Payment(const SeasonalSubscriptionInfo_Payment& from);
  SeasonalSubscriptionInfo_Payment(SeasonalSubscriptionInfo_Payment&& from) noexcept
    : SeasonalSubscriptionInfo_Payment() {
    *this = ::std::move(from);
  }

  inline SeasonalSubscriptionInfo_Payment& operator=(const SeasonalSubscriptionInfo_Payment& from) {
    CopyFrom(from);
    return *this;
  }
  inline SeasonalSubscriptionInfo_Payment& operator=(SeasonalSubscriptionInfo_Payment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SeasonalSubscriptionInfo_Payment& default_instance() {
    return *internal_default_instance();
  }
  static inline const SeasonalSubscriptionInfo_Payment* internal_default_instance() {
    return reinterpret_cast<const SeasonalSubscriptionInfo_Payment*>(
               &_SeasonalSubscriptionInfo_Payment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SeasonalSubscriptionInfo_Payment& a, SeasonalSubscriptionInfo_Payment& b) {
    a.Swap(&b);
  }
  inline void Swap(SeasonalSubscriptionInfo_Payment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SeasonalSubscriptionInfo_Payment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SeasonalSubscriptionInfo_Payment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SeasonalSubscriptionInfo_Payment>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SeasonalSubscriptionInfo_Payment& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SeasonalSubscriptionInfo_Payment& from) {
    SeasonalSubscriptionInfo_Payment::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SeasonalSubscriptionInfo_Payment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.SeasonalSubscriptionInfo.Payment";
  }
  protected:
  explicit SeasonalSubscriptionInfo_Payment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurrencyCodeFieldNumber = 2,
    kFormattedAmountFieldNumber = 3,
    kPeriodFieldNumber = 4,
    kMicrosFieldNumber = 1,
  };
  // optional string currencyCode = 2;
  bool has_currencycode() const;
  private:
  bool _internal_has_currencycode() const;
  public:
  void clear_currencycode();
  const std::string& currencycode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_currencycode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_currencycode();
  PROTOBUF_NODISCARD std::string* release_currencycode();
  void set_allocated_currencycode(std::string* currencycode);
  private:
  const std::string& _internal_currencycode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_currencycode(const std::string& value);
  std::string* _internal_mutable_currencycode();
  public:

  // optional string formattedAmount = 3;
  bool has_formattedamount() const;
  private:
  bool _internal_has_formattedamount() const;
  public:
  void clear_formattedamount();
  const std::string& formattedamount() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_formattedamount(ArgT0&& arg0, ArgT... args);
  std::string* mutable_formattedamount();
  PROTOBUF_NODISCARD std::string* release_formattedamount();
  void set_allocated_formattedamount(std::string* formattedamount);
  private:
  const std::string& _internal_formattedamount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_formattedamount(const std::string& value);
  std::string* _internal_mutable_formattedamount();
  public:

  // optional .playapi.proto.finsky.TimePeriod period = 4;
  bool has_period() const;
  private:
  bool _internal_has_period() const;
  public:
  void clear_period();
  const ::playapi::proto::finsky::TimePeriod& period() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::TimePeriod* release_period();
  ::playapi::proto::finsky::TimePeriod* mutable_period();
  void set_allocated_period(::playapi::proto::finsky::TimePeriod* period);
  private:
  const ::playapi::proto::finsky::TimePeriod& _internal_period() const;
  ::playapi::proto::finsky::TimePeriod* _internal_mutable_period();
  public:
  void unsafe_arena_set_allocated_period(
      ::playapi::proto::finsky::TimePeriod* period);
  ::playapi::proto::finsky::TimePeriod* unsafe_arena_release_period();

  // optional int64 micros = 1;
  bool has_micros() const;
  private:
  bool _internal_has_micros() const;
  public:
  void clear_micros();
  int64_t micros() const;
  void set_micros(int64_t value);
  private:
  int64_t _internal_micros() const;
  void _internal_set_micros(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.SeasonalSubscriptionInfo.Payment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr currencycode_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr formattedamount_;
    ::playapi::proto::finsky::TimePeriod* period_;
    int64_t micros_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class SeasonalSubscriptionInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.SeasonalSubscriptionInfo) */ {
 public:
  inline SeasonalSubscriptionInfo() : SeasonalSubscriptionInfo(nullptr) {}
  ~SeasonalSubscriptionInfo() override;
  explicit PROTOBUF_CONSTEXPR SeasonalSubscriptionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SeasonalSubscriptionInfo(const SeasonalSubscriptionInfo& from);
  SeasonalSubscriptionInfo(SeasonalSubscriptionInfo&& from) noexcept
    : SeasonalSubscriptionInfo() {
    *this = ::std::move(from);
  }

  inline SeasonalSubscriptionInfo& operator=(const SeasonalSubscriptionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SeasonalSubscriptionInfo& operator=(SeasonalSubscriptionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SeasonalSubscriptionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SeasonalSubscriptionInfo* internal_default_instance() {
    return reinterpret_cast<const SeasonalSubscriptionInfo*>(
               &_SeasonalSubscriptionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SeasonalSubscriptionInfo& a, SeasonalSubscriptionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SeasonalSubscriptionInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SeasonalSubscriptionInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SeasonalSubscriptionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SeasonalSubscriptionInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SeasonalSubscriptionInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SeasonalSubscriptionInfo& from) {
    SeasonalSubscriptionInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SeasonalSubscriptionInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.SeasonalSubscriptionInfo";
  }
  protected:
  explicit SeasonalSubscriptionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SeasonalSubscriptionInfo_Payment Payment;

  // accessors -------------------------------------------------------

  enum : int {
    kPeriodStartFieldNumber = 1,
    kPeriodEndFieldNumber = 2,
    kPostTrialConversionPaymentFieldNumber = 5,
    kProratedFieldNumber = 4,
  };
  // optional .playapi.proto.finsky.MonthAndDay periodStart = 1;
  bool has_periodstart() const;
  private:
  bool _internal_has_periodstart() const;
  public:
  void clear_periodstart();
  const ::playapi::proto::finsky::MonthAndDay& periodstart() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::MonthAndDay* release_periodstart();
  ::playapi::proto::finsky::MonthAndDay* mutable_periodstart();
  void set_allocated_periodstart(::playapi::proto::finsky::MonthAndDay* periodstart);
  private:
  const ::playapi::proto::finsky::MonthAndDay& _internal_periodstart() const;
  ::playapi::proto::finsky::MonthAndDay* _internal_mutable_periodstart();
  public:
  void unsafe_arena_set_allocated_periodstart(
      ::playapi::proto::finsky::MonthAndDay* periodstart);
  ::playapi::proto::finsky::MonthAndDay* unsafe_arena_release_periodstart();

  // optional .playapi.proto.finsky.MonthAndDay periodEnd = 2;
  bool has_periodend() const;
  private:
  bool _internal_has_periodend() const;
  public:
  void clear_periodend();
  const ::playapi::proto::finsky::MonthAndDay& periodend() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::MonthAndDay* release_periodend();
  ::playapi::proto::finsky::MonthAndDay* mutable_periodend();
  void set_allocated_periodend(::playapi::proto::finsky::MonthAndDay* periodend);
  private:
  const ::playapi::proto::finsky::MonthAndDay& _internal_periodend() const;
  ::playapi::proto::finsky::MonthAndDay* _internal_mutable_periodend();
  public:
  void unsafe_arena_set_allocated_periodend(
      ::playapi::proto::finsky::MonthAndDay* periodend);
  ::playapi::proto::finsky::MonthAndDay* unsafe_arena_release_periodend();

  // optional .playapi.proto.finsky.SeasonalSubscriptionInfo.Payment postTrialConversionPayment = 5;
  bool has_posttrialconversionpayment() const;
  private:
  bool _internal_has_posttrialconversionpayment() const;
  public:
  void clear_posttrialconversionpayment();
  const ::playapi::proto::finsky::SeasonalSubscriptionInfo_Payment& posttrialconversionpayment() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::SeasonalSubscriptionInfo_Payment* release_posttrialconversionpayment();
  ::playapi::proto::finsky::SeasonalSubscriptionInfo_Payment* mutable_posttrialconversionpayment();
  void set_allocated_posttrialconversionpayment(::playapi::proto::finsky::SeasonalSubscriptionInfo_Payment* posttrialconversionpayment);
  private:
  const ::playapi::proto::finsky::SeasonalSubscriptionInfo_Payment& _internal_posttrialconversionpayment() const;
  ::playapi::proto::finsky::SeasonalSubscriptionInfo_Payment* _internal_mutable_posttrialconversionpayment();
  public:
  void unsafe_arena_set_allocated_posttrialconversionpayment(
      ::playapi::proto::finsky::SeasonalSubscriptionInfo_Payment* posttrialconversionpayment);
  ::playapi::proto::finsky::SeasonalSubscriptionInfo_Payment* unsafe_arena_release_posttrialconversionpayment();

  // optional bool prorated = 4;
  bool has_prorated() const;
  private:
  bool _internal_has_prorated() const;
  public:
  void clear_prorated();
  bool prorated() const;
  void set_prorated(bool value);
  private:
  bool _internal_prorated() const;
  void _internal_set_prorated(bool value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.SeasonalSubscriptionInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::playapi::proto::finsky::MonthAndDay* periodstart_;
    ::playapi::proto::finsky::MonthAndDay* periodend_;
    ::playapi::proto::finsky::SeasonalSubscriptionInfo_Payment* posttrialconversionpayment_;
    bool prorated_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class SubscriptionTerms_SubscriptionReplacement final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.SubscriptionTerms.SubscriptionReplacement) */ {
 public:
  inline SubscriptionTerms_SubscriptionReplacement() : SubscriptionTerms_SubscriptionReplacement(nullptr) {}
  ~SubscriptionTerms_SubscriptionReplacement() override;
  explicit PROTOBUF_CONSTEXPR SubscriptionTerms_SubscriptionReplacement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscriptionTerms_SubscriptionReplacement(const SubscriptionTerms_SubscriptionReplacement& from);
  SubscriptionTerms_SubscriptionReplacement(SubscriptionTerms_SubscriptionReplacement&& from) noexcept
    : SubscriptionTerms_SubscriptionReplacement() {
    *this = ::std::move(from);
  }

  inline SubscriptionTerms_SubscriptionReplacement& operator=(const SubscriptionTerms_SubscriptionReplacement& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscriptionTerms_SubscriptionReplacement& operator=(SubscriptionTerms_SubscriptionReplacement&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscriptionTerms_SubscriptionReplacement& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscriptionTerms_SubscriptionReplacement* internal_default_instance() {
    return reinterpret_cast<const SubscriptionTerms_SubscriptionReplacement*>(
               &_SubscriptionTerms_SubscriptionReplacement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SubscriptionTerms_SubscriptionReplacement& a, SubscriptionTerms_SubscriptionReplacement& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscriptionTerms_SubscriptionReplacement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscriptionTerms_SubscriptionReplacement* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscriptionTerms_SubscriptionReplacement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscriptionTerms_SubscriptionReplacement>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscriptionTerms_SubscriptionReplacement& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubscriptionTerms_SubscriptionReplacement& from) {
    SubscriptionTerms_SubscriptionReplacement::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscriptionTerms_SubscriptionReplacement* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.SubscriptionTerms.SubscriptionReplacement";
  }
  protected:
  explicit SubscriptionTerms_SubscriptionReplacement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOldDocidFieldNumber = 2,
    kNewDocidFieldNumber = 1,
    kKeepNextRecurrenceTimeFieldNumber = 3,
    kReplaceOnFirstRecurrenceFieldNumber = 4,
  };
  // repeated .playapi.proto.finsky.Docid oldDocid = 2;
  int olddocid_size() const;
  private:
  int _internal_olddocid_size() const;
  public:
  void clear_olddocid();
  ::playapi::proto::finsky::Docid* mutable_olddocid(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Docid >*
      mutable_olddocid();
  private:
  const ::playapi::proto::finsky::Docid& _internal_olddocid(int index) const;
  ::playapi::proto::finsky::Docid* _internal_add_olddocid();
  public:
  const ::playapi::proto::finsky::Docid& olddocid(int index) const;
  ::playapi::proto::finsky::Docid* add_olddocid();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Docid >&
      olddocid() const;

  // optional .playapi.proto.finsky.Docid newDocid = 1;
  bool has_newdocid() const;
  private:
  bool _internal_has_newdocid() const;
  public:
  void clear_newdocid();
  const ::playapi::proto::finsky::Docid& newdocid() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::Docid* release_newdocid();
  ::playapi::proto::finsky::Docid* mutable_newdocid();
  void set_allocated_newdocid(::playapi::proto::finsky::Docid* newdocid);
  private:
  const ::playapi::proto::finsky::Docid& _internal_newdocid() const;
  ::playapi::proto::finsky::Docid* _internal_mutable_newdocid();
  public:
  void unsafe_arena_set_allocated_newdocid(
      ::playapi::proto::finsky::Docid* newdocid);
  ::playapi::proto::finsky::Docid* unsafe_arena_release_newdocid();

  // optional bool keepNextRecurrenceTime = 3;
  bool has_keepnextrecurrencetime() const;
  private:
  bool _internal_has_keepnextrecurrencetime() const;
  public:
  void clear_keepnextrecurrencetime();
  bool keepnextrecurrencetime() const;
  void set_keepnextrecurrencetime(bool value);
  private:
  bool _internal_keepnextrecurrencetime() const;
  void _internal_set_keepnextrecurrencetime(bool value);
  public:

  // optional bool replaceOnFirstRecurrence = 4;
  bool has_replaceonfirstrecurrence() const;
  private:
  bool _internal_has_replaceonfirstrecurrence() const;
  public:
  void clear_replaceonfirstrecurrence();
  bool replaceonfirstrecurrence() const;
  void set_replaceonfirstrecurrence(bool value);
  private:
  bool _internal_replaceonfirstrecurrence() const;
  void _internal_set_replaceonfirstrecurrence(bool value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.SubscriptionTerms.SubscriptionReplacement)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Docid > olddocid_;
    ::playapi::proto::finsky::Docid* newdocid_;
    bool keepnextrecurrencetime_;
    bool replaceonfirstrecurrence_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class SubscriptionTerms final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.SubscriptionTerms) */ {
 public:
  inline SubscriptionTerms() : SubscriptionTerms(nullptr) {}
  ~SubscriptionTerms() override;
  explicit PROTOBUF_CONSTEXPR SubscriptionTerms(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscriptionTerms(const SubscriptionTerms& from);
  SubscriptionTerms(SubscriptionTerms&& from) noexcept
    : SubscriptionTerms() {
    *this = ::std::move(from);
  }

  inline SubscriptionTerms& operator=(const SubscriptionTerms& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscriptionTerms& operator=(SubscriptionTerms&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscriptionTerms& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscriptionTerms* internal_default_instance() {
    return reinterpret_cast<const SubscriptionTerms*>(
               &_SubscriptionTerms_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SubscriptionTerms& a, SubscriptionTerms& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscriptionTerms* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscriptionTerms* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscriptionTerms* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscriptionTerms>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscriptionTerms& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubscriptionTerms& from) {
    SubscriptionTerms::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscriptionTerms* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.SubscriptionTerms";
  }
  protected:
  explicit SubscriptionTerms(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SubscriptionTerms_SubscriptionReplacement SubscriptionReplacement;

  // accessors -------------------------------------------------------

  enum : int {
    kReplaceDocidFieldNumber = 5,
    kFormattedPriceWithRecurrencePeriodFieldNumber = 3,
    kNextPaymentCurrencyCodeFieldNumber = 9,
    kRecurringPeriodFieldNumber = 1,
    kTrialPeriodFieldNumber = 2,
    kSeasonalSubscriptionInfoFieldNumber = 4,
    kGracePeriodFieldNumber = 6,
    kSubscriptionReplacementFieldNumber = 12,
    kInitialValidUntilTimestampMsecFieldNumber = 8,
    kNextPaymentPriceMicrosFieldNumber = 10,
    kResignupFieldNumber = 7,
    kEnableAppSpecifiedTrialPeriodFieldNumber = 11,
  };
  // repeated .playapi.proto.finsky.Docid replaceDocid = 5;
  int replacedocid_size() const;
  private:
  int _internal_replacedocid_size() const;
  public:
  void clear_replacedocid();
  ::playapi::proto::finsky::Docid* mutable_replacedocid(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Docid >*
      mutable_replacedocid();
  private:
  const ::playapi::proto::finsky::Docid& _internal_replacedocid(int index) const;
  ::playapi::proto::finsky::Docid* _internal_add_replacedocid();
  public:
  const ::playapi::proto::finsky::Docid& replacedocid(int index) const;
  ::playapi::proto::finsky::Docid* add_replacedocid();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Docid >&
      replacedocid() const;

  // optional string formattedPriceWithRecurrencePeriod = 3;
  bool has_formattedpricewithrecurrenceperiod() const;
  private:
  bool _internal_has_formattedpricewithrecurrenceperiod() const;
  public:
  void clear_formattedpricewithrecurrenceperiod();
  const std::string& formattedpricewithrecurrenceperiod() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_formattedpricewithrecurrenceperiod(ArgT0&& arg0, ArgT... args);
  std::string* mutable_formattedpricewithrecurrenceperiod();
  PROTOBUF_NODISCARD std::string* release_formattedpricewithrecurrenceperiod();
  void set_allocated_formattedpricewithrecurrenceperiod(std::string* formattedpricewithrecurrenceperiod);
  private:
  const std::string& _internal_formattedpricewithrecurrenceperiod() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_formattedpricewithrecurrenceperiod(const std::string& value);
  std::string* _internal_mutable_formattedpricewithrecurrenceperiod();
  public:

  // optional string nextPaymentCurrencyCode = 9;
  bool has_nextpaymentcurrencycode() const;
  private:
  bool _internal_has_nextpaymentcurrencycode() const;
  public:
  void clear_nextpaymentcurrencycode();
  const std::string& nextpaymentcurrencycode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nextpaymentcurrencycode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nextpaymentcurrencycode();
  PROTOBUF_NODISCARD std::string* release_nextpaymentcurrencycode();
  void set_allocated_nextpaymentcurrencycode(std::string* nextpaymentcurrencycode);
  private:
  const std::string& _internal_nextpaymentcurrencycode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nextpaymentcurrencycode(const std::string& value);
  std::string* _internal_mutable_nextpaymentcurrencycode();
  public:

  // optional .playapi.proto.finsky.TimePeriod recurringPeriod = 1;
  bool has_recurringperiod() const;
  private:
  bool _internal_has_recurringperiod() const;
  public:
  void clear_recurringperiod();
  const ::playapi::proto::finsky::TimePeriod& recurringperiod() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::TimePeriod* release_recurringperiod();
  ::playapi::proto::finsky::TimePeriod* mutable_recurringperiod();
  void set_allocated_recurringperiod(::playapi::proto::finsky::TimePeriod* recurringperiod);
  private:
  const ::playapi::proto::finsky::TimePeriod& _internal_recurringperiod() const;
  ::playapi::proto::finsky::TimePeriod* _internal_mutable_recurringperiod();
  public:
  void unsafe_arena_set_allocated_recurringperiod(
      ::playapi::proto::finsky::TimePeriod* recurringperiod);
  ::playapi::proto::finsky::TimePeriod* unsafe_arena_release_recurringperiod();

  // optional .playapi.proto.finsky.TimePeriod trialPeriod = 2;
  bool has_trialperiod() const;
  private:
  bool _internal_has_trialperiod() const;
  public:
  void clear_trialperiod();
  const ::playapi::proto::finsky::TimePeriod& trialperiod() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::TimePeriod* release_trialperiod();
  ::playapi::proto::finsky::TimePeriod* mutable_trialperiod();
  void set_allocated_trialperiod(::playapi::proto::finsky::TimePeriod* trialperiod);
  private:
  const ::playapi::proto::finsky::TimePeriod& _internal_trialperiod() const;
  ::playapi::proto::finsky::TimePeriod* _internal_mutable_trialperiod();
  public:
  void unsafe_arena_set_allocated_trialperiod(
      ::playapi::proto::finsky::TimePeriod* trialperiod);
  ::playapi::proto::finsky::TimePeriod* unsafe_arena_release_trialperiod();

  // optional .playapi.proto.finsky.SeasonalSubscriptionInfo seasonalSubscriptionInfo = 4;
  bool has_seasonalsubscriptioninfo() const;
  private:
  bool _internal_has_seasonalsubscriptioninfo() const;
  public:
  void clear_seasonalsubscriptioninfo();
  const ::playapi::proto::finsky::SeasonalSubscriptionInfo& seasonalsubscriptioninfo() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::SeasonalSubscriptionInfo* release_seasonalsubscriptioninfo();
  ::playapi::proto::finsky::SeasonalSubscriptionInfo* mutable_seasonalsubscriptioninfo();
  void set_allocated_seasonalsubscriptioninfo(::playapi::proto::finsky::SeasonalSubscriptionInfo* seasonalsubscriptioninfo);
  private:
  const ::playapi::proto::finsky::SeasonalSubscriptionInfo& _internal_seasonalsubscriptioninfo() const;
  ::playapi::proto::finsky::SeasonalSubscriptionInfo* _internal_mutable_seasonalsubscriptioninfo();
  public:
  void unsafe_arena_set_allocated_seasonalsubscriptioninfo(
      ::playapi::proto::finsky::SeasonalSubscriptionInfo* seasonalsubscriptioninfo);
  ::playapi::proto::finsky::SeasonalSubscriptionInfo* unsafe_arena_release_seasonalsubscriptioninfo();

  // optional .playapi.proto.finsky.TimePeriod gracePeriod = 6;
  bool has_graceperiod() const;
  private:
  bool _internal_has_graceperiod() const;
  public:
  void clear_graceperiod();
  const ::playapi::proto::finsky::TimePeriod& graceperiod() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::TimePeriod* release_graceperiod();
  ::playapi::proto::finsky::TimePeriod* mutable_graceperiod();
  void set_allocated_graceperiod(::playapi::proto::finsky::TimePeriod* graceperiod);
  private:
  const ::playapi::proto::finsky::TimePeriod& _internal_graceperiod() const;
  ::playapi::proto::finsky::TimePeriod* _internal_mutable_graceperiod();
  public:
  void unsafe_arena_set_allocated_graceperiod(
      ::playapi::proto::finsky::TimePeriod* graceperiod);
  ::playapi::proto::finsky::TimePeriod* unsafe_arena_release_graceperiod();

  // optional .playapi.proto.finsky.SubscriptionTerms.SubscriptionReplacement subscriptionReplacement = 12;
  bool has_subscriptionreplacement() const;
  private:
  bool _internal_has_subscriptionreplacement() const;
  public:
  void clear_subscriptionreplacement();
  const ::playapi::proto::finsky::SubscriptionTerms_SubscriptionReplacement& subscriptionreplacement() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::SubscriptionTerms_SubscriptionReplacement* release_subscriptionreplacement();
  ::playapi::proto::finsky::SubscriptionTerms_SubscriptionReplacement* mutable_subscriptionreplacement();
  void set_allocated_subscriptionreplacement(::playapi::proto::finsky::SubscriptionTerms_SubscriptionReplacement* subscriptionreplacement);
  private:
  const ::playapi::proto::finsky::SubscriptionTerms_SubscriptionReplacement& _internal_subscriptionreplacement() const;
  ::playapi::proto::finsky::SubscriptionTerms_SubscriptionReplacement* _internal_mutable_subscriptionreplacement();
  public:
  void unsafe_arena_set_allocated_subscriptionreplacement(
      ::playapi::proto::finsky::SubscriptionTerms_SubscriptionReplacement* subscriptionreplacement);
  ::playapi::proto::finsky::SubscriptionTerms_SubscriptionReplacement* unsafe_arena_release_subscriptionreplacement();

  // optional int64 initialValidUntilTimestampMsec = 8;
  bool has_initialvaliduntiltimestampmsec() const;
  private:
  bool _internal_has_initialvaliduntiltimestampmsec() const;
  public:
  void clear_initialvaliduntiltimestampmsec();
  int64_t initialvaliduntiltimestampmsec() const;
  void set_initialvaliduntiltimestampmsec(int64_t value);
  private:
  int64_t _internal_initialvaliduntiltimestampmsec() const;
  void _internal_set_initialvaliduntiltimestampmsec(int64_t value);
  public:

  // optional int64 nextPaymentPriceMicros = 10;
  bool has_nextpaymentpricemicros() const;
  private:
  bool _internal_has_nextpaymentpricemicros() const;
  public:
  void clear_nextpaymentpricemicros();
  int64_t nextpaymentpricemicros() const;
  void set_nextpaymentpricemicros(int64_t value);
  private:
  int64_t _internal_nextpaymentpricemicros() const;
  void _internal_set_nextpaymentpricemicros(int64_t value);
  public:

  // optional bool resignup = 7;
  bool has_resignup() const;
  private:
  bool _internal_has_resignup() const;
  public:
  void clear_resignup();
  bool resignup() const;
  void set_resignup(bool value);
  private:
  bool _internal_resignup() const;
  void _internal_set_resignup(bool value);
  public:

  // optional bool enableAppSpecifiedTrialPeriod = 11;
  bool has_enableappspecifiedtrialperiod() const;
  private:
  bool _internal_has_enableappspecifiedtrialperiod() const;
  public:
  void clear_enableappspecifiedtrialperiod();
  bool enableappspecifiedtrialperiod() const;
  void set_enableappspecifiedtrialperiod(bool value);
  private:
  bool _internal_enableappspecifiedtrialperiod() const;
  void _internal_set_enableappspecifiedtrialperiod(bool value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.SubscriptionTerms)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Docid > replacedocid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr formattedpricewithrecurrenceperiod_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nextpaymentcurrencycode_;
    ::playapi::proto::finsky::TimePeriod* recurringperiod_;
    ::playapi::proto::finsky::TimePeriod* trialperiod_;
    ::playapi::proto::finsky::SeasonalSubscriptionInfo* seasonalsubscriptioninfo_;
    ::playapi::proto::finsky::TimePeriod* graceperiod_;
    ::playapi::proto::finsky::SubscriptionTerms_SubscriptionReplacement* subscriptionreplacement_;
    int64_t initialvaliduntiltimestampmsec_;
    int64_t nextpaymentpricemicros_;
    bool resignup_;
    bool enableappspecifiedtrialperiod_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class SubscriptionContentTerms final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.SubscriptionContentTerms) */ {
 public:
  inline SubscriptionContentTerms() : SubscriptionContentTerms(nullptr) {}
  ~SubscriptionContentTerms() override;
  explicit PROTOBUF_CONSTEXPR SubscriptionContentTerms(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscriptionContentTerms(const SubscriptionContentTerms& from);
  SubscriptionContentTerms(SubscriptionContentTerms&& from) noexcept
    : SubscriptionContentTerms() {
    *this = ::std::move(from);
  }

  inline SubscriptionContentTerms& operator=(const SubscriptionContentTerms& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscriptionContentTerms& operator=(SubscriptionContentTerms&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscriptionContentTerms& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscriptionContentTerms* internal_default_instance() {
    return reinterpret_cast<const SubscriptionContentTerms*>(
               &_SubscriptionContentTerms_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SubscriptionContentTerms& a, SubscriptionContentTerms& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscriptionContentTerms* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscriptionContentTerms* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscriptionContentTerms* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscriptionContentTerms>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscriptionContentTerms& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubscriptionContentTerms& from) {
    SubscriptionContentTerms::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscriptionContentTerms* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.SubscriptionContentTerms";
  }
  protected:
  explicit SubscriptionContentTerms(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequiredSubscriptionFieldNumber = 1,
  };
  // optional .playapi.proto.finsky.Docid requiredSubscription = 1;
  bool has_requiredsubscription() const;
  private:
  bool _internal_has_requiredsubscription() const;
  public:
  void clear_requiredsubscription();
  const ::playapi::proto::finsky::Docid& requiredsubscription() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::Docid* release_requiredsubscription();
  ::playapi::proto::finsky::Docid* mutable_requiredsubscription();
  void set_allocated_requiredsubscription(::playapi::proto::finsky::Docid* requiredsubscription);
  private:
  const ::playapi::proto::finsky::Docid& _internal_requiredsubscription() const;
  ::playapi::proto::finsky::Docid* _internal_mutable_requiredsubscription();
  public:
  void unsafe_arena_set_allocated_requiredsubscription(
      ::playapi::proto::finsky::Docid* requiredsubscription);
  ::playapi::proto::finsky::Docid* unsafe_arena_release_requiredsubscription();

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.SubscriptionContentTerms)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::playapi::proto::finsky::Docid* requiredsubscription_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class GroupLicenseKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.GroupLicenseKey) */ {
 public:
  inline GroupLicenseKey() : GroupLicenseKey(nullptr) {}
  ~GroupLicenseKey() override;
  explicit PROTOBUF_CONSTEXPR GroupLicenseKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GroupLicenseKey(const GroupLicenseKey& from);
  GroupLicenseKey(GroupLicenseKey&& from) noexcept
    : GroupLicenseKey() {
    *this = ::std::move(from);
  }

  inline GroupLicenseKey& operator=(const GroupLicenseKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupLicenseKey& operator=(GroupLicenseKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GroupLicenseKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const GroupLicenseKey* internal_default_instance() {
    return reinterpret_cast<const GroupLicenseKey*>(
               &_GroupLicenseKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(GroupLicenseKey& a, GroupLicenseKey& b) {
    a.Swap(&b);
  }
  inline void Swap(GroupLicenseKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupLicenseKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GroupLicenseKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GroupLicenseKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GroupLicenseKey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GroupLicenseKey& from) {
    GroupLicenseKey::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GroupLicenseKey* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.GroupLicenseKey";
  }
  protected:
  explicit GroupLicenseKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDocidFieldNumber = 2,
    kDasherCustomerIdFieldNumber = 1,
    kLicensedOfferTypeFieldNumber = 3,
    kTypeFieldNumber = 4,
    kRentalPeriodDaysFieldNumber = 5,
  };
  // optional .playapi.proto.finsky.Docid docid = 2;
  bool has_docid() const;
  private:
  bool _internal_has_docid() const;
  public:
  void clear_docid();
  const ::playapi::proto::finsky::Docid& docid() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::Docid* release_docid();
  ::playapi::proto::finsky::Docid* mutable_docid();
  void set_allocated_docid(::playapi::proto::finsky::Docid* docid);
  private:
  const ::playapi::proto::finsky::Docid& _internal_docid() const;
  ::playapi::proto::finsky::Docid* _internal_mutable_docid();
  public:
  void unsafe_arena_set_allocated_docid(
      ::playapi::proto::finsky::Docid* docid);
  ::playapi::proto::finsky::Docid* unsafe_arena_release_docid();

  // optional fixed64 dasherCustomerId = 1;
  bool has_dashercustomerid() const;
  private:
  bool _internal_has_dashercustomerid() const;
  public:
  void clear_dashercustomerid();
  uint64_t dashercustomerid() const;
  void set_dashercustomerid(uint64_t value);
  private:
  uint64_t _internal_dashercustomerid() const;
  void _internal_set_dashercustomerid(uint64_t value);
  public:

  // optional int32 licensedOfferType = 3;
  bool has_licensedoffertype() const;
  private:
  bool _internal_has_licensedoffertype() const;
  public:
  void clear_licensedoffertype();
  int32_t licensedoffertype() const;
  void set_licensedoffertype(int32_t value);
  private:
  int32_t _internal_licensedoffertype() const;
  void _internal_set_licensedoffertype(int32_t value);
  public:

  // optional int32 type = 4;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  int32_t type() const;
  void set_type(int32_t value);
  private:
  int32_t _internal_type() const;
  void _internal_set_type(int32_t value);
  public:

  // optional int32 rentalPeriodDays = 5;
  bool has_rentalperioddays() const;
  private:
  bool _internal_has_rentalperioddays() const;
  public:
  void clear_rentalperioddays();
  int32_t rentalperioddays() const;
  void set_rentalperioddays(int32_t value);
  private:
  int32_t _internal_rentalperioddays() const;
  void _internal_set_rentalperioddays(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.GroupLicenseKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::playapi::proto::finsky::Docid* docid_;
    uint64_t dashercustomerid_;
    int32_t licensedoffertype_;
    int32_t type_;
    int32_t rentalperioddays_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class GroupLicenseInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.GroupLicenseInfo) */ {
 public:
  inline GroupLicenseInfo() : GroupLicenseInfo(nullptr) {}
  ~GroupLicenseInfo() override;
  explicit PROTOBUF_CONSTEXPR GroupLicenseInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GroupLicenseInfo(const GroupLicenseInfo& from);
  GroupLicenseInfo(GroupLicenseInfo&& from) noexcept
    : GroupLicenseInfo() {
    *this = ::std::move(from);
  }

  inline GroupLicenseInfo& operator=(const GroupLicenseInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupLicenseInfo& operator=(GroupLicenseInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GroupLicenseInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const GroupLicenseInfo* internal_default_instance() {
    return reinterpret_cast<const GroupLicenseInfo*>(
               &_GroupLicenseInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(GroupLicenseInfo& a, GroupLicenseInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(GroupLicenseInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupLicenseInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GroupLicenseInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GroupLicenseInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GroupLicenseInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GroupLicenseInfo& from) {
    GroupLicenseInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GroupLicenseInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.GroupLicenseInfo";
  }
  protected:
  explicit GroupLicenseInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupLicenseKeyFieldNumber = 3,
    kGaiaGroupIdFieldNumber = 2,
    kLicensedOfferTypeFieldNumber = 1,
  };
  // optional .playapi.proto.finsky.GroupLicenseKey groupLicenseKey = 3;
  bool has_grouplicensekey() const;
  private:
  bool _internal_has_grouplicensekey() const;
  public:
  void clear_grouplicensekey();
  const ::playapi::proto::finsky::GroupLicenseKey& grouplicensekey() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::GroupLicenseKey* release_grouplicensekey();
  ::playapi::proto::finsky::GroupLicenseKey* mutable_grouplicensekey();
  void set_allocated_grouplicensekey(::playapi::proto::finsky::GroupLicenseKey* grouplicensekey);
  private:
  const ::playapi::proto::finsky::GroupLicenseKey& _internal_grouplicensekey() const;
  ::playapi::proto::finsky::GroupLicenseKey* _internal_mutable_grouplicensekey();
  public:
  void unsafe_arena_set_allocated_grouplicensekey(
      ::playapi::proto::finsky::GroupLicenseKey* grouplicensekey);
  ::playapi::proto::finsky::GroupLicenseKey* unsafe_arena_release_grouplicensekey();

  // optional fixed64 gaiaGroupId = 2;
  bool has_gaiagroupid() const;
  private:
  bool _internal_has_gaiagroupid() const;
  public:
  void clear_gaiagroupid();
  uint64_t gaiagroupid() const;
  void set_gaiagroupid(uint64_t value);
  private:
  uint64_t _internal_gaiagroupid() const;
  void _internal_set_gaiagroupid(uint64_t value);
  public:

  // optional int32 licensedOfferType = 1;
  bool has_licensedoffertype() const;
  private:
  bool _internal_has_licensedoffertype() const;
  public:
  void clear_licensedoffertype();
  int32_t licensedoffertype() const;
  void set_licensedoffertype(int32_t value);
  private:
  int32_t _internal_licensedoffertype() const;
  void _internal_set_licensedoffertype(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.GroupLicenseInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::playapi::proto::finsky::GroupLicenseKey* grouplicensekey_;
    uint64_t gaiagroupid_;
    int32_t licensedoffertype_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class LicenseTerms final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.LicenseTerms) */ {
 public:
  inline LicenseTerms() : LicenseTerms(nullptr) {}
  ~LicenseTerms() override;
  explicit PROTOBUF_CONSTEXPR LicenseTerms(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LicenseTerms(const LicenseTerms& from);
  LicenseTerms(LicenseTerms&& from) noexcept
    : LicenseTerms() {
    *this = ::std::move(from);
  }

  inline LicenseTerms& operator=(const LicenseTerms& from) {
    CopyFrom(from);
    return *this;
  }
  inline LicenseTerms& operator=(LicenseTerms&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LicenseTerms& default_instance() {
    return *internal_default_instance();
  }
  static inline const LicenseTerms* internal_default_instance() {
    return reinterpret_cast<const LicenseTerms*>(
               &_LicenseTerms_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(LicenseTerms& a, LicenseTerms& b) {
    a.Swap(&b);
  }
  inline void Swap(LicenseTerms* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LicenseTerms* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LicenseTerms* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LicenseTerms>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LicenseTerms& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LicenseTerms& from) {
    LicenseTerms::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LicenseTerms* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.LicenseTerms";
  }
  protected:
  explicit LicenseTerms(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupLicenseKeyFieldNumber = 1,
  };
  // optional .playapi.proto.finsky.GroupLicenseKey groupLicenseKey = 1;
  bool has_grouplicensekey() const;
  private:
  bool _internal_has_grouplicensekey() const;
  public:
  void clear_grouplicensekey();
  const ::playapi::proto::finsky::GroupLicenseKey& grouplicensekey() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::GroupLicenseKey* release_grouplicensekey();
  ::playapi::proto::finsky::GroupLicenseKey* mutable_grouplicensekey();
  void set_allocated_grouplicensekey(::playapi::proto::finsky::GroupLicenseKey* grouplicensekey);
  private:
  const ::playapi::proto::finsky::GroupLicenseKey& _internal_grouplicensekey() const;
  ::playapi::proto::finsky::GroupLicenseKey* _internal_mutable_grouplicensekey();
  public:
  void unsafe_arena_set_allocated_grouplicensekey(
      ::playapi::proto::finsky::GroupLicenseKey* grouplicensekey);
  ::playapi::proto::finsky::GroupLicenseKey* unsafe_arena_release_grouplicensekey();

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.LicenseTerms)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::playapi::proto::finsky::GroupLicenseKey* grouplicensekey_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class LicensedDocumentInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.LicensedDocumentInfo) */ {
 public:
  inline LicensedDocumentInfo() : LicensedDocumentInfo(nullptr) {}
  ~LicensedDocumentInfo() override;
  explicit PROTOBUF_CONSTEXPR LicensedDocumentInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LicensedDocumentInfo(const LicensedDocumentInfo& from);
  LicensedDocumentInfo(LicensedDocumentInfo&& from) noexcept
    : LicensedDocumentInfo() {
    *this = ::std::move(from);
  }

  inline LicensedDocumentInfo& operator=(const LicensedDocumentInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline LicensedDocumentInfo& operator=(LicensedDocumentInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LicensedDocumentInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const LicensedDocumentInfo* internal_default_instance() {
    return reinterpret_cast<const LicensedDocumentInfo*>(
               &_LicensedDocumentInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(LicensedDocumentInfo& a, LicensedDocumentInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(LicensedDocumentInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LicensedDocumentInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LicensedDocumentInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LicensedDocumentInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LicensedDocumentInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LicensedDocumentInfo& from) {
    LicensedDocumentInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LicensedDocumentInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.LicensedDocumentInfo";
  }
  protected:
  explicit LicensedDocumentInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGaiaGroupIdFieldNumber = 1,
    kGroupLicenseCheckoutOrderIdFieldNumber = 2,
    kDEPRECATEDAssignmentIdFieldNumber = 5,
    kGroupLicenseKeyFieldNumber = 3,
    kAssignedByGaiaIdFieldNumber = 4,
  };
  // repeated fixed64 gaiaGroupId = 1;
  int gaiagroupid_size() const;
  private:
  int _internal_gaiagroupid_size() const;
  public:
  void clear_gaiagroupid();
  private:
  uint64_t _internal_gaiagroupid(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_gaiagroupid() const;
  void _internal_add_gaiagroupid(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_gaiagroupid();
  public:
  uint64_t gaiagroupid(int index) const;
  void set_gaiagroupid(int index, uint64_t value);
  void add_gaiagroupid(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      gaiagroupid() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_gaiagroupid();

  // optional string groupLicenseCheckoutOrderId = 2;
  bool has_grouplicensecheckoutorderid() const;
  private:
  bool _internal_has_grouplicensecheckoutorderid() const;
  public:
  void clear_grouplicensecheckoutorderid();
  const std::string& grouplicensecheckoutorderid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_grouplicensecheckoutorderid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_grouplicensecheckoutorderid();
  PROTOBUF_NODISCARD std::string* release_grouplicensecheckoutorderid();
  void set_allocated_grouplicensecheckoutorderid(std::string* grouplicensecheckoutorderid);
  private:
  const std::string& _internal_grouplicensecheckoutorderid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_grouplicensecheckoutorderid(const std::string& value);
  std::string* _internal_mutable_grouplicensecheckoutorderid();
  public:

  // optional string DEPRECATEDAssignmentId = 5;
  bool has_deprecatedassignmentid() const;
  private:
  bool _internal_has_deprecatedassignmentid() const;
  public:
  void clear_deprecatedassignmentid();
  const std::string& deprecatedassignmentid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_deprecatedassignmentid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_deprecatedassignmentid();
  PROTOBUF_NODISCARD std::string* release_deprecatedassignmentid();
  void set_allocated_deprecatedassignmentid(std::string* deprecatedassignmentid);
  private:
  const std::string& _internal_deprecatedassignmentid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deprecatedassignmentid(const std::string& value);
  std::string* _internal_mutable_deprecatedassignmentid();
  public:

  // optional .playapi.proto.finsky.GroupLicenseKey groupLicenseKey = 3;
  bool has_grouplicensekey() const;
  private:
  bool _internal_has_grouplicensekey() const;
  public:
  void clear_grouplicensekey();
  const ::playapi::proto::finsky::GroupLicenseKey& grouplicensekey() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::GroupLicenseKey* release_grouplicensekey();
  ::playapi::proto::finsky::GroupLicenseKey* mutable_grouplicensekey();
  void set_allocated_grouplicensekey(::playapi::proto::finsky::GroupLicenseKey* grouplicensekey);
  private:
  const ::playapi::proto::finsky::GroupLicenseKey& _internal_grouplicensekey() const;
  ::playapi::proto::finsky::GroupLicenseKey* _internal_mutable_grouplicensekey();
  public:
  void unsafe_arena_set_allocated_grouplicensekey(
      ::playapi::proto::finsky::GroupLicenseKey* grouplicensekey);
  ::playapi::proto::finsky::GroupLicenseKey* unsafe_arena_release_grouplicensekey();

  // optional fixed64 assignedByGaiaId = 4;
  bool has_assignedbygaiaid() const;
  private:
  bool _internal_has_assignedbygaiaid() const;
  public:
  void clear_assignedbygaiaid();
  uint64_t assignedbygaiaid() const;
  void set_assignedbygaiaid(uint64_t value);
  private:
  uint64_t _internal_assignedbygaiaid() const;
  void _internal_set_assignedbygaiaid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.LicensedDocumentInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > gaiagroupid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr grouplicensecheckoutorderid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deprecatedassignmentid_;
    ::playapi::proto::finsky::GroupLicenseKey* grouplicensekey_;
    uint64_t assignedbygaiaid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class RedemptionRecordKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.RedemptionRecordKey) */ {
 public:
  inline RedemptionRecordKey() : RedemptionRecordKey(nullptr) {}
  ~RedemptionRecordKey() override;
  explicit PROTOBUF_CONSTEXPR RedemptionRecordKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RedemptionRecordKey(const RedemptionRecordKey& from);
  RedemptionRecordKey(RedemptionRecordKey&& from) noexcept
    : RedemptionRecordKey() {
    *this = ::std::move(from);
  }

  inline RedemptionRecordKey& operator=(const RedemptionRecordKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline RedemptionRecordKey& operator=(RedemptionRecordKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RedemptionRecordKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const RedemptionRecordKey* internal_default_instance() {
    return reinterpret_cast<const RedemptionRecordKey*>(
               &_RedemptionRecordKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(RedemptionRecordKey& a, RedemptionRecordKey& b) {
    a.Swap(&b);
  }
  inline void Swap(RedemptionRecordKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RedemptionRecordKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RedemptionRecordKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RedemptionRecordKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RedemptionRecordKey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RedemptionRecordKey& from) {
    RedemptionRecordKey::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RedemptionRecordKey* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.RedemptionRecordKey";
  }
  protected:
  explicit RedemptionRecordKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublisherIdFieldNumber = 1,
    kCampaignIdFieldNumber = 2,
    kCodeGroupIdFieldNumber = 3,
    kRecordIdFieldNumber = 4,
    kTypeFieldNumber = 5,
  };
  // optional int64 publisherId = 1;
  bool has_publisherid() const;
  private:
  bool _internal_has_publisherid() const;
  public:
  void clear_publisherid();
  int64_t publisherid() const;
  void set_publisherid(int64_t value);
  private:
  int64_t _internal_publisherid() const;
  void _internal_set_publisherid(int64_t value);
  public:

  // optional int64 campaignId = 2;
  bool has_campaignid() const;
  private:
  bool _internal_has_campaignid() const;
  public:
  void clear_campaignid();
  int64_t campaignid() const;
  void set_campaignid(int64_t value);
  private:
  int64_t _internal_campaignid() const;
  void _internal_set_campaignid(int64_t value);
  public:

  // optional int64 codeGroupId = 3;
  bool has_codegroupid() const;
  private:
  bool _internal_has_codegroupid() const;
  public:
  void clear_codegroupid();
  int64_t codegroupid() const;
  void set_codegroupid(int64_t value);
  private:
  int64_t _internal_codegroupid() const;
  void _internal_set_codegroupid(int64_t value);
  public:

  // optional int64 recordId = 4;
  bool has_recordid() const;
  private:
  bool _internal_has_recordid() const;
  public:
  void clear_recordid();
  int64_t recordid() const;
  void set_recordid(int64_t value);
  private:
  int64_t _internal_recordid() const;
  void _internal_set_recordid(int64_t value);
  public:

  // optional int32 type = 5;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  int32_t type() const;
  void set_type(int32_t value);
  private:
  int32_t _internal_type() const;
  void _internal_set_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.RedemptionRecordKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t publisherid_;
    int64_t campaignid_;
    int64_t codegroupid_;
    int64_t recordid_;
    int32_t type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class VoucherId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.VoucherId) */ {
 public:
  inline VoucherId() : VoucherId(nullptr) {}
  ~VoucherId() override;
  explicit PROTOBUF_CONSTEXPR VoucherId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VoucherId(const VoucherId& from);
  VoucherId(VoucherId&& from) noexcept
    : VoucherId() {
    *this = ::std::move(from);
  }

  inline VoucherId& operator=(const VoucherId& from) {
    CopyFrom(from);
    return *this;
  }
  inline VoucherId& operator=(VoucherId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VoucherId& default_instance() {
    return *internal_default_instance();
  }
  static inline const VoucherId* internal_default_instance() {
    return reinterpret_cast<const VoucherId*>(
               &_VoucherId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(VoucherId& a, VoucherId& b) {
    a.Swap(&b);
  }
  inline void Swap(VoucherId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VoucherId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VoucherId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VoucherId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VoucherId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VoucherId& from) {
    VoucherId::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VoucherId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.VoucherId";
  }
  protected:
  explicit VoucherId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVoucherDocidFieldNumber = 1,
    kKeyFieldNumber = 2,
  };
  // optional .playapi.proto.finsky.Docid voucherDocid = 1;
  bool has_voucherdocid() const;
  private:
  bool _internal_has_voucherdocid() const;
  public:
  void clear_voucherdocid();
  const ::playapi::proto::finsky::Docid& voucherdocid() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::Docid* release_voucherdocid();
  ::playapi::proto::finsky::Docid* mutable_voucherdocid();
  void set_allocated_voucherdocid(::playapi::proto::finsky::Docid* voucherdocid);
  private:
  const ::playapi::proto::finsky::Docid& _internal_voucherdocid() const;
  ::playapi::proto::finsky::Docid* _internal_mutable_voucherdocid();
  public:
  void unsafe_arena_set_allocated_voucherdocid(
      ::playapi::proto::finsky::Docid* voucherdocid);
  ::playapi::proto::finsky::Docid* unsafe_arena_release_voucherdocid();

  // optional .playapi.proto.finsky.RedemptionRecordKey key = 2;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const ::playapi::proto::finsky::RedemptionRecordKey& key() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::RedemptionRecordKey* release_key();
  ::playapi::proto::finsky::RedemptionRecordKey* mutable_key();
  void set_allocated_key(::playapi::proto::finsky::RedemptionRecordKey* key);
  private:
  const ::playapi::proto::finsky::RedemptionRecordKey& _internal_key() const;
  ::playapi::proto::finsky::RedemptionRecordKey* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::playapi::proto::finsky::RedemptionRecordKey* key);
  ::playapi::proto::finsky::RedemptionRecordKey* unsafe_arena_release_key();

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.VoucherId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::playapi::proto::finsky::Docid* voucherdocid_;
    ::playapi::proto::finsky::RedemptionRecordKey* key_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class VoucherOfferTerms final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.VoucherOfferTerms) */ {
 public:
  inline VoucherOfferTerms() : VoucherOfferTerms(nullptr) {}
  ~VoucherOfferTerms() override;
  explicit PROTOBUF_CONSTEXPR VoucherOfferTerms(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VoucherOfferTerms(const VoucherOfferTerms& from);
  VoucherOfferTerms(VoucherOfferTerms&& from) noexcept
    : VoucherOfferTerms() {
    *this = ::std::move(from);
  }

  inline VoucherOfferTerms& operator=(const VoucherOfferTerms& from) {
    CopyFrom(from);
    return *this;
  }
  inline VoucherOfferTerms& operator=(VoucherOfferTerms&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VoucherOfferTerms& default_instance() {
    return *internal_default_instance();
  }
  static inline const VoucherOfferTerms* internal_default_instance() {
    return reinterpret_cast<const VoucherOfferTerms*>(
               &_VoucherOfferTerms_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(VoucherOfferTerms& a, VoucherOfferTerms& b) {
    a.Swap(&b);
  }
  inline void Swap(VoucherOfferTerms* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VoucherOfferTerms* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VoucherOfferTerms* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VoucherOfferTerms>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VoucherOfferTerms& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VoucherOfferTerms& from) {
    VoucherOfferTerms::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VoucherOfferTerms* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.VoucherOfferTerms";
  }
  protected:
  explicit VoucherOfferTerms(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVoucherDocidFieldNumber = 1,
    kVoucherFormattedAmountFieldNumber = 3,
    kVoucherPriceMicrosFieldNumber = 2,
  };
  // repeated .playapi.proto.finsky.Docid voucherDocid = 1;
  int voucherdocid_size() const;
  private:
  int _internal_voucherdocid_size() const;
  public:
  void clear_voucherdocid();
  ::playapi::proto::finsky::Docid* mutable_voucherdocid(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Docid >*
      mutable_voucherdocid();
  private:
  const ::playapi::proto::finsky::Docid& _internal_voucherdocid(int index) const;
  ::playapi::proto::finsky::Docid* _internal_add_voucherdocid();
  public:
  const ::playapi::proto::finsky::Docid& voucherdocid(int index) const;
  ::playapi::proto::finsky::Docid* add_voucherdocid();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Docid >&
      voucherdocid() const;

  // optional string voucherFormattedAmount = 3;
  bool has_voucherformattedamount() const;
  private:
  bool _internal_has_voucherformattedamount() const;
  public:
  void clear_voucherformattedamount();
  const std::string& voucherformattedamount() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_voucherformattedamount(ArgT0&& arg0, ArgT... args);
  std::string* mutable_voucherformattedamount();
  PROTOBUF_NODISCARD std::string* release_voucherformattedamount();
  void set_allocated_voucherformattedamount(std::string* voucherformattedamount);
  private:
  const std::string& _internal_voucherformattedamount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_voucherformattedamount(const std::string& value);
  std::string* _internal_mutable_voucherformattedamount();
  public:

  // optional int64 voucherPriceMicros = 2;
  bool has_voucherpricemicros() const;
  private:
  bool _internal_has_voucherpricemicros() const;
  public:
  void clear_voucherpricemicros();
  int64_t voucherpricemicros() const;
  void set_voucherpricemicros(int64_t value);
  private:
  int64_t _internal_voucherpricemicros() const;
  void _internal_set_voucherpricemicros(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.VoucherOfferTerms)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Docid > voucherdocid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr voucherformattedamount_;
    int64_t voucherpricemicros_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class LibraryVoucher final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.LibraryVoucher) */ {
 public:
  inline LibraryVoucher() : LibraryVoucher(nullptr) {}
  ~LibraryVoucher() override;
  explicit PROTOBUF_CONSTEXPR LibraryVoucher(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LibraryVoucher(const LibraryVoucher& from);
  LibraryVoucher(LibraryVoucher&& from) noexcept
    : LibraryVoucher() {
    *this = ::std::move(from);
  }

  inline LibraryVoucher& operator=(const LibraryVoucher& from) {
    CopyFrom(from);
    return *this;
  }
  inline LibraryVoucher& operator=(LibraryVoucher&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LibraryVoucher& default_instance() {
    return *internal_default_instance();
  }
  static inline const LibraryVoucher* internal_default_instance() {
    return reinterpret_cast<const LibraryVoucher*>(
               &_LibraryVoucher_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(LibraryVoucher& a, LibraryVoucher& b) {
    a.Swap(&b);
  }
  inline void Swap(LibraryVoucher* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LibraryVoucher* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LibraryVoucher* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LibraryVoucher>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LibraryVoucher& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LibraryVoucher& from) {
    LibraryVoucher::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LibraryVoucher* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.LibraryVoucher";
  }
  protected:
  explicit LibraryVoucher(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVoucherIdFieldNumber = 1,
  };
  // optional .playapi.proto.finsky.VoucherId voucherId = 1;
  bool has_voucherid() const;
  private:
  bool _internal_has_voucherid() const;
  public:
  void clear_voucherid();
  const ::playapi::proto::finsky::VoucherId& voucherid() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::VoucherId* release_voucherid();
  ::playapi::proto::finsky::VoucherId* mutable_voucherid();
  void set_allocated_voucherid(::playapi::proto::finsky::VoucherId* voucherid);
  private:
  const ::playapi::proto::finsky::VoucherId& _internal_voucherid() const;
  ::playapi::proto::finsky::VoucherId* _internal_mutable_voucherid();
  public:
  void unsafe_arena_set_allocated_voucherid(
      ::playapi::proto::finsky::VoucherId* voucherid);
  ::playapi::proto::finsky::VoucherId* unsafe_arena_release_voucherid();

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.LibraryVoucher)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::playapi::proto::finsky::VoucherId* voucherid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class OwnershipInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.OwnershipInfo) */ {
 public:
  inline OwnershipInfo() : OwnershipInfo(nullptr) {}
  ~OwnershipInfo() override;
  explicit PROTOBUF_CONSTEXPR OwnershipInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OwnershipInfo(const OwnershipInfo& from);
  OwnershipInfo(OwnershipInfo&& from) noexcept
    : OwnershipInfo() {
    *this = ::std::move(from);
  }

  inline OwnershipInfo& operator=(const OwnershipInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline OwnershipInfo& operator=(OwnershipInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OwnershipInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const OwnershipInfo* internal_default_instance() {
    return reinterpret_cast<const OwnershipInfo*>(
               &_OwnershipInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(OwnershipInfo& a, OwnershipInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(OwnershipInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OwnershipInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OwnershipInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OwnershipInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OwnershipInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OwnershipInfo& from) {
    OwnershipInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OwnershipInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.OwnershipInfo";
  }
  protected:
  explicit OwnershipInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeveloperPurchaseInfoFieldNumber = 6,
    kRentalTermsFieldNumber = 9,
    kGroupLicenseInfoFieldNumber = 10,
    kLicensedDocumentInfoFieldNumber = 11,
    kLibraryVoucherFieldNumber = 15,
    kBundleDocidFieldNumber = 16,
    kInitiationTimestampMsecFieldNumber = 1,
    kValidUntilTimestampMsecFieldNumber = 2,
    kRefundTimeoutTimestampMsecFieldNumber = 4,
    kPostDeliveryRefundWindowMsecFieldNumber = 5,
    kAutoRenewingFieldNumber = 3,
    kPreorderedFieldNumber = 7,
    kHiddenFieldNumber = 8,
    kBonusFieldNumber = 17,
    kQuantityFieldNumber = 12,
    kLibraryExpirationTimestampMsecFieldNumber = 14,
    kStoredValidUntilTimestampMsecFieldNumber = 18,
  };
  // optional .playapi.proto.finsky.SignedData developerPurchaseInfo = 6;
  bool has_developerpurchaseinfo() const;
  private:
  bool _internal_has_developerpurchaseinfo() const;
  public:
  void clear_developerpurchaseinfo();
  const ::playapi::proto::finsky::SignedData& developerpurchaseinfo() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::SignedData* release_developerpurchaseinfo();
  ::playapi::proto::finsky::SignedData* mutable_developerpurchaseinfo();
  void set_allocated_developerpurchaseinfo(::playapi::proto::finsky::SignedData* developerpurchaseinfo);
  private:
  const ::playapi::proto::finsky::SignedData& _internal_developerpurchaseinfo() const;
  ::playapi::proto::finsky::SignedData* _internal_mutable_developerpurchaseinfo();
  public:
  void unsafe_arena_set_allocated_developerpurchaseinfo(
      ::playapi::proto::finsky::SignedData* developerpurchaseinfo);
  ::playapi::proto::finsky::SignedData* unsafe_arena_release_developerpurchaseinfo();

  // optional .playapi.proto.finsky.RentalTerms rentalTerms = 9;
  bool has_rentalterms() const;
  private:
  bool _internal_has_rentalterms() const;
  public:
  void clear_rentalterms();
  const ::playapi::proto::finsky::RentalTerms& rentalterms() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::RentalTerms* release_rentalterms();
  ::playapi::proto::finsky::RentalTerms* mutable_rentalterms();
  void set_allocated_rentalterms(::playapi::proto::finsky::RentalTerms* rentalterms);
  private:
  const ::playapi::proto::finsky::RentalTerms& _internal_rentalterms() const;
  ::playapi::proto::finsky::RentalTerms* _internal_mutable_rentalterms();
  public:
  void unsafe_arena_set_allocated_rentalterms(
      ::playapi::proto::finsky::RentalTerms* rentalterms);
  ::playapi::proto::finsky::RentalTerms* unsafe_arena_release_rentalterms();

  // optional .playapi.proto.finsky.GroupLicenseInfo groupLicenseInfo = 10;
  bool has_grouplicenseinfo() const;
  private:
  bool _internal_has_grouplicenseinfo() const;
  public:
  void clear_grouplicenseinfo();
  const ::playapi::proto::finsky::GroupLicenseInfo& grouplicenseinfo() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::GroupLicenseInfo* release_grouplicenseinfo();
  ::playapi::proto::finsky::GroupLicenseInfo* mutable_grouplicenseinfo();
  void set_allocated_grouplicenseinfo(::playapi::proto::finsky::GroupLicenseInfo* grouplicenseinfo);
  private:
  const ::playapi::proto::finsky::GroupLicenseInfo& _internal_grouplicenseinfo() const;
  ::playapi::proto::finsky::GroupLicenseInfo* _internal_mutable_grouplicenseinfo();
  public:
  void unsafe_arena_set_allocated_grouplicenseinfo(
      ::playapi::proto::finsky::GroupLicenseInfo* grouplicenseinfo);
  ::playapi::proto::finsky::GroupLicenseInfo* unsafe_arena_release_grouplicenseinfo();

  // optional .playapi.proto.finsky.LicensedDocumentInfo licensedDocumentInfo = 11;
  bool has_licenseddocumentinfo() const;
  private:
  bool _internal_has_licenseddocumentinfo() const;
  public:
  void clear_licenseddocumentinfo();
  const ::playapi::proto::finsky::LicensedDocumentInfo& licenseddocumentinfo() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::LicensedDocumentInfo* release_licenseddocumentinfo();
  ::playapi::proto::finsky::LicensedDocumentInfo* mutable_licenseddocumentinfo();
  void set_allocated_licenseddocumentinfo(::playapi::proto::finsky::LicensedDocumentInfo* licenseddocumentinfo);
  private:
  const ::playapi::proto::finsky::LicensedDocumentInfo& _internal_licenseddocumentinfo() const;
  ::playapi::proto::finsky::LicensedDocumentInfo* _internal_mutable_licenseddocumentinfo();
  public:
  void unsafe_arena_set_allocated_licenseddocumentinfo(
      ::playapi::proto::finsky::LicensedDocumentInfo* licenseddocumentinfo);
  ::playapi::proto::finsky::LicensedDocumentInfo* unsafe_arena_release_licenseddocumentinfo();

  // optional .playapi.proto.finsky.LibraryVoucher libraryVoucher = 15;
  bool has_libraryvoucher() const;
  private:
  bool _internal_has_libraryvoucher() const;
  public:
  void clear_libraryvoucher();
  const ::playapi::proto::finsky::LibraryVoucher& libraryvoucher() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::LibraryVoucher* release_libraryvoucher();
  ::playapi::proto::finsky::LibraryVoucher* mutable_libraryvoucher();
  void set_allocated_libraryvoucher(::playapi::proto::finsky::LibraryVoucher* libraryvoucher);
  private:
  const ::playapi::proto::finsky::LibraryVoucher& _internal_libraryvoucher() const;
  ::playapi::proto::finsky::LibraryVoucher* _internal_mutable_libraryvoucher();
  public:
  void unsafe_arena_set_allocated_libraryvoucher(
      ::playapi::proto::finsky::LibraryVoucher* libraryvoucher);
  ::playapi::proto::finsky::LibraryVoucher* unsafe_arena_release_libraryvoucher();

  // optional .playapi.proto.finsky.Docid bundleDocid = 16;
  bool has_bundledocid() const;
  private:
  bool _internal_has_bundledocid() const;
  public:
  void clear_bundledocid();
  const ::playapi::proto::finsky::Docid& bundledocid() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::Docid* release_bundledocid();
  ::playapi::proto::finsky::Docid* mutable_bundledocid();
  void set_allocated_bundledocid(::playapi::proto::finsky::Docid* bundledocid);
  private:
  const ::playapi::proto::finsky::Docid& _internal_bundledocid() const;
  ::playapi::proto::finsky::Docid* _internal_mutable_bundledocid();
  public:
  void unsafe_arena_set_allocated_bundledocid(
      ::playapi::proto::finsky::Docid* bundledocid);
  ::playapi::proto::finsky::Docid* unsafe_arena_release_bundledocid();

  // optional int64 initiationTimestampMsec = 1;
  bool has_initiationtimestampmsec() const;
  private:
  bool _internal_has_initiationtimestampmsec() const;
  public:
  void clear_initiationtimestampmsec();
  int64_t initiationtimestampmsec() const;
  void set_initiationtimestampmsec(int64_t value);
  private:
  int64_t _internal_initiationtimestampmsec() const;
  void _internal_set_initiationtimestampmsec(int64_t value);
  public:

  // optional int64 validUntilTimestampMsec = 2;
  bool has_validuntiltimestampmsec() const;
  private:
  bool _internal_has_validuntiltimestampmsec() const;
  public:
  void clear_validuntiltimestampmsec();
  int64_t validuntiltimestampmsec() const;
  void set_validuntiltimestampmsec(int64_t value);
  private:
  int64_t _internal_validuntiltimestampmsec() const;
  void _internal_set_validuntiltimestampmsec(int64_t value);
  public:

  // optional int64 refundTimeoutTimestampMsec = 4;
  bool has_refundtimeouttimestampmsec() const;
  private:
  bool _internal_has_refundtimeouttimestampmsec() const;
  public:
  void clear_refundtimeouttimestampmsec();
  int64_t refundtimeouttimestampmsec() const;
  void set_refundtimeouttimestampmsec(int64_t value);
  private:
  int64_t _internal_refundtimeouttimestampmsec() const;
  void _internal_set_refundtimeouttimestampmsec(int64_t value);
  public:

  // optional int64 postDeliveryRefundWindowMsec = 5;
  bool has_postdeliveryrefundwindowmsec() const;
  private:
  bool _internal_has_postdeliveryrefundwindowmsec() const;
  public:
  void clear_postdeliveryrefundwindowmsec();
  int64_t postdeliveryrefundwindowmsec() const;
  void set_postdeliveryrefundwindowmsec(int64_t value);
  private:
  int64_t _internal_postdeliveryrefundwindowmsec() const;
  void _internal_set_postdeliveryrefundwindowmsec(int64_t value);
  public:

  // optional bool autoRenewing = 3;
  bool has_autorenewing() const;
  private:
  bool _internal_has_autorenewing() const;
  public:
  void clear_autorenewing();
  bool autorenewing() const;
  void set_autorenewing(bool value);
  private:
  bool _internal_autorenewing() const;
  void _internal_set_autorenewing(bool value);
  public:

  // optional bool preordered = 7;
  bool has_preordered() const;
  private:
  bool _internal_has_preordered() const;
  public:
  void clear_preordered();
  bool preordered() const;
  void set_preordered(bool value);
  private:
  bool _internal_preordered() const;
  void _internal_set_preordered(bool value);
  public:

  // optional bool hidden = 8;
  bool has_hidden() const;
  private:
  bool _internal_has_hidden() const;
  public:
  void clear_hidden();
  bool hidden() const;
  void set_hidden(bool value);
  private:
  bool _internal_hidden() const;
  void _internal_set_hidden(bool value);
  public:

  // optional bool bonus = 17;
  bool has_bonus() const;
  private:
  bool _internal_has_bonus() const;
  public:
  void clear_bonus();
  bool bonus() const;
  void set_bonus(bool value);
  private:
  bool _internal_bonus() const;
  void _internal_set_bonus(bool value);
  public:

  // optional int32 quantity = 12;
  bool has_quantity() const;
  private:
  bool _internal_has_quantity() const;
  public:
  void clear_quantity();
  int32_t quantity() const;
  void set_quantity(int32_t value);
  private:
  int32_t _internal_quantity() const;
  void _internal_set_quantity(int32_t value);
  public:

  // optional int64 libraryExpirationTimestampMsec = 14;
  bool has_libraryexpirationtimestampmsec() const;
  private:
  bool _internal_has_libraryexpirationtimestampmsec() const;
  public:
  void clear_libraryexpirationtimestampmsec();
  int64_t libraryexpirationtimestampmsec() const;
  void set_libraryexpirationtimestampmsec(int64_t value);
  private:
  int64_t _internal_libraryexpirationtimestampmsec() const;
  void _internal_set_libraryexpirationtimestampmsec(int64_t value);
  public:

  // optional int64 storedValidUntilTimestampMsec = 18;
  bool has_storedvaliduntiltimestampmsec() const;
  private:
  bool _internal_has_storedvaliduntiltimestampmsec() const;
  public:
  void clear_storedvaliduntiltimestampmsec();
  int64_t storedvaliduntiltimestampmsec() const;
  void set_storedvaliduntiltimestampmsec(int64_t value);
  private:
  int64_t _internal_storedvaliduntiltimestampmsec() const;
  void _internal_set_storedvaliduntiltimestampmsec(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.OwnershipInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::playapi::proto::finsky::SignedData* developerpurchaseinfo_;
    ::playapi::proto::finsky::RentalTerms* rentalterms_;
    ::playapi::proto::finsky::GroupLicenseInfo* grouplicenseinfo_;
    ::playapi::proto::finsky::LicensedDocumentInfo* licenseddocumentinfo_;
    ::playapi::proto::finsky::LibraryVoucher* libraryvoucher_;
    ::playapi::proto::finsky::Docid* bundledocid_;
    int64_t initiationtimestampmsec_;
    int64_t validuntiltimestampmsec_;
    int64_t refundtimeouttimestampmsec_;
    int64_t postdeliveryrefundwindowmsec_;
    bool autorenewing_;
    bool preordered_;
    bool hidden_;
    bool bonus_;
    int32_t quantity_;
    int64_t libraryexpirationtimestampmsec_;
    int64_t storedvaliduntiltimestampmsec_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class Image_Dimension final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.Image.Dimension) */ {
 public:
  inline Image_Dimension() : Image_Dimension(nullptr) {}
  ~Image_Dimension() override;
  explicit PROTOBUF_CONSTEXPR Image_Dimension(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Image_Dimension(const Image_Dimension& from);
  Image_Dimension(Image_Dimension&& from) noexcept
    : Image_Dimension() {
    *this = ::std::move(from);
  }

  inline Image_Dimension& operator=(const Image_Dimension& from) {
    CopyFrom(from);
    return *this;
  }
  inline Image_Dimension& operator=(Image_Dimension&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Image_Dimension& default_instance() {
    return *internal_default_instance();
  }
  static inline const Image_Dimension* internal_default_instance() {
    return reinterpret_cast<const Image_Dimension*>(
               &_Image_Dimension_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(Image_Dimension& a, Image_Dimension& b) {
    a.Swap(&b);
  }
  inline void Swap(Image_Dimension* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Image_Dimension* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Image_Dimension* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Image_Dimension>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Image_Dimension& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Image_Dimension& from) {
    Image_Dimension::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Image_Dimension* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.Image.Dimension";
  }
  protected:
  explicit Image_Dimension(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWidthFieldNumber = 3,
    kHeightFieldNumber = 4,
    kAspectRatioFieldNumber = 18,
  };
  // optional int32 width = 3;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  int32_t width() const;
  void set_width(int32_t value);
  private:
  int32_t _internal_width() const;
  void _internal_set_width(int32_t value);
  public:

  // optional int32 height = 4;
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  int32_t height() const;
  void set_height(int32_t value);
  private:
  int32_t _internal_height() const;
  void _internal_set_height(int32_t value);
  public:

  // optional int32 aspectRatio = 18;
  bool has_aspectratio() const;
  private:
  bool _internal_has_aspectratio() const;
  public:
  void clear_aspectratio();
  int32_t aspectratio() const;
  void set_aspectratio(int32_t value);
  private:
  int32_t _internal_aspectratio() const;
  void _internal_set_aspectratio(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.Image.Dimension)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t width_;
    int32_t height_;
    int32_t aspectratio_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class Image_Citation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.Image.Citation) */ {
 public:
  inline Image_Citation() : Image_Citation(nullptr) {}
  ~Image_Citation() override;
  explicit PROTOBUF_CONSTEXPR Image_Citation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Image_Citation(const Image_Citation& from);
  Image_Citation(Image_Citation&& from) noexcept
    : Image_Citation() {
    *this = ::std::move(from);
  }

  inline Image_Citation& operator=(const Image_Citation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Image_Citation& operator=(Image_Citation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Image_Citation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Image_Citation* internal_default_instance() {
    return reinterpret_cast<const Image_Citation*>(
               &_Image_Citation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(Image_Citation& a, Image_Citation& b) {
    a.Swap(&b);
  }
  inline void Swap(Image_Citation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Image_Citation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Image_Citation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Image_Citation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Image_Citation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Image_Citation& from) {
    Image_Citation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Image_Citation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.Image.Citation";
  }
  protected:
  explicit Image_Citation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleLocalizedFieldNumber = 11,
    kUrlFieldNumber = 12,
  };
  // optional string titleLocalized = 11;
  bool has_titlelocalized() const;
  private:
  bool _internal_has_titlelocalized() const;
  public:
  void clear_titlelocalized();
  const std::string& titlelocalized() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_titlelocalized(ArgT0&& arg0, ArgT... args);
  std::string* mutable_titlelocalized();
  PROTOBUF_NODISCARD std::string* release_titlelocalized();
  void set_allocated_titlelocalized(std::string* titlelocalized);
  private:
  const std::string& _internal_titlelocalized() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_titlelocalized(const std::string& value);
  std::string* _internal_mutable_titlelocalized();
  public:

  // optional string url = 12;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.Image.Citation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr titlelocalized_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class Image final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.Image) */ {
 public:
  inline Image() : Image(nullptr) {}
  ~Image() override;
  explicit PROTOBUF_CONSTEXPR Image(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Image(const Image& from);
  Image(Image&& from) noexcept
    : Image() {
    *this = ::std::move(from);
  }

  inline Image& operator=(const Image& from) {
    CopyFrom(from);
    return *this;
  }
  inline Image& operator=(Image&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Image& default_instance() {
    return *internal_default_instance();
  }
  static inline const Image* internal_default_instance() {
    return reinterpret_cast<const Image*>(
               &_Image_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(Image& a, Image& b) {
    a.Swap(&b);
  }
  inline void Swap(Image* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Image* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Image* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Image>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Image& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Image& from) {
    Image::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Image* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.Image";
  }
  protected:
  explicit Image(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Image_Dimension Dimension;
  typedef Image_Citation Citation;

  // accessors -------------------------------------------------------

  enum : int {
    kImageUrlFieldNumber = 5,
    kAltTextLocalizedFieldNumber = 6,
    kSecureUrlFieldNumber = 7,
    kFillColorRgbFieldNumber = 15,
    kBackgroundColorRgbFieldNumber = 19,
    kDimensionFieldNumber = 2,
    kCitationFieldNumber = 10,
    kAttributionFieldNumber = 17,
    kPaletteFieldNumber = 20,
    kImageTypeFieldNumber = 1,
    kPositionInSequenceFieldNumber = 8,
    kDurationSecondsFieldNumber = 14,
    kSupportsFifeUrlOptionsFieldNumber = 9,
    kAutogenFieldNumber = 16,
    kSupportsFifeMonogramOptionFieldNumber = 22,
    kDeviceClassFieldNumber = 21,
  };
  // optional string imageUrl = 5;
  bool has_imageurl() const;
  private:
  bool _internal_has_imageurl() const;
  public:
  void clear_imageurl();
  const std::string& imageurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_imageurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_imageurl();
  PROTOBUF_NODISCARD std::string* release_imageurl();
  void set_allocated_imageurl(std::string* imageurl);
  private:
  const std::string& _internal_imageurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_imageurl(const std::string& value);
  std::string* _internal_mutable_imageurl();
  public:

  // optional string altTextLocalized = 6;
  bool has_alttextlocalized() const;
  private:
  bool _internal_has_alttextlocalized() const;
  public:
  void clear_alttextlocalized();
  const std::string& alttextlocalized() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_alttextlocalized(ArgT0&& arg0, ArgT... args);
  std::string* mutable_alttextlocalized();
  PROTOBUF_NODISCARD std::string* release_alttextlocalized();
  void set_allocated_alttextlocalized(std::string* alttextlocalized);
  private:
  const std::string& _internal_alttextlocalized() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_alttextlocalized(const std::string& value);
  std::string* _internal_mutable_alttextlocalized();
  public:

  // optional string secureUrl = 7;
  bool has_secureurl() const;
  private:
  bool _internal_has_secureurl() const;
  public:
  void clear_secureurl();
  const std::string& secureurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_secureurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_secureurl();
  PROTOBUF_NODISCARD std::string* release_secureurl();
  void set_allocated_secureurl(std::string* secureurl);
  private:
  const std::string& _internal_secureurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secureurl(const std::string& value);
  std::string* _internal_mutable_secureurl();
  public:

  // optional string fillColorRgb = 15;
  bool has_fillcolorrgb() const;
  private:
  bool _internal_has_fillcolorrgb() const;
  public:
  void clear_fillcolorrgb();
  const std::string& fillcolorrgb() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fillcolorrgb(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fillcolorrgb();
  PROTOBUF_NODISCARD std::string* release_fillcolorrgb();
  void set_allocated_fillcolorrgb(std::string* fillcolorrgb);
  private:
  const std::string& _internal_fillcolorrgb() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fillcolorrgb(const std::string& value);
  std::string* _internal_mutable_fillcolorrgb();
  public:

  // optional string backgroundColorRgb = 19;
  bool has_backgroundcolorrgb() const;
  private:
  bool _internal_has_backgroundcolorrgb() const;
  public:
  void clear_backgroundcolorrgb();
  const std::string& backgroundcolorrgb() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_backgroundcolorrgb(ArgT0&& arg0, ArgT... args);
  std::string* mutable_backgroundcolorrgb();
  PROTOBUF_NODISCARD std::string* release_backgroundcolorrgb();
  void set_allocated_backgroundcolorrgb(std::string* backgroundcolorrgb);
  private:
  const std::string& _internal_backgroundcolorrgb() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_backgroundcolorrgb(const std::string& value);
  std::string* _internal_mutable_backgroundcolorrgb();
  public:

  // optional group Dimension = 2 { ... };
  bool has_dimension() const;
  private:
  bool _internal_has_dimension() const;
  public:
  void clear_dimension();
  const ::playapi::proto::finsky::Image_Dimension& dimension() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::Image_Dimension* release_dimension();
  ::playapi::proto::finsky::Image_Dimension* mutable_dimension();
  void set_allocated_dimension(::playapi::proto::finsky::Image_Dimension* dimension);
  private:
  const ::playapi::proto::finsky::Image_Dimension& _internal_dimension() const;
  ::playapi::proto::finsky::Image_Dimension* _internal_mutable_dimension();
  public:
  void unsafe_arena_set_allocated_dimension(
      ::playapi::proto::finsky::Image_Dimension* dimension);
  ::playapi::proto::finsky::Image_Dimension* unsafe_arena_release_dimension();

  // optional group Citation = 10 { ... };
  bool has_citation() const;
  private:
  bool _internal_has_citation() const;
  public:
  void clear_citation();
  const ::playapi::proto::finsky::Image_Citation& citation() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::Image_Citation* release_citation();
  ::playapi::proto::finsky::Image_Citation* mutable_citation();
  void set_allocated_citation(::playapi::proto::finsky::Image_Citation* citation);
  private:
  const ::playapi::proto::finsky::Image_Citation& _internal_citation() const;
  ::playapi::proto::finsky::Image_Citation* _internal_mutable_citation();
  public:
  void unsafe_arena_set_allocated_citation(
      ::playapi::proto::finsky::Image_Citation* citation);
  ::playapi::proto::finsky::Image_Citation* unsafe_arena_release_citation();

  // optional .playapi.proto.finsky.Attribution attribution = 17;
  bool has_attribution() const;
  private:
  bool _internal_has_attribution() const;
  public:
  void clear_attribution();
  const ::playapi::proto::finsky::Attribution& attribution() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::Attribution* release_attribution();
  ::playapi::proto::finsky::Attribution* mutable_attribution();
  void set_allocated_attribution(::playapi::proto::finsky::Attribution* attribution);
  private:
  const ::playapi::proto::finsky::Attribution& _internal_attribution() const;
  ::playapi::proto::finsky::Attribution* _internal_mutable_attribution();
  public:
  void unsafe_arena_set_allocated_attribution(
      ::playapi::proto::finsky::Attribution* attribution);
  ::playapi::proto::finsky::Attribution* unsafe_arena_release_attribution();

  // optional .playapi.proto.finsky.ImagePalette palette = 20;
  bool has_palette() const;
  private:
  bool _internal_has_palette() const;
  public:
  void clear_palette();
  const ::playapi::proto::finsky::ImagePalette& palette() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::ImagePalette* release_palette();
  ::playapi::proto::finsky::ImagePalette* mutable_palette();
  void set_allocated_palette(::playapi::proto::finsky::ImagePalette* palette);
  private:
  const ::playapi::proto::finsky::ImagePalette& _internal_palette() const;
  ::playapi::proto::finsky::ImagePalette* _internal_mutable_palette();
  public:
  void unsafe_arena_set_allocated_palette(
      ::playapi::proto::finsky::ImagePalette* palette);
  ::playapi::proto::finsky::ImagePalette* unsafe_arena_release_palette();

  // optional int32 imageType = 1;
  bool has_imagetype() const;
  private:
  bool _internal_has_imagetype() const;
  public:
  void clear_imagetype();
  int32_t imagetype() const;
  void set_imagetype(int32_t value);
  private:
  int32_t _internal_imagetype() const;
  void _internal_set_imagetype(int32_t value);
  public:

  // optional int32 positionInSequence = 8;
  bool has_positioninsequence() const;
  private:
  bool _internal_has_positioninsequence() const;
  public:
  void clear_positioninsequence();
  int32_t positioninsequence() const;
  void set_positioninsequence(int32_t value);
  private:
  int32_t _internal_positioninsequence() const;
  void _internal_set_positioninsequence(int32_t value);
  public:

  // optional int32 durationSeconds = 14;
  bool has_durationseconds() const;
  private:
  bool _internal_has_durationseconds() const;
  public:
  void clear_durationseconds();
  int32_t durationseconds() const;
  void set_durationseconds(int32_t value);
  private:
  int32_t _internal_durationseconds() const;
  void _internal_set_durationseconds(int32_t value);
  public:

  // optional bool supportsFifeUrlOptions = 9;
  bool has_supportsfifeurloptions() const;
  private:
  bool _internal_has_supportsfifeurloptions() const;
  public:
  void clear_supportsfifeurloptions();
  bool supportsfifeurloptions() const;
  void set_supportsfifeurloptions(bool value);
  private:
  bool _internal_supportsfifeurloptions() const;
  void _internal_set_supportsfifeurloptions(bool value);
  public:

  // optional bool autogen = 16;
  bool has_autogen() const;
  private:
  bool _internal_has_autogen() const;
  public:
  void clear_autogen();
  bool autogen() const;
  void set_autogen(bool value);
  private:
  bool _internal_autogen() const;
  void _internal_set_autogen(bool value);
  public:

  // optional bool supportsFifeMonogramOption = 22;
  bool has_supportsfifemonogramoption() const;
  private:
  bool _internal_has_supportsfifemonogramoption() const;
  public:
  void clear_supportsfifemonogramoption();
  bool supportsfifemonogramoption() const;
  void set_supportsfifemonogramoption(bool value);
  private:
  bool _internal_supportsfifemonogramoption() const;
  void _internal_set_supportsfifemonogramoption(bool value);
  public:

  // optional int32 deviceClass = 21;
  bool has_deviceclass() const;
  private:
  bool _internal_has_deviceclass() const;
  public:
  void clear_deviceclass();
  int32_t deviceclass() const;
  void set_deviceclass(int32_t value);
  private:
  int32_t _internal_deviceclass() const;
  void _internal_set_deviceclass(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.Image)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr imageurl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr alttextlocalized_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr secureurl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fillcolorrgb_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr backgroundcolorrgb_;
    ::playapi::proto::finsky::Image_Dimension* dimension_;
    ::playapi::proto::finsky::Image_Citation* citation_;
    ::playapi::proto::finsky::Attribution* attribution_;
    ::playapi::proto::finsky::ImagePalette* palette_;
    int32_t imagetype_;
    int32_t positioninsequence_;
    int32_t durationseconds_;
    bool supportsfifeurloptions_;
    bool autogen_;
    bool supportsfifemonogramoption_;
    int32_t deviceclass_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class ImagePalette final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.ImagePalette) */ {
 public:
  inline ImagePalette() : ImagePalette(nullptr) {}
  ~ImagePalette() override;
  explicit PROTOBUF_CONSTEXPR ImagePalette(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImagePalette(const ImagePalette& from);
  ImagePalette(ImagePalette&& from) noexcept
    : ImagePalette() {
    *this = ::std::move(from);
  }

  inline ImagePalette& operator=(const ImagePalette& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImagePalette& operator=(ImagePalette&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImagePalette& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImagePalette* internal_default_instance() {
    return reinterpret_cast<const ImagePalette*>(
               &_ImagePalette_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(ImagePalette& a, ImagePalette& b) {
    a.Swap(&b);
  }
  inline void Swap(ImagePalette* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImagePalette* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImagePalette* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImagePalette>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImagePalette& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ImagePalette& from) {
    ImagePalette::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImagePalette* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.ImagePalette";
  }
  protected:
  explicit ImagePalette(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLightVibrantRgbFieldNumber = 1,
    kVibrantRgbFieldNumber = 2,
    kDarkVibrantRgbFieldNumber = 3,
    kLightMutedRgbFieldNumber = 4,
    kMutedRgbFieldNumber = 5,
    kDarkMutedRgbFieldNumber = 6,
  };
  // optional string lightVibrantRgb = 1;
  bool has_lightvibrantrgb() const;
  private:
  bool _internal_has_lightvibrantrgb() const;
  public:
  void clear_lightvibrantrgb();
  const std::string& lightvibrantrgb() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_lightvibrantrgb(ArgT0&& arg0, ArgT... args);
  std::string* mutable_lightvibrantrgb();
  PROTOBUF_NODISCARD std::string* release_lightvibrantrgb();
  void set_allocated_lightvibrantrgb(std::string* lightvibrantrgb);
  private:
  const std::string& _internal_lightvibrantrgb() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lightvibrantrgb(const std::string& value);
  std::string* _internal_mutable_lightvibrantrgb();
  public:

  // optional string vibrantRgb = 2;
  bool has_vibrantrgb() const;
  private:
  bool _internal_has_vibrantrgb() const;
  public:
  void clear_vibrantrgb();
  const std::string& vibrantrgb() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vibrantrgb(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vibrantrgb();
  PROTOBUF_NODISCARD std::string* release_vibrantrgb();
  void set_allocated_vibrantrgb(std::string* vibrantrgb);
  private:
  const std::string& _internal_vibrantrgb() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vibrantrgb(const std::string& value);
  std::string* _internal_mutable_vibrantrgb();
  public:

  // optional string darkVibrantRgb = 3;
  bool has_darkvibrantrgb() const;
  private:
  bool _internal_has_darkvibrantrgb() const;
  public:
  void clear_darkvibrantrgb();
  const std::string& darkvibrantrgb() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_darkvibrantrgb(ArgT0&& arg0, ArgT... args);
  std::string* mutable_darkvibrantrgb();
  PROTOBUF_NODISCARD std::string* release_darkvibrantrgb();
  void set_allocated_darkvibrantrgb(std::string* darkvibrantrgb);
  private:
  const std::string& _internal_darkvibrantrgb() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_darkvibrantrgb(const std::string& value);
  std::string* _internal_mutable_darkvibrantrgb();
  public:

  // optional string lightMutedRgb = 4;
  bool has_lightmutedrgb() const;
  private:
  bool _internal_has_lightmutedrgb() const;
  public:
  void clear_lightmutedrgb();
  const std::string& lightmutedrgb() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_lightmutedrgb(ArgT0&& arg0, ArgT... args);
  std::string* mutable_lightmutedrgb();
  PROTOBUF_NODISCARD std::string* release_lightmutedrgb();
  void set_allocated_lightmutedrgb(std::string* lightmutedrgb);
  private:
  const std::string& _internal_lightmutedrgb() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lightmutedrgb(const std::string& value);
  std::string* _internal_mutable_lightmutedrgb();
  public:

  // optional string mutedRgb = 5;
  bool has_mutedrgb() const;
  private:
  bool _internal_has_mutedrgb() const;
  public:
  void clear_mutedrgb();
  const std::string& mutedrgb() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mutedrgb(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mutedrgb();
  PROTOBUF_NODISCARD std::string* release_mutedrgb();
  void set_allocated_mutedrgb(std::string* mutedrgb);
  private:
  const std::string& _internal_mutedrgb() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mutedrgb(const std::string& value);
  std::string* _internal_mutable_mutedrgb();
  public:

  // optional string darkMutedRgb = 6;
  bool has_darkmutedrgb() const;
  private:
  bool _internal_has_darkmutedrgb() const;
  public:
  void clear_darkmutedrgb();
  const std::string& darkmutedrgb() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_darkmutedrgb(ArgT0&& arg0, ArgT... args);
  std::string* mutable_darkmutedrgb();
  PROTOBUF_NODISCARD std::string* release_darkmutedrgb();
  void set_allocated_darkmutedrgb(std::string* darkmutedrgb);
  private:
  const std::string& _internal_darkmutedrgb() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_darkmutedrgb(const std::string& value);
  std::string* _internal_mutable_darkmutedrgb();
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.ImagePalette)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lightvibrantrgb_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vibrantrgb_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr darkvibrantrgb_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lightmutedrgb_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mutedrgb_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr darkmutedrgb_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class Attribution final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.Attribution) */ {
 public:
  inline Attribution() : Attribution(nullptr) {}
  ~Attribution() override;
  explicit PROTOBUF_CONSTEXPR Attribution(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Attribution(const Attribution& from);
  Attribution(Attribution&& from) noexcept
    : Attribution() {
    *this = ::std::move(from);
  }

  inline Attribution& operator=(const Attribution& from) {
    CopyFrom(from);
    return *this;
  }
  inline Attribution& operator=(Attribution&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Attribution& default_instance() {
    return *internal_default_instance();
  }
  static inline const Attribution* internal_default_instance() {
    return reinterpret_cast<const Attribution*>(
               &_Attribution_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(Attribution& a, Attribution& b) {
    a.Swap(&b);
  }
  inline void Swap(Attribution* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Attribution* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Attribution* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Attribution>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Attribution& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Attribution& from) {
    Attribution::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Attribution* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.Attribution";
  }
  protected:
  explicit Attribution(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceTitleFieldNumber = 1,
    kSourceUrlFieldNumber = 2,
    kLicenseTitleFieldNumber = 3,
    kLicenseUrlFieldNumber = 4,
  };
  // optional string sourceTitle = 1;
  bool has_sourcetitle() const;
  private:
  bool _internal_has_sourcetitle() const;
  public:
  void clear_sourcetitle();
  const std::string& sourcetitle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sourcetitle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sourcetitle();
  PROTOBUF_NODISCARD std::string* release_sourcetitle();
  void set_allocated_sourcetitle(std::string* sourcetitle);
  private:
  const std::string& _internal_sourcetitle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sourcetitle(const std::string& value);
  std::string* _internal_mutable_sourcetitle();
  public:

  // optional string sourceUrl = 2;
  bool has_sourceurl() const;
  private:
  bool _internal_has_sourceurl() const;
  public:
  void clear_sourceurl();
  const std::string& sourceurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sourceurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sourceurl();
  PROTOBUF_NODISCARD std::string* release_sourceurl();
  void set_allocated_sourceurl(std::string* sourceurl);
  private:
  const std::string& _internal_sourceurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sourceurl(const std::string& value);
  std::string* _internal_mutable_sourceurl();
  public:

  // optional string licenseTitle = 3;
  bool has_licensetitle() const;
  private:
  bool _internal_has_licensetitle() const;
  public:
  void clear_licensetitle();
  const std::string& licensetitle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_licensetitle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_licensetitle();
  PROTOBUF_NODISCARD std::string* release_licensetitle();
  void set_allocated_licensetitle(std::string* licensetitle);
  private:
  const std::string& _internal_licensetitle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_licensetitle(const std::string& value);
  std::string* _internal_mutable_licensetitle();
  public:

  // optional string licenseUrl = 4;
  bool has_licenseurl() const;
  private:
  bool _internal_has_licenseurl() const;
  public:
  void clear_licenseurl();
  const std::string& licenseurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_licenseurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_licenseurl();
  PROTOBUF_NODISCARD std::string* release_licenseurl();
  void set_allocated_licenseurl(std::string* licenseurl);
  private:
  const std::string& _internal_licenseurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_licenseurl(const std::string& value);
  std::string* _internal_mutable_licenseurl();
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.Attribution)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sourcetitle_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sourceurl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr licensetitle_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr licenseurl_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class CertificateSet final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.CertificateSet) */ {
 public:
  inline CertificateSet() : CertificateSet(nullptr) {}
  ~CertificateSet() override;
  explicit PROTOBUF_CONSTEXPR CertificateSet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CertificateSet(const CertificateSet& from);
  CertificateSet(CertificateSet&& from) noexcept
    : CertificateSet() {
    *this = ::std::move(from);
  }

  inline CertificateSet& operator=(const CertificateSet& from) {
    CopyFrom(from);
    return *this;
  }
  inline CertificateSet& operator=(CertificateSet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CertificateSet& default_instance() {
    return *internal_default_instance();
  }
  static inline const CertificateSet* internal_default_instance() {
    return reinterpret_cast<const CertificateSet*>(
               &_CertificateSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(CertificateSet& a, CertificateSet& b) {
    a.Swap(&b);
  }
  inline void Swap(CertificateSet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CertificateSet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CertificateSet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CertificateSet>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CertificateSet& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CertificateSet& from) {
    CertificateSet::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CertificateSet* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.CertificateSet";
  }
  protected:
  explicit CertificateSet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCertificateHashFieldNumber = 1,
  };
  // repeated string certificateHash = 1;
  int certificatehash_size() const;
  private:
  int _internal_certificatehash_size() const;
  public:
  void clear_certificatehash();
  const std::string& certificatehash(int index) const;
  std::string* mutable_certificatehash(int index);
  void set_certificatehash(int index, const std::string& value);
  void set_certificatehash(int index, std::string&& value);
  void set_certificatehash(int index, const char* value);
  void set_certificatehash(int index, const char* value, size_t size);
  std::string* add_certificatehash();
  void add_certificatehash(const std::string& value);
  void add_certificatehash(std::string&& value);
  void add_certificatehash(const char* value);
  void add_certificatehash(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& certificatehash() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_certificatehash();
  private:
  const std::string& _internal_certificatehash(int index) const;
  std::string* _internal_add_certificatehash();
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.CertificateSet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> certificatehash_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fcommon_2eproto;
};
// -------------------------------------------------------------------

class EncodedTargets final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.EncodedTargets) */ {
 public:
  inline EncodedTargets() : EncodedTargets(nullptr) {}
  ~EncodedTargets() override;
  explicit PROTOBUF_CONSTEXPR EncodedTargets(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EncodedTargets(const EncodedTargets& from);
  EncodedTargets(EncodedTargets&& from) noexcept
    : EncodedTargets() {
    *this = ::std::move(from);
  }

  inline EncodedTargets& operator=(const EncodedTargets& from) {
    CopyFrom(from);
    return *this;
  }
  inline EncodedTargets& operator=(EncodedTargets&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EncodedTargets& default_instance() {
    return *internal_default_instance();
  }
  static inline const EncodedTargets* internal_default_instance() {
    return reinterpret_cast<const EncodedTargets*>(
               &_EncodedTargets_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(EncodedTargets& a, EncodedTargets& b) {
    a.Swap(&b);
  }
  inline void Swap(EncodedTargets* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EncodedTargets* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EncodedTargets* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EncodedTargets>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EncodedTargets& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EncodedTargets& from) {
    EncodedTargets::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EncodedTargets* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.EncodedTargets";
  }
  protected:
  explicit EncodedTargets(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSupportedTargetFieldNumber = 2,
    kOtherTargetFieldNumber = 3,
    kVersionFieldNumber = 1,
  };
  // repeated int64 supportedTarget = 2;
  int supportedtarget_size() const;
  private:
  int _internal_supportedtarget_size() const;
  public:
  void clear_supportedtarget();
  private:
  int64_t _internal_supportedtarget(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_supportedtarget() const;
  void _internal_add_supportedtarget(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_supportedtarget();
  public:
  int64_t supportedtarget(int index) const;
  void set_supportedtarget(int index, int64_t value);
  void add_supportedtarget(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      supportedtarget() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_supportedtarget();

  // repeated int64 otherTarget = 3;
  int othertarget_size() const;
  private:
  int _internal_othertarget_size() const;
  public:
  void clear_othertarget();
  private:
  int64_t _internal_othertarget(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_othertarget() const;
  void _internal_add_othertarget(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_othertarget();
  public:
  int64_t othertarget(int index) const;
  void set_othertarget(int index, int64_t value);
  void add_othertarget(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      othertarget() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_othertarget();

  // optional int32 version = 1;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  int32_t version() const;
  void set_version(int32_t value);
  private:
  int32_t _internal_version() const;
  void _internal_set_version(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.EncodedTargets)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > supportedtarget_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > othertarget_;
    int32_t version_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fcommon_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// HttpCookie

// optional string name = 1;
inline bool HttpCookie::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HttpCookie::has_name() const {
  return _internal_has_name();
}
inline void HttpCookie::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& HttpCookie::name() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.HttpCookie.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HttpCookie::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.HttpCookie.name)
}
inline std::string* HttpCookie::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.HttpCookie.name)
  return _s;
}
inline const std::string& HttpCookie::_internal_name() const {
  return _impl_.name_.Get();
}
inline void HttpCookie::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* HttpCookie::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* HttpCookie::release_name() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.HttpCookie.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void HttpCookie::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.HttpCookie.name)
}

// optional string value = 2;
inline bool HttpCookie::_internal_has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool HttpCookie::has_value() const {
  return _internal_has_value();
}
inline void HttpCookie::clear_value() {
  _impl_.value_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& HttpCookie::value() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.HttpCookie.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HttpCookie::set_value(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.HttpCookie.value)
}
inline std::string* HttpCookie::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.HttpCookie.value)
  return _s;
}
inline const std::string& HttpCookie::_internal_value() const {
  return _impl_.value_.Get();
}
inline void HttpCookie::_internal_set_value(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* HttpCookie::_internal_mutable_value() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* HttpCookie::release_value() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.HttpCookie.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.value_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void HttpCookie::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.HttpCookie.value)
}

// -------------------------------------------------------------------

// TimePeriod

// optional int32 unit = 1;
inline bool TimePeriod::_internal_has_unit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TimePeriod::has_unit() const {
  return _internal_has_unit();
}
inline void TimePeriod::clear_unit() {
  _impl_.unit_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t TimePeriod::_internal_unit() const {
  return _impl_.unit_;
}
inline int32_t TimePeriod::unit() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.TimePeriod.unit)
  return _internal_unit();
}
inline void TimePeriod::_internal_set_unit(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.unit_ = value;
}
inline void TimePeriod::set_unit(int32_t value) {
  _internal_set_unit(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.TimePeriod.unit)
}

// optional int32 count = 2;
inline bool TimePeriod::_internal_has_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TimePeriod::has_count() const {
  return _internal_has_count();
}
inline void TimePeriod::clear_count() {
  _impl_.count_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t TimePeriod::_internal_count() const {
  return _impl_.count_;
}
inline int32_t TimePeriod::count() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.TimePeriod.count)
  return _internal_count();
}
inline void TimePeriod::_internal_set_count(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.count_ = value;
}
inline void TimePeriod::set_count(int32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.TimePeriod.count)
}

// -------------------------------------------------------------------

// MonthAndDay

// optional int32 month = 1;
inline bool MonthAndDay::_internal_has_month() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MonthAndDay::has_month() const {
  return _internal_has_month();
}
inline void MonthAndDay::clear_month() {
  _impl_.month_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t MonthAndDay::_internal_month() const {
  return _impl_.month_;
}
inline int32_t MonthAndDay::month() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.MonthAndDay.month)
  return _internal_month();
}
inline void MonthAndDay::_internal_set_month(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.month_ = value;
}
inline void MonthAndDay::set_month(int32_t value) {
  _internal_set_month(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.MonthAndDay.month)
}

// optional int32 day = 2;
inline bool MonthAndDay::_internal_has_day() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MonthAndDay::has_day() const {
  return _internal_has_day();
}
inline void MonthAndDay::clear_day() {
  _impl_.day_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t MonthAndDay::_internal_day() const {
  return _impl_.day_;
}
inline int32_t MonthAndDay::day() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.MonthAndDay.day)
  return _internal_day();
}
inline void MonthAndDay::_internal_set_day(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.day_ = value;
}
inline void MonthAndDay::set_day(int32_t value) {
  _internal_set_day(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.MonthAndDay.day)
}

// -------------------------------------------------------------------

// SignedData

// optional string signedData = 1;
inline bool SignedData::_internal_has_signeddata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SignedData::has_signeddata() const {
  return _internal_has_signeddata();
}
inline void SignedData::clear_signeddata() {
  _impl_.signeddata_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SignedData::signeddata() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.SignedData.signedData)
  return _internal_signeddata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignedData::set_signeddata(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.signeddata_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.SignedData.signedData)
}
inline std::string* SignedData::mutable_signeddata() {
  std::string* _s = _internal_mutable_signeddata();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.SignedData.signedData)
  return _s;
}
inline const std::string& SignedData::_internal_signeddata() const {
  return _impl_.signeddata_.Get();
}
inline void SignedData::_internal_set_signeddata(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.signeddata_.Set(value, GetArenaForAllocation());
}
inline std::string* SignedData::_internal_mutable_signeddata() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.signeddata_.Mutable(GetArenaForAllocation());
}
inline std::string* SignedData::release_signeddata() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.SignedData.signedData)
  if (!_internal_has_signeddata()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.signeddata_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.signeddata_.IsDefault()) {
    _impl_.signeddata_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SignedData::set_allocated_signeddata(std::string* signeddata) {
  if (signeddata != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.signeddata_.SetAllocated(signeddata, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.signeddata_.IsDefault()) {
    _impl_.signeddata_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.SignedData.signedData)
}

// optional string signature = 2;
inline bool SignedData::_internal_has_signature() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SignedData::has_signature() const {
  return _internal_has_signature();
}
inline void SignedData::clear_signature() {
  _impl_.signature_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SignedData::signature() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.SignedData.signature)
  return _internal_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignedData::set_signature(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.signature_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.SignedData.signature)
}
inline std::string* SignedData::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.SignedData.signature)
  return _s;
}
inline const std::string& SignedData::_internal_signature() const {
  return _impl_.signature_.Get();
}
inline void SignedData::_internal_set_signature(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.signature_.Set(value, GetArenaForAllocation());
}
inline std::string* SignedData::_internal_mutable_signature() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.signature_.Mutable(GetArenaForAllocation());
}
inline std::string* SignedData::release_signature() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.SignedData.signature)
  if (!_internal_has_signature()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.signature_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.signature_.IsDefault()) {
    _impl_.signature_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SignedData::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.signature_.SetAllocated(signature, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.signature_.IsDefault()) {
    _impl_.signature_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.SignedData.signature)
}

// -------------------------------------------------------------------

// Docid

// optional string backendDocid = 1;
inline bool Docid::_internal_has_backenddocid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Docid::has_backenddocid() const {
  return _internal_has_backenddocid();
}
inline void Docid::clear_backenddocid() {
  _impl_.backenddocid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Docid::backenddocid() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Docid.backendDocid)
  return _internal_backenddocid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Docid::set_backenddocid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.backenddocid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.Docid.backendDocid)
}
inline std::string* Docid::mutable_backenddocid() {
  std::string* _s = _internal_mutable_backenddocid();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.Docid.backendDocid)
  return _s;
}
inline const std::string& Docid::_internal_backenddocid() const {
  return _impl_.backenddocid_.Get();
}
inline void Docid::_internal_set_backenddocid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.backenddocid_.Set(value, GetArenaForAllocation());
}
inline std::string* Docid::_internal_mutable_backenddocid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.backenddocid_.Mutable(GetArenaForAllocation());
}
inline std::string* Docid::release_backenddocid() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.Docid.backendDocid)
  if (!_internal_has_backenddocid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.backenddocid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.backenddocid_.IsDefault()) {
    _impl_.backenddocid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Docid::set_allocated_backenddocid(std::string* backenddocid) {
  if (backenddocid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.backenddocid_.SetAllocated(backenddocid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.backenddocid_.IsDefault()) {
    _impl_.backenddocid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.Docid.backendDocid)
}

// optional int32 type = 2;
inline bool Docid::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Docid::has_type() const {
  return _internal_has_type();
}
inline void Docid::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t Docid::_internal_type() const {
  return _impl_.type_;
}
inline int32_t Docid::type() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Docid.type)
  return _internal_type();
}
inline void Docid::_internal_set_type(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}
inline void Docid::set_type(int32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.Docid.type)
}

// optional int32 backend = 3;
inline bool Docid::_internal_has_backend() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Docid::has_backend() const {
  return _internal_has_backend();
}
inline void Docid::clear_backend() {
  _impl_.backend_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t Docid::_internal_backend() const {
  return _impl_.backend_;
}
inline int32_t Docid::backend() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Docid.backend)
  return _internal_backend();
}
inline void Docid::_internal_set_backend(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.backend_ = value;
}
inline void Docid::set_backend(int32_t value) {
  _internal_set_backend(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.Docid.backend)
}

// -------------------------------------------------------------------

// Offer

// optional int64 micros = 1;
inline bool Offer::_internal_has_micros() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool Offer::has_micros() const {
  return _internal_has_micros();
}
inline void Offer::clear_micros() {
  _impl_.micros_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline int64_t Offer::_internal_micros() const {
  return _impl_.micros_;
}
inline int64_t Offer::micros() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Offer.micros)
  return _internal_micros();
}
inline void Offer::_internal_set_micros(int64_t value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.micros_ = value;
}
inline void Offer::set_micros(int64_t value) {
  _internal_set_micros(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.Offer.micros)
}

// optional string currencyCode = 2;
inline bool Offer::_internal_has_currencycode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Offer::has_currencycode() const {
  return _internal_has_currencycode();
}
inline void Offer::clear_currencycode() {
  _impl_.currencycode_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Offer::currencycode() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Offer.currencyCode)
  return _internal_currencycode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Offer::set_currencycode(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.currencycode_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.Offer.currencyCode)
}
inline std::string* Offer::mutable_currencycode() {
  std::string* _s = _internal_mutable_currencycode();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.Offer.currencyCode)
  return _s;
}
inline const std::string& Offer::_internal_currencycode() const {
  return _impl_.currencycode_.Get();
}
inline void Offer::_internal_set_currencycode(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.currencycode_.Set(value, GetArenaForAllocation());
}
inline std::string* Offer::_internal_mutable_currencycode() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.currencycode_.Mutable(GetArenaForAllocation());
}
inline std::string* Offer::release_currencycode() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.Offer.currencyCode)
  if (!_internal_has_currencycode()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.currencycode_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.currencycode_.IsDefault()) {
    _impl_.currencycode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Offer::set_allocated_currencycode(std::string* currencycode) {
  if (currencycode != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.currencycode_.SetAllocated(currencycode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.currencycode_.IsDefault()) {
    _impl_.currencycode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.Offer.currencyCode)
}

// optional string formattedAmount = 3;
inline bool Offer::_internal_has_formattedamount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Offer::has_formattedamount() const {
  return _internal_has_formattedamount();
}
inline void Offer::clear_formattedamount() {
  _impl_.formattedamount_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Offer::formattedamount() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Offer.formattedAmount)
  return _internal_formattedamount();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Offer::set_formattedamount(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.formattedamount_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.Offer.formattedAmount)
}
inline std::string* Offer::mutable_formattedamount() {
  std::string* _s = _internal_mutable_formattedamount();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.Offer.formattedAmount)
  return _s;
}
inline const std::string& Offer::_internal_formattedamount() const {
  return _impl_.formattedamount_.Get();
}
inline void Offer::_internal_set_formattedamount(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.formattedamount_.Set(value, GetArenaForAllocation());
}
inline std::string* Offer::_internal_mutable_formattedamount() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.formattedamount_.Mutable(GetArenaForAllocation());
}
inline std::string* Offer::release_formattedamount() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.Offer.formattedAmount)
  if (!_internal_has_formattedamount()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.formattedamount_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.formattedamount_.IsDefault()) {
    _impl_.formattedamount_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Offer::set_allocated_formattedamount(std::string* formattedamount) {
  if (formattedamount != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.formattedamount_.SetAllocated(formattedamount, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.formattedamount_.IsDefault()) {
    _impl_.formattedamount_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.Offer.formattedAmount)
}

// repeated .playapi.proto.finsky.Offer convertedPrice = 4;
inline int Offer::_internal_convertedprice_size() const {
  return _impl_.convertedprice_.size();
}
inline int Offer::convertedprice_size() const {
  return _internal_convertedprice_size();
}
inline void Offer::clear_convertedprice() {
  _impl_.convertedprice_.Clear();
}
inline ::playapi::proto::finsky::Offer* Offer::mutable_convertedprice(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.Offer.convertedPrice)
  return _impl_.convertedprice_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Offer >*
Offer::mutable_convertedprice() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.Offer.convertedPrice)
  return &_impl_.convertedprice_;
}
inline const ::playapi::proto::finsky::Offer& Offer::_internal_convertedprice(int index) const {
  return _impl_.convertedprice_.Get(index);
}
inline const ::playapi::proto::finsky::Offer& Offer::convertedprice(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Offer.convertedPrice)
  return _internal_convertedprice(index);
}
inline ::playapi::proto::finsky::Offer* Offer::_internal_add_convertedprice() {
  return _impl_.convertedprice_.Add();
}
inline ::playapi::proto::finsky::Offer* Offer::add_convertedprice() {
  ::playapi::proto::finsky::Offer* _add = _internal_add_convertedprice();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.Offer.convertedPrice)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Offer >&
Offer::convertedprice() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.Offer.convertedPrice)
  return _impl_.convertedprice_;
}

// optional bool checkoutFlowRequired = 5;
inline bool Offer::_internal_has_checkoutflowrequired() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool Offer::has_checkoutflowrequired() const {
  return _internal_has_checkoutflowrequired();
}
inline void Offer::clear_checkoutflowrequired() {
  _impl_.checkoutflowrequired_ = false;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline bool Offer::_internal_checkoutflowrequired() const {
  return _impl_.checkoutflowrequired_;
}
inline bool Offer::checkoutflowrequired() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Offer.checkoutFlowRequired)
  return _internal_checkoutflowrequired();
}
inline void Offer::_internal_set_checkoutflowrequired(bool value) {
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.checkoutflowrequired_ = value;
}
inline void Offer::set_checkoutflowrequired(bool value) {
  _internal_set_checkoutflowrequired(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.Offer.checkoutFlowRequired)
}

// optional int64 fullPriceMicros = 6;
inline bool Offer::_internal_has_fullpricemicros() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool Offer::has_fullpricemicros() const {
  return _internal_has_fullpricemicros();
}
inline void Offer::clear_fullpricemicros() {
  _impl_.fullpricemicros_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline int64_t Offer::_internal_fullpricemicros() const {
  return _impl_.fullpricemicros_;
}
inline int64_t Offer::fullpricemicros() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Offer.fullPriceMicros)
  return _internal_fullpricemicros();
}
inline void Offer::_internal_set_fullpricemicros(int64_t value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.fullpricemicros_ = value;
}
inline void Offer::set_fullpricemicros(int64_t value) {
  _internal_set_fullpricemicros(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.Offer.fullPriceMicros)
}

// optional string formattedFullAmount = 7;
inline bool Offer::_internal_has_formattedfullamount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Offer::has_formattedfullamount() const {
  return _internal_has_formattedfullamount();
}
inline void Offer::clear_formattedfullamount() {
  _impl_.formattedfullamount_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Offer::formattedfullamount() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Offer.formattedFullAmount)
  return _internal_formattedfullamount();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Offer::set_formattedfullamount(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.formattedfullamount_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.Offer.formattedFullAmount)
}
inline std::string* Offer::mutable_formattedfullamount() {
  std::string* _s = _internal_mutable_formattedfullamount();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.Offer.formattedFullAmount)
  return _s;
}
inline const std::string& Offer::_internal_formattedfullamount() const {
  return _impl_.formattedfullamount_.Get();
}
inline void Offer::_internal_set_formattedfullamount(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.formattedfullamount_.Set(value, GetArenaForAllocation());
}
inline std::string* Offer::_internal_mutable_formattedfullamount() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.formattedfullamount_.Mutable(GetArenaForAllocation());
}
inline std::string* Offer::release_formattedfullamount() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.Offer.formattedFullAmount)
  if (!_internal_has_formattedfullamount()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.formattedfullamount_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.formattedfullamount_.IsDefault()) {
    _impl_.formattedfullamount_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Offer::set_allocated_formattedfullamount(std::string* formattedfullamount) {
  if (formattedfullamount != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.formattedfullamount_.SetAllocated(formattedfullamount, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.formattedfullamount_.IsDefault()) {
    _impl_.formattedfullamount_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.Offer.formattedFullAmount)
}

// optional int32 offerType = 8;
inline bool Offer::_internal_has_offertype() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool Offer::has_offertype() const {
  return _internal_has_offertype();
}
inline void Offer::clear_offertype() {
  _impl_.offertype_ = 0;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline int32_t Offer::_internal_offertype() const {
  return _impl_.offertype_;
}
inline int32_t Offer::offertype() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Offer.offerType)
  return _internal_offertype();
}
inline void Offer::_internal_set_offertype(int32_t value) {
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.offertype_ = value;
}
inline void Offer::set_offertype(int32_t value) {
  _internal_set_offertype(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.Offer.offerType)
}

// optional .playapi.proto.finsky.RentalTerms rentalTerms = 9;
inline bool Offer::_internal_has_rentalterms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rentalterms_ != nullptr);
  return value;
}
inline bool Offer::has_rentalterms() const {
  return _internal_has_rentalterms();
}
inline void Offer::clear_rentalterms() {
  if (_impl_.rentalterms_ != nullptr) _impl_.rentalterms_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::playapi::proto::finsky::RentalTerms& Offer::_internal_rentalterms() const {
  const ::playapi::proto::finsky::RentalTerms* p = _impl_.rentalterms_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::RentalTerms&>(
      ::playapi::proto::finsky::_RentalTerms_default_instance_);
}
inline const ::playapi::proto::finsky::RentalTerms& Offer::rentalterms() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Offer.rentalTerms)
  return _internal_rentalterms();
}
inline void Offer::unsafe_arena_set_allocated_rentalterms(
    ::playapi::proto::finsky::RentalTerms* rentalterms) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rentalterms_);
  }
  _impl_.rentalterms_ = rentalterms;
  if (rentalterms) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.Offer.rentalTerms)
}
inline ::playapi::proto::finsky::RentalTerms* Offer::release_rentalterms() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::playapi::proto::finsky::RentalTerms* temp = _impl_.rentalterms_;
  _impl_.rentalterms_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::RentalTerms* Offer::unsafe_arena_release_rentalterms() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.Offer.rentalTerms)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::playapi::proto::finsky::RentalTerms* temp = _impl_.rentalterms_;
  _impl_.rentalterms_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::RentalTerms* Offer::_internal_mutable_rentalterms() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.rentalterms_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::RentalTerms>(GetArenaForAllocation());
    _impl_.rentalterms_ = p;
  }
  return _impl_.rentalterms_;
}
inline ::playapi::proto::finsky::RentalTerms* Offer::mutable_rentalterms() {
  ::playapi::proto::finsky::RentalTerms* _msg = _internal_mutable_rentalterms();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.Offer.rentalTerms)
  return _msg;
}
inline void Offer::set_allocated_rentalterms(::playapi::proto::finsky::RentalTerms* rentalterms) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rentalterms_;
  }
  if (rentalterms) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rentalterms);
    if (message_arena != submessage_arena) {
      rentalterms = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rentalterms, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.rentalterms_ = rentalterms;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.Offer.rentalTerms)
}

// optional int64 onSaleDate = 10;
inline bool Offer::_internal_has_onsaledate() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool Offer::has_onsaledate() const {
  return _internal_has_onsaledate();
}
inline void Offer::clear_onsaledate() {
  _impl_.onsaledate_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline int64_t Offer::_internal_onsaledate() const {
  return _impl_.onsaledate_;
}
inline int64_t Offer::onsaledate() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Offer.onSaleDate)
  return _internal_onsaledate();
}
inline void Offer::_internal_set_onsaledate(int64_t value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.onsaledate_ = value;
}
inline void Offer::set_onsaledate(int64_t value) {
  _internal_set_onsaledate(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.Offer.onSaleDate)
}

// repeated string promotionLabel = 11;
inline int Offer::_internal_promotionlabel_size() const {
  return _impl_.promotionlabel_.size();
}
inline int Offer::promotionlabel_size() const {
  return _internal_promotionlabel_size();
}
inline void Offer::clear_promotionlabel() {
  _impl_.promotionlabel_.Clear();
}
inline std::string* Offer::add_promotionlabel() {
  std::string* _s = _internal_add_promotionlabel();
  // @@protoc_insertion_point(field_add_mutable:playapi.proto.finsky.Offer.promotionLabel)
  return _s;
}
inline const std::string& Offer::_internal_promotionlabel(int index) const {
  return _impl_.promotionlabel_.Get(index);
}
inline const std::string& Offer::promotionlabel(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Offer.promotionLabel)
  return _internal_promotionlabel(index);
}
inline std::string* Offer::mutable_promotionlabel(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.Offer.promotionLabel)
  return _impl_.promotionlabel_.Mutable(index);
}
inline void Offer::set_promotionlabel(int index, const std::string& value) {
  _impl_.promotionlabel_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.Offer.promotionLabel)
}
inline void Offer::set_promotionlabel(int index, std::string&& value) {
  _impl_.promotionlabel_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.Offer.promotionLabel)
}
inline void Offer::set_promotionlabel(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.promotionlabel_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:playapi.proto.finsky.Offer.promotionLabel)
}
inline void Offer::set_promotionlabel(int index, const char* value, size_t size) {
  _impl_.promotionlabel_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:playapi.proto.finsky.Offer.promotionLabel)
}
inline std::string* Offer::_internal_add_promotionlabel() {
  return _impl_.promotionlabel_.Add();
}
inline void Offer::add_promotionlabel(const std::string& value) {
  _impl_.promotionlabel_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.Offer.promotionLabel)
}
inline void Offer::add_promotionlabel(std::string&& value) {
  _impl_.promotionlabel_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.Offer.promotionLabel)
}
inline void Offer::add_promotionlabel(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.promotionlabel_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:playapi.proto.finsky.Offer.promotionLabel)
}
inline void Offer::add_promotionlabel(const char* value, size_t size) {
  _impl_.promotionlabel_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:playapi.proto.finsky.Offer.promotionLabel)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Offer::promotionlabel() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.Offer.promotionLabel)
  return _impl_.promotionlabel_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Offer::mutable_promotionlabel() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.Offer.promotionLabel)
  return &_impl_.promotionlabel_;
}

// optional .playapi.proto.finsky.SubscriptionTerms subscriptionTerms = 12;
inline bool Offer::_internal_has_subscriptionterms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.subscriptionterms_ != nullptr);
  return value;
}
inline bool Offer::has_subscriptionterms() const {
  return _internal_has_subscriptionterms();
}
inline void Offer::clear_subscriptionterms() {
  if (_impl_.subscriptionterms_ != nullptr) _impl_.subscriptionterms_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::playapi::proto::finsky::SubscriptionTerms& Offer::_internal_subscriptionterms() const {
  const ::playapi::proto::finsky::SubscriptionTerms* p = _impl_.subscriptionterms_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::SubscriptionTerms&>(
      ::playapi::proto::finsky::_SubscriptionTerms_default_instance_);
}
inline const ::playapi::proto::finsky::SubscriptionTerms& Offer::subscriptionterms() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Offer.subscriptionTerms)
  return _internal_subscriptionterms();
}
inline void Offer::unsafe_arena_set_allocated_subscriptionterms(
    ::playapi::proto::finsky::SubscriptionTerms* subscriptionterms) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.subscriptionterms_);
  }
  _impl_.subscriptionterms_ = subscriptionterms;
  if (subscriptionterms) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.Offer.subscriptionTerms)
}
inline ::playapi::proto::finsky::SubscriptionTerms* Offer::release_subscriptionterms() {
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::playapi::proto::finsky::SubscriptionTerms* temp = _impl_.subscriptionterms_;
  _impl_.subscriptionterms_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::SubscriptionTerms* Offer::unsafe_arena_release_subscriptionterms() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.Offer.subscriptionTerms)
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::playapi::proto::finsky::SubscriptionTerms* temp = _impl_.subscriptionterms_;
  _impl_.subscriptionterms_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::SubscriptionTerms* Offer::_internal_mutable_subscriptionterms() {
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.subscriptionterms_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::SubscriptionTerms>(GetArenaForAllocation());
    _impl_.subscriptionterms_ = p;
  }
  return _impl_.subscriptionterms_;
}
inline ::playapi::proto::finsky::SubscriptionTerms* Offer::mutable_subscriptionterms() {
  ::playapi::proto::finsky::SubscriptionTerms* _msg = _internal_mutable_subscriptionterms();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.Offer.subscriptionTerms)
  return _msg;
}
inline void Offer::set_allocated_subscriptionterms(::playapi::proto::finsky::SubscriptionTerms* subscriptionterms) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.subscriptionterms_;
  }
  if (subscriptionterms) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(subscriptionterms);
    if (message_arena != submessage_arena) {
      subscriptionterms = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subscriptionterms, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.subscriptionterms_ = subscriptionterms;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.Offer.subscriptionTerms)
}

// optional string formattedName = 13;
inline bool Offer::_internal_has_formattedname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Offer::has_formattedname() const {
  return _internal_has_formattedname();
}
inline void Offer::clear_formattedname() {
  _impl_.formattedname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& Offer::formattedname() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Offer.formattedName)
  return _internal_formattedname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Offer::set_formattedname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.formattedname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.Offer.formattedName)
}
inline std::string* Offer::mutable_formattedname() {
  std::string* _s = _internal_mutable_formattedname();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.Offer.formattedName)
  return _s;
}
inline const std::string& Offer::_internal_formattedname() const {
  return _impl_.formattedname_.Get();
}
inline void Offer::_internal_set_formattedname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.formattedname_.Set(value, GetArenaForAllocation());
}
inline std::string* Offer::_internal_mutable_formattedname() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.formattedname_.Mutable(GetArenaForAllocation());
}
inline std::string* Offer::release_formattedname() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.Offer.formattedName)
  if (!_internal_has_formattedname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.formattedname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.formattedname_.IsDefault()) {
    _impl_.formattedname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Offer::set_allocated_formattedname(std::string* formattedname) {
  if (formattedname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.formattedname_.SetAllocated(formattedname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.formattedname_.IsDefault()) {
    _impl_.formattedname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.Offer.formattedName)
}

// optional string formattedDescription = 14;
inline bool Offer::_internal_has_formatteddescription() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Offer::has_formatteddescription() const {
  return _internal_has_formatteddescription();
}
inline void Offer::clear_formatteddescription() {
  _impl_.formatteddescription_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& Offer::formatteddescription() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Offer.formattedDescription)
  return _internal_formatteddescription();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Offer::set_formatteddescription(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.formatteddescription_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.Offer.formattedDescription)
}
inline std::string* Offer::mutable_formatteddescription() {
  std::string* _s = _internal_mutable_formatteddescription();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.Offer.formattedDescription)
  return _s;
}
inline const std::string& Offer::_internal_formatteddescription() const {
  return _impl_.formatteddescription_.Get();
}
inline void Offer::_internal_set_formatteddescription(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.formatteddescription_.Set(value, GetArenaForAllocation());
}
inline std::string* Offer::_internal_mutable_formatteddescription() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.formatteddescription_.Mutable(GetArenaForAllocation());
}
inline std::string* Offer::release_formatteddescription() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.Offer.formattedDescription)
  if (!_internal_has_formatteddescription()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.formatteddescription_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.formatteddescription_.IsDefault()) {
    _impl_.formatteddescription_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Offer::set_allocated_formatteddescription(std::string* formatteddescription) {
  if (formatteddescription != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.formatteddescription_.SetAllocated(formatteddescription, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.formatteddescription_.IsDefault()) {
    _impl_.formatteddescription_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.Offer.formattedDescription)
}

// optional bool preorder = 15;
inline bool Offer::_internal_has_preorder() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool Offer::has_preorder() const {
  return _internal_has_preorder();
}
inline void Offer::clear_preorder() {
  _impl_.preorder_ = false;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline bool Offer::_internal_preorder() const {
  return _impl_.preorder_;
}
inline bool Offer::preorder() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Offer.preorder)
  return _internal_preorder();
}
inline void Offer::_internal_set_preorder(bool value) {
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.preorder_ = value;
}
inline void Offer::set_preorder(bool value) {
  _internal_set_preorder(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.Offer.preorder)
}

// optional int32 onSaleDateDisplayTimeZoneOffsetMsec = 16;
inline bool Offer::_internal_has_onsaledatedisplaytimezoneoffsetmsec() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool Offer::has_onsaledatedisplaytimezoneoffsetmsec() const {
  return _internal_has_onsaledatedisplaytimezoneoffsetmsec();
}
inline void Offer::clear_onsaledatedisplaytimezoneoffsetmsec() {
  _impl_.onsaledatedisplaytimezoneoffsetmsec_ = 0;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline int32_t Offer::_internal_onsaledatedisplaytimezoneoffsetmsec() const {
  return _impl_.onsaledatedisplaytimezoneoffsetmsec_;
}
inline int32_t Offer::onsaledatedisplaytimezoneoffsetmsec() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Offer.onSaleDateDisplayTimeZoneOffsetMsec)
  return _internal_onsaledatedisplaytimezoneoffsetmsec();
}
inline void Offer::_internal_set_onsaledatedisplaytimezoneoffsetmsec(int32_t value) {
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.onsaledatedisplaytimezoneoffsetmsec_ = value;
}
inline void Offer::set_onsaledatedisplaytimezoneoffsetmsec(int32_t value) {
  _internal_set_onsaledatedisplaytimezoneoffsetmsec(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.Offer.onSaleDateDisplayTimeZoneOffsetMsec)
}

// optional int32 licensedOfferType = 17;
inline bool Offer::_internal_has_licensedoffertype() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool Offer::has_licensedoffertype() const {
  return _internal_has_licensedoffertype();
}
inline void Offer::clear_licensedoffertype() {
  _impl_.licensedoffertype_ = 0;
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline int32_t Offer::_internal_licensedoffertype() const {
  return _impl_.licensedoffertype_;
}
inline int32_t Offer::licensedoffertype() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Offer.licensedOfferType)
  return _internal_licensedoffertype();
}
inline void Offer::_internal_set_licensedoffertype(int32_t value) {
  _impl_._has_bits_[0] |= 0x00200000u;
  _impl_.licensedoffertype_ = value;
}
inline void Offer::set_licensedoffertype(int32_t value) {
  _internal_set_licensedoffertype(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.Offer.licensedOfferType)
}

// optional .playapi.proto.finsky.SubscriptionContentTerms subscriptionContentTerms = 18;
inline bool Offer::_internal_has_subscriptioncontentterms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.subscriptioncontentterms_ != nullptr);
  return value;
}
inline bool Offer::has_subscriptioncontentterms() const {
  return _internal_has_subscriptioncontentterms();
}
inline void Offer::clear_subscriptioncontentterms() {
  if (_impl_.subscriptioncontentterms_ != nullptr) _impl_.subscriptioncontentterms_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const ::playapi::proto::finsky::SubscriptionContentTerms& Offer::_internal_subscriptioncontentterms() const {
  const ::playapi::proto::finsky::SubscriptionContentTerms* p = _impl_.subscriptioncontentterms_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::SubscriptionContentTerms&>(
      ::playapi::proto::finsky::_SubscriptionContentTerms_default_instance_);
}
inline const ::playapi::proto::finsky::SubscriptionContentTerms& Offer::subscriptioncontentterms() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Offer.subscriptionContentTerms)
  return _internal_subscriptioncontentterms();
}
inline void Offer::unsafe_arena_set_allocated_subscriptioncontentterms(
    ::playapi::proto::finsky::SubscriptionContentTerms* subscriptioncontentterms) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.subscriptioncontentterms_);
  }
  _impl_.subscriptioncontentterms_ = subscriptioncontentterms;
  if (subscriptioncontentterms) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.Offer.subscriptionContentTerms)
}
inline ::playapi::proto::finsky::SubscriptionContentTerms* Offer::release_subscriptioncontentterms() {
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::playapi::proto::finsky::SubscriptionContentTerms* temp = _impl_.subscriptioncontentterms_;
  _impl_.subscriptioncontentterms_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::SubscriptionContentTerms* Offer::unsafe_arena_release_subscriptioncontentterms() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.Offer.subscriptionContentTerms)
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::playapi::proto::finsky::SubscriptionContentTerms* temp = _impl_.subscriptioncontentterms_;
  _impl_.subscriptioncontentterms_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::SubscriptionContentTerms* Offer::_internal_mutable_subscriptioncontentterms() {
  _impl_._has_bits_[0] |= 0x00000200u;
  if (_impl_.subscriptioncontentterms_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::SubscriptionContentTerms>(GetArenaForAllocation());
    _impl_.subscriptioncontentterms_ = p;
  }
  return _impl_.subscriptioncontentterms_;
}
inline ::playapi::proto::finsky::SubscriptionContentTerms* Offer::mutable_subscriptioncontentterms() {
  ::playapi::proto::finsky::SubscriptionContentTerms* _msg = _internal_mutable_subscriptioncontentterms();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.Offer.subscriptionContentTerms)
  return _msg;
}
inline void Offer::set_allocated_subscriptioncontentterms(::playapi::proto::finsky::SubscriptionContentTerms* subscriptioncontentterms) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.subscriptioncontentterms_;
  }
  if (subscriptioncontentterms) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(subscriptioncontentterms);
    if (message_arena != submessage_arena) {
      subscriptioncontentterms = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subscriptioncontentterms, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.subscriptioncontentterms_ = subscriptioncontentterms;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.Offer.subscriptionContentTerms)
}

// optional string offerId = 19;
inline bool Offer::_internal_has_offerid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Offer::has_offerid() const {
  return _internal_has_offerid();
}
inline void Offer::clear_offerid() {
  _impl_.offerid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& Offer::offerid() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Offer.offerId)
  return _internal_offerid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Offer::set_offerid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.offerid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.Offer.offerId)
}
inline std::string* Offer::mutable_offerid() {
  std::string* _s = _internal_mutable_offerid();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.Offer.offerId)
  return _s;
}
inline const std::string& Offer::_internal_offerid() const {
  return _impl_.offerid_.Get();
}
inline void Offer::_internal_set_offerid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.offerid_.Set(value, GetArenaForAllocation());
}
inline std::string* Offer::_internal_mutable_offerid() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.offerid_.Mutable(GetArenaForAllocation());
}
inline std::string* Offer::release_offerid() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.Offer.offerId)
  if (!_internal_has_offerid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.offerid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.offerid_.IsDefault()) {
    _impl_.offerid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Offer::set_allocated_offerid(std::string* offerid) {
  if (offerid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.offerid_.SetAllocated(offerid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.offerid_.IsDefault()) {
    _impl_.offerid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.Offer.offerId)
}

// optional int64 preorderFulfillmentDisplayDate = 20;
inline bool Offer::_internal_has_preorderfulfillmentdisplaydate() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool Offer::has_preorderfulfillmentdisplaydate() const {
  return _internal_has_preorderfulfillmentdisplaydate();
}
inline void Offer::clear_preorderfulfillmentdisplaydate() {
  _impl_.preorderfulfillmentdisplaydate_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00400000u;
}
inline int64_t Offer::_internal_preorderfulfillmentdisplaydate() const {
  return _impl_.preorderfulfillmentdisplaydate_;
}
inline int64_t Offer::preorderfulfillmentdisplaydate() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Offer.preorderFulfillmentDisplayDate)
  return _internal_preorderfulfillmentdisplaydate();
}
inline void Offer::_internal_set_preorderfulfillmentdisplaydate(int64_t value) {
  _impl_._has_bits_[0] |= 0x00400000u;
  _impl_.preorderfulfillmentdisplaydate_ = value;
}
inline void Offer::set_preorderfulfillmentdisplaydate(int64_t value) {
  _internal_set_preorderfulfillmentdisplaydate(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.Offer.preorderFulfillmentDisplayDate)
}

// optional .playapi.proto.finsky.LicenseTerms licenseTerms = 21;
inline bool Offer::_internal_has_licenseterms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.licenseterms_ != nullptr);
  return value;
}
inline bool Offer::has_licenseterms() const {
  return _internal_has_licenseterms();
}
inline void Offer::clear_licenseterms() {
  if (_impl_.licenseterms_ != nullptr) _impl_.licenseterms_->Clear();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const ::playapi::proto::finsky::LicenseTerms& Offer::_internal_licenseterms() const {
  const ::playapi::proto::finsky::LicenseTerms* p = _impl_.licenseterms_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::LicenseTerms&>(
      ::playapi::proto::finsky::_LicenseTerms_default_instance_);
}
inline const ::playapi::proto::finsky::LicenseTerms& Offer::licenseterms() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Offer.licenseTerms)
  return _internal_licenseterms();
}
inline void Offer::unsafe_arena_set_allocated_licenseterms(
    ::playapi::proto::finsky::LicenseTerms* licenseterms) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.licenseterms_);
  }
  _impl_.licenseterms_ = licenseterms;
  if (licenseterms) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.Offer.licenseTerms)
}
inline ::playapi::proto::finsky::LicenseTerms* Offer::release_licenseterms() {
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::playapi::proto::finsky::LicenseTerms* temp = _impl_.licenseterms_;
  _impl_.licenseterms_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::LicenseTerms* Offer::unsafe_arena_release_licenseterms() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.Offer.licenseTerms)
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::playapi::proto::finsky::LicenseTerms* temp = _impl_.licenseterms_;
  _impl_.licenseterms_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::LicenseTerms* Offer::_internal_mutable_licenseterms() {
  _impl_._has_bits_[0] |= 0x00000400u;
  if (_impl_.licenseterms_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::LicenseTerms>(GetArenaForAllocation());
    _impl_.licenseterms_ = p;
  }
  return _impl_.licenseterms_;
}
inline ::playapi::proto::finsky::LicenseTerms* Offer::mutable_licenseterms() {
  ::playapi::proto::finsky::LicenseTerms* _msg = _internal_mutable_licenseterms();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.Offer.licenseTerms)
  return _msg;
}
inline void Offer::set_allocated_licenseterms(::playapi::proto::finsky::LicenseTerms* licenseterms) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.licenseterms_;
  }
  if (licenseterms) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(licenseterms);
    if (message_arena != submessage_arena) {
      licenseterms = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, licenseterms, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.licenseterms_ = licenseterms;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.Offer.licenseTerms)
}

// optional bool temporarilyFree = 22;
inline bool Offer::_internal_has_temporarilyfree() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool Offer::has_temporarilyfree() const {
  return _internal_has_temporarilyfree();
}
inline void Offer::clear_temporarilyfree() {
  _impl_.temporarilyfree_ = false;
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline bool Offer::_internal_temporarilyfree() const {
  return _impl_.temporarilyfree_;
}
inline bool Offer::temporarilyfree() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Offer.temporarilyFree)
  return _internal_temporarilyfree();
}
inline void Offer::_internal_set_temporarilyfree(bool value) {
  _impl_._has_bits_[0] |= 0x00080000u;
  _impl_.temporarilyfree_ = value;
}
inline void Offer::set_temporarilyfree(bool value) {
  _internal_set_temporarilyfree(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.Offer.temporarilyFree)
}

// optional .playapi.proto.finsky.VoucherOfferTerms voucherTerms = 23;
inline bool Offer::_internal_has_voucherterms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.voucherterms_ != nullptr);
  return value;
}
inline bool Offer::has_voucherterms() const {
  return _internal_has_voucherterms();
}
inline void Offer::clear_voucherterms() {
  if (_impl_.voucherterms_ != nullptr) _impl_.voucherterms_->Clear();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline const ::playapi::proto::finsky::VoucherOfferTerms& Offer::_internal_voucherterms() const {
  const ::playapi::proto::finsky::VoucherOfferTerms* p = _impl_.voucherterms_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::VoucherOfferTerms&>(
      ::playapi::proto::finsky::_VoucherOfferTerms_default_instance_);
}
inline const ::playapi::proto::finsky::VoucherOfferTerms& Offer::voucherterms() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Offer.voucherTerms)
  return _internal_voucherterms();
}
inline void Offer::unsafe_arena_set_allocated_voucherterms(
    ::playapi::proto::finsky::VoucherOfferTerms* voucherterms) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.voucherterms_);
  }
  _impl_.voucherterms_ = voucherterms;
  if (voucherterms) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.Offer.voucherTerms)
}
inline ::playapi::proto::finsky::VoucherOfferTerms* Offer::release_voucherterms() {
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::playapi::proto::finsky::VoucherOfferTerms* temp = _impl_.voucherterms_;
  _impl_.voucherterms_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::VoucherOfferTerms* Offer::unsafe_arena_release_voucherterms() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.Offer.voucherTerms)
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::playapi::proto::finsky::VoucherOfferTerms* temp = _impl_.voucherterms_;
  _impl_.voucherterms_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::VoucherOfferTerms* Offer::_internal_mutable_voucherterms() {
  _impl_._has_bits_[0] |= 0x00000800u;
  if (_impl_.voucherterms_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::VoucherOfferTerms>(GetArenaForAllocation());
    _impl_.voucherterms_ = p;
  }
  return _impl_.voucherterms_;
}
inline ::playapi::proto::finsky::VoucherOfferTerms* Offer::mutable_voucherterms() {
  ::playapi::proto::finsky::VoucherOfferTerms* _msg = _internal_mutable_voucherterms();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.Offer.voucherTerms)
  return _msg;
}
inline void Offer::set_allocated_voucherterms(::playapi::proto::finsky::VoucherOfferTerms* voucherterms) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.voucherterms_;
  }
  if (voucherterms) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(voucherterms);
    if (message_arena != submessage_arena) {
      voucherterms = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, voucherterms, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  _impl_.voucherterms_ = voucherterms;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.Offer.voucherTerms)
}

// repeated .playapi.proto.finsky.OfferPayment offerPayment = 24;
inline int Offer::_internal_offerpayment_size() const {
  return _impl_.offerpayment_.size();
}
inline int Offer::offerpayment_size() const {
  return _internal_offerpayment_size();
}
inline void Offer::clear_offerpayment() {
  _impl_.offerpayment_.Clear();
}
inline ::playapi::proto::finsky::OfferPayment* Offer::mutable_offerpayment(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.Offer.offerPayment)
  return _impl_.offerpayment_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::OfferPayment >*
Offer::mutable_offerpayment() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.Offer.offerPayment)
  return &_impl_.offerpayment_;
}
inline const ::playapi::proto::finsky::OfferPayment& Offer::_internal_offerpayment(int index) const {
  return _impl_.offerpayment_.Get(index);
}
inline const ::playapi::proto::finsky::OfferPayment& Offer::offerpayment(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Offer.offerPayment)
  return _internal_offerpayment(index);
}
inline ::playapi::proto::finsky::OfferPayment* Offer::_internal_add_offerpayment() {
  return _impl_.offerpayment_.Add();
}
inline ::playapi::proto::finsky::OfferPayment* Offer::add_offerpayment() {
  ::playapi::proto::finsky::OfferPayment* _add = _internal_add_offerpayment();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.Offer.offerPayment)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::OfferPayment >&
Offer::offerpayment() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.Offer.offerPayment)
  return _impl_.offerpayment_;
}

// optional bool repeatLastPayment = 25;
inline bool Offer::_internal_has_repeatlastpayment() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool Offer::has_repeatlastpayment() const {
  return _internal_has_repeatlastpayment();
}
inline void Offer::clear_repeatlastpayment() {
  _impl_.repeatlastpayment_ = false;
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline bool Offer::_internal_repeatlastpayment() const {
  return _impl_.repeatlastpayment_;
}
inline bool Offer::repeatlastpayment() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Offer.repeatLastPayment)
  return _internal_repeatlastpayment();
}
inline void Offer::_internal_set_repeatlastpayment(bool value) {
  _impl_._has_bits_[0] |= 0x00100000u;
  _impl_.repeatlastpayment_ = value;
}
inline void Offer::set_repeatlastpayment(bool value) {
  _internal_set_repeatlastpayment(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.Offer.repeatLastPayment)
}

// optional string buyButtonLabel = 26;
inline bool Offer::_internal_has_buybuttonlabel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Offer::has_buybuttonlabel() const {
  return _internal_has_buybuttonlabel();
}
inline void Offer::clear_buybuttonlabel() {
  _impl_.buybuttonlabel_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& Offer::buybuttonlabel() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Offer.buyButtonLabel)
  return _internal_buybuttonlabel();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Offer::set_buybuttonlabel(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000040u;
 _impl_.buybuttonlabel_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.Offer.buyButtonLabel)
}
inline std::string* Offer::mutable_buybuttonlabel() {
  std::string* _s = _internal_mutable_buybuttonlabel();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.Offer.buyButtonLabel)
  return _s;
}
inline const std::string& Offer::_internal_buybuttonlabel() const {
  return _impl_.buybuttonlabel_.Get();
}
inline void Offer::_internal_set_buybuttonlabel(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.buybuttonlabel_.Set(value, GetArenaForAllocation());
}
inline std::string* Offer::_internal_mutable_buybuttonlabel() {
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.buybuttonlabel_.Mutable(GetArenaForAllocation());
}
inline std::string* Offer::release_buybuttonlabel() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.Offer.buyButtonLabel)
  if (!_internal_has_buybuttonlabel()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* p = _impl_.buybuttonlabel_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.buybuttonlabel_.IsDefault()) {
    _impl_.buybuttonlabel_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Offer::set_allocated_buybuttonlabel(std::string* buybuttonlabel) {
  if (buybuttonlabel != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.buybuttonlabel_.SetAllocated(buybuttonlabel, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.buybuttonlabel_.IsDefault()) {
    _impl_.buybuttonlabel_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.Offer.buyButtonLabel)
}

// optional bool instantPurchaseEnabled = 27;
inline bool Offer::_internal_has_instantpurchaseenabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool Offer::has_instantpurchaseenabled() const {
  return _internal_has_instantpurchaseenabled();
}
inline void Offer::clear_instantpurchaseenabled() {
  _impl_.instantpurchaseenabled_ = false;
  _impl_._has_bits_[0] &= ~0x00800000u;
}
inline bool Offer::_internal_instantpurchaseenabled() const {
  return _impl_.instantpurchaseenabled_;
}
inline bool Offer::instantpurchaseenabled() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Offer.instantPurchaseEnabled)
  return _internal_instantpurchaseenabled();
}
inline void Offer::_internal_set_instantpurchaseenabled(bool value) {
  _impl_._has_bits_[0] |= 0x00800000u;
  _impl_.instantpurchaseenabled_ = value;
}
inline void Offer::set_instantpurchaseenabled(bool value) {
  _internal_set_instantpurchaseenabled(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.Offer.instantPurchaseEnabled)
}

// -------------------------------------------------------------------

// RentalTerms

// optional int32 DEPRECATEDGrantPeriodSeconds = 1;
inline bool RentalTerms::_internal_has_deprecatedgrantperiodseconds() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RentalTerms::has_deprecatedgrantperiodseconds() const {
  return _internal_has_deprecatedgrantperiodseconds();
}
inline void RentalTerms::clear_deprecatedgrantperiodseconds() {
  _impl_.deprecatedgrantperiodseconds_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t RentalTerms::_internal_deprecatedgrantperiodseconds() const {
  return _impl_.deprecatedgrantperiodseconds_;
}
inline int32_t RentalTerms::deprecatedgrantperiodseconds() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.RentalTerms.DEPRECATEDGrantPeriodSeconds)
  return _internal_deprecatedgrantperiodseconds();
}
inline void RentalTerms::_internal_set_deprecatedgrantperiodseconds(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.deprecatedgrantperiodseconds_ = value;
}
inline void RentalTerms::set_deprecatedgrantperiodseconds(int32_t value) {
  _internal_set_deprecatedgrantperiodseconds(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.RentalTerms.DEPRECATEDGrantPeriodSeconds)
}

// optional int32 DEPRECATEDActivatePeriodSeconds = 2;
inline bool RentalTerms::_internal_has_deprecatedactivateperiodseconds() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RentalTerms::has_deprecatedactivateperiodseconds() const {
  return _internal_has_deprecatedactivateperiodseconds();
}
inline void RentalTerms::clear_deprecatedactivateperiodseconds() {
  _impl_.deprecatedactivateperiodseconds_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t RentalTerms::_internal_deprecatedactivateperiodseconds() const {
  return _impl_.deprecatedactivateperiodseconds_;
}
inline int32_t RentalTerms::deprecatedactivateperiodseconds() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.RentalTerms.DEPRECATEDActivatePeriodSeconds)
  return _internal_deprecatedactivateperiodseconds();
}
inline void RentalTerms::_internal_set_deprecatedactivateperiodseconds(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.deprecatedactivateperiodseconds_ = value;
}
inline void RentalTerms::set_deprecatedactivateperiodseconds(int32_t value) {
  _internal_set_deprecatedactivateperiodseconds(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.RentalTerms.DEPRECATEDActivatePeriodSeconds)
}

// optional .playapi.proto.finsky.TimePeriod grantPeriod = 3;
inline bool RentalTerms::_internal_has_grantperiod() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.grantperiod_ != nullptr);
  return value;
}
inline bool RentalTerms::has_grantperiod() const {
  return _internal_has_grantperiod();
}
inline void RentalTerms::clear_grantperiod() {
  if (_impl_.grantperiod_ != nullptr) _impl_.grantperiod_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::playapi::proto::finsky::TimePeriod& RentalTerms::_internal_grantperiod() const {
  const ::playapi::proto::finsky::TimePeriod* p = _impl_.grantperiod_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::TimePeriod&>(
      ::playapi::proto::finsky::_TimePeriod_default_instance_);
}
inline const ::playapi::proto::finsky::TimePeriod& RentalTerms::grantperiod() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.RentalTerms.grantPeriod)
  return _internal_grantperiod();
}
inline void RentalTerms::unsafe_arena_set_allocated_grantperiod(
    ::playapi::proto::finsky::TimePeriod* grantperiod) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.grantperiod_);
  }
  _impl_.grantperiod_ = grantperiod;
  if (grantperiod) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.RentalTerms.grantPeriod)
}
inline ::playapi::proto::finsky::TimePeriod* RentalTerms::release_grantperiod() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::playapi::proto::finsky::TimePeriod* temp = _impl_.grantperiod_;
  _impl_.grantperiod_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::TimePeriod* RentalTerms::unsafe_arena_release_grantperiod() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.RentalTerms.grantPeriod)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::playapi::proto::finsky::TimePeriod* temp = _impl_.grantperiod_;
  _impl_.grantperiod_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::TimePeriod* RentalTerms::_internal_mutable_grantperiod() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.grantperiod_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::TimePeriod>(GetArenaForAllocation());
    _impl_.grantperiod_ = p;
  }
  return _impl_.grantperiod_;
}
inline ::playapi::proto::finsky::TimePeriod* RentalTerms::mutable_grantperiod() {
  ::playapi::proto::finsky::TimePeriod* _msg = _internal_mutable_grantperiod();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.RentalTerms.grantPeriod)
  return _msg;
}
inline void RentalTerms::set_allocated_grantperiod(::playapi::proto::finsky::TimePeriod* grantperiod) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.grantperiod_;
  }
  if (grantperiod) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(grantperiod);
    if (message_arena != submessage_arena) {
      grantperiod = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, grantperiod, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.grantperiod_ = grantperiod;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.RentalTerms.grantPeriod)
}

// optional .playapi.proto.finsky.TimePeriod activatePeriod = 4;
inline bool RentalTerms::_internal_has_activateperiod() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.activateperiod_ != nullptr);
  return value;
}
inline bool RentalTerms::has_activateperiod() const {
  return _internal_has_activateperiod();
}
inline void RentalTerms::clear_activateperiod() {
  if (_impl_.activateperiod_ != nullptr) _impl_.activateperiod_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::playapi::proto::finsky::TimePeriod& RentalTerms::_internal_activateperiod() const {
  const ::playapi::proto::finsky::TimePeriod* p = _impl_.activateperiod_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::TimePeriod&>(
      ::playapi::proto::finsky::_TimePeriod_default_instance_);
}
inline const ::playapi::proto::finsky::TimePeriod& RentalTerms::activateperiod() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.RentalTerms.activatePeriod)
  return _internal_activateperiod();
}
inline void RentalTerms::unsafe_arena_set_allocated_activateperiod(
    ::playapi::proto::finsky::TimePeriod* activateperiod) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.activateperiod_);
  }
  _impl_.activateperiod_ = activateperiod;
  if (activateperiod) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.RentalTerms.activatePeriod)
}
inline ::playapi::proto::finsky::TimePeriod* RentalTerms::release_activateperiod() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::playapi::proto::finsky::TimePeriod* temp = _impl_.activateperiod_;
  _impl_.activateperiod_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::TimePeriod* RentalTerms::unsafe_arena_release_activateperiod() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.RentalTerms.activatePeriod)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::playapi::proto::finsky::TimePeriod* temp = _impl_.activateperiod_;
  _impl_.activateperiod_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::TimePeriod* RentalTerms::_internal_mutable_activateperiod() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.activateperiod_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::TimePeriod>(GetArenaForAllocation());
    _impl_.activateperiod_ = p;
  }
  return _impl_.activateperiod_;
}
inline ::playapi::proto::finsky::TimePeriod* RentalTerms::mutable_activateperiod() {
  ::playapi::proto::finsky::TimePeriod* _msg = _internal_mutable_activateperiod();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.RentalTerms.activatePeriod)
  return _msg;
}
inline void RentalTerms::set_allocated_activateperiod(::playapi::proto::finsky::TimePeriod* activateperiod) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.activateperiod_;
  }
  if (activateperiod) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(activateperiod);
    if (message_arena != submessage_arena) {
      activateperiod = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, activateperiod, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.activateperiod_ = activateperiod;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.RentalTerms.activatePeriod)
}

// optional int64 grantEndTimeSeconds = 5;
inline bool RentalTerms::_internal_has_grantendtimeseconds() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool RentalTerms::has_grantendtimeseconds() const {
  return _internal_has_grantendtimeseconds();
}
inline void RentalTerms::clear_grantendtimeseconds() {
  _impl_.grantendtimeseconds_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int64_t RentalTerms::_internal_grantendtimeseconds() const {
  return _impl_.grantendtimeseconds_;
}
inline int64_t RentalTerms::grantendtimeseconds() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.RentalTerms.grantEndTimeSeconds)
  return _internal_grantendtimeseconds();
}
inline void RentalTerms::_internal_set_grantendtimeseconds(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.grantendtimeseconds_ = value;
}
inline void RentalTerms::set_grantendtimeseconds(int64_t value) {
  _internal_set_grantendtimeseconds(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.RentalTerms.grantEndTimeSeconds)
}

// -------------------------------------------------------------------

// OfferPayment

// optional int64 micros = 1;
inline bool OfferPayment::_internal_has_micros() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool OfferPayment::has_micros() const {
  return _internal_has_micros();
}
inline void OfferPayment::clear_micros() {
  _impl_.micros_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t OfferPayment::_internal_micros() const {
  return _impl_.micros_;
}
inline int64_t OfferPayment::micros() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.OfferPayment.micros)
  return _internal_micros();
}
inline void OfferPayment::_internal_set_micros(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.micros_ = value;
}
inline void OfferPayment::set_micros(int64_t value) {
  _internal_set_micros(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.OfferPayment.micros)
}

// optional string currencyCode = 2;
inline bool OfferPayment::_internal_has_currencycode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OfferPayment::has_currencycode() const {
  return _internal_has_currencycode();
}
inline void OfferPayment::clear_currencycode() {
  _impl_.currencycode_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OfferPayment::currencycode() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.OfferPayment.currencyCode)
  return _internal_currencycode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OfferPayment::set_currencycode(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.currencycode_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.OfferPayment.currencyCode)
}
inline std::string* OfferPayment::mutable_currencycode() {
  std::string* _s = _internal_mutable_currencycode();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.OfferPayment.currencyCode)
  return _s;
}
inline const std::string& OfferPayment::_internal_currencycode() const {
  return _impl_.currencycode_.Get();
}
inline void OfferPayment::_internal_set_currencycode(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.currencycode_.Set(value, GetArenaForAllocation());
}
inline std::string* OfferPayment::_internal_mutable_currencycode() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.currencycode_.Mutable(GetArenaForAllocation());
}
inline std::string* OfferPayment::release_currencycode() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.OfferPayment.currencyCode)
  if (!_internal_has_currencycode()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.currencycode_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.currencycode_.IsDefault()) {
    _impl_.currencycode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OfferPayment::set_allocated_currencycode(std::string* currencycode) {
  if (currencycode != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.currencycode_.SetAllocated(currencycode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.currencycode_.IsDefault()) {
    _impl_.currencycode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.OfferPayment.currencyCode)
}

// optional .playapi.proto.finsky.OfferPaymentPeriod offerPaymentPeriod = 3;
inline bool OfferPayment::_internal_has_offerpaymentperiod() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.offerpaymentperiod_ != nullptr);
  return value;
}
inline bool OfferPayment::has_offerpaymentperiod() const {
  return _internal_has_offerpaymentperiod();
}
inline void OfferPayment::clear_offerpaymentperiod() {
  if (_impl_.offerpaymentperiod_ != nullptr) _impl_.offerpaymentperiod_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::playapi::proto::finsky::OfferPaymentPeriod& OfferPayment::_internal_offerpaymentperiod() const {
  const ::playapi::proto::finsky::OfferPaymentPeriod* p = _impl_.offerpaymentperiod_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::OfferPaymentPeriod&>(
      ::playapi::proto::finsky::_OfferPaymentPeriod_default_instance_);
}
inline const ::playapi::proto::finsky::OfferPaymentPeriod& OfferPayment::offerpaymentperiod() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.OfferPayment.offerPaymentPeriod)
  return _internal_offerpaymentperiod();
}
inline void OfferPayment::unsafe_arena_set_allocated_offerpaymentperiod(
    ::playapi::proto::finsky::OfferPaymentPeriod* offerpaymentperiod) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.offerpaymentperiod_);
  }
  _impl_.offerpaymentperiod_ = offerpaymentperiod;
  if (offerpaymentperiod) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.OfferPayment.offerPaymentPeriod)
}
inline ::playapi::proto::finsky::OfferPaymentPeriod* OfferPayment::release_offerpaymentperiod() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::playapi::proto::finsky::OfferPaymentPeriod* temp = _impl_.offerpaymentperiod_;
  _impl_.offerpaymentperiod_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::OfferPaymentPeriod* OfferPayment::unsafe_arena_release_offerpaymentperiod() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.OfferPayment.offerPaymentPeriod)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::playapi::proto::finsky::OfferPaymentPeriod* temp = _impl_.offerpaymentperiod_;
  _impl_.offerpaymentperiod_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::OfferPaymentPeriod* OfferPayment::_internal_mutable_offerpaymentperiod() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.offerpaymentperiod_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::OfferPaymentPeriod>(GetArenaForAllocation());
    _impl_.offerpaymentperiod_ = p;
  }
  return _impl_.offerpaymentperiod_;
}
inline ::playapi::proto::finsky::OfferPaymentPeriod* OfferPayment::mutable_offerpaymentperiod() {
  ::playapi::proto::finsky::OfferPaymentPeriod* _msg = _internal_mutable_offerpaymentperiod();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.OfferPayment.offerPaymentPeriod)
  return _msg;
}
inline void OfferPayment::set_allocated_offerpaymentperiod(::playapi::proto::finsky::OfferPaymentPeriod* offerpaymentperiod) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.offerpaymentperiod_;
  }
  if (offerpaymentperiod) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(offerpaymentperiod);
    if (message_arena != submessage_arena) {
      offerpaymentperiod = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, offerpaymentperiod, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.offerpaymentperiod_ = offerpaymentperiod;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.OfferPayment.offerPaymentPeriod)
}

// repeated .playapi.proto.finsky.OfferPaymentOverride offerPaymentOverride = 4;
inline int OfferPayment::_internal_offerpaymentoverride_size() const {
  return _impl_.offerpaymentoverride_.size();
}
inline int OfferPayment::offerpaymentoverride_size() const {
  return _internal_offerpaymentoverride_size();
}
inline void OfferPayment::clear_offerpaymentoverride() {
  _impl_.offerpaymentoverride_.Clear();
}
inline ::playapi::proto::finsky::OfferPaymentOverride* OfferPayment::mutable_offerpaymentoverride(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.OfferPayment.offerPaymentOverride)
  return _impl_.offerpaymentoverride_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::OfferPaymentOverride >*
OfferPayment::mutable_offerpaymentoverride() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.OfferPayment.offerPaymentOverride)
  return &_impl_.offerpaymentoverride_;
}
inline const ::playapi::proto::finsky::OfferPaymentOverride& OfferPayment::_internal_offerpaymentoverride(int index) const {
  return _impl_.offerpaymentoverride_.Get(index);
}
inline const ::playapi::proto::finsky::OfferPaymentOverride& OfferPayment::offerpaymentoverride(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.OfferPayment.offerPaymentOverride)
  return _internal_offerpaymentoverride(index);
}
inline ::playapi::proto::finsky::OfferPaymentOverride* OfferPayment::_internal_add_offerpaymentoverride() {
  return _impl_.offerpaymentoverride_.Add();
}
inline ::playapi::proto::finsky::OfferPaymentOverride* OfferPayment::add_offerpaymentoverride() {
  ::playapi::proto::finsky::OfferPaymentOverride* _add = _internal_add_offerpaymentoverride();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.OfferPayment.offerPaymentOverride)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::OfferPaymentOverride >&
OfferPayment::offerpaymentoverride() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.OfferPayment.offerPaymentOverride)
  return _impl_.offerpaymentoverride_;
}

// -------------------------------------------------------------------

// OfferPaymentPeriod

// optional .playapi.proto.finsky.TimePeriod duration = 1;
inline bool OfferPaymentPeriod::_internal_has_duration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.duration_ != nullptr);
  return value;
}
inline bool OfferPaymentPeriod::has_duration() const {
  return _internal_has_duration();
}
inline void OfferPaymentPeriod::clear_duration() {
  if (_impl_.duration_ != nullptr) _impl_.duration_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::playapi::proto::finsky::TimePeriod& OfferPaymentPeriod::_internal_duration() const {
  const ::playapi::proto::finsky::TimePeriod* p = _impl_.duration_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::TimePeriod&>(
      ::playapi::proto::finsky::_TimePeriod_default_instance_);
}
inline const ::playapi::proto::finsky::TimePeriod& OfferPaymentPeriod::duration() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.OfferPaymentPeriod.duration)
  return _internal_duration();
}
inline void OfferPaymentPeriod::unsafe_arena_set_allocated_duration(
    ::playapi::proto::finsky::TimePeriod* duration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.duration_);
  }
  _impl_.duration_ = duration;
  if (duration) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.OfferPaymentPeriod.duration)
}
inline ::playapi::proto::finsky::TimePeriod* OfferPaymentPeriod::release_duration() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::playapi::proto::finsky::TimePeriod* temp = _impl_.duration_;
  _impl_.duration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::TimePeriod* OfferPaymentPeriod::unsafe_arena_release_duration() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.OfferPaymentPeriod.duration)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::playapi::proto::finsky::TimePeriod* temp = _impl_.duration_;
  _impl_.duration_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::TimePeriod* OfferPaymentPeriod::_internal_mutable_duration() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.duration_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::TimePeriod>(GetArenaForAllocation());
    _impl_.duration_ = p;
  }
  return _impl_.duration_;
}
inline ::playapi::proto::finsky::TimePeriod* OfferPaymentPeriod::mutable_duration() {
  ::playapi::proto::finsky::TimePeriod* _msg = _internal_mutable_duration();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.OfferPaymentPeriod.duration)
  return _msg;
}
inline void OfferPaymentPeriod::set_allocated_duration(::playapi::proto::finsky::TimePeriod* duration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.duration_;
  }
  if (duration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(duration);
    if (message_arena != submessage_arena) {
      duration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, duration, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.duration_ = duration;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.OfferPaymentPeriod.duration)
}

// optional .playapi.proto.finsky.MonthAndDay start = 2;
inline bool OfferPaymentPeriod::_internal_has_start() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.start_ != nullptr);
  return value;
}
inline bool OfferPaymentPeriod::has_start() const {
  return _internal_has_start();
}
inline void OfferPaymentPeriod::clear_start() {
  if (_impl_.start_ != nullptr) _impl_.start_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::playapi::proto::finsky::MonthAndDay& OfferPaymentPeriod::_internal_start() const {
  const ::playapi::proto::finsky::MonthAndDay* p = _impl_.start_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::MonthAndDay&>(
      ::playapi::proto::finsky::_MonthAndDay_default_instance_);
}
inline const ::playapi::proto::finsky::MonthAndDay& OfferPaymentPeriod::start() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.OfferPaymentPeriod.start)
  return _internal_start();
}
inline void OfferPaymentPeriod::unsafe_arena_set_allocated_start(
    ::playapi::proto::finsky::MonthAndDay* start) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_);
  }
  _impl_.start_ = start;
  if (start) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.OfferPaymentPeriod.start)
}
inline ::playapi::proto::finsky::MonthAndDay* OfferPaymentPeriod::release_start() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::playapi::proto::finsky::MonthAndDay* temp = _impl_.start_;
  _impl_.start_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::MonthAndDay* OfferPaymentPeriod::unsafe_arena_release_start() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.OfferPaymentPeriod.start)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::playapi::proto::finsky::MonthAndDay* temp = _impl_.start_;
  _impl_.start_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::MonthAndDay* OfferPaymentPeriod::_internal_mutable_start() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.start_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::MonthAndDay>(GetArenaForAllocation());
    _impl_.start_ = p;
  }
  return _impl_.start_;
}
inline ::playapi::proto::finsky::MonthAndDay* OfferPaymentPeriod::mutable_start() {
  ::playapi::proto::finsky::MonthAndDay* _msg = _internal_mutable_start();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.OfferPaymentPeriod.start)
  return _msg;
}
inline void OfferPaymentPeriod::set_allocated_start(::playapi::proto::finsky::MonthAndDay* start) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.start_;
  }
  if (start) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(start);
    if (message_arena != submessage_arena) {
      start = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.start_ = start;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.OfferPaymentPeriod.start)
}

// optional .playapi.proto.finsky.MonthAndDay end = 3;
inline bool OfferPaymentPeriod::_internal_has_end() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.end_ != nullptr);
  return value;
}
inline bool OfferPaymentPeriod::has_end() const {
  return _internal_has_end();
}
inline void OfferPaymentPeriod::clear_end() {
  if (_impl_.end_ != nullptr) _impl_.end_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::playapi::proto::finsky::MonthAndDay& OfferPaymentPeriod::_internal_end() const {
  const ::playapi::proto::finsky::MonthAndDay* p = _impl_.end_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::MonthAndDay&>(
      ::playapi::proto::finsky::_MonthAndDay_default_instance_);
}
inline const ::playapi::proto::finsky::MonthAndDay& OfferPaymentPeriod::end() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.OfferPaymentPeriod.end)
  return _internal_end();
}
inline void OfferPaymentPeriod::unsafe_arena_set_allocated_end(
    ::playapi::proto::finsky::MonthAndDay* end) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_);
  }
  _impl_.end_ = end;
  if (end) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.OfferPaymentPeriod.end)
}
inline ::playapi::proto::finsky::MonthAndDay* OfferPaymentPeriod::release_end() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::playapi::proto::finsky::MonthAndDay* temp = _impl_.end_;
  _impl_.end_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::MonthAndDay* OfferPaymentPeriod::unsafe_arena_release_end() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.OfferPaymentPeriod.end)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::playapi::proto::finsky::MonthAndDay* temp = _impl_.end_;
  _impl_.end_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::MonthAndDay* OfferPaymentPeriod::_internal_mutable_end() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.end_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::MonthAndDay>(GetArenaForAllocation());
    _impl_.end_ = p;
  }
  return _impl_.end_;
}
inline ::playapi::proto::finsky::MonthAndDay* OfferPaymentPeriod::mutable_end() {
  ::playapi::proto::finsky::MonthAndDay* _msg = _internal_mutable_end();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.OfferPaymentPeriod.end)
  return _msg;
}
inline void OfferPaymentPeriod::set_allocated_end(::playapi::proto::finsky::MonthAndDay* end) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.end_;
  }
  if (end) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(end);
    if (message_arena != submessage_arena) {
      end = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.end_ = end;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.OfferPaymentPeriod.end)
}

// -------------------------------------------------------------------

// OfferPaymentOverride

// optional int64 micros = 1;
inline bool OfferPaymentOverride::_internal_has_micros() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool OfferPaymentOverride::has_micros() const {
  return _internal_has_micros();
}
inline void OfferPaymentOverride::clear_micros() {
  _impl_.micros_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t OfferPaymentOverride::_internal_micros() const {
  return _impl_.micros_;
}
inline int64_t OfferPaymentOverride::micros() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.OfferPaymentOverride.micros)
  return _internal_micros();
}
inline void OfferPaymentOverride::_internal_set_micros(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.micros_ = value;
}
inline void OfferPaymentOverride::set_micros(int64_t value) {
  _internal_set_micros(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.OfferPaymentOverride.micros)
}

// optional .playapi.proto.finsky.MonthAndDay start = 2;
inline bool OfferPaymentOverride::_internal_has_start() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.start_ != nullptr);
  return value;
}
inline bool OfferPaymentOverride::has_start() const {
  return _internal_has_start();
}
inline void OfferPaymentOverride::clear_start() {
  if (_impl_.start_ != nullptr) _impl_.start_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::playapi::proto::finsky::MonthAndDay& OfferPaymentOverride::_internal_start() const {
  const ::playapi::proto::finsky::MonthAndDay* p = _impl_.start_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::MonthAndDay&>(
      ::playapi::proto::finsky::_MonthAndDay_default_instance_);
}
inline const ::playapi::proto::finsky::MonthAndDay& OfferPaymentOverride::start() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.OfferPaymentOverride.start)
  return _internal_start();
}
inline void OfferPaymentOverride::unsafe_arena_set_allocated_start(
    ::playapi::proto::finsky::MonthAndDay* start) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_);
  }
  _impl_.start_ = start;
  if (start) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.OfferPaymentOverride.start)
}
inline ::playapi::proto::finsky::MonthAndDay* OfferPaymentOverride::release_start() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::playapi::proto::finsky::MonthAndDay* temp = _impl_.start_;
  _impl_.start_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::MonthAndDay* OfferPaymentOverride::unsafe_arena_release_start() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.OfferPaymentOverride.start)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::playapi::proto::finsky::MonthAndDay* temp = _impl_.start_;
  _impl_.start_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::MonthAndDay* OfferPaymentOverride::_internal_mutable_start() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.start_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::MonthAndDay>(GetArenaForAllocation());
    _impl_.start_ = p;
  }
  return _impl_.start_;
}
inline ::playapi::proto::finsky::MonthAndDay* OfferPaymentOverride::mutable_start() {
  ::playapi::proto::finsky::MonthAndDay* _msg = _internal_mutable_start();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.OfferPaymentOverride.start)
  return _msg;
}
inline void OfferPaymentOverride::set_allocated_start(::playapi::proto::finsky::MonthAndDay* start) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.start_;
  }
  if (start) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(start);
    if (message_arena != submessage_arena) {
      start = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.start_ = start;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.OfferPaymentOverride.start)
}

// optional .playapi.proto.finsky.MonthAndDay end = 3;
inline bool OfferPaymentOverride::_internal_has_end() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.end_ != nullptr);
  return value;
}
inline bool OfferPaymentOverride::has_end() const {
  return _internal_has_end();
}
inline void OfferPaymentOverride::clear_end() {
  if (_impl_.end_ != nullptr) _impl_.end_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::playapi::proto::finsky::MonthAndDay& OfferPaymentOverride::_internal_end() const {
  const ::playapi::proto::finsky::MonthAndDay* p = _impl_.end_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::MonthAndDay&>(
      ::playapi::proto::finsky::_MonthAndDay_default_instance_);
}
inline const ::playapi::proto::finsky::MonthAndDay& OfferPaymentOverride::end() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.OfferPaymentOverride.end)
  return _internal_end();
}
inline void OfferPaymentOverride::unsafe_arena_set_allocated_end(
    ::playapi::proto::finsky::MonthAndDay* end) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_);
  }
  _impl_.end_ = end;
  if (end) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.OfferPaymentOverride.end)
}
inline ::playapi::proto::finsky::MonthAndDay* OfferPaymentOverride::release_end() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::playapi::proto::finsky::MonthAndDay* temp = _impl_.end_;
  _impl_.end_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::MonthAndDay* OfferPaymentOverride::unsafe_arena_release_end() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.OfferPaymentOverride.end)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::playapi::proto::finsky::MonthAndDay* temp = _impl_.end_;
  _impl_.end_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::MonthAndDay* OfferPaymentOverride::_internal_mutable_end() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.end_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::MonthAndDay>(GetArenaForAllocation());
    _impl_.end_ = p;
  }
  return _impl_.end_;
}
inline ::playapi::proto::finsky::MonthAndDay* OfferPaymentOverride::mutable_end() {
  ::playapi::proto::finsky::MonthAndDay* _msg = _internal_mutable_end();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.OfferPaymentOverride.end)
  return _msg;
}
inline void OfferPaymentOverride::set_allocated_end(::playapi::proto::finsky::MonthAndDay* end) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.end_;
  }
  if (end) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(end);
    if (message_arena != submessage_arena) {
      end = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.end_ = end;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.OfferPaymentOverride.end)
}

// -------------------------------------------------------------------

// SeasonalSubscriptionInfo_Payment

// optional int64 micros = 1;
inline bool SeasonalSubscriptionInfo_Payment::_internal_has_micros() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SeasonalSubscriptionInfo_Payment::has_micros() const {
  return _internal_has_micros();
}
inline void SeasonalSubscriptionInfo_Payment::clear_micros() {
  _impl_.micros_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int64_t SeasonalSubscriptionInfo_Payment::_internal_micros() const {
  return _impl_.micros_;
}
inline int64_t SeasonalSubscriptionInfo_Payment::micros() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.SeasonalSubscriptionInfo.Payment.micros)
  return _internal_micros();
}
inline void SeasonalSubscriptionInfo_Payment::_internal_set_micros(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.micros_ = value;
}
inline void SeasonalSubscriptionInfo_Payment::set_micros(int64_t value) {
  _internal_set_micros(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.SeasonalSubscriptionInfo.Payment.micros)
}

// optional string currencyCode = 2;
inline bool SeasonalSubscriptionInfo_Payment::_internal_has_currencycode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SeasonalSubscriptionInfo_Payment::has_currencycode() const {
  return _internal_has_currencycode();
}
inline void SeasonalSubscriptionInfo_Payment::clear_currencycode() {
  _impl_.currencycode_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SeasonalSubscriptionInfo_Payment::currencycode() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.SeasonalSubscriptionInfo.Payment.currencyCode)
  return _internal_currencycode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SeasonalSubscriptionInfo_Payment::set_currencycode(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.currencycode_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.SeasonalSubscriptionInfo.Payment.currencyCode)
}
inline std::string* SeasonalSubscriptionInfo_Payment::mutable_currencycode() {
  std::string* _s = _internal_mutable_currencycode();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.SeasonalSubscriptionInfo.Payment.currencyCode)
  return _s;
}
inline const std::string& SeasonalSubscriptionInfo_Payment::_internal_currencycode() const {
  return _impl_.currencycode_.Get();
}
inline void SeasonalSubscriptionInfo_Payment::_internal_set_currencycode(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.currencycode_.Set(value, GetArenaForAllocation());
}
inline std::string* SeasonalSubscriptionInfo_Payment::_internal_mutable_currencycode() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.currencycode_.Mutable(GetArenaForAllocation());
}
inline std::string* SeasonalSubscriptionInfo_Payment::release_currencycode() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.SeasonalSubscriptionInfo.Payment.currencyCode)
  if (!_internal_has_currencycode()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.currencycode_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.currencycode_.IsDefault()) {
    _impl_.currencycode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SeasonalSubscriptionInfo_Payment::set_allocated_currencycode(std::string* currencycode) {
  if (currencycode != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.currencycode_.SetAllocated(currencycode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.currencycode_.IsDefault()) {
    _impl_.currencycode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.SeasonalSubscriptionInfo.Payment.currencyCode)
}

// optional string formattedAmount = 3;
inline bool SeasonalSubscriptionInfo_Payment::_internal_has_formattedamount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SeasonalSubscriptionInfo_Payment::has_formattedamount() const {
  return _internal_has_formattedamount();
}
inline void SeasonalSubscriptionInfo_Payment::clear_formattedamount() {
  _impl_.formattedamount_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SeasonalSubscriptionInfo_Payment::formattedamount() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.SeasonalSubscriptionInfo.Payment.formattedAmount)
  return _internal_formattedamount();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SeasonalSubscriptionInfo_Payment::set_formattedamount(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.formattedamount_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.SeasonalSubscriptionInfo.Payment.formattedAmount)
}
inline std::string* SeasonalSubscriptionInfo_Payment::mutable_formattedamount() {
  std::string* _s = _internal_mutable_formattedamount();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.SeasonalSubscriptionInfo.Payment.formattedAmount)
  return _s;
}
inline const std::string& SeasonalSubscriptionInfo_Payment::_internal_formattedamount() const {
  return _impl_.formattedamount_.Get();
}
inline void SeasonalSubscriptionInfo_Payment::_internal_set_formattedamount(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.formattedamount_.Set(value, GetArenaForAllocation());
}
inline std::string* SeasonalSubscriptionInfo_Payment::_internal_mutable_formattedamount() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.formattedamount_.Mutable(GetArenaForAllocation());
}
inline std::string* SeasonalSubscriptionInfo_Payment::release_formattedamount() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.SeasonalSubscriptionInfo.Payment.formattedAmount)
  if (!_internal_has_formattedamount()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.formattedamount_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.formattedamount_.IsDefault()) {
    _impl_.formattedamount_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SeasonalSubscriptionInfo_Payment::set_allocated_formattedamount(std::string* formattedamount) {
  if (formattedamount != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.formattedamount_.SetAllocated(formattedamount, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.formattedamount_.IsDefault()) {
    _impl_.formattedamount_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.SeasonalSubscriptionInfo.Payment.formattedAmount)
}

// optional .playapi.proto.finsky.TimePeriod period = 4;
inline bool SeasonalSubscriptionInfo_Payment::_internal_has_period() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.period_ != nullptr);
  return value;
}
inline bool SeasonalSubscriptionInfo_Payment::has_period() const {
  return _internal_has_period();
}
inline void SeasonalSubscriptionInfo_Payment::clear_period() {
  if (_impl_.period_ != nullptr) _impl_.period_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::playapi::proto::finsky::TimePeriod& SeasonalSubscriptionInfo_Payment::_internal_period() const {
  const ::playapi::proto::finsky::TimePeriod* p = _impl_.period_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::TimePeriod&>(
      ::playapi::proto::finsky::_TimePeriod_default_instance_);
}
inline const ::playapi::proto::finsky::TimePeriod& SeasonalSubscriptionInfo_Payment::period() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.SeasonalSubscriptionInfo.Payment.period)
  return _internal_period();
}
inline void SeasonalSubscriptionInfo_Payment::unsafe_arena_set_allocated_period(
    ::playapi::proto::finsky::TimePeriod* period) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.period_);
  }
  _impl_.period_ = period;
  if (period) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.SeasonalSubscriptionInfo.Payment.period)
}
inline ::playapi::proto::finsky::TimePeriod* SeasonalSubscriptionInfo_Payment::release_period() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::playapi::proto::finsky::TimePeriod* temp = _impl_.period_;
  _impl_.period_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::TimePeriod* SeasonalSubscriptionInfo_Payment::unsafe_arena_release_period() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.SeasonalSubscriptionInfo.Payment.period)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::playapi::proto::finsky::TimePeriod* temp = _impl_.period_;
  _impl_.period_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::TimePeriod* SeasonalSubscriptionInfo_Payment::_internal_mutable_period() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.period_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::TimePeriod>(GetArenaForAllocation());
    _impl_.period_ = p;
  }
  return _impl_.period_;
}
inline ::playapi::proto::finsky::TimePeriod* SeasonalSubscriptionInfo_Payment::mutable_period() {
  ::playapi::proto::finsky::TimePeriod* _msg = _internal_mutable_period();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.SeasonalSubscriptionInfo.Payment.period)
  return _msg;
}
inline void SeasonalSubscriptionInfo_Payment::set_allocated_period(::playapi::proto::finsky::TimePeriod* period) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.period_;
  }
  if (period) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(period);
    if (message_arena != submessage_arena) {
      period = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, period, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.period_ = period;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.SeasonalSubscriptionInfo.Payment.period)
}

// -------------------------------------------------------------------

// SeasonalSubscriptionInfo

// optional .playapi.proto.finsky.MonthAndDay periodStart = 1;
inline bool SeasonalSubscriptionInfo::_internal_has_periodstart() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.periodstart_ != nullptr);
  return value;
}
inline bool SeasonalSubscriptionInfo::has_periodstart() const {
  return _internal_has_periodstart();
}
inline void SeasonalSubscriptionInfo::clear_periodstart() {
  if (_impl_.periodstart_ != nullptr) _impl_.periodstart_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::playapi::proto::finsky::MonthAndDay& SeasonalSubscriptionInfo::_internal_periodstart() const {
  const ::playapi::proto::finsky::MonthAndDay* p = _impl_.periodstart_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::MonthAndDay&>(
      ::playapi::proto::finsky::_MonthAndDay_default_instance_);
}
inline const ::playapi::proto::finsky::MonthAndDay& SeasonalSubscriptionInfo::periodstart() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.SeasonalSubscriptionInfo.periodStart)
  return _internal_periodstart();
}
inline void SeasonalSubscriptionInfo::unsafe_arena_set_allocated_periodstart(
    ::playapi::proto::finsky::MonthAndDay* periodstart) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.periodstart_);
  }
  _impl_.periodstart_ = periodstart;
  if (periodstart) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.SeasonalSubscriptionInfo.periodStart)
}
inline ::playapi::proto::finsky::MonthAndDay* SeasonalSubscriptionInfo::release_periodstart() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::playapi::proto::finsky::MonthAndDay* temp = _impl_.periodstart_;
  _impl_.periodstart_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::MonthAndDay* SeasonalSubscriptionInfo::unsafe_arena_release_periodstart() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.SeasonalSubscriptionInfo.periodStart)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::playapi::proto::finsky::MonthAndDay* temp = _impl_.periodstart_;
  _impl_.periodstart_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::MonthAndDay* SeasonalSubscriptionInfo::_internal_mutable_periodstart() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.periodstart_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::MonthAndDay>(GetArenaForAllocation());
    _impl_.periodstart_ = p;
  }
  return _impl_.periodstart_;
}
inline ::playapi::proto::finsky::MonthAndDay* SeasonalSubscriptionInfo::mutable_periodstart() {
  ::playapi::proto::finsky::MonthAndDay* _msg = _internal_mutable_periodstart();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.SeasonalSubscriptionInfo.periodStart)
  return _msg;
}
inline void SeasonalSubscriptionInfo::set_allocated_periodstart(::playapi::proto::finsky::MonthAndDay* periodstart) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.periodstart_;
  }
  if (periodstart) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(periodstart);
    if (message_arena != submessage_arena) {
      periodstart = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, periodstart, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.periodstart_ = periodstart;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.SeasonalSubscriptionInfo.periodStart)
}

// optional .playapi.proto.finsky.MonthAndDay periodEnd = 2;
inline bool SeasonalSubscriptionInfo::_internal_has_periodend() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.periodend_ != nullptr);
  return value;
}
inline bool SeasonalSubscriptionInfo::has_periodend() const {
  return _internal_has_periodend();
}
inline void SeasonalSubscriptionInfo::clear_periodend() {
  if (_impl_.periodend_ != nullptr) _impl_.periodend_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::playapi::proto::finsky::MonthAndDay& SeasonalSubscriptionInfo::_internal_periodend() const {
  const ::playapi::proto::finsky::MonthAndDay* p = _impl_.periodend_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::MonthAndDay&>(
      ::playapi::proto::finsky::_MonthAndDay_default_instance_);
}
inline const ::playapi::proto::finsky::MonthAndDay& SeasonalSubscriptionInfo::periodend() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.SeasonalSubscriptionInfo.periodEnd)
  return _internal_periodend();
}
inline void SeasonalSubscriptionInfo::unsafe_arena_set_allocated_periodend(
    ::playapi::proto::finsky::MonthAndDay* periodend) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.periodend_);
  }
  _impl_.periodend_ = periodend;
  if (periodend) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.SeasonalSubscriptionInfo.periodEnd)
}
inline ::playapi::proto::finsky::MonthAndDay* SeasonalSubscriptionInfo::release_periodend() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::playapi::proto::finsky::MonthAndDay* temp = _impl_.periodend_;
  _impl_.periodend_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::MonthAndDay* SeasonalSubscriptionInfo::unsafe_arena_release_periodend() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.SeasonalSubscriptionInfo.periodEnd)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::playapi::proto::finsky::MonthAndDay* temp = _impl_.periodend_;
  _impl_.periodend_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::MonthAndDay* SeasonalSubscriptionInfo::_internal_mutable_periodend() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.periodend_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::MonthAndDay>(GetArenaForAllocation());
    _impl_.periodend_ = p;
  }
  return _impl_.periodend_;
}
inline ::playapi::proto::finsky::MonthAndDay* SeasonalSubscriptionInfo::mutable_periodend() {
  ::playapi::proto::finsky::MonthAndDay* _msg = _internal_mutable_periodend();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.SeasonalSubscriptionInfo.periodEnd)
  return _msg;
}
inline void SeasonalSubscriptionInfo::set_allocated_periodend(::playapi::proto::finsky::MonthAndDay* periodend) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.periodend_;
  }
  if (periodend) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(periodend);
    if (message_arena != submessage_arena) {
      periodend = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, periodend, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.periodend_ = periodend;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.SeasonalSubscriptionInfo.periodEnd)
}

// optional bool prorated = 4;
inline bool SeasonalSubscriptionInfo::_internal_has_prorated() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SeasonalSubscriptionInfo::has_prorated() const {
  return _internal_has_prorated();
}
inline void SeasonalSubscriptionInfo::clear_prorated() {
  _impl_.prorated_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool SeasonalSubscriptionInfo::_internal_prorated() const {
  return _impl_.prorated_;
}
inline bool SeasonalSubscriptionInfo::prorated() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.SeasonalSubscriptionInfo.prorated)
  return _internal_prorated();
}
inline void SeasonalSubscriptionInfo::_internal_set_prorated(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.prorated_ = value;
}
inline void SeasonalSubscriptionInfo::set_prorated(bool value) {
  _internal_set_prorated(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.SeasonalSubscriptionInfo.prorated)
}

// optional .playapi.proto.finsky.SeasonalSubscriptionInfo.Payment postTrialConversionPayment = 5;
inline bool SeasonalSubscriptionInfo::_internal_has_posttrialconversionpayment() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.posttrialconversionpayment_ != nullptr);
  return value;
}
inline bool SeasonalSubscriptionInfo::has_posttrialconversionpayment() const {
  return _internal_has_posttrialconversionpayment();
}
inline void SeasonalSubscriptionInfo::clear_posttrialconversionpayment() {
  if (_impl_.posttrialconversionpayment_ != nullptr) _impl_.posttrialconversionpayment_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::playapi::proto::finsky::SeasonalSubscriptionInfo_Payment& SeasonalSubscriptionInfo::_internal_posttrialconversionpayment() const {
  const ::playapi::proto::finsky::SeasonalSubscriptionInfo_Payment* p = _impl_.posttrialconversionpayment_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::SeasonalSubscriptionInfo_Payment&>(
      ::playapi::proto::finsky::_SeasonalSubscriptionInfo_Payment_default_instance_);
}
inline const ::playapi::proto::finsky::SeasonalSubscriptionInfo_Payment& SeasonalSubscriptionInfo::posttrialconversionpayment() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.SeasonalSubscriptionInfo.postTrialConversionPayment)
  return _internal_posttrialconversionpayment();
}
inline void SeasonalSubscriptionInfo::unsafe_arena_set_allocated_posttrialconversionpayment(
    ::playapi::proto::finsky::SeasonalSubscriptionInfo_Payment* posttrialconversionpayment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.posttrialconversionpayment_);
  }
  _impl_.posttrialconversionpayment_ = posttrialconversionpayment;
  if (posttrialconversionpayment) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.SeasonalSubscriptionInfo.postTrialConversionPayment)
}
inline ::playapi::proto::finsky::SeasonalSubscriptionInfo_Payment* SeasonalSubscriptionInfo::release_posttrialconversionpayment() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::playapi::proto::finsky::SeasonalSubscriptionInfo_Payment* temp = _impl_.posttrialconversionpayment_;
  _impl_.posttrialconversionpayment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::SeasonalSubscriptionInfo_Payment* SeasonalSubscriptionInfo::unsafe_arena_release_posttrialconversionpayment() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.SeasonalSubscriptionInfo.postTrialConversionPayment)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::playapi::proto::finsky::SeasonalSubscriptionInfo_Payment* temp = _impl_.posttrialconversionpayment_;
  _impl_.posttrialconversionpayment_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::SeasonalSubscriptionInfo_Payment* SeasonalSubscriptionInfo::_internal_mutable_posttrialconversionpayment() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.posttrialconversionpayment_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::SeasonalSubscriptionInfo_Payment>(GetArenaForAllocation());
    _impl_.posttrialconversionpayment_ = p;
  }
  return _impl_.posttrialconversionpayment_;
}
inline ::playapi::proto::finsky::SeasonalSubscriptionInfo_Payment* SeasonalSubscriptionInfo::mutable_posttrialconversionpayment() {
  ::playapi::proto::finsky::SeasonalSubscriptionInfo_Payment* _msg = _internal_mutable_posttrialconversionpayment();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.SeasonalSubscriptionInfo.postTrialConversionPayment)
  return _msg;
}
inline void SeasonalSubscriptionInfo::set_allocated_posttrialconversionpayment(::playapi::proto::finsky::SeasonalSubscriptionInfo_Payment* posttrialconversionpayment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.posttrialconversionpayment_;
  }
  if (posttrialconversionpayment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(posttrialconversionpayment);
    if (message_arena != submessage_arena) {
      posttrialconversionpayment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, posttrialconversionpayment, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.posttrialconversionpayment_ = posttrialconversionpayment;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.SeasonalSubscriptionInfo.postTrialConversionPayment)
}

// -------------------------------------------------------------------

// SubscriptionTerms_SubscriptionReplacement

// optional .playapi.proto.finsky.Docid newDocid = 1;
inline bool SubscriptionTerms_SubscriptionReplacement::_internal_has_newdocid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.newdocid_ != nullptr);
  return value;
}
inline bool SubscriptionTerms_SubscriptionReplacement::has_newdocid() const {
  return _internal_has_newdocid();
}
inline void SubscriptionTerms_SubscriptionReplacement::clear_newdocid() {
  if (_impl_.newdocid_ != nullptr) _impl_.newdocid_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::playapi::proto::finsky::Docid& SubscriptionTerms_SubscriptionReplacement::_internal_newdocid() const {
  const ::playapi::proto::finsky::Docid* p = _impl_.newdocid_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::Docid&>(
      ::playapi::proto::finsky::_Docid_default_instance_);
}
inline const ::playapi::proto::finsky::Docid& SubscriptionTerms_SubscriptionReplacement::newdocid() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.SubscriptionTerms.SubscriptionReplacement.newDocid)
  return _internal_newdocid();
}
inline void SubscriptionTerms_SubscriptionReplacement::unsafe_arena_set_allocated_newdocid(
    ::playapi::proto::finsky::Docid* newdocid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.newdocid_);
  }
  _impl_.newdocid_ = newdocid;
  if (newdocid) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.SubscriptionTerms.SubscriptionReplacement.newDocid)
}
inline ::playapi::proto::finsky::Docid* SubscriptionTerms_SubscriptionReplacement::release_newdocid() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::playapi::proto::finsky::Docid* temp = _impl_.newdocid_;
  _impl_.newdocid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::Docid* SubscriptionTerms_SubscriptionReplacement::unsafe_arena_release_newdocid() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.SubscriptionTerms.SubscriptionReplacement.newDocid)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::playapi::proto::finsky::Docid* temp = _impl_.newdocid_;
  _impl_.newdocid_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::Docid* SubscriptionTerms_SubscriptionReplacement::_internal_mutable_newdocid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.newdocid_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::Docid>(GetArenaForAllocation());
    _impl_.newdocid_ = p;
  }
  return _impl_.newdocid_;
}
inline ::playapi::proto::finsky::Docid* SubscriptionTerms_SubscriptionReplacement::mutable_newdocid() {
  ::playapi::proto::finsky::Docid* _msg = _internal_mutable_newdocid();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.SubscriptionTerms.SubscriptionReplacement.newDocid)
  return _msg;
}
inline void SubscriptionTerms_SubscriptionReplacement::set_allocated_newdocid(::playapi::proto::finsky::Docid* newdocid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.newdocid_;
  }
  if (newdocid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(newdocid);
    if (message_arena != submessage_arena) {
      newdocid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, newdocid, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.newdocid_ = newdocid;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.SubscriptionTerms.SubscriptionReplacement.newDocid)
}

// repeated .playapi.proto.finsky.Docid oldDocid = 2;
inline int SubscriptionTerms_SubscriptionReplacement::_internal_olddocid_size() const {
  return _impl_.olddocid_.size();
}
inline int SubscriptionTerms_SubscriptionReplacement::olddocid_size() const {
  return _internal_olddocid_size();
}
inline void SubscriptionTerms_SubscriptionReplacement::clear_olddocid() {
  _impl_.olddocid_.Clear();
}
inline ::playapi::proto::finsky::Docid* SubscriptionTerms_SubscriptionReplacement::mutable_olddocid(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.SubscriptionTerms.SubscriptionReplacement.oldDocid)
  return _impl_.olddocid_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Docid >*
SubscriptionTerms_SubscriptionReplacement::mutable_olddocid() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.SubscriptionTerms.SubscriptionReplacement.oldDocid)
  return &_impl_.olddocid_;
}
inline const ::playapi::proto::finsky::Docid& SubscriptionTerms_SubscriptionReplacement::_internal_olddocid(int index) const {
  return _impl_.olddocid_.Get(index);
}
inline const ::playapi::proto::finsky::Docid& SubscriptionTerms_SubscriptionReplacement::olddocid(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.SubscriptionTerms.SubscriptionReplacement.oldDocid)
  return _internal_olddocid(index);
}
inline ::playapi::proto::finsky::Docid* SubscriptionTerms_SubscriptionReplacement::_internal_add_olddocid() {
  return _impl_.olddocid_.Add();
}
inline ::playapi::proto::finsky::Docid* SubscriptionTerms_SubscriptionReplacement::add_olddocid() {
  ::playapi::proto::finsky::Docid* _add = _internal_add_olddocid();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.SubscriptionTerms.SubscriptionReplacement.oldDocid)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Docid >&
SubscriptionTerms_SubscriptionReplacement::olddocid() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.SubscriptionTerms.SubscriptionReplacement.oldDocid)
  return _impl_.olddocid_;
}

// optional bool keepNextRecurrenceTime = 3;
inline bool SubscriptionTerms_SubscriptionReplacement::_internal_has_keepnextrecurrencetime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SubscriptionTerms_SubscriptionReplacement::has_keepnextrecurrencetime() const {
  return _internal_has_keepnextrecurrencetime();
}
inline void SubscriptionTerms_SubscriptionReplacement::clear_keepnextrecurrencetime() {
  _impl_.keepnextrecurrencetime_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool SubscriptionTerms_SubscriptionReplacement::_internal_keepnextrecurrencetime() const {
  return _impl_.keepnextrecurrencetime_;
}
inline bool SubscriptionTerms_SubscriptionReplacement::keepnextrecurrencetime() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.SubscriptionTerms.SubscriptionReplacement.keepNextRecurrenceTime)
  return _internal_keepnextrecurrencetime();
}
inline void SubscriptionTerms_SubscriptionReplacement::_internal_set_keepnextrecurrencetime(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.keepnextrecurrencetime_ = value;
}
inline void SubscriptionTerms_SubscriptionReplacement::set_keepnextrecurrencetime(bool value) {
  _internal_set_keepnextrecurrencetime(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.SubscriptionTerms.SubscriptionReplacement.keepNextRecurrenceTime)
}

// optional bool replaceOnFirstRecurrence = 4;
inline bool SubscriptionTerms_SubscriptionReplacement::_internal_has_replaceonfirstrecurrence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SubscriptionTerms_SubscriptionReplacement::has_replaceonfirstrecurrence() const {
  return _internal_has_replaceonfirstrecurrence();
}
inline void SubscriptionTerms_SubscriptionReplacement::clear_replaceonfirstrecurrence() {
  _impl_.replaceonfirstrecurrence_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool SubscriptionTerms_SubscriptionReplacement::_internal_replaceonfirstrecurrence() const {
  return _impl_.replaceonfirstrecurrence_;
}
inline bool SubscriptionTerms_SubscriptionReplacement::replaceonfirstrecurrence() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.SubscriptionTerms.SubscriptionReplacement.replaceOnFirstRecurrence)
  return _internal_replaceonfirstrecurrence();
}
inline void SubscriptionTerms_SubscriptionReplacement::_internal_set_replaceonfirstrecurrence(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.replaceonfirstrecurrence_ = value;
}
inline void SubscriptionTerms_SubscriptionReplacement::set_replaceonfirstrecurrence(bool value) {
  _internal_set_replaceonfirstrecurrence(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.SubscriptionTerms.SubscriptionReplacement.replaceOnFirstRecurrence)
}

// -------------------------------------------------------------------

// SubscriptionTerms

// optional .playapi.proto.finsky.TimePeriod recurringPeriod = 1;
inline bool SubscriptionTerms::_internal_has_recurringperiod() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.recurringperiod_ != nullptr);
  return value;
}
inline bool SubscriptionTerms::has_recurringperiod() const {
  return _internal_has_recurringperiod();
}
inline void SubscriptionTerms::clear_recurringperiod() {
  if (_impl_.recurringperiod_ != nullptr) _impl_.recurringperiod_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::playapi::proto::finsky::TimePeriod& SubscriptionTerms::_internal_recurringperiod() const {
  const ::playapi::proto::finsky::TimePeriod* p = _impl_.recurringperiod_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::TimePeriod&>(
      ::playapi::proto::finsky::_TimePeriod_default_instance_);
}
inline const ::playapi::proto::finsky::TimePeriod& SubscriptionTerms::recurringperiod() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.SubscriptionTerms.recurringPeriod)
  return _internal_recurringperiod();
}
inline void SubscriptionTerms::unsafe_arena_set_allocated_recurringperiod(
    ::playapi::proto::finsky::TimePeriod* recurringperiod) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.recurringperiod_);
  }
  _impl_.recurringperiod_ = recurringperiod;
  if (recurringperiod) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.SubscriptionTerms.recurringPeriod)
}
inline ::playapi::proto::finsky::TimePeriod* SubscriptionTerms::release_recurringperiod() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::playapi::proto::finsky::TimePeriod* temp = _impl_.recurringperiod_;
  _impl_.recurringperiod_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::TimePeriod* SubscriptionTerms::unsafe_arena_release_recurringperiod() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.SubscriptionTerms.recurringPeriod)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::playapi::proto::finsky::TimePeriod* temp = _impl_.recurringperiod_;
  _impl_.recurringperiod_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::TimePeriod* SubscriptionTerms::_internal_mutable_recurringperiod() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.recurringperiod_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::TimePeriod>(GetArenaForAllocation());
    _impl_.recurringperiod_ = p;
  }
  return _impl_.recurringperiod_;
}
inline ::playapi::proto::finsky::TimePeriod* SubscriptionTerms::mutable_recurringperiod() {
  ::playapi::proto::finsky::TimePeriod* _msg = _internal_mutable_recurringperiod();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.SubscriptionTerms.recurringPeriod)
  return _msg;
}
inline void SubscriptionTerms::set_allocated_recurringperiod(::playapi::proto::finsky::TimePeriod* recurringperiod) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.recurringperiod_;
  }
  if (recurringperiod) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(recurringperiod);
    if (message_arena != submessage_arena) {
      recurringperiod = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, recurringperiod, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.recurringperiod_ = recurringperiod;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.SubscriptionTerms.recurringPeriod)
}

// optional .playapi.proto.finsky.TimePeriod trialPeriod = 2;
inline bool SubscriptionTerms::_internal_has_trialperiod() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.trialperiod_ != nullptr);
  return value;
}
inline bool SubscriptionTerms::has_trialperiod() const {
  return _internal_has_trialperiod();
}
inline void SubscriptionTerms::clear_trialperiod() {
  if (_impl_.trialperiod_ != nullptr) _impl_.trialperiod_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::playapi::proto::finsky::TimePeriod& SubscriptionTerms::_internal_trialperiod() const {
  const ::playapi::proto::finsky::TimePeriod* p = _impl_.trialperiod_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::TimePeriod&>(
      ::playapi::proto::finsky::_TimePeriod_default_instance_);
}
inline const ::playapi::proto::finsky::TimePeriod& SubscriptionTerms::trialperiod() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.SubscriptionTerms.trialPeriod)
  return _internal_trialperiod();
}
inline void SubscriptionTerms::unsafe_arena_set_allocated_trialperiod(
    ::playapi::proto::finsky::TimePeriod* trialperiod) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.trialperiod_);
  }
  _impl_.trialperiod_ = trialperiod;
  if (trialperiod) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.SubscriptionTerms.trialPeriod)
}
inline ::playapi::proto::finsky::TimePeriod* SubscriptionTerms::release_trialperiod() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::playapi::proto::finsky::TimePeriod* temp = _impl_.trialperiod_;
  _impl_.trialperiod_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::TimePeriod* SubscriptionTerms::unsafe_arena_release_trialperiod() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.SubscriptionTerms.trialPeriod)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::playapi::proto::finsky::TimePeriod* temp = _impl_.trialperiod_;
  _impl_.trialperiod_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::TimePeriod* SubscriptionTerms::_internal_mutable_trialperiod() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.trialperiod_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::TimePeriod>(GetArenaForAllocation());
    _impl_.trialperiod_ = p;
  }
  return _impl_.trialperiod_;
}
inline ::playapi::proto::finsky::TimePeriod* SubscriptionTerms::mutable_trialperiod() {
  ::playapi::proto::finsky::TimePeriod* _msg = _internal_mutable_trialperiod();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.SubscriptionTerms.trialPeriod)
  return _msg;
}
inline void SubscriptionTerms::set_allocated_trialperiod(::playapi::proto::finsky::TimePeriod* trialperiod) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.trialperiod_;
  }
  if (trialperiod) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(trialperiod);
    if (message_arena != submessage_arena) {
      trialperiod = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trialperiod, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.trialperiod_ = trialperiod;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.SubscriptionTerms.trialPeriod)
}

// optional string formattedPriceWithRecurrencePeriod = 3;
inline bool SubscriptionTerms::_internal_has_formattedpricewithrecurrenceperiod() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SubscriptionTerms::has_formattedpricewithrecurrenceperiod() const {
  return _internal_has_formattedpricewithrecurrenceperiod();
}
inline void SubscriptionTerms::clear_formattedpricewithrecurrenceperiod() {
  _impl_.formattedpricewithrecurrenceperiod_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SubscriptionTerms::formattedpricewithrecurrenceperiod() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.SubscriptionTerms.formattedPriceWithRecurrencePeriod)
  return _internal_formattedpricewithrecurrenceperiod();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubscriptionTerms::set_formattedpricewithrecurrenceperiod(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.formattedpricewithrecurrenceperiod_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.SubscriptionTerms.formattedPriceWithRecurrencePeriod)
}
inline std::string* SubscriptionTerms::mutable_formattedpricewithrecurrenceperiod() {
  std::string* _s = _internal_mutable_formattedpricewithrecurrenceperiod();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.SubscriptionTerms.formattedPriceWithRecurrencePeriod)
  return _s;
}
inline const std::string& SubscriptionTerms::_internal_formattedpricewithrecurrenceperiod() const {
  return _impl_.formattedpricewithrecurrenceperiod_.Get();
}
inline void SubscriptionTerms::_internal_set_formattedpricewithrecurrenceperiod(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.formattedpricewithrecurrenceperiod_.Set(value, GetArenaForAllocation());
}
inline std::string* SubscriptionTerms::_internal_mutable_formattedpricewithrecurrenceperiod() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.formattedpricewithrecurrenceperiod_.Mutable(GetArenaForAllocation());
}
inline std::string* SubscriptionTerms::release_formattedpricewithrecurrenceperiod() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.SubscriptionTerms.formattedPriceWithRecurrencePeriod)
  if (!_internal_has_formattedpricewithrecurrenceperiod()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.formattedpricewithrecurrenceperiod_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.formattedpricewithrecurrenceperiod_.IsDefault()) {
    _impl_.formattedpricewithrecurrenceperiod_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SubscriptionTerms::set_allocated_formattedpricewithrecurrenceperiod(std::string* formattedpricewithrecurrenceperiod) {
  if (formattedpricewithrecurrenceperiod != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.formattedpricewithrecurrenceperiod_.SetAllocated(formattedpricewithrecurrenceperiod, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.formattedpricewithrecurrenceperiod_.IsDefault()) {
    _impl_.formattedpricewithrecurrenceperiod_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.SubscriptionTerms.formattedPriceWithRecurrencePeriod)
}

// optional .playapi.proto.finsky.SeasonalSubscriptionInfo seasonalSubscriptionInfo = 4;
inline bool SubscriptionTerms::_internal_has_seasonalsubscriptioninfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.seasonalsubscriptioninfo_ != nullptr);
  return value;
}
inline bool SubscriptionTerms::has_seasonalsubscriptioninfo() const {
  return _internal_has_seasonalsubscriptioninfo();
}
inline void SubscriptionTerms::clear_seasonalsubscriptioninfo() {
  if (_impl_.seasonalsubscriptioninfo_ != nullptr) _impl_.seasonalsubscriptioninfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::playapi::proto::finsky::SeasonalSubscriptionInfo& SubscriptionTerms::_internal_seasonalsubscriptioninfo() const {
  const ::playapi::proto::finsky::SeasonalSubscriptionInfo* p = _impl_.seasonalsubscriptioninfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::SeasonalSubscriptionInfo&>(
      ::playapi::proto::finsky::_SeasonalSubscriptionInfo_default_instance_);
}
inline const ::playapi::proto::finsky::SeasonalSubscriptionInfo& SubscriptionTerms::seasonalsubscriptioninfo() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.SubscriptionTerms.seasonalSubscriptionInfo)
  return _internal_seasonalsubscriptioninfo();
}
inline void SubscriptionTerms::unsafe_arena_set_allocated_seasonalsubscriptioninfo(
    ::playapi::proto::finsky::SeasonalSubscriptionInfo* seasonalsubscriptioninfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.seasonalsubscriptioninfo_);
  }
  _impl_.seasonalsubscriptioninfo_ = seasonalsubscriptioninfo;
  if (seasonalsubscriptioninfo) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.SubscriptionTerms.seasonalSubscriptionInfo)
}
inline ::playapi::proto::finsky::SeasonalSubscriptionInfo* SubscriptionTerms::release_seasonalsubscriptioninfo() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::playapi::proto::finsky::SeasonalSubscriptionInfo* temp = _impl_.seasonalsubscriptioninfo_;
  _impl_.seasonalsubscriptioninfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::SeasonalSubscriptionInfo* SubscriptionTerms::unsafe_arena_release_seasonalsubscriptioninfo() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.SubscriptionTerms.seasonalSubscriptionInfo)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::playapi::proto::finsky::SeasonalSubscriptionInfo* temp = _impl_.seasonalsubscriptioninfo_;
  _impl_.seasonalsubscriptioninfo_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::SeasonalSubscriptionInfo* SubscriptionTerms::_internal_mutable_seasonalsubscriptioninfo() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.seasonalsubscriptioninfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::SeasonalSubscriptionInfo>(GetArenaForAllocation());
    _impl_.seasonalsubscriptioninfo_ = p;
  }
  return _impl_.seasonalsubscriptioninfo_;
}
inline ::playapi::proto::finsky::SeasonalSubscriptionInfo* SubscriptionTerms::mutable_seasonalsubscriptioninfo() {
  ::playapi::proto::finsky::SeasonalSubscriptionInfo* _msg = _internal_mutable_seasonalsubscriptioninfo();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.SubscriptionTerms.seasonalSubscriptionInfo)
  return _msg;
}
inline void SubscriptionTerms::set_allocated_seasonalsubscriptioninfo(::playapi::proto::finsky::SeasonalSubscriptionInfo* seasonalsubscriptioninfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.seasonalsubscriptioninfo_;
  }
  if (seasonalsubscriptioninfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(seasonalsubscriptioninfo);
    if (message_arena != submessage_arena) {
      seasonalsubscriptioninfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, seasonalsubscriptioninfo, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.seasonalsubscriptioninfo_ = seasonalsubscriptioninfo;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.SubscriptionTerms.seasonalSubscriptionInfo)
}

// repeated .playapi.proto.finsky.Docid replaceDocid = 5;
inline int SubscriptionTerms::_internal_replacedocid_size() const {
  return _impl_.replacedocid_.size();
}
inline int SubscriptionTerms::replacedocid_size() const {
  return _internal_replacedocid_size();
}
inline void SubscriptionTerms::clear_replacedocid() {
  _impl_.replacedocid_.Clear();
}
inline ::playapi::proto::finsky::Docid* SubscriptionTerms::mutable_replacedocid(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.SubscriptionTerms.replaceDocid)
  return _impl_.replacedocid_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Docid >*
SubscriptionTerms::mutable_replacedocid() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.SubscriptionTerms.replaceDocid)
  return &_impl_.replacedocid_;
}
inline const ::playapi::proto::finsky::Docid& SubscriptionTerms::_internal_replacedocid(int index) const {
  return _impl_.replacedocid_.Get(index);
}
inline const ::playapi::proto::finsky::Docid& SubscriptionTerms::replacedocid(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.SubscriptionTerms.replaceDocid)
  return _internal_replacedocid(index);
}
inline ::playapi::proto::finsky::Docid* SubscriptionTerms::_internal_add_replacedocid() {
  return _impl_.replacedocid_.Add();
}
inline ::playapi::proto::finsky::Docid* SubscriptionTerms::add_replacedocid() {
  ::playapi::proto::finsky::Docid* _add = _internal_add_replacedocid();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.SubscriptionTerms.replaceDocid)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Docid >&
SubscriptionTerms::replacedocid() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.SubscriptionTerms.replaceDocid)
  return _impl_.replacedocid_;
}

// optional .playapi.proto.finsky.TimePeriod gracePeriod = 6;
inline bool SubscriptionTerms::_internal_has_graceperiod() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.graceperiod_ != nullptr);
  return value;
}
inline bool SubscriptionTerms::has_graceperiod() const {
  return _internal_has_graceperiod();
}
inline void SubscriptionTerms::clear_graceperiod() {
  if (_impl_.graceperiod_ != nullptr) _impl_.graceperiod_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::playapi::proto::finsky::TimePeriod& SubscriptionTerms::_internal_graceperiod() const {
  const ::playapi::proto::finsky::TimePeriod* p = _impl_.graceperiod_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::TimePeriod&>(
      ::playapi::proto::finsky::_TimePeriod_default_instance_);
}
inline const ::playapi::proto::finsky::TimePeriod& SubscriptionTerms::graceperiod() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.SubscriptionTerms.gracePeriod)
  return _internal_graceperiod();
}
inline void SubscriptionTerms::unsafe_arena_set_allocated_graceperiod(
    ::playapi::proto::finsky::TimePeriod* graceperiod) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.graceperiod_);
  }
  _impl_.graceperiod_ = graceperiod;
  if (graceperiod) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.SubscriptionTerms.gracePeriod)
}
inline ::playapi::proto::finsky::TimePeriod* SubscriptionTerms::release_graceperiod() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::playapi::proto::finsky::TimePeriod* temp = _impl_.graceperiod_;
  _impl_.graceperiod_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::TimePeriod* SubscriptionTerms::unsafe_arena_release_graceperiod() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.SubscriptionTerms.gracePeriod)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::playapi::proto::finsky::TimePeriod* temp = _impl_.graceperiod_;
  _impl_.graceperiod_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::TimePeriod* SubscriptionTerms::_internal_mutable_graceperiod() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.graceperiod_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::TimePeriod>(GetArenaForAllocation());
    _impl_.graceperiod_ = p;
  }
  return _impl_.graceperiod_;
}
inline ::playapi::proto::finsky::TimePeriod* SubscriptionTerms::mutable_graceperiod() {
  ::playapi::proto::finsky::TimePeriod* _msg = _internal_mutable_graceperiod();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.SubscriptionTerms.gracePeriod)
  return _msg;
}
inline void SubscriptionTerms::set_allocated_graceperiod(::playapi::proto::finsky::TimePeriod* graceperiod) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.graceperiod_;
  }
  if (graceperiod) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(graceperiod);
    if (message_arena != submessage_arena) {
      graceperiod = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, graceperiod, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.graceperiod_ = graceperiod;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.SubscriptionTerms.gracePeriod)
}

// optional bool resignup = 7;
inline bool SubscriptionTerms::_internal_has_resignup() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool SubscriptionTerms::has_resignup() const {
  return _internal_has_resignup();
}
inline void SubscriptionTerms::clear_resignup() {
  _impl_.resignup_ = false;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline bool SubscriptionTerms::_internal_resignup() const {
  return _impl_.resignup_;
}
inline bool SubscriptionTerms::resignup() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.SubscriptionTerms.resignup)
  return _internal_resignup();
}
inline void SubscriptionTerms::_internal_set_resignup(bool value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.resignup_ = value;
}
inline void SubscriptionTerms::set_resignup(bool value) {
  _internal_set_resignup(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.SubscriptionTerms.resignup)
}

// optional int64 initialValidUntilTimestampMsec = 8;
inline bool SubscriptionTerms::_internal_has_initialvaliduntiltimestampmsec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool SubscriptionTerms::has_initialvaliduntiltimestampmsec() const {
  return _internal_has_initialvaliduntiltimestampmsec();
}
inline void SubscriptionTerms::clear_initialvaliduntiltimestampmsec() {
  _impl_.initialvaliduntiltimestampmsec_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline int64_t SubscriptionTerms::_internal_initialvaliduntiltimestampmsec() const {
  return _impl_.initialvaliduntiltimestampmsec_;
}
inline int64_t SubscriptionTerms::initialvaliduntiltimestampmsec() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.SubscriptionTerms.initialValidUntilTimestampMsec)
  return _internal_initialvaliduntiltimestampmsec();
}
inline void SubscriptionTerms::_internal_set_initialvaliduntiltimestampmsec(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.initialvaliduntiltimestampmsec_ = value;
}
inline void SubscriptionTerms::set_initialvaliduntiltimestampmsec(int64_t value) {
  _internal_set_initialvaliduntiltimestampmsec(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.SubscriptionTerms.initialValidUntilTimestampMsec)
}

// optional string nextPaymentCurrencyCode = 9;
inline bool SubscriptionTerms::_internal_has_nextpaymentcurrencycode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SubscriptionTerms::has_nextpaymentcurrencycode() const {
  return _internal_has_nextpaymentcurrencycode();
}
inline void SubscriptionTerms::clear_nextpaymentcurrencycode() {
  _impl_.nextpaymentcurrencycode_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SubscriptionTerms::nextpaymentcurrencycode() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.SubscriptionTerms.nextPaymentCurrencyCode)
  return _internal_nextpaymentcurrencycode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubscriptionTerms::set_nextpaymentcurrencycode(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.nextpaymentcurrencycode_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.SubscriptionTerms.nextPaymentCurrencyCode)
}
inline std::string* SubscriptionTerms::mutable_nextpaymentcurrencycode() {
  std::string* _s = _internal_mutable_nextpaymentcurrencycode();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.SubscriptionTerms.nextPaymentCurrencyCode)
  return _s;
}
inline const std::string& SubscriptionTerms::_internal_nextpaymentcurrencycode() const {
  return _impl_.nextpaymentcurrencycode_.Get();
}
inline void SubscriptionTerms::_internal_set_nextpaymentcurrencycode(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.nextpaymentcurrencycode_.Set(value, GetArenaForAllocation());
}
inline std::string* SubscriptionTerms::_internal_mutable_nextpaymentcurrencycode() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.nextpaymentcurrencycode_.Mutable(GetArenaForAllocation());
}
inline std::string* SubscriptionTerms::release_nextpaymentcurrencycode() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.SubscriptionTerms.nextPaymentCurrencyCode)
  if (!_internal_has_nextpaymentcurrencycode()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.nextpaymentcurrencycode_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nextpaymentcurrencycode_.IsDefault()) {
    _impl_.nextpaymentcurrencycode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SubscriptionTerms::set_allocated_nextpaymentcurrencycode(std::string* nextpaymentcurrencycode) {
  if (nextpaymentcurrencycode != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.nextpaymentcurrencycode_.SetAllocated(nextpaymentcurrencycode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nextpaymentcurrencycode_.IsDefault()) {
    _impl_.nextpaymentcurrencycode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.SubscriptionTerms.nextPaymentCurrencyCode)
}

// optional int64 nextPaymentPriceMicros = 10;
inline bool SubscriptionTerms::_internal_has_nextpaymentpricemicros() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool SubscriptionTerms::has_nextpaymentpricemicros() const {
  return _internal_has_nextpaymentpricemicros();
}
inline void SubscriptionTerms::clear_nextpaymentpricemicros() {
  _impl_.nextpaymentpricemicros_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline int64_t SubscriptionTerms::_internal_nextpaymentpricemicros() const {
  return _impl_.nextpaymentpricemicros_;
}
inline int64_t SubscriptionTerms::nextpaymentpricemicros() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.SubscriptionTerms.nextPaymentPriceMicros)
  return _internal_nextpaymentpricemicros();
}
inline void SubscriptionTerms::_internal_set_nextpaymentpricemicros(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.nextpaymentpricemicros_ = value;
}
inline void SubscriptionTerms::set_nextpaymentpricemicros(int64_t value) {
  _internal_set_nextpaymentpricemicros(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.SubscriptionTerms.nextPaymentPriceMicros)
}

// optional bool enableAppSpecifiedTrialPeriod = 11;
inline bool SubscriptionTerms::_internal_has_enableappspecifiedtrialperiod() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool SubscriptionTerms::has_enableappspecifiedtrialperiod() const {
  return _internal_has_enableappspecifiedtrialperiod();
}
inline void SubscriptionTerms::clear_enableappspecifiedtrialperiod() {
  _impl_.enableappspecifiedtrialperiod_ = false;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline bool SubscriptionTerms::_internal_enableappspecifiedtrialperiod() const {
  return _impl_.enableappspecifiedtrialperiod_;
}
inline bool SubscriptionTerms::enableappspecifiedtrialperiod() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.SubscriptionTerms.enableAppSpecifiedTrialPeriod)
  return _internal_enableappspecifiedtrialperiod();
}
inline void SubscriptionTerms::_internal_set_enableappspecifiedtrialperiod(bool value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.enableappspecifiedtrialperiod_ = value;
}
inline void SubscriptionTerms::set_enableappspecifiedtrialperiod(bool value) {
  _internal_set_enableappspecifiedtrialperiod(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.SubscriptionTerms.enableAppSpecifiedTrialPeriod)
}

// optional .playapi.proto.finsky.SubscriptionTerms.SubscriptionReplacement subscriptionReplacement = 12;
inline bool SubscriptionTerms::_internal_has_subscriptionreplacement() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.subscriptionreplacement_ != nullptr);
  return value;
}
inline bool SubscriptionTerms::has_subscriptionreplacement() const {
  return _internal_has_subscriptionreplacement();
}
inline void SubscriptionTerms::clear_subscriptionreplacement() {
  if (_impl_.subscriptionreplacement_ != nullptr) _impl_.subscriptionreplacement_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::playapi::proto::finsky::SubscriptionTerms_SubscriptionReplacement& SubscriptionTerms::_internal_subscriptionreplacement() const {
  const ::playapi::proto::finsky::SubscriptionTerms_SubscriptionReplacement* p = _impl_.subscriptionreplacement_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::SubscriptionTerms_SubscriptionReplacement&>(
      ::playapi::proto::finsky::_SubscriptionTerms_SubscriptionReplacement_default_instance_);
}
inline const ::playapi::proto::finsky::SubscriptionTerms_SubscriptionReplacement& SubscriptionTerms::subscriptionreplacement() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.SubscriptionTerms.subscriptionReplacement)
  return _internal_subscriptionreplacement();
}
inline void SubscriptionTerms::unsafe_arena_set_allocated_subscriptionreplacement(
    ::playapi::proto::finsky::SubscriptionTerms_SubscriptionReplacement* subscriptionreplacement) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.subscriptionreplacement_);
  }
  _impl_.subscriptionreplacement_ = subscriptionreplacement;
  if (subscriptionreplacement) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.SubscriptionTerms.subscriptionReplacement)
}
inline ::playapi::proto::finsky::SubscriptionTerms_SubscriptionReplacement* SubscriptionTerms::release_subscriptionreplacement() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::playapi::proto::finsky::SubscriptionTerms_SubscriptionReplacement* temp = _impl_.subscriptionreplacement_;
  _impl_.subscriptionreplacement_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::SubscriptionTerms_SubscriptionReplacement* SubscriptionTerms::unsafe_arena_release_subscriptionreplacement() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.SubscriptionTerms.subscriptionReplacement)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::playapi::proto::finsky::SubscriptionTerms_SubscriptionReplacement* temp = _impl_.subscriptionreplacement_;
  _impl_.subscriptionreplacement_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::SubscriptionTerms_SubscriptionReplacement* SubscriptionTerms::_internal_mutable_subscriptionreplacement() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.subscriptionreplacement_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::SubscriptionTerms_SubscriptionReplacement>(GetArenaForAllocation());
    _impl_.subscriptionreplacement_ = p;
  }
  return _impl_.subscriptionreplacement_;
}
inline ::playapi::proto::finsky::SubscriptionTerms_SubscriptionReplacement* SubscriptionTerms::mutable_subscriptionreplacement() {
  ::playapi::proto::finsky::SubscriptionTerms_SubscriptionReplacement* _msg = _internal_mutable_subscriptionreplacement();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.SubscriptionTerms.subscriptionReplacement)
  return _msg;
}
inline void SubscriptionTerms::set_allocated_subscriptionreplacement(::playapi::proto::finsky::SubscriptionTerms_SubscriptionReplacement* subscriptionreplacement) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.subscriptionreplacement_;
  }
  if (subscriptionreplacement) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(subscriptionreplacement);
    if (message_arena != submessage_arena) {
      subscriptionreplacement = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subscriptionreplacement, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.subscriptionreplacement_ = subscriptionreplacement;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.SubscriptionTerms.subscriptionReplacement)
}

// -------------------------------------------------------------------

// SubscriptionContentTerms

// optional .playapi.proto.finsky.Docid requiredSubscription = 1;
inline bool SubscriptionContentTerms::_internal_has_requiredsubscription() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.requiredsubscription_ != nullptr);
  return value;
}
inline bool SubscriptionContentTerms::has_requiredsubscription() const {
  return _internal_has_requiredsubscription();
}
inline void SubscriptionContentTerms::clear_requiredsubscription() {
  if (_impl_.requiredsubscription_ != nullptr) _impl_.requiredsubscription_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::playapi::proto::finsky::Docid& SubscriptionContentTerms::_internal_requiredsubscription() const {
  const ::playapi::proto::finsky::Docid* p = _impl_.requiredsubscription_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::Docid&>(
      ::playapi::proto::finsky::_Docid_default_instance_);
}
inline const ::playapi::proto::finsky::Docid& SubscriptionContentTerms::requiredsubscription() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.SubscriptionContentTerms.requiredSubscription)
  return _internal_requiredsubscription();
}
inline void SubscriptionContentTerms::unsafe_arena_set_allocated_requiredsubscription(
    ::playapi::proto::finsky::Docid* requiredsubscription) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.requiredsubscription_);
  }
  _impl_.requiredsubscription_ = requiredsubscription;
  if (requiredsubscription) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.SubscriptionContentTerms.requiredSubscription)
}
inline ::playapi::proto::finsky::Docid* SubscriptionContentTerms::release_requiredsubscription() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::playapi::proto::finsky::Docid* temp = _impl_.requiredsubscription_;
  _impl_.requiredsubscription_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::Docid* SubscriptionContentTerms::unsafe_arena_release_requiredsubscription() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.SubscriptionContentTerms.requiredSubscription)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::playapi::proto::finsky::Docid* temp = _impl_.requiredsubscription_;
  _impl_.requiredsubscription_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::Docid* SubscriptionContentTerms::_internal_mutable_requiredsubscription() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.requiredsubscription_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::Docid>(GetArenaForAllocation());
    _impl_.requiredsubscription_ = p;
  }
  return _impl_.requiredsubscription_;
}
inline ::playapi::proto::finsky::Docid* SubscriptionContentTerms::mutable_requiredsubscription() {
  ::playapi::proto::finsky::Docid* _msg = _internal_mutable_requiredsubscription();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.SubscriptionContentTerms.requiredSubscription)
  return _msg;
}
inline void SubscriptionContentTerms::set_allocated_requiredsubscription(::playapi::proto::finsky::Docid* requiredsubscription) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.requiredsubscription_;
  }
  if (requiredsubscription) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(requiredsubscription);
    if (message_arena != submessage_arena) {
      requiredsubscription = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, requiredsubscription, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.requiredsubscription_ = requiredsubscription;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.SubscriptionContentTerms.requiredSubscription)
}

// -------------------------------------------------------------------

// GroupLicenseKey

// optional fixed64 dasherCustomerId = 1;
inline bool GroupLicenseKey::_internal_has_dashercustomerid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GroupLicenseKey::has_dashercustomerid() const {
  return _internal_has_dashercustomerid();
}
inline void GroupLicenseKey::clear_dashercustomerid() {
  _impl_.dashercustomerid_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t GroupLicenseKey::_internal_dashercustomerid() const {
  return _impl_.dashercustomerid_;
}
inline uint64_t GroupLicenseKey::dashercustomerid() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.GroupLicenseKey.dasherCustomerId)
  return _internal_dashercustomerid();
}
inline void GroupLicenseKey::_internal_set_dashercustomerid(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.dashercustomerid_ = value;
}
inline void GroupLicenseKey::set_dashercustomerid(uint64_t value) {
  _internal_set_dashercustomerid(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.GroupLicenseKey.dasherCustomerId)
}

// optional .playapi.proto.finsky.Docid docid = 2;
inline bool GroupLicenseKey::_internal_has_docid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.docid_ != nullptr);
  return value;
}
inline bool GroupLicenseKey::has_docid() const {
  return _internal_has_docid();
}
inline void GroupLicenseKey::clear_docid() {
  if (_impl_.docid_ != nullptr) _impl_.docid_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::playapi::proto::finsky::Docid& GroupLicenseKey::_internal_docid() const {
  const ::playapi::proto::finsky::Docid* p = _impl_.docid_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::Docid&>(
      ::playapi::proto::finsky::_Docid_default_instance_);
}
inline const ::playapi::proto::finsky::Docid& GroupLicenseKey::docid() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.GroupLicenseKey.docid)
  return _internal_docid();
}
inline void GroupLicenseKey::unsafe_arena_set_allocated_docid(
    ::playapi::proto::finsky::Docid* docid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.docid_);
  }
  _impl_.docid_ = docid;
  if (docid) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.GroupLicenseKey.docid)
}
inline ::playapi::proto::finsky::Docid* GroupLicenseKey::release_docid() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::playapi::proto::finsky::Docid* temp = _impl_.docid_;
  _impl_.docid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::Docid* GroupLicenseKey::unsafe_arena_release_docid() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.GroupLicenseKey.docid)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::playapi::proto::finsky::Docid* temp = _impl_.docid_;
  _impl_.docid_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::Docid* GroupLicenseKey::_internal_mutable_docid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.docid_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::Docid>(GetArenaForAllocation());
    _impl_.docid_ = p;
  }
  return _impl_.docid_;
}
inline ::playapi::proto::finsky::Docid* GroupLicenseKey::mutable_docid() {
  ::playapi::proto::finsky::Docid* _msg = _internal_mutable_docid();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.GroupLicenseKey.docid)
  return _msg;
}
inline void GroupLicenseKey::set_allocated_docid(::playapi::proto::finsky::Docid* docid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.docid_;
  }
  if (docid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(docid);
    if (message_arena != submessage_arena) {
      docid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, docid, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.docid_ = docid;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.GroupLicenseKey.docid)
}

// optional int32 licensedOfferType = 3;
inline bool GroupLicenseKey::_internal_has_licensedoffertype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GroupLicenseKey::has_licensedoffertype() const {
  return _internal_has_licensedoffertype();
}
inline void GroupLicenseKey::clear_licensedoffertype() {
  _impl_.licensedoffertype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t GroupLicenseKey::_internal_licensedoffertype() const {
  return _impl_.licensedoffertype_;
}
inline int32_t GroupLicenseKey::licensedoffertype() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.GroupLicenseKey.licensedOfferType)
  return _internal_licensedoffertype();
}
inline void GroupLicenseKey::_internal_set_licensedoffertype(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.licensedoffertype_ = value;
}
inline void GroupLicenseKey::set_licensedoffertype(int32_t value) {
  _internal_set_licensedoffertype(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.GroupLicenseKey.licensedOfferType)
}

// optional int32 type = 4;
inline bool GroupLicenseKey::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool GroupLicenseKey::has_type() const {
  return _internal_has_type();
}
inline void GroupLicenseKey::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t GroupLicenseKey::_internal_type() const {
  return _impl_.type_;
}
inline int32_t GroupLicenseKey::type() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.GroupLicenseKey.type)
  return _internal_type();
}
inline void GroupLicenseKey::_internal_set_type(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.type_ = value;
}
inline void GroupLicenseKey::set_type(int32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.GroupLicenseKey.type)
}

// optional int32 rentalPeriodDays = 5;
inline bool GroupLicenseKey::_internal_has_rentalperioddays() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool GroupLicenseKey::has_rentalperioddays() const {
  return _internal_has_rentalperioddays();
}
inline void GroupLicenseKey::clear_rentalperioddays() {
  _impl_.rentalperioddays_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t GroupLicenseKey::_internal_rentalperioddays() const {
  return _impl_.rentalperioddays_;
}
inline int32_t GroupLicenseKey::rentalperioddays() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.GroupLicenseKey.rentalPeriodDays)
  return _internal_rentalperioddays();
}
inline void GroupLicenseKey::_internal_set_rentalperioddays(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.rentalperioddays_ = value;
}
inline void GroupLicenseKey::set_rentalperioddays(int32_t value) {
  _internal_set_rentalperioddays(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.GroupLicenseKey.rentalPeriodDays)
}

// -------------------------------------------------------------------

// GroupLicenseInfo

// optional int32 licensedOfferType = 1;
inline bool GroupLicenseInfo::_internal_has_licensedoffertype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GroupLicenseInfo::has_licensedoffertype() const {
  return _internal_has_licensedoffertype();
}
inline void GroupLicenseInfo::clear_licensedoffertype() {
  _impl_.licensedoffertype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t GroupLicenseInfo::_internal_licensedoffertype() const {
  return _impl_.licensedoffertype_;
}
inline int32_t GroupLicenseInfo::licensedoffertype() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.GroupLicenseInfo.licensedOfferType)
  return _internal_licensedoffertype();
}
inline void GroupLicenseInfo::_internal_set_licensedoffertype(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.licensedoffertype_ = value;
}
inline void GroupLicenseInfo::set_licensedoffertype(int32_t value) {
  _internal_set_licensedoffertype(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.GroupLicenseInfo.licensedOfferType)
}

// optional fixed64 gaiaGroupId = 2;
inline bool GroupLicenseInfo::_internal_has_gaiagroupid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GroupLicenseInfo::has_gaiagroupid() const {
  return _internal_has_gaiagroupid();
}
inline void GroupLicenseInfo::clear_gaiagroupid() {
  _impl_.gaiagroupid_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t GroupLicenseInfo::_internal_gaiagroupid() const {
  return _impl_.gaiagroupid_;
}
inline uint64_t GroupLicenseInfo::gaiagroupid() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.GroupLicenseInfo.gaiaGroupId)
  return _internal_gaiagroupid();
}
inline void GroupLicenseInfo::_internal_set_gaiagroupid(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.gaiagroupid_ = value;
}
inline void GroupLicenseInfo::set_gaiagroupid(uint64_t value) {
  _internal_set_gaiagroupid(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.GroupLicenseInfo.gaiaGroupId)
}

// optional .playapi.proto.finsky.GroupLicenseKey groupLicenseKey = 3;
inline bool GroupLicenseInfo::_internal_has_grouplicensekey() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.grouplicensekey_ != nullptr);
  return value;
}
inline bool GroupLicenseInfo::has_grouplicensekey() const {
  return _internal_has_grouplicensekey();
}
inline void GroupLicenseInfo::clear_grouplicensekey() {
  if (_impl_.grouplicensekey_ != nullptr) _impl_.grouplicensekey_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::playapi::proto::finsky::GroupLicenseKey& GroupLicenseInfo::_internal_grouplicensekey() const {
  const ::playapi::proto::finsky::GroupLicenseKey* p = _impl_.grouplicensekey_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::GroupLicenseKey&>(
      ::playapi::proto::finsky::_GroupLicenseKey_default_instance_);
}
inline const ::playapi::proto::finsky::GroupLicenseKey& GroupLicenseInfo::grouplicensekey() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.GroupLicenseInfo.groupLicenseKey)
  return _internal_grouplicensekey();
}
inline void GroupLicenseInfo::unsafe_arena_set_allocated_grouplicensekey(
    ::playapi::proto::finsky::GroupLicenseKey* grouplicensekey) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.grouplicensekey_);
  }
  _impl_.grouplicensekey_ = grouplicensekey;
  if (grouplicensekey) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.GroupLicenseInfo.groupLicenseKey)
}
inline ::playapi::proto::finsky::GroupLicenseKey* GroupLicenseInfo::release_grouplicensekey() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::playapi::proto::finsky::GroupLicenseKey* temp = _impl_.grouplicensekey_;
  _impl_.grouplicensekey_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::GroupLicenseKey* GroupLicenseInfo::unsafe_arena_release_grouplicensekey() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.GroupLicenseInfo.groupLicenseKey)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::playapi::proto::finsky::GroupLicenseKey* temp = _impl_.grouplicensekey_;
  _impl_.grouplicensekey_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::GroupLicenseKey* GroupLicenseInfo::_internal_mutable_grouplicensekey() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.grouplicensekey_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::GroupLicenseKey>(GetArenaForAllocation());
    _impl_.grouplicensekey_ = p;
  }
  return _impl_.grouplicensekey_;
}
inline ::playapi::proto::finsky::GroupLicenseKey* GroupLicenseInfo::mutable_grouplicensekey() {
  ::playapi::proto::finsky::GroupLicenseKey* _msg = _internal_mutable_grouplicensekey();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.GroupLicenseInfo.groupLicenseKey)
  return _msg;
}
inline void GroupLicenseInfo::set_allocated_grouplicensekey(::playapi::proto::finsky::GroupLicenseKey* grouplicensekey) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.grouplicensekey_;
  }
  if (grouplicensekey) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(grouplicensekey);
    if (message_arena != submessage_arena) {
      grouplicensekey = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, grouplicensekey, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.grouplicensekey_ = grouplicensekey;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.GroupLicenseInfo.groupLicenseKey)
}

// -------------------------------------------------------------------

// LicenseTerms

// optional .playapi.proto.finsky.GroupLicenseKey groupLicenseKey = 1;
inline bool LicenseTerms::_internal_has_grouplicensekey() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.grouplicensekey_ != nullptr);
  return value;
}
inline bool LicenseTerms::has_grouplicensekey() const {
  return _internal_has_grouplicensekey();
}
inline void LicenseTerms::clear_grouplicensekey() {
  if (_impl_.grouplicensekey_ != nullptr) _impl_.grouplicensekey_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::playapi::proto::finsky::GroupLicenseKey& LicenseTerms::_internal_grouplicensekey() const {
  const ::playapi::proto::finsky::GroupLicenseKey* p = _impl_.grouplicensekey_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::GroupLicenseKey&>(
      ::playapi::proto::finsky::_GroupLicenseKey_default_instance_);
}
inline const ::playapi::proto::finsky::GroupLicenseKey& LicenseTerms::grouplicensekey() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.LicenseTerms.groupLicenseKey)
  return _internal_grouplicensekey();
}
inline void LicenseTerms::unsafe_arena_set_allocated_grouplicensekey(
    ::playapi::proto::finsky::GroupLicenseKey* grouplicensekey) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.grouplicensekey_);
  }
  _impl_.grouplicensekey_ = grouplicensekey;
  if (grouplicensekey) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.LicenseTerms.groupLicenseKey)
}
inline ::playapi::proto::finsky::GroupLicenseKey* LicenseTerms::release_grouplicensekey() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::playapi::proto::finsky::GroupLicenseKey* temp = _impl_.grouplicensekey_;
  _impl_.grouplicensekey_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::GroupLicenseKey* LicenseTerms::unsafe_arena_release_grouplicensekey() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.LicenseTerms.groupLicenseKey)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::playapi::proto::finsky::GroupLicenseKey* temp = _impl_.grouplicensekey_;
  _impl_.grouplicensekey_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::GroupLicenseKey* LicenseTerms::_internal_mutable_grouplicensekey() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.grouplicensekey_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::GroupLicenseKey>(GetArenaForAllocation());
    _impl_.grouplicensekey_ = p;
  }
  return _impl_.grouplicensekey_;
}
inline ::playapi::proto::finsky::GroupLicenseKey* LicenseTerms::mutable_grouplicensekey() {
  ::playapi::proto::finsky::GroupLicenseKey* _msg = _internal_mutable_grouplicensekey();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.LicenseTerms.groupLicenseKey)
  return _msg;
}
inline void LicenseTerms::set_allocated_grouplicensekey(::playapi::proto::finsky::GroupLicenseKey* grouplicensekey) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.grouplicensekey_;
  }
  if (grouplicensekey) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(grouplicensekey);
    if (message_arena != submessage_arena) {
      grouplicensekey = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, grouplicensekey, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.grouplicensekey_ = grouplicensekey;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.LicenseTerms.groupLicenseKey)
}

// -------------------------------------------------------------------

// LicensedDocumentInfo

// repeated fixed64 gaiaGroupId = 1;
inline int LicensedDocumentInfo::_internal_gaiagroupid_size() const {
  return _impl_.gaiagroupid_.size();
}
inline int LicensedDocumentInfo::gaiagroupid_size() const {
  return _internal_gaiagroupid_size();
}
inline void LicensedDocumentInfo::clear_gaiagroupid() {
  _impl_.gaiagroupid_.Clear();
}
inline uint64_t LicensedDocumentInfo::_internal_gaiagroupid(int index) const {
  return _impl_.gaiagroupid_.Get(index);
}
inline uint64_t LicensedDocumentInfo::gaiagroupid(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.LicensedDocumentInfo.gaiaGroupId)
  return _internal_gaiagroupid(index);
}
inline void LicensedDocumentInfo::set_gaiagroupid(int index, uint64_t value) {
  _impl_.gaiagroupid_.Set(index, value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.LicensedDocumentInfo.gaiaGroupId)
}
inline void LicensedDocumentInfo::_internal_add_gaiagroupid(uint64_t value) {
  _impl_.gaiagroupid_.Add(value);
}
inline void LicensedDocumentInfo::add_gaiagroupid(uint64_t value) {
  _internal_add_gaiagroupid(value);
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.LicensedDocumentInfo.gaiaGroupId)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
LicensedDocumentInfo::_internal_gaiagroupid() const {
  return _impl_.gaiagroupid_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
LicensedDocumentInfo::gaiagroupid() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.LicensedDocumentInfo.gaiaGroupId)
  return _internal_gaiagroupid();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
LicensedDocumentInfo::_internal_mutable_gaiagroupid() {
  return &_impl_.gaiagroupid_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
LicensedDocumentInfo::mutable_gaiagroupid() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.LicensedDocumentInfo.gaiaGroupId)
  return _internal_mutable_gaiagroupid();
}

// optional string groupLicenseCheckoutOrderId = 2;
inline bool LicensedDocumentInfo::_internal_has_grouplicensecheckoutorderid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LicensedDocumentInfo::has_grouplicensecheckoutorderid() const {
  return _internal_has_grouplicensecheckoutorderid();
}
inline void LicensedDocumentInfo::clear_grouplicensecheckoutorderid() {
  _impl_.grouplicensecheckoutorderid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LicensedDocumentInfo::grouplicensecheckoutorderid() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.LicensedDocumentInfo.groupLicenseCheckoutOrderId)
  return _internal_grouplicensecheckoutorderid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LicensedDocumentInfo::set_grouplicensecheckoutorderid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.grouplicensecheckoutorderid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.LicensedDocumentInfo.groupLicenseCheckoutOrderId)
}
inline std::string* LicensedDocumentInfo::mutable_grouplicensecheckoutorderid() {
  std::string* _s = _internal_mutable_grouplicensecheckoutorderid();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.LicensedDocumentInfo.groupLicenseCheckoutOrderId)
  return _s;
}
inline const std::string& LicensedDocumentInfo::_internal_grouplicensecheckoutorderid() const {
  return _impl_.grouplicensecheckoutorderid_.Get();
}
inline void LicensedDocumentInfo::_internal_set_grouplicensecheckoutorderid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.grouplicensecheckoutorderid_.Set(value, GetArenaForAllocation());
}
inline std::string* LicensedDocumentInfo::_internal_mutable_grouplicensecheckoutorderid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.grouplicensecheckoutorderid_.Mutable(GetArenaForAllocation());
}
inline std::string* LicensedDocumentInfo::release_grouplicensecheckoutorderid() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.LicensedDocumentInfo.groupLicenseCheckoutOrderId)
  if (!_internal_has_grouplicensecheckoutorderid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.grouplicensecheckoutorderid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.grouplicensecheckoutorderid_.IsDefault()) {
    _impl_.grouplicensecheckoutorderid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LicensedDocumentInfo::set_allocated_grouplicensecheckoutorderid(std::string* grouplicensecheckoutorderid) {
  if (grouplicensecheckoutorderid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.grouplicensecheckoutorderid_.SetAllocated(grouplicensecheckoutorderid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.grouplicensecheckoutorderid_.IsDefault()) {
    _impl_.grouplicensecheckoutorderid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.LicensedDocumentInfo.groupLicenseCheckoutOrderId)
}

// optional .playapi.proto.finsky.GroupLicenseKey groupLicenseKey = 3;
inline bool LicensedDocumentInfo::_internal_has_grouplicensekey() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.grouplicensekey_ != nullptr);
  return value;
}
inline bool LicensedDocumentInfo::has_grouplicensekey() const {
  return _internal_has_grouplicensekey();
}
inline void LicensedDocumentInfo::clear_grouplicensekey() {
  if (_impl_.grouplicensekey_ != nullptr) _impl_.grouplicensekey_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::playapi::proto::finsky::GroupLicenseKey& LicensedDocumentInfo::_internal_grouplicensekey() const {
  const ::playapi::proto::finsky::GroupLicenseKey* p = _impl_.grouplicensekey_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::GroupLicenseKey&>(
      ::playapi::proto::finsky::_GroupLicenseKey_default_instance_);
}
inline const ::playapi::proto::finsky::GroupLicenseKey& LicensedDocumentInfo::grouplicensekey() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.LicensedDocumentInfo.groupLicenseKey)
  return _internal_grouplicensekey();
}
inline void LicensedDocumentInfo::unsafe_arena_set_allocated_grouplicensekey(
    ::playapi::proto::finsky::GroupLicenseKey* grouplicensekey) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.grouplicensekey_);
  }
  _impl_.grouplicensekey_ = grouplicensekey;
  if (grouplicensekey) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.LicensedDocumentInfo.groupLicenseKey)
}
inline ::playapi::proto::finsky::GroupLicenseKey* LicensedDocumentInfo::release_grouplicensekey() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::playapi::proto::finsky::GroupLicenseKey* temp = _impl_.grouplicensekey_;
  _impl_.grouplicensekey_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::GroupLicenseKey* LicensedDocumentInfo::unsafe_arena_release_grouplicensekey() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.LicensedDocumentInfo.groupLicenseKey)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::playapi::proto::finsky::GroupLicenseKey* temp = _impl_.grouplicensekey_;
  _impl_.grouplicensekey_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::GroupLicenseKey* LicensedDocumentInfo::_internal_mutable_grouplicensekey() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.grouplicensekey_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::GroupLicenseKey>(GetArenaForAllocation());
    _impl_.grouplicensekey_ = p;
  }
  return _impl_.grouplicensekey_;
}
inline ::playapi::proto::finsky::GroupLicenseKey* LicensedDocumentInfo::mutable_grouplicensekey() {
  ::playapi::proto::finsky::GroupLicenseKey* _msg = _internal_mutable_grouplicensekey();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.LicensedDocumentInfo.groupLicenseKey)
  return _msg;
}
inline void LicensedDocumentInfo::set_allocated_grouplicensekey(::playapi::proto::finsky::GroupLicenseKey* grouplicensekey) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.grouplicensekey_;
  }
  if (grouplicensekey) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(grouplicensekey);
    if (message_arena != submessage_arena) {
      grouplicensekey = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, grouplicensekey, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.grouplicensekey_ = grouplicensekey;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.LicensedDocumentInfo.groupLicenseKey)
}

// optional fixed64 assignedByGaiaId = 4;
inline bool LicensedDocumentInfo::_internal_has_assignedbygaiaid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LicensedDocumentInfo::has_assignedbygaiaid() const {
  return _internal_has_assignedbygaiaid();
}
inline void LicensedDocumentInfo::clear_assignedbygaiaid() {
  _impl_.assignedbygaiaid_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint64_t LicensedDocumentInfo::_internal_assignedbygaiaid() const {
  return _impl_.assignedbygaiaid_;
}
inline uint64_t LicensedDocumentInfo::assignedbygaiaid() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.LicensedDocumentInfo.assignedByGaiaId)
  return _internal_assignedbygaiaid();
}
inline void LicensedDocumentInfo::_internal_set_assignedbygaiaid(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.assignedbygaiaid_ = value;
}
inline void LicensedDocumentInfo::set_assignedbygaiaid(uint64_t value) {
  _internal_set_assignedbygaiaid(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.LicensedDocumentInfo.assignedByGaiaId)
}

// optional string DEPRECATEDAssignmentId = 5;
inline bool LicensedDocumentInfo::_internal_has_deprecatedassignmentid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LicensedDocumentInfo::has_deprecatedassignmentid() const {
  return _internal_has_deprecatedassignmentid();
}
inline void LicensedDocumentInfo::clear_deprecatedassignmentid() {
  _impl_.deprecatedassignmentid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& LicensedDocumentInfo::deprecatedassignmentid() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.LicensedDocumentInfo.DEPRECATEDAssignmentId)
  return _internal_deprecatedassignmentid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LicensedDocumentInfo::set_deprecatedassignmentid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.deprecatedassignmentid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.LicensedDocumentInfo.DEPRECATEDAssignmentId)
}
inline std::string* LicensedDocumentInfo::mutable_deprecatedassignmentid() {
  std::string* _s = _internal_mutable_deprecatedassignmentid();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.LicensedDocumentInfo.DEPRECATEDAssignmentId)
  return _s;
}
inline const std::string& LicensedDocumentInfo::_internal_deprecatedassignmentid() const {
  return _impl_.deprecatedassignmentid_.Get();
}
inline void LicensedDocumentInfo::_internal_set_deprecatedassignmentid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.deprecatedassignmentid_.Set(value, GetArenaForAllocation());
}
inline std::string* LicensedDocumentInfo::_internal_mutable_deprecatedassignmentid() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.deprecatedassignmentid_.Mutable(GetArenaForAllocation());
}
inline std::string* LicensedDocumentInfo::release_deprecatedassignmentid() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.LicensedDocumentInfo.DEPRECATEDAssignmentId)
  if (!_internal_has_deprecatedassignmentid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.deprecatedassignmentid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.deprecatedassignmentid_.IsDefault()) {
    _impl_.deprecatedassignmentid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LicensedDocumentInfo::set_allocated_deprecatedassignmentid(std::string* deprecatedassignmentid) {
  if (deprecatedassignmentid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.deprecatedassignmentid_.SetAllocated(deprecatedassignmentid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.deprecatedassignmentid_.IsDefault()) {
    _impl_.deprecatedassignmentid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.LicensedDocumentInfo.DEPRECATEDAssignmentId)
}

// -------------------------------------------------------------------

// RedemptionRecordKey

// optional int64 publisherId = 1;
inline bool RedemptionRecordKey::_internal_has_publisherid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RedemptionRecordKey::has_publisherid() const {
  return _internal_has_publisherid();
}
inline void RedemptionRecordKey::clear_publisherid() {
  _impl_.publisherid_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t RedemptionRecordKey::_internal_publisherid() const {
  return _impl_.publisherid_;
}
inline int64_t RedemptionRecordKey::publisherid() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.RedemptionRecordKey.publisherId)
  return _internal_publisherid();
}
inline void RedemptionRecordKey::_internal_set_publisherid(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.publisherid_ = value;
}
inline void RedemptionRecordKey::set_publisherid(int64_t value) {
  _internal_set_publisherid(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.RedemptionRecordKey.publisherId)
}

// optional int64 campaignId = 2;
inline bool RedemptionRecordKey::_internal_has_campaignid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RedemptionRecordKey::has_campaignid() const {
  return _internal_has_campaignid();
}
inline void RedemptionRecordKey::clear_campaignid() {
  _impl_.campaignid_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t RedemptionRecordKey::_internal_campaignid() const {
  return _impl_.campaignid_;
}
inline int64_t RedemptionRecordKey::campaignid() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.RedemptionRecordKey.campaignId)
  return _internal_campaignid();
}
inline void RedemptionRecordKey::_internal_set_campaignid(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.campaignid_ = value;
}
inline void RedemptionRecordKey::set_campaignid(int64_t value) {
  _internal_set_campaignid(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.RedemptionRecordKey.campaignId)
}

// optional int64 codeGroupId = 3;
inline bool RedemptionRecordKey::_internal_has_codegroupid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RedemptionRecordKey::has_codegroupid() const {
  return _internal_has_codegroupid();
}
inline void RedemptionRecordKey::clear_codegroupid() {
  _impl_.codegroupid_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t RedemptionRecordKey::_internal_codegroupid() const {
  return _impl_.codegroupid_;
}
inline int64_t RedemptionRecordKey::codegroupid() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.RedemptionRecordKey.codeGroupId)
  return _internal_codegroupid();
}
inline void RedemptionRecordKey::_internal_set_codegroupid(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.codegroupid_ = value;
}
inline void RedemptionRecordKey::set_codegroupid(int64_t value) {
  _internal_set_codegroupid(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.RedemptionRecordKey.codeGroupId)
}

// optional int64 recordId = 4;
inline bool RedemptionRecordKey::_internal_has_recordid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RedemptionRecordKey::has_recordid() const {
  return _internal_has_recordid();
}
inline void RedemptionRecordKey::clear_recordid() {
  _impl_.recordid_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int64_t RedemptionRecordKey::_internal_recordid() const {
  return _impl_.recordid_;
}
inline int64_t RedemptionRecordKey::recordid() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.RedemptionRecordKey.recordId)
  return _internal_recordid();
}
inline void RedemptionRecordKey::_internal_set_recordid(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.recordid_ = value;
}
inline void RedemptionRecordKey::set_recordid(int64_t value) {
  _internal_set_recordid(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.RedemptionRecordKey.recordId)
}

// optional int32 type = 5;
inline bool RedemptionRecordKey::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool RedemptionRecordKey::has_type() const {
  return _internal_has_type();
}
inline void RedemptionRecordKey::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t RedemptionRecordKey::_internal_type() const {
  return _impl_.type_;
}
inline int32_t RedemptionRecordKey::type() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.RedemptionRecordKey.type)
  return _internal_type();
}
inline void RedemptionRecordKey::_internal_set_type(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.type_ = value;
}
inline void RedemptionRecordKey::set_type(int32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.RedemptionRecordKey.type)
}

// -------------------------------------------------------------------

// VoucherId

// optional .playapi.proto.finsky.Docid voucherDocid = 1;
inline bool VoucherId::_internal_has_voucherdocid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.voucherdocid_ != nullptr);
  return value;
}
inline bool VoucherId::has_voucherdocid() const {
  return _internal_has_voucherdocid();
}
inline void VoucherId::clear_voucherdocid() {
  if (_impl_.voucherdocid_ != nullptr) _impl_.voucherdocid_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::playapi::proto::finsky::Docid& VoucherId::_internal_voucherdocid() const {
  const ::playapi::proto::finsky::Docid* p = _impl_.voucherdocid_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::Docid&>(
      ::playapi::proto::finsky::_Docid_default_instance_);
}
inline const ::playapi::proto::finsky::Docid& VoucherId::voucherdocid() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.VoucherId.voucherDocid)
  return _internal_voucherdocid();
}
inline void VoucherId::unsafe_arena_set_allocated_voucherdocid(
    ::playapi::proto::finsky::Docid* voucherdocid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.voucherdocid_);
  }
  _impl_.voucherdocid_ = voucherdocid;
  if (voucherdocid) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.VoucherId.voucherDocid)
}
inline ::playapi::proto::finsky::Docid* VoucherId::release_voucherdocid() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::playapi::proto::finsky::Docid* temp = _impl_.voucherdocid_;
  _impl_.voucherdocid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::Docid* VoucherId::unsafe_arena_release_voucherdocid() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.VoucherId.voucherDocid)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::playapi::proto::finsky::Docid* temp = _impl_.voucherdocid_;
  _impl_.voucherdocid_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::Docid* VoucherId::_internal_mutable_voucherdocid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.voucherdocid_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::Docid>(GetArenaForAllocation());
    _impl_.voucherdocid_ = p;
  }
  return _impl_.voucherdocid_;
}
inline ::playapi::proto::finsky::Docid* VoucherId::mutable_voucherdocid() {
  ::playapi::proto::finsky::Docid* _msg = _internal_mutable_voucherdocid();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.VoucherId.voucherDocid)
  return _msg;
}
inline void VoucherId::set_allocated_voucherdocid(::playapi::proto::finsky::Docid* voucherdocid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.voucherdocid_;
  }
  if (voucherdocid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(voucherdocid);
    if (message_arena != submessage_arena) {
      voucherdocid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, voucherdocid, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.voucherdocid_ = voucherdocid;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.VoucherId.voucherDocid)
}

// optional .playapi.proto.finsky.RedemptionRecordKey key = 2;
inline bool VoucherId::_internal_has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.key_ != nullptr);
  return value;
}
inline bool VoucherId::has_key() const {
  return _internal_has_key();
}
inline void VoucherId::clear_key() {
  if (_impl_.key_ != nullptr) _impl_.key_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::playapi::proto::finsky::RedemptionRecordKey& VoucherId::_internal_key() const {
  const ::playapi::proto::finsky::RedemptionRecordKey* p = _impl_.key_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::RedemptionRecordKey&>(
      ::playapi::proto::finsky::_RedemptionRecordKey_default_instance_);
}
inline const ::playapi::proto::finsky::RedemptionRecordKey& VoucherId::key() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.VoucherId.key)
  return _internal_key();
}
inline void VoucherId::unsafe_arena_set_allocated_key(
    ::playapi::proto::finsky::RedemptionRecordKey* key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.key_);
  }
  _impl_.key_ = key;
  if (key) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.VoucherId.key)
}
inline ::playapi::proto::finsky::RedemptionRecordKey* VoucherId::release_key() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::playapi::proto::finsky::RedemptionRecordKey* temp = _impl_.key_;
  _impl_.key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::RedemptionRecordKey* VoucherId::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.VoucherId.key)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::playapi::proto::finsky::RedemptionRecordKey* temp = _impl_.key_;
  _impl_.key_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::RedemptionRecordKey* VoucherId::_internal_mutable_key() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.key_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::RedemptionRecordKey>(GetArenaForAllocation());
    _impl_.key_ = p;
  }
  return _impl_.key_;
}
inline ::playapi::proto::finsky::RedemptionRecordKey* VoucherId::mutable_key() {
  ::playapi::proto::finsky::RedemptionRecordKey* _msg = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.VoucherId.key)
  return _msg;
}
inline void VoucherId::set_allocated_key(::playapi::proto::finsky::RedemptionRecordKey* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.key_;
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(key);
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.key_ = key;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.VoucherId.key)
}

// -------------------------------------------------------------------

// VoucherOfferTerms

// repeated .playapi.proto.finsky.Docid voucherDocid = 1;
inline int VoucherOfferTerms::_internal_voucherdocid_size() const {
  return _impl_.voucherdocid_.size();
}
inline int VoucherOfferTerms::voucherdocid_size() const {
  return _internal_voucherdocid_size();
}
inline void VoucherOfferTerms::clear_voucherdocid() {
  _impl_.voucherdocid_.Clear();
}
inline ::playapi::proto::finsky::Docid* VoucherOfferTerms::mutable_voucherdocid(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.VoucherOfferTerms.voucherDocid)
  return _impl_.voucherdocid_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Docid >*
VoucherOfferTerms::mutable_voucherdocid() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.VoucherOfferTerms.voucherDocid)
  return &_impl_.voucherdocid_;
}
inline const ::playapi::proto::finsky::Docid& VoucherOfferTerms::_internal_voucherdocid(int index) const {
  return _impl_.voucherdocid_.Get(index);
}
inline const ::playapi::proto::finsky::Docid& VoucherOfferTerms::voucherdocid(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.VoucherOfferTerms.voucherDocid)
  return _internal_voucherdocid(index);
}
inline ::playapi::proto::finsky::Docid* VoucherOfferTerms::_internal_add_voucherdocid() {
  return _impl_.voucherdocid_.Add();
}
inline ::playapi::proto::finsky::Docid* VoucherOfferTerms::add_voucherdocid() {
  ::playapi::proto::finsky::Docid* _add = _internal_add_voucherdocid();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.VoucherOfferTerms.voucherDocid)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Docid >&
VoucherOfferTerms::voucherdocid() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.VoucherOfferTerms.voucherDocid)
  return _impl_.voucherdocid_;
}

// optional int64 voucherPriceMicros = 2;
inline bool VoucherOfferTerms::_internal_has_voucherpricemicros() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VoucherOfferTerms::has_voucherpricemicros() const {
  return _internal_has_voucherpricemicros();
}
inline void VoucherOfferTerms::clear_voucherpricemicros() {
  _impl_.voucherpricemicros_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t VoucherOfferTerms::_internal_voucherpricemicros() const {
  return _impl_.voucherpricemicros_;
}
inline int64_t VoucherOfferTerms::voucherpricemicros() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.VoucherOfferTerms.voucherPriceMicros)
  return _internal_voucherpricemicros();
}
inline void VoucherOfferTerms::_internal_set_voucherpricemicros(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.voucherpricemicros_ = value;
}
inline void VoucherOfferTerms::set_voucherpricemicros(int64_t value) {
  _internal_set_voucherpricemicros(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.VoucherOfferTerms.voucherPriceMicros)
}

// optional string voucherFormattedAmount = 3;
inline bool VoucherOfferTerms::_internal_has_voucherformattedamount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VoucherOfferTerms::has_voucherformattedamount() const {
  return _internal_has_voucherformattedamount();
}
inline void VoucherOfferTerms::clear_voucherformattedamount() {
  _impl_.voucherformattedamount_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VoucherOfferTerms::voucherformattedamount() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.VoucherOfferTerms.voucherFormattedAmount)
  return _internal_voucherformattedamount();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoucherOfferTerms::set_voucherformattedamount(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.voucherformattedamount_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.VoucherOfferTerms.voucherFormattedAmount)
}
inline std::string* VoucherOfferTerms::mutable_voucherformattedamount() {
  std::string* _s = _internal_mutable_voucherformattedamount();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.VoucherOfferTerms.voucherFormattedAmount)
  return _s;
}
inline const std::string& VoucherOfferTerms::_internal_voucherformattedamount() const {
  return _impl_.voucherformattedamount_.Get();
}
inline void VoucherOfferTerms::_internal_set_voucherformattedamount(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.voucherformattedamount_.Set(value, GetArenaForAllocation());
}
inline std::string* VoucherOfferTerms::_internal_mutable_voucherformattedamount() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.voucherformattedamount_.Mutable(GetArenaForAllocation());
}
inline std::string* VoucherOfferTerms::release_voucherformattedamount() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.VoucherOfferTerms.voucherFormattedAmount)
  if (!_internal_has_voucherformattedamount()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.voucherformattedamount_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.voucherformattedamount_.IsDefault()) {
    _impl_.voucherformattedamount_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void VoucherOfferTerms::set_allocated_voucherformattedamount(std::string* voucherformattedamount) {
  if (voucherformattedamount != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.voucherformattedamount_.SetAllocated(voucherformattedamount, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.voucherformattedamount_.IsDefault()) {
    _impl_.voucherformattedamount_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.VoucherOfferTerms.voucherFormattedAmount)
}

// -------------------------------------------------------------------

// LibraryVoucher

// optional .playapi.proto.finsky.VoucherId voucherId = 1;
inline bool LibraryVoucher::_internal_has_voucherid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.voucherid_ != nullptr);
  return value;
}
inline bool LibraryVoucher::has_voucherid() const {
  return _internal_has_voucherid();
}
inline void LibraryVoucher::clear_voucherid() {
  if (_impl_.voucherid_ != nullptr) _impl_.voucherid_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::playapi::proto::finsky::VoucherId& LibraryVoucher::_internal_voucherid() const {
  const ::playapi::proto::finsky::VoucherId* p = _impl_.voucherid_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::VoucherId&>(
      ::playapi::proto::finsky::_VoucherId_default_instance_);
}
inline const ::playapi::proto::finsky::VoucherId& LibraryVoucher::voucherid() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.LibraryVoucher.voucherId)
  return _internal_voucherid();
}
inline void LibraryVoucher::unsafe_arena_set_allocated_voucherid(
    ::playapi::proto::finsky::VoucherId* voucherid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.voucherid_);
  }
  _impl_.voucherid_ = voucherid;
  if (voucherid) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.LibraryVoucher.voucherId)
}
inline ::playapi::proto::finsky::VoucherId* LibraryVoucher::release_voucherid() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::playapi::proto::finsky::VoucherId* temp = _impl_.voucherid_;
  _impl_.voucherid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::VoucherId* LibraryVoucher::unsafe_arena_release_voucherid() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.LibraryVoucher.voucherId)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::playapi::proto::finsky::VoucherId* temp = _impl_.voucherid_;
  _impl_.voucherid_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::VoucherId* LibraryVoucher::_internal_mutable_voucherid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.voucherid_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::VoucherId>(GetArenaForAllocation());
    _impl_.voucherid_ = p;
  }
  return _impl_.voucherid_;
}
inline ::playapi::proto::finsky::VoucherId* LibraryVoucher::mutable_voucherid() {
  ::playapi::proto::finsky::VoucherId* _msg = _internal_mutable_voucherid();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.LibraryVoucher.voucherId)
  return _msg;
}
inline void LibraryVoucher::set_allocated_voucherid(::playapi::proto::finsky::VoucherId* voucherid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.voucherid_;
  }
  if (voucherid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(voucherid);
    if (message_arena != submessage_arena) {
      voucherid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, voucherid, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.voucherid_ = voucherid;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.LibraryVoucher.voucherId)
}

// -------------------------------------------------------------------

// OwnershipInfo

// optional int64 initiationTimestampMsec = 1;
inline bool OwnershipInfo::_internal_has_initiationtimestampmsec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool OwnershipInfo::has_initiationtimestampmsec() const {
  return _internal_has_initiationtimestampmsec();
}
inline void OwnershipInfo::clear_initiationtimestampmsec() {
  _impl_.initiationtimestampmsec_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int64_t OwnershipInfo::_internal_initiationtimestampmsec() const {
  return _impl_.initiationtimestampmsec_;
}
inline int64_t OwnershipInfo::initiationtimestampmsec() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.OwnershipInfo.initiationTimestampMsec)
  return _internal_initiationtimestampmsec();
}
inline void OwnershipInfo::_internal_set_initiationtimestampmsec(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.initiationtimestampmsec_ = value;
}
inline void OwnershipInfo::set_initiationtimestampmsec(int64_t value) {
  _internal_set_initiationtimestampmsec(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.OwnershipInfo.initiationTimestampMsec)
}

// optional int64 validUntilTimestampMsec = 2;
inline bool OwnershipInfo::_internal_has_validuntiltimestampmsec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool OwnershipInfo::has_validuntiltimestampmsec() const {
  return _internal_has_validuntiltimestampmsec();
}
inline void OwnershipInfo::clear_validuntiltimestampmsec() {
  _impl_.validuntiltimestampmsec_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline int64_t OwnershipInfo::_internal_validuntiltimestampmsec() const {
  return _impl_.validuntiltimestampmsec_;
}
inline int64_t OwnershipInfo::validuntiltimestampmsec() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.OwnershipInfo.validUntilTimestampMsec)
  return _internal_validuntiltimestampmsec();
}
inline void OwnershipInfo::_internal_set_validuntiltimestampmsec(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.validuntiltimestampmsec_ = value;
}
inline void OwnershipInfo::set_validuntiltimestampmsec(int64_t value) {
  _internal_set_validuntiltimestampmsec(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.OwnershipInfo.validUntilTimestampMsec)
}

// optional bool autoRenewing = 3;
inline bool OwnershipInfo::_internal_has_autorenewing() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool OwnershipInfo::has_autorenewing() const {
  return _internal_has_autorenewing();
}
inline void OwnershipInfo::clear_autorenewing() {
  _impl_.autorenewing_ = false;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline bool OwnershipInfo::_internal_autorenewing() const {
  return _impl_.autorenewing_;
}
inline bool OwnershipInfo::autorenewing() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.OwnershipInfo.autoRenewing)
  return _internal_autorenewing();
}
inline void OwnershipInfo::_internal_set_autorenewing(bool value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.autorenewing_ = value;
}
inline void OwnershipInfo::set_autorenewing(bool value) {
  _internal_set_autorenewing(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.OwnershipInfo.autoRenewing)
}

// optional int64 refundTimeoutTimestampMsec = 4;
inline bool OwnershipInfo::_internal_has_refundtimeouttimestampmsec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool OwnershipInfo::has_refundtimeouttimestampmsec() const {
  return _internal_has_refundtimeouttimestampmsec();
}
inline void OwnershipInfo::clear_refundtimeouttimestampmsec() {
  _impl_.refundtimeouttimestampmsec_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline int64_t OwnershipInfo::_internal_refundtimeouttimestampmsec() const {
  return _impl_.refundtimeouttimestampmsec_;
}
inline int64_t OwnershipInfo::refundtimeouttimestampmsec() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.OwnershipInfo.refundTimeoutTimestampMsec)
  return _internal_refundtimeouttimestampmsec();
}
inline void OwnershipInfo::_internal_set_refundtimeouttimestampmsec(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.refundtimeouttimestampmsec_ = value;
}
inline void OwnershipInfo::set_refundtimeouttimestampmsec(int64_t value) {
  _internal_set_refundtimeouttimestampmsec(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.OwnershipInfo.refundTimeoutTimestampMsec)
}

// optional int64 postDeliveryRefundWindowMsec = 5;
inline bool OwnershipInfo::_internal_has_postdeliveryrefundwindowmsec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool OwnershipInfo::has_postdeliveryrefundwindowmsec() const {
  return _internal_has_postdeliveryrefundwindowmsec();
}
inline void OwnershipInfo::clear_postdeliveryrefundwindowmsec() {
  _impl_.postdeliveryrefundwindowmsec_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline int64_t OwnershipInfo::_internal_postdeliveryrefundwindowmsec() const {
  return _impl_.postdeliveryrefundwindowmsec_;
}
inline int64_t OwnershipInfo::postdeliveryrefundwindowmsec() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.OwnershipInfo.postDeliveryRefundWindowMsec)
  return _internal_postdeliveryrefundwindowmsec();
}
inline void OwnershipInfo::_internal_set_postdeliveryrefundwindowmsec(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.postdeliveryrefundwindowmsec_ = value;
}
inline void OwnershipInfo::set_postdeliveryrefundwindowmsec(int64_t value) {
  _internal_set_postdeliveryrefundwindowmsec(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.OwnershipInfo.postDeliveryRefundWindowMsec)
}

// optional .playapi.proto.finsky.SignedData developerPurchaseInfo = 6;
inline bool OwnershipInfo::_internal_has_developerpurchaseinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.developerpurchaseinfo_ != nullptr);
  return value;
}
inline bool OwnershipInfo::has_developerpurchaseinfo() const {
  return _internal_has_developerpurchaseinfo();
}
inline void OwnershipInfo::clear_developerpurchaseinfo() {
  if (_impl_.developerpurchaseinfo_ != nullptr) _impl_.developerpurchaseinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::playapi::proto::finsky::SignedData& OwnershipInfo::_internal_developerpurchaseinfo() const {
  const ::playapi::proto::finsky::SignedData* p = _impl_.developerpurchaseinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::SignedData&>(
      ::playapi::proto::finsky::_SignedData_default_instance_);
}
inline const ::playapi::proto::finsky::SignedData& OwnershipInfo::developerpurchaseinfo() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.OwnershipInfo.developerPurchaseInfo)
  return _internal_developerpurchaseinfo();
}
inline void OwnershipInfo::unsafe_arena_set_allocated_developerpurchaseinfo(
    ::playapi::proto::finsky::SignedData* developerpurchaseinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.developerpurchaseinfo_);
  }
  _impl_.developerpurchaseinfo_ = developerpurchaseinfo;
  if (developerpurchaseinfo) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.OwnershipInfo.developerPurchaseInfo)
}
inline ::playapi::proto::finsky::SignedData* OwnershipInfo::release_developerpurchaseinfo() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::playapi::proto::finsky::SignedData* temp = _impl_.developerpurchaseinfo_;
  _impl_.developerpurchaseinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::SignedData* OwnershipInfo::unsafe_arena_release_developerpurchaseinfo() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.OwnershipInfo.developerPurchaseInfo)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::playapi::proto::finsky::SignedData* temp = _impl_.developerpurchaseinfo_;
  _impl_.developerpurchaseinfo_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::SignedData* OwnershipInfo::_internal_mutable_developerpurchaseinfo() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.developerpurchaseinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::SignedData>(GetArenaForAllocation());
    _impl_.developerpurchaseinfo_ = p;
  }
  return _impl_.developerpurchaseinfo_;
}
inline ::playapi::proto::finsky::SignedData* OwnershipInfo::mutable_developerpurchaseinfo() {
  ::playapi::proto::finsky::SignedData* _msg = _internal_mutable_developerpurchaseinfo();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.OwnershipInfo.developerPurchaseInfo)
  return _msg;
}
inline void OwnershipInfo::set_allocated_developerpurchaseinfo(::playapi::proto::finsky::SignedData* developerpurchaseinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.developerpurchaseinfo_;
  }
  if (developerpurchaseinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(developerpurchaseinfo);
    if (message_arena != submessage_arena) {
      developerpurchaseinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, developerpurchaseinfo, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.developerpurchaseinfo_ = developerpurchaseinfo;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.OwnershipInfo.developerPurchaseInfo)
}

// optional bool preordered = 7;
inline bool OwnershipInfo::_internal_has_preordered() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool OwnershipInfo::has_preordered() const {
  return _internal_has_preordered();
}
inline void OwnershipInfo::clear_preordered() {
  _impl_.preordered_ = false;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline bool OwnershipInfo::_internal_preordered() const {
  return _impl_.preordered_;
}
inline bool OwnershipInfo::preordered() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.OwnershipInfo.preordered)
  return _internal_preordered();
}
inline void OwnershipInfo::_internal_set_preordered(bool value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.preordered_ = value;
}
inline void OwnershipInfo::set_preordered(bool value) {
  _internal_set_preordered(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.OwnershipInfo.preordered)
}

// optional bool hidden = 8;
inline bool OwnershipInfo::_internal_has_hidden() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool OwnershipInfo::has_hidden() const {
  return _internal_has_hidden();
}
inline void OwnershipInfo::clear_hidden() {
  _impl_.hidden_ = false;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline bool OwnershipInfo::_internal_hidden() const {
  return _impl_.hidden_;
}
inline bool OwnershipInfo::hidden() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.OwnershipInfo.hidden)
  return _internal_hidden();
}
inline void OwnershipInfo::_internal_set_hidden(bool value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.hidden_ = value;
}
inline void OwnershipInfo::set_hidden(bool value) {
  _internal_set_hidden(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.OwnershipInfo.hidden)
}

// optional .playapi.proto.finsky.RentalTerms rentalTerms = 9;
inline bool OwnershipInfo::_internal_has_rentalterms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rentalterms_ != nullptr);
  return value;
}
inline bool OwnershipInfo::has_rentalterms() const {
  return _internal_has_rentalterms();
}
inline void OwnershipInfo::clear_rentalterms() {
  if (_impl_.rentalterms_ != nullptr) _impl_.rentalterms_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::playapi::proto::finsky::RentalTerms& OwnershipInfo::_internal_rentalterms() const {
  const ::playapi::proto::finsky::RentalTerms* p = _impl_.rentalterms_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::RentalTerms&>(
      ::playapi::proto::finsky::_RentalTerms_default_instance_);
}
inline const ::playapi::proto::finsky::RentalTerms& OwnershipInfo::rentalterms() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.OwnershipInfo.rentalTerms)
  return _internal_rentalterms();
}
inline void OwnershipInfo::unsafe_arena_set_allocated_rentalterms(
    ::playapi::proto::finsky::RentalTerms* rentalterms) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rentalterms_);
  }
  _impl_.rentalterms_ = rentalterms;
  if (rentalterms) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.OwnershipInfo.rentalTerms)
}
inline ::playapi::proto::finsky::RentalTerms* OwnershipInfo::release_rentalterms() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::playapi::proto::finsky::RentalTerms* temp = _impl_.rentalterms_;
  _impl_.rentalterms_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::RentalTerms* OwnershipInfo::unsafe_arena_release_rentalterms() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.OwnershipInfo.rentalTerms)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::playapi::proto::finsky::RentalTerms* temp = _impl_.rentalterms_;
  _impl_.rentalterms_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::RentalTerms* OwnershipInfo::_internal_mutable_rentalterms() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.rentalterms_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::RentalTerms>(GetArenaForAllocation());
    _impl_.rentalterms_ = p;
  }
  return _impl_.rentalterms_;
}
inline ::playapi::proto::finsky::RentalTerms* OwnershipInfo::mutable_rentalterms() {
  ::playapi::proto::finsky::RentalTerms* _msg = _internal_mutable_rentalterms();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.OwnershipInfo.rentalTerms)
  return _msg;
}
inline void OwnershipInfo::set_allocated_rentalterms(::playapi::proto::finsky::RentalTerms* rentalterms) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rentalterms_;
  }
  if (rentalterms) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rentalterms);
    if (message_arena != submessage_arena) {
      rentalterms = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rentalterms, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.rentalterms_ = rentalterms;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.OwnershipInfo.rentalTerms)
}

// optional .playapi.proto.finsky.GroupLicenseInfo groupLicenseInfo = 10;
inline bool OwnershipInfo::_internal_has_grouplicenseinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.grouplicenseinfo_ != nullptr);
  return value;
}
inline bool OwnershipInfo::has_grouplicenseinfo() const {
  return _internal_has_grouplicenseinfo();
}
inline void OwnershipInfo::clear_grouplicenseinfo() {
  if (_impl_.grouplicenseinfo_ != nullptr) _impl_.grouplicenseinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::playapi::proto::finsky::GroupLicenseInfo& OwnershipInfo::_internal_grouplicenseinfo() const {
  const ::playapi::proto::finsky::GroupLicenseInfo* p = _impl_.grouplicenseinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::GroupLicenseInfo&>(
      ::playapi::proto::finsky::_GroupLicenseInfo_default_instance_);
}
inline const ::playapi::proto::finsky::GroupLicenseInfo& OwnershipInfo::grouplicenseinfo() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.OwnershipInfo.groupLicenseInfo)
  return _internal_grouplicenseinfo();
}
inline void OwnershipInfo::unsafe_arena_set_allocated_grouplicenseinfo(
    ::playapi::proto::finsky::GroupLicenseInfo* grouplicenseinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.grouplicenseinfo_);
  }
  _impl_.grouplicenseinfo_ = grouplicenseinfo;
  if (grouplicenseinfo) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.OwnershipInfo.groupLicenseInfo)
}
inline ::playapi::proto::finsky::GroupLicenseInfo* OwnershipInfo::release_grouplicenseinfo() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::playapi::proto::finsky::GroupLicenseInfo* temp = _impl_.grouplicenseinfo_;
  _impl_.grouplicenseinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::GroupLicenseInfo* OwnershipInfo::unsafe_arena_release_grouplicenseinfo() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.OwnershipInfo.groupLicenseInfo)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::playapi::proto::finsky::GroupLicenseInfo* temp = _impl_.grouplicenseinfo_;
  _impl_.grouplicenseinfo_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::GroupLicenseInfo* OwnershipInfo::_internal_mutable_grouplicenseinfo() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.grouplicenseinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::GroupLicenseInfo>(GetArenaForAllocation());
    _impl_.grouplicenseinfo_ = p;
  }
  return _impl_.grouplicenseinfo_;
}
inline ::playapi::proto::finsky::GroupLicenseInfo* OwnershipInfo::mutable_grouplicenseinfo() {
  ::playapi::proto::finsky::GroupLicenseInfo* _msg = _internal_mutable_grouplicenseinfo();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.OwnershipInfo.groupLicenseInfo)
  return _msg;
}
inline void OwnershipInfo::set_allocated_grouplicenseinfo(::playapi::proto::finsky::GroupLicenseInfo* grouplicenseinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.grouplicenseinfo_;
  }
  if (grouplicenseinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(grouplicenseinfo);
    if (message_arena != submessage_arena) {
      grouplicenseinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, grouplicenseinfo, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.grouplicenseinfo_ = grouplicenseinfo;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.OwnershipInfo.groupLicenseInfo)
}

// optional .playapi.proto.finsky.LicensedDocumentInfo licensedDocumentInfo = 11;
inline bool OwnershipInfo::_internal_has_licenseddocumentinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.licenseddocumentinfo_ != nullptr);
  return value;
}
inline bool OwnershipInfo::has_licenseddocumentinfo() const {
  return _internal_has_licenseddocumentinfo();
}
inline void OwnershipInfo::clear_licenseddocumentinfo() {
  if (_impl_.licenseddocumentinfo_ != nullptr) _impl_.licenseddocumentinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::playapi::proto::finsky::LicensedDocumentInfo& OwnershipInfo::_internal_licenseddocumentinfo() const {
  const ::playapi::proto::finsky::LicensedDocumentInfo* p = _impl_.licenseddocumentinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::LicensedDocumentInfo&>(
      ::playapi::proto::finsky::_LicensedDocumentInfo_default_instance_);
}
inline const ::playapi::proto::finsky::LicensedDocumentInfo& OwnershipInfo::licenseddocumentinfo() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.OwnershipInfo.licensedDocumentInfo)
  return _internal_licenseddocumentinfo();
}
inline void OwnershipInfo::unsafe_arena_set_allocated_licenseddocumentinfo(
    ::playapi::proto::finsky::LicensedDocumentInfo* licenseddocumentinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.licenseddocumentinfo_);
  }
  _impl_.licenseddocumentinfo_ = licenseddocumentinfo;
  if (licenseddocumentinfo) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.OwnershipInfo.licensedDocumentInfo)
}
inline ::playapi::proto::finsky::LicensedDocumentInfo* OwnershipInfo::release_licenseddocumentinfo() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::playapi::proto::finsky::LicensedDocumentInfo* temp = _impl_.licenseddocumentinfo_;
  _impl_.licenseddocumentinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::LicensedDocumentInfo* OwnershipInfo::unsafe_arena_release_licenseddocumentinfo() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.OwnershipInfo.licensedDocumentInfo)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::playapi::proto::finsky::LicensedDocumentInfo* temp = _impl_.licenseddocumentinfo_;
  _impl_.licenseddocumentinfo_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::LicensedDocumentInfo* OwnershipInfo::_internal_mutable_licenseddocumentinfo() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.licenseddocumentinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::LicensedDocumentInfo>(GetArenaForAllocation());
    _impl_.licenseddocumentinfo_ = p;
  }
  return _impl_.licenseddocumentinfo_;
}
inline ::playapi::proto::finsky::LicensedDocumentInfo* OwnershipInfo::mutable_licenseddocumentinfo() {
  ::playapi::proto::finsky::LicensedDocumentInfo* _msg = _internal_mutable_licenseddocumentinfo();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.OwnershipInfo.licensedDocumentInfo)
  return _msg;
}
inline void OwnershipInfo::set_allocated_licenseddocumentinfo(::playapi::proto::finsky::LicensedDocumentInfo* licenseddocumentinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.licenseddocumentinfo_;
  }
  if (licenseddocumentinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(licenseddocumentinfo);
    if (message_arena != submessage_arena) {
      licenseddocumentinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, licenseddocumentinfo, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.licenseddocumentinfo_ = licenseddocumentinfo;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.OwnershipInfo.licensedDocumentInfo)
}

// optional int32 quantity = 12;
inline bool OwnershipInfo::_internal_has_quantity() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool OwnershipInfo::has_quantity() const {
  return _internal_has_quantity();
}
inline void OwnershipInfo::clear_quantity() {
  _impl_.quantity_ = 0;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline int32_t OwnershipInfo::_internal_quantity() const {
  return _impl_.quantity_;
}
inline int32_t OwnershipInfo::quantity() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.OwnershipInfo.quantity)
  return _internal_quantity();
}
inline void OwnershipInfo::_internal_set_quantity(int32_t value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.quantity_ = value;
}
inline void OwnershipInfo::set_quantity(int32_t value) {
  _internal_set_quantity(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.OwnershipInfo.quantity)
}

// optional int64 libraryExpirationTimestampMsec = 14;
inline bool OwnershipInfo::_internal_has_libraryexpirationtimestampmsec() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool OwnershipInfo::has_libraryexpirationtimestampmsec() const {
  return _internal_has_libraryexpirationtimestampmsec();
}
inline void OwnershipInfo::clear_libraryexpirationtimestampmsec() {
  _impl_.libraryexpirationtimestampmsec_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline int64_t OwnershipInfo::_internal_libraryexpirationtimestampmsec() const {
  return _impl_.libraryexpirationtimestampmsec_;
}
inline int64_t OwnershipInfo::libraryexpirationtimestampmsec() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.OwnershipInfo.libraryExpirationTimestampMsec)
  return _internal_libraryexpirationtimestampmsec();
}
inline void OwnershipInfo::_internal_set_libraryexpirationtimestampmsec(int64_t value) {
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.libraryexpirationtimestampmsec_ = value;
}
inline void OwnershipInfo::set_libraryexpirationtimestampmsec(int64_t value) {
  _internal_set_libraryexpirationtimestampmsec(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.OwnershipInfo.libraryExpirationTimestampMsec)
}

// optional .playapi.proto.finsky.LibraryVoucher libraryVoucher = 15;
inline bool OwnershipInfo::_internal_has_libraryvoucher() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.libraryvoucher_ != nullptr);
  return value;
}
inline bool OwnershipInfo::has_libraryvoucher() const {
  return _internal_has_libraryvoucher();
}
inline void OwnershipInfo::clear_libraryvoucher() {
  if (_impl_.libraryvoucher_ != nullptr) _impl_.libraryvoucher_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::playapi::proto::finsky::LibraryVoucher& OwnershipInfo::_internal_libraryvoucher() const {
  const ::playapi::proto::finsky::LibraryVoucher* p = _impl_.libraryvoucher_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::LibraryVoucher&>(
      ::playapi::proto::finsky::_LibraryVoucher_default_instance_);
}
inline const ::playapi::proto::finsky::LibraryVoucher& OwnershipInfo::libraryvoucher() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.OwnershipInfo.libraryVoucher)
  return _internal_libraryvoucher();
}
inline void OwnershipInfo::unsafe_arena_set_allocated_libraryvoucher(
    ::playapi::proto::finsky::LibraryVoucher* libraryvoucher) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.libraryvoucher_);
  }
  _impl_.libraryvoucher_ = libraryvoucher;
  if (libraryvoucher) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.OwnershipInfo.libraryVoucher)
}
inline ::playapi::proto::finsky::LibraryVoucher* OwnershipInfo::release_libraryvoucher() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::playapi::proto::finsky::LibraryVoucher* temp = _impl_.libraryvoucher_;
  _impl_.libraryvoucher_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::LibraryVoucher* OwnershipInfo::unsafe_arena_release_libraryvoucher() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.OwnershipInfo.libraryVoucher)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::playapi::proto::finsky::LibraryVoucher* temp = _impl_.libraryvoucher_;
  _impl_.libraryvoucher_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::LibraryVoucher* OwnershipInfo::_internal_mutable_libraryvoucher() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.libraryvoucher_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::LibraryVoucher>(GetArenaForAllocation());
    _impl_.libraryvoucher_ = p;
  }
  return _impl_.libraryvoucher_;
}
inline ::playapi::proto::finsky::LibraryVoucher* OwnershipInfo::mutable_libraryvoucher() {
  ::playapi::proto::finsky::LibraryVoucher* _msg = _internal_mutable_libraryvoucher();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.OwnershipInfo.libraryVoucher)
  return _msg;
}
inline void OwnershipInfo::set_allocated_libraryvoucher(::playapi::proto::finsky::LibraryVoucher* libraryvoucher) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.libraryvoucher_;
  }
  if (libraryvoucher) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(libraryvoucher);
    if (message_arena != submessage_arena) {
      libraryvoucher = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, libraryvoucher, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.libraryvoucher_ = libraryvoucher;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.OwnershipInfo.libraryVoucher)
}

// optional .playapi.proto.finsky.Docid bundleDocid = 16;
inline bool OwnershipInfo::_internal_has_bundledocid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.bundledocid_ != nullptr);
  return value;
}
inline bool OwnershipInfo::has_bundledocid() const {
  return _internal_has_bundledocid();
}
inline void OwnershipInfo::clear_bundledocid() {
  if (_impl_.bundledocid_ != nullptr) _impl_.bundledocid_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::playapi::proto::finsky::Docid& OwnershipInfo::_internal_bundledocid() const {
  const ::playapi::proto::finsky::Docid* p = _impl_.bundledocid_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::Docid&>(
      ::playapi::proto::finsky::_Docid_default_instance_);
}
inline const ::playapi::proto::finsky::Docid& OwnershipInfo::bundledocid() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.OwnershipInfo.bundleDocid)
  return _internal_bundledocid();
}
inline void OwnershipInfo::unsafe_arena_set_allocated_bundledocid(
    ::playapi::proto::finsky::Docid* bundledocid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bundledocid_);
  }
  _impl_.bundledocid_ = bundledocid;
  if (bundledocid) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.OwnershipInfo.bundleDocid)
}
inline ::playapi::proto::finsky::Docid* OwnershipInfo::release_bundledocid() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::playapi::proto::finsky::Docid* temp = _impl_.bundledocid_;
  _impl_.bundledocid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::Docid* OwnershipInfo::unsafe_arena_release_bundledocid() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.OwnershipInfo.bundleDocid)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::playapi::proto::finsky::Docid* temp = _impl_.bundledocid_;
  _impl_.bundledocid_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::Docid* OwnershipInfo::_internal_mutable_bundledocid() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.bundledocid_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::Docid>(GetArenaForAllocation());
    _impl_.bundledocid_ = p;
  }
  return _impl_.bundledocid_;
}
inline ::playapi::proto::finsky::Docid* OwnershipInfo::mutable_bundledocid() {
  ::playapi::proto::finsky::Docid* _msg = _internal_mutable_bundledocid();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.OwnershipInfo.bundleDocid)
  return _msg;
}
inline void OwnershipInfo::set_allocated_bundledocid(::playapi::proto::finsky::Docid* bundledocid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.bundledocid_;
  }
  if (bundledocid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bundledocid);
    if (message_arena != submessage_arena) {
      bundledocid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bundledocid, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.bundledocid_ = bundledocid;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.OwnershipInfo.bundleDocid)
}

// optional bool bonus = 17;
inline bool OwnershipInfo::_internal_has_bonus() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool OwnershipInfo::has_bonus() const {
  return _internal_has_bonus();
}
inline void OwnershipInfo::clear_bonus() {
  _impl_.bonus_ = false;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline bool OwnershipInfo::_internal_bonus() const {
  return _impl_.bonus_;
}
inline bool OwnershipInfo::bonus() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.OwnershipInfo.bonus)
  return _internal_bonus();
}
inline void OwnershipInfo::_internal_set_bonus(bool value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.bonus_ = value;
}
inline void OwnershipInfo::set_bonus(bool value) {
  _internal_set_bonus(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.OwnershipInfo.bonus)
}

// optional int64 storedValidUntilTimestampMsec = 18;
inline bool OwnershipInfo::_internal_has_storedvaliduntiltimestampmsec() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool OwnershipInfo::has_storedvaliduntiltimestampmsec() const {
  return _internal_has_storedvaliduntiltimestampmsec();
}
inline void OwnershipInfo::clear_storedvaliduntiltimestampmsec() {
  _impl_.storedvaliduntiltimestampmsec_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline int64_t OwnershipInfo::_internal_storedvaliduntiltimestampmsec() const {
  return _impl_.storedvaliduntiltimestampmsec_;
}
inline int64_t OwnershipInfo::storedvaliduntiltimestampmsec() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.OwnershipInfo.storedValidUntilTimestampMsec)
  return _internal_storedvaliduntiltimestampmsec();
}
inline void OwnershipInfo::_internal_set_storedvaliduntiltimestampmsec(int64_t value) {
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.storedvaliduntiltimestampmsec_ = value;
}
inline void OwnershipInfo::set_storedvaliduntiltimestampmsec(int64_t value) {
  _internal_set_storedvaliduntiltimestampmsec(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.OwnershipInfo.storedValidUntilTimestampMsec)
}

// -------------------------------------------------------------------

// Image_Dimension

// optional int32 width = 3;
inline bool Image_Dimension::_internal_has_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Image_Dimension::has_width() const {
  return _internal_has_width();
}
inline void Image_Dimension::clear_width() {
  _impl_.width_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t Image_Dimension::_internal_width() const {
  return _impl_.width_;
}
inline int32_t Image_Dimension::width() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Image.Dimension.width)
  return _internal_width();
}
inline void Image_Dimension::_internal_set_width(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.width_ = value;
}
inline void Image_Dimension::set_width(int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.Image.Dimension.width)
}

// optional int32 height = 4;
inline bool Image_Dimension::_internal_has_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Image_Dimension::has_height() const {
  return _internal_has_height();
}
inline void Image_Dimension::clear_height() {
  _impl_.height_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t Image_Dimension::_internal_height() const {
  return _impl_.height_;
}
inline int32_t Image_Dimension::height() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Image.Dimension.height)
  return _internal_height();
}
inline void Image_Dimension::_internal_set_height(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.height_ = value;
}
inline void Image_Dimension::set_height(int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.Image.Dimension.height)
}

// optional int32 aspectRatio = 18;
inline bool Image_Dimension::_internal_has_aspectratio() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Image_Dimension::has_aspectratio() const {
  return _internal_has_aspectratio();
}
inline void Image_Dimension::clear_aspectratio() {
  _impl_.aspectratio_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t Image_Dimension::_internal_aspectratio() const {
  return _impl_.aspectratio_;
}
inline int32_t Image_Dimension::aspectratio() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Image.Dimension.aspectRatio)
  return _internal_aspectratio();
}
inline void Image_Dimension::_internal_set_aspectratio(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.aspectratio_ = value;
}
inline void Image_Dimension::set_aspectratio(int32_t value) {
  _internal_set_aspectratio(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.Image.Dimension.aspectRatio)
}

// -------------------------------------------------------------------

// Image_Citation

// optional string titleLocalized = 11;
inline bool Image_Citation::_internal_has_titlelocalized() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Image_Citation::has_titlelocalized() const {
  return _internal_has_titlelocalized();
}
inline void Image_Citation::clear_titlelocalized() {
  _impl_.titlelocalized_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Image_Citation::titlelocalized() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Image.Citation.titleLocalized)
  return _internal_titlelocalized();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Image_Citation::set_titlelocalized(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.titlelocalized_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.Image.Citation.titleLocalized)
}
inline std::string* Image_Citation::mutable_titlelocalized() {
  std::string* _s = _internal_mutable_titlelocalized();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.Image.Citation.titleLocalized)
  return _s;
}
inline const std::string& Image_Citation::_internal_titlelocalized() const {
  return _impl_.titlelocalized_.Get();
}
inline void Image_Citation::_internal_set_titlelocalized(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.titlelocalized_.Set(value, GetArenaForAllocation());
}
inline std::string* Image_Citation::_internal_mutable_titlelocalized() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.titlelocalized_.Mutable(GetArenaForAllocation());
}
inline std::string* Image_Citation::release_titlelocalized() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.Image.Citation.titleLocalized)
  if (!_internal_has_titlelocalized()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.titlelocalized_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.titlelocalized_.IsDefault()) {
    _impl_.titlelocalized_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Image_Citation::set_allocated_titlelocalized(std::string* titlelocalized) {
  if (titlelocalized != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.titlelocalized_.SetAllocated(titlelocalized, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.titlelocalized_.IsDefault()) {
    _impl_.titlelocalized_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.Image.Citation.titleLocalized)
}

// optional string url = 12;
inline bool Image_Citation::_internal_has_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Image_Citation::has_url() const {
  return _internal_has_url();
}
inline void Image_Citation::clear_url() {
  _impl_.url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Image_Citation::url() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Image.Citation.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Image_Citation::set_url(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.Image.Citation.url)
}
inline std::string* Image_Citation::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.Image.Citation.url)
  return _s;
}
inline const std::string& Image_Citation::_internal_url() const {
  return _impl_.url_.Get();
}
inline void Image_Citation::_internal_set_url(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* Image_Citation::_internal_mutable_url() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* Image_Citation::release_url() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.Image.Citation.url)
  if (!_internal_has_url()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Image_Citation::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.Image.Citation.url)
}

// -------------------------------------------------------------------

// Image

// optional int32 imageType = 1;
inline bool Image::_internal_has_imagetype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Image::has_imagetype() const {
  return _internal_has_imagetype();
}
inline void Image::clear_imagetype() {
  _impl_.imagetype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline int32_t Image::_internal_imagetype() const {
  return _impl_.imagetype_;
}
inline int32_t Image::imagetype() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Image.imageType)
  return _internal_imagetype();
}
inline void Image::_internal_set_imagetype(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.imagetype_ = value;
}
inline void Image::set_imagetype(int32_t value) {
  _internal_set_imagetype(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.Image.imageType)
}

// optional group Dimension = 2 { ... };
inline bool Image::_internal_has_dimension() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dimension_ != nullptr);
  return value;
}
inline bool Image::has_dimension() const {
  return _internal_has_dimension();
}
inline void Image::clear_dimension() {
  if (_impl_.dimension_ != nullptr) _impl_.dimension_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::playapi::proto::finsky::Image_Dimension& Image::_internal_dimension() const {
  const ::playapi::proto::finsky::Image_Dimension* p = _impl_.dimension_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::Image_Dimension&>(
      ::playapi::proto::finsky::_Image_Dimension_default_instance_);
}
inline const ::playapi::proto::finsky::Image_Dimension& Image::dimension() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Image.dimension)
  return _internal_dimension();
}
inline void Image::unsafe_arena_set_allocated_dimension(
    ::playapi::proto::finsky::Image_Dimension* dimension) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dimension_);
  }
  _impl_.dimension_ = dimension;
  if (dimension) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.Image.dimension)
}
inline ::playapi::proto::finsky::Image_Dimension* Image::release_dimension() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::playapi::proto::finsky::Image_Dimension* temp = _impl_.dimension_;
  _impl_.dimension_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::Image_Dimension* Image::unsafe_arena_release_dimension() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.Image.dimension)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::playapi::proto::finsky::Image_Dimension* temp = _impl_.dimension_;
  _impl_.dimension_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::Image_Dimension* Image::_internal_mutable_dimension() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.dimension_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::Image_Dimension>(GetArenaForAllocation());
    _impl_.dimension_ = p;
  }
  return _impl_.dimension_;
}
inline ::playapi::proto::finsky::Image_Dimension* Image::mutable_dimension() {
  ::playapi::proto::finsky::Image_Dimension* _msg = _internal_mutable_dimension();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.Image.dimension)
  return _msg;
}
inline void Image::set_allocated_dimension(::playapi::proto::finsky::Image_Dimension* dimension) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.dimension_;
  }
  if (dimension) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dimension);
    if (message_arena != submessage_arena) {
      dimension = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dimension, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.dimension_ = dimension;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.Image.dimension)
}

// optional string imageUrl = 5;
inline bool Image::_internal_has_imageurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Image::has_imageurl() const {
  return _internal_has_imageurl();
}
inline void Image::clear_imageurl() {
  _impl_.imageurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Image::imageurl() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Image.imageUrl)
  return _internal_imageurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Image::set_imageurl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.imageurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.Image.imageUrl)
}
inline std::string* Image::mutable_imageurl() {
  std::string* _s = _internal_mutable_imageurl();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.Image.imageUrl)
  return _s;
}
inline const std::string& Image::_internal_imageurl() const {
  return _impl_.imageurl_.Get();
}
inline void Image::_internal_set_imageurl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.imageurl_.Set(value, GetArenaForAllocation());
}
inline std::string* Image::_internal_mutable_imageurl() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.imageurl_.Mutable(GetArenaForAllocation());
}
inline std::string* Image::release_imageurl() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.Image.imageUrl)
  if (!_internal_has_imageurl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.imageurl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.imageurl_.IsDefault()) {
    _impl_.imageurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Image::set_allocated_imageurl(std::string* imageurl) {
  if (imageurl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.imageurl_.SetAllocated(imageurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.imageurl_.IsDefault()) {
    _impl_.imageurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.Image.imageUrl)
}

// optional string altTextLocalized = 6;
inline bool Image::_internal_has_alttextlocalized() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Image::has_alttextlocalized() const {
  return _internal_has_alttextlocalized();
}
inline void Image::clear_alttextlocalized() {
  _impl_.alttextlocalized_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Image::alttextlocalized() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Image.altTextLocalized)
  return _internal_alttextlocalized();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Image::set_alttextlocalized(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.alttextlocalized_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.Image.altTextLocalized)
}
inline std::string* Image::mutable_alttextlocalized() {
  std::string* _s = _internal_mutable_alttextlocalized();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.Image.altTextLocalized)
  return _s;
}
inline const std::string& Image::_internal_alttextlocalized() const {
  return _impl_.alttextlocalized_.Get();
}
inline void Image::_internal_set_alttextlocalized(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.alttextlocalized_.Set(value, GetArenaForAllocation());
}
inline std::string* Image::_internal_mutable_alttextlocalized() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.alttextlocalized_.Mutable(GetArenaForAllocation());
}
inline std::string* Image::release_alttextlocalized() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.Image.altTextLocalized)
  if (!_internal_has_alttextlocalized()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.alttextlocalized_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.alttextlocalized_.IsDefault()) {
    _impl_.alttextlocalized_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Image::set_allocated_alttextlocalized(std::string* alttextlocalized) {
  if (alttextlocalized != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.alttextlocalized_.SetAllocated(alttextlocalized, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.alttextlocalized_.IsDefault()) {
    _impl_.alttextlocalized_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.Image.altTextLocalized)
}

// optional string secureUrl = 7;
inline bool Image::_internal_has_secureurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Image::has_secureurl() const {
  return _internal_has_secureurl();
}
inline void Image::clear_secureurl() {
  _impl_.secureurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Image::secureurl() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Image.secureUrl)
  return _internal_secureurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Image::set_secureurl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.secureurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.Image.secureUrl)
}
inline std::string* Image::mutable_secureurl() {
  std::string* _s = _internal_mutable_secureurl();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.Image.secureUrl)
  return _s;
}
inline const std::string& Image::_internal_secureurl() const {
  return _impl_.secureurl_.Get();
}
inline void Image::_internal_set_secureurl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.secureurl_.Set(value, GetArenaForAllocation());
}
inline std::string* Image::_internal_mutable_secureurl() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.secureurl_.Mutable(GetArenaForAllocation());
}
inline std::string* Image::release_secureurl() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.Image.secureUrl)
  if (!_internal_has_secureurl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.secureurl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.secureurl_.IsDefault()) {
    _impl_.secureurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Image::set_allocated_secureurl(std::string* secureurl) {
  if (secureurl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.secureurl_.SetAllocated(secureurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.secureurl_.IsDefault()) {
    _impl_.secureurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.Image.secureUrl)
}

// optional int32 positionInSequence = 8;
inline bool Image::_internal_has_positioninsequence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool Image::has_positioninsequence() const {
  return _internal_has_positioninsequence();
}
inline void Image::clear_positioninsequence() {
  _impl_.positioninsequence_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline int32_t Image::_internal_positioninsequence() const {
  return _impl_.positioninsequence_;
}
inline int32_t Image::positioninsequence() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Image.positionInSequence)
  return _internal_positioninsequence();
}
inline void Image::_internal_set_positioninsequence(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.positioninsequence_ = value;
}
inline void Image::set_positioninsequence(int32_t value) {
  _internal_set_positioninsequence(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.Image.positionInSequence)
}

// optional bool supportsFifeUrlOptions = 9;
inline bool Image::_internal_has_supportsfifeurloptions() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool Image::has_supportsfifeurloptions() const {
  return _internal_has_supportsfifeurloptions();
}
inline void Image::clear_supportsfifeurloptions() {
  _impl_.supportsfifeurloptions_ = false;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline bool Image::_internal_supportsfifeurloptions() const {
  return _impl_.supportsfifeurloptions_;
}
inline bool Image::supportsfifeurloptions() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Image.supportsFifeUrlOptions)
  return _internal_supportsfifeurloptions();
}
inline void Image::_internal_set_supportsfifeurloptions(bool value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.supportsfifeurloptions_ = value;
}
inline void Image::set_supportsfifeurloptions(bool value) {
  _internal_set_supportsfifeurloptions(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.Image.supportsFifeUrlOptions)
}

// optional group Citation = 10 { ... };
inline bool Image::_internal_has_citation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.citation_ != nullptr);
  return value;
}
inline bool Image::has_citation() const {
  return _internal_has_citation();
}
inline void Image::clear_citation() {
  if (_impl_.citation_ != nullptr) _impl_.citation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::playapi::proto::finsky::Image_Citation& Image::_internal_citation() const {
  const ::playapi::proto::finsky::Image_Citation* p = _impl_.citation_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::Image_Citation&>(
      ::playapi::proto::finsky::_Image_Citation_default_instance_);
}
inline const ::playapi::proto::finsky::Image_Citation& Image::citation() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Image.citation)
  return _internal_citation();
}
inline void Image::unsafe_arena_set_allocated_citation(
    ::playapi::proto::finsky::Image_Citation* citation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.citation_);
  }
  _impl_.citation_ = citation;
  if (citation) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.Image.citation)
}
inline ::playapi::proto::finsky::Image_Citation* Image::release_citation() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::playapi::proto::finsky::Image_Citation* temp = _impl_.citation_;
  _impl_.citation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::Image_Citation* Image::unsafe_arena_release_citation() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.Image.citation)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::playapi::proto::finsky::Image_Citation* temp = _impl_.citation_;
  _impl_.citation_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::Image_Citation* Image::_internal_mutable_citation() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.citation_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::Image_Citation>(GetArenaForAllocation());
    _impl_.citation_ = p;
  }
  return _impl_.citation_;
}
inline ::playapi::proto::finsky::Image_Citation* Image::mutable_citation() {
  ::playapi::proto::finsky::Image_Citation* _msg = _internal_mutable_citation();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.Image.citation)
  return _msg;
}
inline void Image::set_allocated_citation(::playapi::proto::finsky::Image_Citation* citation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.citation_;
  }
  if (citation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(citation);
    if (message_arena != submessage_arena) {
      citation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, citation, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.citation_ = citation;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.Image.citation)
}

// optional int32 durationSeconds = 14;
inline bool Image::_internal_has_durationseconds() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool Image::has_durationseconds() const {
  return _internal_has_durationseconds();
}
inline void Image::clear_durationseconds() {
  _impl_.durationseconds_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline int32_t Image::_internal_durationseconds() const {
  return _impl_.durationseconds_;
}
inline int32_t Image::durationseconds() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Image.durationSeconds)
  return _internal_durationseconds();
}
inline void Image::_internal_set_durationseconds(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.durationseconds_ = value;
}
inline void Image::set_durationseconds(int32_t value) {
  _internal_set_durationseconds(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.Image.durationSeconds)
}

// optional string fillColorRgb = 15;
inline bool Image::_internal_has_fillcolorrgb() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Image::has_fillcolorrgb() const {
  return _internal_has_fillcolorrgb();
}
inline void Image::clear_fillcolorrgb() {
  _impl_.fillcolorrgb_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& Image::fillcolorrgb() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Image.fillColorRgb)
  return _internal_fillcolorrgb();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Image::set_fillcolorrgb(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.fillcolorrgb_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.Image.fillColorRgb)
}
inline std::string* Image::mutable_fillcolorrgb() {
  std::string* _s = _internal_mutable_fillcolorrgb();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.Image.fillColorRgb)
  return _s;
}
inline const std::string& Image::_internal_fillcolorrgb() const {
  return _impl_.fillcolorrgb_.Get();
}
inline void Image::_internal_set_fillcolorrgb(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.fillcolorrgb_.Set(value, GetArenaForAllocation());
}
inline std::string* Image::_internal_mutable_fillcolorrgb() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.fillcolorrgb_.Mutable(GetArenaForAllocation());
}
inline std::string* Image::release_fillcolorrgb() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.Image.fillColorRgb)
  if (!_internal_has_fillcolorrgb()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.fillcolorrgb_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fillcolorrgb_.IsDefault()) {
    _impl_.fillcolorrgb_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Image::set_allocated_fillcolorrgb(std::string* fillcolorrgb) {
  if (fillcolorrgb != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.fillcolorrgb_.SetAllocated(fillcolorrgb, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fillcolorrgb_.IsDefault()) {
    _impl_.fillcolorrgb_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.Image.fillColorRgb)
}

// optional bool autogen = 16;
inline bool Image::_internal_has_autogen() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool Image::has_autogen() const {
  return _internal_has_autogen();
}
inline void Image::clear_autogen() {
  _impl_.autogen_ = false;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline bool Image::_internal_autogen() const {
  return _impl_.autogen_;
}
inline bool Image::autogen() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Image.autogen)
  return _internal_autogen();
}
inline void Image::_internal_set_autogen(bool value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.autogen_ = value;
}
inline void Image::set_autogen(bool value) {
  _internal_set_autogen(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.Image.autogen)
}

// optional .playapi.proto.finsky.Attribution attribution = 17;
inline bool Image::_internal_has_attribution() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.attribution_ != nullptr);
  return value;
}
inline bool Image::has_attribution() const {
  return _internal_has_attribution();
}
inline void Image::clear_attribution() {
  if (_impl_.attribution_ != nullptr) _impl_.attribution_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::playapi::proto::finsky::Attribution& Image::_internal_attribution() const {
  const ::playapi::proto::finsky::Attribution* p = _impl_.attribution_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::Attribution&>(
      ::playapi::proto::finsky::_Attribution_default_instance_);
}
inline const ::playapi::proto::finsky::Attribution& Image::attribution() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Image.attribution)
  return _internal_attribution();
}
inline void Image::unsafe_arena_set_allocated_attribution(
    ::playapi::proto::finsky::Attribution* attribution) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.attribution_);
  }
  _impl_.attribution_ = attribution;
  if (attribution) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.Image.attribution)
}
inline ::playapi::proto::finsky::Attribution* Image::release_attribution() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::playapi::proto::finsky::Attribution* temp = _impl_.attribution_;
  _impl_.attribution_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::Attribution* Image::unsafe_arena_release_attribution() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.Image.attribution)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::playapi::proto::finsky::Attribution* temp = _impl_.attribution_;
  _impl_.attribution_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::Attribution* Image::_internal_mutable_attribution() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.attribution_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::Attribution>(GetArenaForAllocation());
    _impl_.attribution_ = p;
  }
  return _impl_.attribution_;
}
inline ::playapi::proto::finsky::Attribution* Image::mutable_attribution() {
  ::playapi::proto::finsky::Attribution* _msg = _internal_mutable_attribution();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.Image.attribution)
  return _msg;
}
inline void Image::set_allocated_attribution(::playapi::proto::finsky::Attribution* attribution) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.attribution_;
  }
  if (attribution) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(attribution);
    if (message_arena != submessage_arena) {
      attribution = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attribution, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.attribution_ = attribution;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.Image.attribution)
}

// optional string backgroundColorRgb = 19;
inline bool Image::_internal_has_backgroundcolorrgb() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Image::has_backgroundcolorrgb() const {
  return _internal_has_backgroundcolorrgb();
}
inline void Image::clear_backgroundcolorrgb() {
  _impl_.backgroundcolorrgb_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& Image::backgroundcolorrgb() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Image.backgroundColorRgb)
  return _internal_backgroundcolorrgb();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Image::set_backgroundcolorrgb(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.backgroundcolorrgb_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.Image.backgroundColorRgb)
}
inline std::string* Image::mutable_backgroundcolorrgb() {
  std::string* _s = _internal_mutable_backgroundcolorrgb();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.Image.backgroundColorRgb)
  return _s;
}
inline const std::string& Image::_internal_backgroundcolorrgb() const {
  return _impl_.backgroundcolorrgb_.Get();
}
inline void Image::_internal_set_backgroundcolorrgb(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.backgroundcolorrgb_.Set(value, GetArenaForAllocation());
}
inline std::string* Image::_internal_mutable_backgroundcolorrgb() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.backgroundcolorrgb_.Mutable(GetArenaForAllocation());
}
inline std::string* Image::release_backgroundcolorrgb() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.Image.backgroundColorRgb)
  if (!_internal_has_backgroundcolorrgb()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.backgroundcolorrgb_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.backgroundcolorrgb_.IsDefault()) {
    _impl_.backgroundcolorrgb_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Image::set_allocated_backgroundcolorrgb(std::string* backgroundcolorrgb) {
  if (backgroundcolorrgb != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.backgroundcolorrgb_.SetAllocated(backgroundcolorrgb, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.backgroundcolorrgb_.IsDefault()) {
    _impl_.backgroundcolorrgb_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.Image.backgroundColorRgb)
}

// optional .playapi.proto.finsky.ImagePalette palette = 20;
inline bool Image::_internal_has_palette() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.palette_ != nullptr);
  return value;
}
inline bool Image::has_palette() const {
  return _internal_has_palette();
}
inline void Image::clear_palette() {
  if (_impl_.palette_ != nullptr) _impl_.palette_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::playapi::proto::finsky::ImagePalette& Image::_internal_palette() const {
  const ::playapi::proto::finsky::ImagePalette* p = _impl_.palette_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::ImagePalette&>(
      ::playapi::proto::finsky::_ImagePalette_default_instance_);
}
inline const ::playapi::proto::finsky::ImagePalette& Image::palette() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Image.palette)
  return _internal_palette();
}
inline void Image::unsafe_arena_set_allocated_palette(
    ::playapi::proto::finsky::ImagePalette* palette) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.palette_);
  }
  _impl_.palette_ = palette;
  if (palette) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.Image.palette)
}
inline ::playapi::proto::finsky::ImagePalette* Image::release_palette() {
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::playapi::proto::finsky::ImagePalette* temp = _impl_.palette_;
  _impl_.palette_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::ImagePalette* Image::unsafe_arena_release_palette() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.Image.palette)
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::playapi::proto::finsky::ImagePalette* temp = _impl_.palette_;
  _impl_.palette_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::ImagePalette* Image::_internal_mutable_palette() {
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.palette_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::ImagePalette>(GetArenaForAllocation());
    _impl_.palette_ = p;
  }
  return _impl_.palette_;
}
inline ::playapi::proto::finsky::ImagePalette* Image::mutable_palette() {
  ::playapi::proto::finsky::ImagePalette* _msg = _internal_mutable_palette();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.Image.palette)
  return _msg;
}
inline void Image::set_allocated_palette(::playapi::proto::finsky::ImagePalette* palette) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.palette_;
  }
  if (palette) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(palette);
    if (message_arena != submessage_arena) {
      palette = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, palette, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.palette_ = palette;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.Image.palette)
}

// optional int32 deviceClass = 21;
inline bool Image::_internal_has_deviceclass() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool Image::has_deviceclass() const {
  return _internal_has_deviceclass();
}
inline void Image::clear_deviceclass() {
  _impl_.deviceclass_ = 0;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline int32_t Image::_internal_deviceclass() const {
  return _impl_.deviceclass_;
}
inline int32_t Image::deviceclass() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Image.deviceClass)
  return _internal_deviceclass();
}
inline void Image::_internal_set_deviceclass(int32_t value) {
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.deviceclass_ = value;
}
inline void Image::set_deviceclass(int32_t value) {
  _internal_set_deviceclass(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.Image.deviceClass)
}

// optional bool supportsFifeMonogramOption = 22;
inline bool Image::_internal_has_supportsfifemonogramoption() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool Image::has_supportsfifemonogramoption() const {
  return _internal_has_supportsfifemonogramoption();
}
inline void Image::clear_supportsfifemonogramoption() {
  _impl_.supportsfifemonogramoption_ = false;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline bool Image::_internal_supportsfifemonogramoption() const {
  return _impl_.supportsfifemonogramoption_;
}
inline bool Image::supportsfifemonogramoption() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Image.supportsFifeMonogramOption)
  return _internal_supportsfifemonogramoption();
}
inline void Image::_internal_set_supportsfifemonogramoption(bool value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.supportsfifemonogramoption_ = value;
}
inline void Image::set_supportsfifemonogramoption(bool value) {
  _internal_set_supportsfifemonogramoption(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.Image.supportsFifeMonogramOption)
}

// -------------------------------------------------------------------

// ImagePalette

// optional string lightVibrantRgb = 1;
inline bool ImagePalette::_internal_has_lightvibrantrgb() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ImagePalette::has_lightvibrantrgb() const {
  return _internal_has_lightvibrantrgb();
}
inline void ImagePalette::clear_lightvibrantrgb() {
  _impl_.lightvibrantrgb_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ImagePalette::lightvibrantrgb() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.ImagePalette.lightVibrantRgb)
  return _internal_lightvibrantrgb();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImagePalette::set_lightvibrantrgb(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.lightvibrantrgb_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.ImagePalette.lightVibrantRgb)
}
inline std::string* ImagePalette::mutable_lightvibrantrgb() {
  std::string* _s = _internal_mutable_lightvibrantrgb();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.ImagePalette.lightVibrantRgb)
  return _s;
}
inline const std::string& ImagePalette::_internal_lightvibrantrgb() const {
  return _impl_.lightvibrantrgb_.Get();
}
inline void ImagePalette::_internal_set_lightvibrantrgb(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.lightvibrantrgb_.Set(value, GetArenaForAllocation());
}
inline std::string* ImagePalette::_internal_mutable_lightvibrantrgb() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.lightvibrantrgb_.Mutable(GetArenaForAllocation());
}
inline std::string* ImagePalette::release_lightvibrantrgb() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.ImagePalette.lightVibrantRgb)
  if (!_internal_has_lightvibrantrgb()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.lightvibrantrgb_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.lightvibrantrgb_.IsDefault()) {
    _impl_.lightvibrantrgb_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ImagePalette::set_allocated_lightvibrantrgb(std::string* lightvibrantrgb) {
  if (lightvibrantrgb != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.lightvibrantrgb_.SetAllocated(lightvibrantrgb, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.lightvibrantrgb_.IsDefault()) {
    _impl_.lightvibrantrgb_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.ImagePalette.lightVibrantRgb)
}

// optional string vibrantRgb = 2;
inline bool ImagePalette::_internal_has_vibrantrgb() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ImagePalette::has_vibrantrgb() const {
  return _internal_has_vibrantrgb();
}
inline void ImagePalette::clear_vibrantrgb() {
  _impl_.vibrantrgb_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ImagePalette::vibrantrgb() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.ImagePalette.vibrantRgb)
  return _internal_vibrantrgb();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImagePalette::set_vibrantrgb(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.vibrantrgb_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.ImagePalette.vibrantRgb)
}
inline std::string* ImagePalette::mutable_vibrantrgb() {
  std::string* _s = _internal_mutable_vibrantrgb();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.ImagePalette.vibrantRgb)
  return _s;
}
inline const std::string& ImagePalette::_internal_vibrantrgb() const {
  return _impl_.vibrantrgb_.Get();
}
inline void ImagePalette::_internal_set_vibrantrgb(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.vibrantrgb_.Set(value, GetArenaForAllocation());
}
inline std::string* ImagePalette::_internal_mutable_vibrantrgb() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.vibrantrgb_.Mutable(GetArenaForAllocation());
}
inline std::string* ImagePalette::release_vibrantrgb() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.ImagePalette.vibrantRgb)
  if (!_internal_has_vibrantrgb()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.vibrantrgb_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vibrantrgb_.IsDefault()) {
    _impl_.vibrantrgb_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ImagePalette::set_allocated_vibrantrgb(std::string* vibrantrgb) {
  if (vibrantrgb != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.vibrantrgb_.SetAllocated(vibrantrgb, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vibrantrgb_.IsDefault()) {
    _impl_.vibrantrgb_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.ImagePalette.vibrantRgb)
}

// optional string darkVibrantRgb = 3;
inline bool ImagePalette::_internal_has_darkvibrantrgb() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ImagePalette::has_darkvibrantrgb() const {
  return _internal_has_darkvibrantrgb();
}
inline void ImagePalette::clear_darkvibrantrgb() {
  _impl_.darkvibrantrgb_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ImagePalette::darkvibrantrgb() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.ImagePalette.darkVibrantRgb)
  return _internal_darkvibrantrgb();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImagePalette::set_darkvibrantrgb(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.darkvibrantrgb_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.ImagePalette.darkVibrantRgb)
}
inline std::string* ImagePalette::mutable_darkvibrantrgb() {
  std::string* _s = _internal_mutable_darkvibrantrgb();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.ImagePalette.darkVibrantRgb)
  return _s;
}
inline const std::string& ImagePalette::_internal_darkvibrantrgb() const {
  return _impl_.darkvibrantrgb_.Get();
}
inline void ImagePalette::_internal_set_darkvibrantrgb(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.darkvibrantrgb_.Set(value, GetArenaForAllocation());
}
inline std::string* ImagePalette::_internal_mutable_darkvibrantrgb() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.darkvibrantrgb_.Mutable(GetArenaForAllocation());
}
inline std::string* ImagePalette::release_darkvibrantrgb() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.ImagePalette.darkVibrantRgb)
  if (!_internal_has_darkvibrantrgb()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.darkvibrantrgb_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.darkvibrantrgb_.IsDefault()) {
    _impl_.darkvibrantrgb_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ImagePalette::set_allocated_darkvibrantrgb(std::string* darkvibrantrgb) {
  if (darkvibrantrgb != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.darkvibrantrgb_.SetAllocated(darkvibrantrgb, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.darkvibrantrgb_.IsDefault()) {
    _impl_.darkvibrantrgb_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.ImagePalette.darkVibrantRgb)
}

// optional string lightMutedRgb = 4;
inline bool ImagePalette::_internal_has_lightmutedrgb() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ImagePalette::has_lightmutedrgb() const {
  return _internal_has_lightmutedrgb();
}
inline void ImagePalette::clear_lightmutedrgb() {
  _impl_.lightmutedrgb_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ImagePalette::lightmutedrgb() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.ImagePalette.lightMutedRgb)
  return _internal_lightmutedrgb();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImagePalette::set_lightmutedrgb(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.lightmutedrgb_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.ImagePalette.lightMutedRgb)
}
inline std::string* ImagePalette::mutable_lightmutedrgb() {
  std::string* _s = _internal_mutable_lightmutedrgb();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.ImagePalette.lightMutedRgb)
  return _s;
}
inline const std::string& ImagePalette::_internal_lightmutedrgb() const {
  return _impl_.lightmutedrgb_.Get();
}
inline void ImagePalette::_internal_set_lightmutedrgb(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.lightmutedrgb_.Set(value, GetArenaForAllocation());
}
inline std::string* ImagePalette::_internal_mutable_lightmutedrgb() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.lightmutedrgb_.Mutable(GetArenaForAllocation());
}
inline std::string* ImagePalette::release_lightmutedrgb() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.ImagePalette.lightMutedRgb)
  if (!_internal_has_lightmutedrgb()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.lightmutedrgb_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.lightmutedrgb_.IsDefault()) {
    _impl_.lightmutedrgb_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ImagePalette::set_allocated_lightmutedrgb(std::string* lightmutedrgb) {
  if (lightmutedrgb != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.lightmutedrgb_.SetAllocated(lightmutedrgb, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.lightmutedrgb_.IsDefault()) {
    _impl_.lightmutedrgb_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.ImagePalette.lightMutedRgb)
}

// optional string mutedRgb = 5;
inline bool ImagePalette::_internal_has_mutedrgb() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ImagePalette::has_mutedrgb() const {
  return _internal_has_mutedrgb();
}
inline void ImagePalette::clear_mutedrgb() {
  _impl_.mutedrgb_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& ImagePalette::mutedrgb() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.ImagePalette.mutedRgb)
  return _internal_mutedrgb();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImagePalette::set_mutedrgb(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.mutedrgb_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.ImagePalette.mutedRgb)
}
inline std::string* ImagePalette::mutable_mutedrgb() {
  std::string* _s = _internal_mutable_mutedrgb();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.ImagePalette.mutedRgb)
  return _s;
}
inline const std::string& ImagePalette::_internal_mutedrgb() const {
  return _impl_.mutedrgb_.Get();
}
inline void ImagePalette::_internal_set_mutedrgb(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.mutedrgb_.Set(value, GetArenaForAllocation());
}
inline std::string* ImagePalette::_internal_mutable_mutedrgb() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.mutedrgb_.Mutable(GetArenaForAllocation());
}
inline std::string* ImagePalette::release_mutedrgb() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.ImagePalette.mutedRgb)
  if (!_internal_has_mutedrgb()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.mutedrgb_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mutedrgb_.IsDefault()) {
    _impl_.mutedrgb_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ImagePalette::set_allocated_mutedrgb(std::string* mutedrgb) {
  if (mutedrgb != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.mutedrgb_.SetAllocated(mutedrgb, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mutedrgb_.IsDefault()) {
    _impl_.mutedrgb_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.ImagePalette.mutedRgb)
}

// optional string darkMutedRgb = 6;
inline bool ImagePalette::_internal_has_darkmutedrgb() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ImagePalette::has_darkmutedrgb() const {
  return _internal_has_darkmutedrgb();
}
inline void ImagePalette::clear_darkmutedrgb() {
  _impl_.darkmutedrgb_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& ImagePalette::darkmutedrgb() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.ImagePalette.darkMutedRgb)
  return _internal_darkmutedrgb();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImagePalette::set_darkmutedrgb(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.darkmutedrgb_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.ImagePalette.darkMutedRgb)
}
inline std::string* ImagePalette::mutable_darkmutedrgb() {
  std::string* _s = _internal_mutable_darkmutedrgb();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.ImagePalette.darkMutedRgb)
  return _s;
}
inline const std::string& ImagePalette::_internal_darkmutedrgb() const {
  return _impl_.darkmutedrgb_.Get();
}
inline void ImagePalette::_internal_set_darkmutedrgb(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.darkmutedrgb_.Set(value, GetArenaForAllocation());
}
inline std::string* ImagePalette::_internal_mutable_darkmutedrgb() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.darkmutedrgb_.Mutable(GetArenaForAllocation());
}
inline std::string* ImagePalette::release_darkmutedrgb() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.ImagePalette.darkMutedRgb)
  if (!_internal_has_darkmutedrgb()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.darkmutedrgb_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.darkmutedrgb_.IsDefault()) {
    _impl_.darkmutedrgb_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ImagePalette::set_allocated_darkmutedrgb(std::string* darkmutedrgb) {
  if (darkmutedrgb != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.darkmutedrgb_.SetAllocated(darkmutedrgb, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.darkmutedrgb_.IsDefault()) {
    _impl_.darkmutedrgb_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.ImagePalette.darkMutedRgb)
}

// -------------------------------------------------------------------

// Attribution

// optional string sourceTitle = 1;
inline bool Attribution::_internal_has_sourcetitle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Attribution::has_sourcetitle() const {
  return _internal_has_sourcetitle();
}
inline void Attribution::clear_sourcetitle() {
  _impl_.sourcetitle_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Attribution::sourcetitle() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Attribution.sourceTitle)
  return _internal_sourcetitle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Attribution::set_sourcetitle(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.sourcetitle_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.Attribution.sourceTitle)
}
inline std::string* Attribution::mutable_sourcetitle() {
  std::string* _s = _internal_mutable_sourcetitle();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.Attribution.sourceTitle)
  return _s;
}
inline const std::string& Attribution::_internal_sourcetitle() const {
  return _impl_.sourcetitle_.Get();
}
inline void Attribution::_internal_set_sourcetitle(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sourcetitle_.Set(value, GetArenaForAllocation());
}
inline std::string* Attribution::_internal_mutable_sourcetitle() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.sourcetitle_.Mutable(GetArenaForAllocation());
}
inline std::string* Attribution::release_sourcetitle() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.Attribution.sourceTitle)
  if (!_internal_has_sourcetitle()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.sourcetitle_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sourcetitle_.IsDefault()) {
    _impl_.sourcetitle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Attribution::set_allocated_sourcetitle(std::string* sourcetitle) {
  if (sourcetitle != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.sourcetitle_.SetAllocated(sourcetitle, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sourcetitle_.IsDefault()) {
    _impl_.sourcetitle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.Attribution.sourceTitle)
}

// optional string sourceUrl = 2;
inline bool Attribution::_internal_has_sourceurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Attribution::has_sourceurl() const {
  return _internal_has_sourceurl();
}
inline void Attribution::clear_sourceurl() {
  _impl_.sourceurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Attribution::sourceurl() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Attribution.sourceUrl)
  return _internal_sourceurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Attribution::set_sourceurl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.sourceurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.Attribution.sourceUrl)
}
inline std::string* Attribution::mutable_sourceurl() {
  std::string* _s = _internal_mutable_sourceurl();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.Attribution.sourceUrl)
  return _s;
}
inline const std::string& Attribution::_internal_sourceurl() const {
  return _impl_.sourceurl_.Get();
}
inline void Attribution::_internal_set_sourceurl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.sourceurl_.Set(value, GetArenaForAllocation());
}
inline std::string* Attribution::_internal_mutable_sourceurl() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.sourceurl_.Mutable(GetArenaForAllocation());
}
inline std::string* Attribution::release_sourceurl() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.Attribution.sourceUrl)
  if (!_internal_has_sourceurl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.sourceurl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sourceurl_.IsDefault()) {
    _impl_.sourceurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Attribution::set_allocated_sourceurl(std::string* sourceurl) {
  if (sourceurl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.sourceurl_.SetAllocated(sourceurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sourceurl_.IsDefault()) {
    _impl_.sourceurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.Attribution.sourceUrl)
}

// optional string licenseTitle = 3;
inline bool Attribution::_internal_has_licensetitle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Attribution::has_licensetitle() const {
  return _internal_has_licensetitle();
}
inline void Attribution::clear_licensetitle() {
  _impl_.licensetitle_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Attribution::licensetitle() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Attribution.licenseTitle)
  return _internal_licensetitle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Attribution::set_licensetitle(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.licensetitle_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.Attribution.licenseTitle)
}
inline std::string* Attribution::mutable_licensetitle() {
  std::string* _s = _internal_mutable_licensetitle();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.Attribution.licenseTitle)
  return _s;
}
inline const std::string& Attribution::_internal_licensetitle() const {
  return _impl_.licensetitle_.Get();
}
inline void Attribution::_internal_set_licensetitle(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.licensetitle_.Set(value, GetArenaForAllocation());
}
inline std::string* Attribution::_internal_mutable_licensetitle() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.licensetitle_.Mutable(GetArenaForAllocation());
}
inline std::string* Attribution::release_licensetitle() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.Attribution.licenseTitle)
  if (!_internal_has_licensetitle()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.licensetitle_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.licensetitle_.IsDefault()) {
    _impl_.licensetitle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Attribution::set_allocated_licensetitle(std::string* licensetitle) {
  if (licensetitle != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.licensetitle_.SetAllocated(licensetitle, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.licensetitle_.IsDefault()) {
    _impl_.licensetitle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.Attribution.licenseTitle)
}

// optional string licenseUrl = 4;
inline bool Attribution::_internal_has_licenseurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Attribution::has_licenseurl() const {
  return _internal_has_licenseurl();
}
inline void Attribution::clear_licenseurl() {
  _impl_.licenseurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& Attribution::licenseurl() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.Attribution.licenseUrl)
  return _internal_licenseurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Attribution::set_licenseurl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.licenseurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.Attribution.licenseUrl)
}
inline std::string* Attribution::mutable_licenseurl() {
  std::string* _s = _internal_mutable_licenseurl();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.Attribution.licenseUrl)
  return _s;
}
inline const std::string& Attribution::_internal_licenseurl() const {
  return _impl_.licenseurl_.Get();
}
inline void Attribution::_internal_set_licenseurl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.licenseurl_.Set(value, GetArenaForAllocation());
}
inline std::string* Attribution::_internal_mutable_licenseurl() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.licenseurl_.Mutable(GetArenaForAllocation());
}
inline std::string* Attribution::release_licenseurl() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.Attribution.licenseUrl)
  if (!_internal_has_licenseurl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.licenseurl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.licenseurl_.IsDefault()) {
    _impl_.licenseurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Attribution::set_allocated_licenseurl(std::string* licenseurl) {
  if (licenseurl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.licenseurl_.SetAllocated(licenseurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.licenseurl_.IsDefault()) {
    _impl_.licenseurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.Attribution.licenseUrl)
}

// -------------------------------------------------------------------

// CertificateSet

// repeated string certificateHash = 1;
inline int CertificateSet::_internal_certificatehash_size() const {
  return _impl_.certificatehash_.size();
}
inline int CertificateSet::certificatehash_size() const {
  return _internal_certificatehash_size();
}
inline void CertificateSet::clear_certificatehash() {
  _impl_.certificatehash_.Clear();
}
inline std::string* CertificateSet::add_certificatehash() {
  std::string* _s = _internal_add_certificatehash();
  // @@protoc_insertion_point(field_add_mutable:playapi.proto.finsky.CertificateSet.certificateHash)
  return _s;
}
inline const std::string& CertificateSet::_internal_certificatehash(int index) const {
  return _impl_.certificatehash_.Get(index);
}
inline const std::string& CertificateSet::certificatehash(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.CertificateSet.certificateHash)
  return _internal_certificatehash(index);
}
inline std::string* CertificateSet::mutable_certificatehash(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.CertificateSet.certificateHash)
  return _impl_.certificatehash_.Mutable(index);
}
inline void CertificateSet::set_certificatehash(int index, const std::string& value) {
  _impl_.certificatehash_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.CertificateSet.certificateHash)
}
inline void CertificateSet::set_certificatehash(int index, std::string&& value) {
  _impl_.certificatehash_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.CertificateSet.certificateHash)
}
inline void CertificateSet::set_certificatehash(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.certificatehash_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:playapi.proto.finsky.CertificateSet.certificateHash)
}
inline void CertificateSet::set_certificatehash(int index, const char* value, size_t size) {
  _impl_.certificatehash_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:playapi.proto.finsky.CertificateSet.certificateHash)
}
inline std::string* CertificateSet::_internal_add_certificatehash() {
  return _impl_.certificatehash_.Add();
}
inline void CertificateSet::add_certificatehash(const std::string& value) {
  _impl_.certificatehash_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.CertificateSet.certificateHash)
}
inline void CertificateSet::add_certificatehash(std::string&& value) {
  _impl_.certificatehash_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.CertificateSet.certificateHash)
}
inline void CertificateSet::add_certificatehash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.certificatehash_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:playapi.proto.finsky.CertificateSet.certificateHash)
}
inline void CertificateSet::add_certificatehash(const char* value, size_t size) {
  _impl_.certificatehash_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:playapi.proto.finsky.CertificateSet.certificateHash)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CertificateSet::certificatehash() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.CertificateSet.certificateHash)
  return _impl_.certificatehash_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CertificateSet::mutable_certificatehash() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.CertificateSet.certificateHash)
  return &_impl_.certificatehash_;
}

// -------------------------------------------------------------------

// EncodedTargets

// optional int32 version = 1;
inline bool EncodedTargets::_internal_has_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EncodedTargets::has_version() const {
  return _internal_has_version();
}
inline void EncodedTargets::clear_version() {
  _impl_.version_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t EncodedTargets::_internal_version() const {
  return _impl_.version_;
}
inline int32_t EncodedTargets::version() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.EncodedTargets.version)
  return _internal_version();
}
inline void EncodedTargets::_internal_set_version(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.version_ = value;
}
inline void EncodedTargets::set_version(int32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.EncodedTargets.version)
}

// repeated int64 supportedTarget = 2;
inline int EncodedTargets::_internal_supportedtarget_size() const {
  return _impl_.supportedtarget_.size();
}
inline int EncodedTargets::supportedtarget_size() const {
  return _internal_supportedtarget_size();
}
inline void EncodedTargets::clear_supportedtarget() {
  _impl_.supportedtarget_.Clear();
}
inline int64_t EncodedTargets::_internal_supportedtarget(int index) const {
  return _impl_.supportedtarget_.Get(index);
}
inline int64_t EncodedTargets::supportedtarget(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.EncodedTargets.supportedTarget)
  return _internal_supportedtarget(index);
}
inline void EncodedTargets::set_supportedtarget(int index, int64_t value) {
  _impl_.supportedtarget_.Set(index, value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.EncodedTargets.supportedTarget)
}
inline void EncodedTargets::_internal_add_supportedtarget(int64_t value) {
  _impl_.supportedtarget_.Add(value);
}
inline void EncodedTargets::add_supportedtarget(int64_t value) {
  _internal_add_supportedtarget(value);
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.EncodedTargets.supportedTarget)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
EncodedTargets::_internal_supportedtarget() const {
  return _impl_.supportedtarget_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
EncodedTargets::supportedtarget() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.EncodedTargets.supportedTarget)
  return _internal_supportedtarget();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
EncodedTargets::_internal_mutable_supportedtarget() {
  return &_impl_.supportedtarget_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
EncodedTargets::mutable_supportedtarget() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.EncodedTargets.supportedTarget)
  return _internal_mutable_supportedtarget();
}

// repeated int64 otherTarget = 3;
inline int EncodedTargets::_internal_othertarget_size() const {
  return _impl_.othertarget_.size();
}
inline int EncodedTargets::othertarget_size() const {
  return _internal_othertarget_size();
}
inline void EncodedTargets::clear_othertarget() {
  _impl_.othertarget_.Clear();
}
inline int64_t EncodedTargets::_internal_othertarget(int index) const {
  return _impl_.othertarget_.Get(index);
}
inline int64_t EncodedTargets::othertarget(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.EncodedTargets.otherTarget)
  return _internal_othertarget(index);
}
inline void EncodedTargets::set_othertarget(int index, int64_t value) {
  _impl_.othertarget_.Set(index, value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.EncodedTargets.otherTarget)
}
inline void EncodedTargets::_internal_add_othertarget(int64_t value) {
  _impl_.othertarget_.Add(value);
}
inline void EncodedTargets::add_othertarget(int64_t value) {
  _internal_add_othertarget(value);
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.EncodedTargets.otherTarget)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
EncodedTargets::_internal_othertarget() const {
  return _impl_.othertarget_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
EncodedTargets::othertarget() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.EncodedTargets.otherTarget)
  return _internal_othertarget();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
EncodedTargets::_internal_mutable_othertarget() {
  return &_impl_.othertarget_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
EncodedTargets::mutable_othertarget() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.EncodedTargets.otherTarget)
  return _internal_mutable_othertarget();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace finsky
}  // namespace proto
}  // namespace playapi

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_play_5fcommon_2eproto
