// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: play_document.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_play_5fdocument_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_play_5fdocument_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "play_common.pb.h"
#include "play_containers.pb.h"
#include "play_filter_rules.pb.h"
#include "play_link.pb.h"
#include "play_download.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_play_5fdocument_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_play_5fdocument_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_play_5fdocument_2eproto;
namespace playapi {
namespace proto {
namespace finsky {
namespace document {
class AggregateRating;
struct AggregateRatingDefaultTypeInternal;
extern AggregateRatingDefaultTypeInternal _AggregateRating_default_instance_;
class AggregateRatingTip;
struct AggregateRatingTipDefaultTypeInternal;
extern AggregateRatingTipDefaultTypeInternal _AggregateRatingTip_default_instance_;
class AlbumDetails;
struct AlbumDetailsDefaultTypeInternal;
extern AlbumDetailsDefaultTypeInternal _AlbumDetails_default_instance_;
class Annotations;
struct AnnotationsDefaultTypeInternal;
extern AnnotationsDefaultTypeInternal _Annotations_default_instance_;
class AppDetails;
struct AppDetailsDefaultTypeInternal;
extern AppDetailsDefaultTypeInternal _AppDetails_default_instance_;
class ArtistDetails;
struct ArtistDetailsDefaultTypeInternal;
extern ArtistDetailsDefaultTypeInternal _ArtistDetails_default_instance_;
class ArtistExternalLinks;
struct ArtistExternalLinksDefaultTypeInternal;
extern ArtistExternalLinksDefaultTypeInternal _ArtistExternalLinks_default_instance_;
class Badge;
struct BadgeDefaultTypeInternal;
extern BadgeDefaultTypeInternal _Badge_default_instance_;
class BadgeContainer;
struct BadgeContainerDefaultTypeInternal;
extern BadgeContainerDefaultTypeInternal _BadgeContainer_default_instance_;
class BookDetails;
struct BookDetailsDefaultTypeInternal;
extern BookDetailsDefaultTypeInternal _BookDetails_default_instance_;
class BookSeriesDetails;
struct BookSeriesDetailsDefaultTypeInternal;
extern BookSeriesDetailsDefaultTypeInternal _BookSeriesDetails_default_instance_;
class DeveloperDetails;
struct DeveloperDetailsDefaultTypeInternal;
extern DeveloperDetailsDefaultTypeInternal _DeveloperDetails_default_instance_;
class DocV2;
struct DocV2DefaultTypeInternal;
extern DocV2DefaultTypeInternal _DocV2_default_instance_;
class DocumentDetails;
struct DocumentDetailsDefaultTypeInternal;
extern DocumentDetailsDefaultTypeInternal _DocumentDetails_default_instance_;
class MagazineDetails;
struct MagazineDetailsDefaultTypeInternal;
extern MagazineDetailsDefaultTypeInternal _MagazineDetails_default_instance_;
class MusicDetails;
struct MusicDetailsDefaultTypeInternal;
extern MusicDetailsDefaultTypeInternal _MusicDetails_default_instance_;
class MyRewardDetails;
struct MyRewardDetailsDefaultTypeInternal;
extern MyRewardDetailsDefaultTypeInternal _MyRewardDetails_default_instance_;
class MySubscriptionDetails;
struct MySubscriptionDetailsDefaultTypeInternal;
extern MySubscriptionDetailsDefaultTypeInternal _MySubscriptionDetails_default_instance_;
class OBSOLETE_PlusProfile;
struct OBSOLETE_PlusProfileDefaultTypeInternal;
extern OBSOLETE_PlusProfileDefaultTypeInternal _OBSOLETE_PlusProfile_default_instance_;
class OBSOLETE_Reason;
struct OBSOLETE_ReasonDefaultTypeInternal;
extern OBSOLETE_ReasonDefaultTypeInternal _OBSOLETE_Reason_default_instance_;
class PersonDetails;
struct PersonDetailsDefaultTypeInternal;
extern PersonDetailsDefaultTypeInternal _PersonDetails_default_instance_;
class PlusOneData;
struct PlusOneDataDefaultTypeInternal;
extern PlusOneDataDefaultTypeInternal _PlusOneData_default_instance_;
class ProductDetails;
struct ProductDetailsDefaultTypeInternal;
extern ProductDetailsDefaultTypeInternal _ProductDetails_default_instance_;
class ProductDetailsDescription;
struct ProductDetailsDescriptionDefaultTypeInternal;
extern ProductDetailsDescriptionDefaultTypeInternal _ProductDetailsDescription_default_instance_;
class ProductDetailsSection;
struct ProductDetailsSectionDefaultTypeInternal;
extern ProductDetailsSectionDefaultTypeInternal _ProductDetailsSection_default_instance_;
class PromotedDoc;
struct PromotedDocDefaultTypeInternal;
extern PromotedDocDefaultTypeInternal _PromotedDoc_default_instance_;
class PurchaseDetails;
struct PurchaseDetailsDefaultTypeInternal;
extern PurchaseDetailsDefaultTypeInternal _PurchaseDetails_default_instance_;
class PurchaseHistoryDetails;
struct PurchaseHistoryDetailsDefaultTypeInternal;
extern PurchaseHistoryDetailsDefaultTypeInternal _PurchaseHistoryDetails_default_instance_;
class Review;
struct ReviewDefaultTypeInternal;
extern ReviewDefaultTypeInternal _Review_default_instance_;
class ReviewTip;
struct ReviewTipDefaultTypeInternal;
extern ReviewTipDefaultTypeInternal _ReviewTip_default_instance_;
class SectionMetadata;
struct SectionMetadataDefaultTypeInternal;
extern SectionMetadataDefaultTypeInternal _SectionMetadata_default_instance_;
class SelectedChild;
struct SelectedChildDefaultTypeInternal;
extern SelectedChildDefaultTypeInternal _SelectedChild_default_instance_;
class Snippet;
struct SnippetDefaultTypeInternal;
extern SnippetDefaultTypeInternal _Snippet_default_instance_;
class SongDetails;
struct SongDetailsDefaultTypeInternal;
extern SongDetailsDefaultTypeInternal _SongDetails_default_instance_;
class SubscriptionDetails;
struct SubscriptionDetailsDefaultTypeInternal;
extern SubscriptionDetailsDefaultTypeInternal _SubscriptionDetails_default_instance_;
class TalentDetails;
struct TalentDetailsDefaultTypeInternal;
extern TalentDetailsDefaultTypeInternal _TalentDetails_default_instance_;
class TalentExternalLinks;
struct TalentExternalLinksDefaultTypeInternal;
extern TalentExternalLinksDefaultTypeInternal _TalentExternalLinks_default_instance_;
class TestingProgramInfo;
struct TestingProgramInfoDefaultTypeInternal;
extern TestingProgramInfoDefaultTypeInternal _TestingProgramInfo_default_instance_;
class Trailer;
struct TrailerDefaultTypeInternal;
extern TrailerDefaultTypeInternal _Trailer_default_instance_;
class TvEpisodeDetails;
struct TvEpisodeDetailsDefaultTypeInternal;
extern TvEpisodeDetailsDefaultTypeInternal _TvEpisodeDetails_default_instance_;
class TvSeasonDetails;
struct TvSeasonDetailsDefaultTypeInternal;
extern TvSeasonDetailsDefaultTypeInternal _TvSeasonDetails_default_instance_;
class TvShowDetails;
struct TvShowDetailsDefaultTypeInternal;
extern TvShowDetailsDefaultTypeInternal _TvShowDetails_default_instance_;
class VideoAnnotations;
struct VideoAnnotationsDefaultTypeInternal;
extern VideoAnnotationsDefaultTypeInternal _VideoAnnotations_default_instance_;
class VideoCredit;
struct VideoCreditDefaultTypeInternal;
extern VideoCreditDefaultTypeInternal _VideoCredit_default_instance_;
class VideoDetails;
struct VideoDetailsDefaultTypeInternal;
extern VideoDetailsDefaultTypeInternal _VideoDetails_default_instance_;
class VideoRentalTerm;
struct VideoRentalTermDefaultTypeInternal;
extern VideoRentalTermDefaultTypeInternal _VideoRentalTerm_default_instance_;
class VideoRentalTerm_Term;
struct VideoRentalTerm_TermDefaultTypeInternal;
extern VideoRentalTerm_TermDefaultTypeInternal _VideoRentalTerm_Term_default_instance_;
class VoucherInfo;
struct VoucherInfoDefaultTypeInternal;
extern VoucherInfoDefaultTypeInternal _VoucherInfo_default_instance_;
class Warning;
struct WarningDefaultTypeInternal;
extern WarningDefaultTypeInternal _Warning_default_instance_;
}  // namespace document
}  // namespace finsky
}  // namespace proto
}  // namespace playapi
PROTOBUF_NAMESPACE_OPEN
template<> ::playapi::proto::finsky::document::AggregateRating* Arena::CreateMaybeMessage<::playapi::proto::finsky::document::AggregateRating>(Arena*);
template<> ::playapi::proto::finsky::document::AggregateRatingTip* Arena::CreateMaybeMessage<::playapi::proto::finsky::document::AggregateRatingTip>(Arena*);
template<> ::playapi::proto::finsky::document::AlbumDetails* Arena::CreateMaybeMessage<::playapi::proto::finsky::document::AlbumDetails>(Arena*);
template<> ::playapi::proto::finsky::document::Annotations* Arena::CreateMaybeMessage<::playapi::proto::finsky::document::Annotations>(Arena*);
template<> ::playapi::proto::finsky::document::AppDetails* Arena::CreateMaybeMessage<::playapi::proto::finsky::document::AppDetails>(Arena*);
template<> ::playapi::proto::finsky::document::ArtistDetails* Arena::CreateMaybeMessage<::playapi::proto::finsky::document::ArtistDetails>(Arena*);
template<> ::playapi::proto::finsky::document::ArtistExternalLinks* Arena::CreateMaybeMessage<::playapi::proto::finsky::document::ArtistExternalLinks>(Arena*);
template<> ::playapi::proto::finsky::document::Badge* Arena::CreateMaybeMessage<::playapi::proto::finsky::document::Badge>(Arena*);
template<> ::playapi::proto::finsky::document::BadgeContainer* Arena::CreateMaybeMessage<::playapi::proto::finsky::document::BadgeContainer>(Arena*);
template<> ::playapi::proto::finsky::document::BookDetails* Arena::CreateMaybeMessage<::playapi::proto::finsky::document::BookDetails>(Arena*);
template<> ::playapi::proto::finsky::document::BookSeriesDetails* Arena::CreateMaybeMessage<::playapi::proto::finsky::document::BookSeriesDetails>(Arena*);
template<> ::playapi::proto::finsky::document::DeveloperDetails* Arena::CreateMaybeMessage<::playapi::proto::finsky::document::DeveloperDetails>(Arena*);
template<> ::playapi::proto::finsky::document::DocV2* Arena::CreateMaybeMessage<::playapi::proto::finsky::document::DocV2>(Arena*);
template<> ::playapi::proto::finsky::document::DocumentDetails* Arena::CreateMaybeMessage<::playapi::proto::finsky::document::DocumentDetails>(Arena*);
template<> ::playapi::proto::finsky::document::MagazineDetails* Arena::CreateMaybeMessage<::playapi::proto::finsky::document::MagazineDetails>(Arena*);
template<> ::playapi::proto::finsky::document::MusicDetails* Arena::CreateMaybeMessage<::playapi::proto::finsky::document::MusicDetails>(Arena*);
template<> ::playapi::proto::finsky::document::MyRewardDetails* Arena::CreateMaybeMessage<::playapi::proto::finsky::document::MyRewardDetails>(Arena*);
template<> ::playapi::proto::finsky::document::MySubscriptionDetails* Arena::CreateMaybeMessage<::playapi::proto::finsky::document::MySubscriptionDetails>(Arena*);
template<> ::playapi::proto::finsky::document::OBSOLETE_PlusProfile* Arena::CreateMaybeMessage<::playapi::proto::finsky::document::OBSOLETE_PlusProfile>(Arena*);
template<> ::playapi::proto::finsky::document::OBSOLETE_Reason* Arena::CreateMaybeMessage<::playapi::proto::finsky::document::OBSOLETE_Reason>(Arena*);
template<> ::playapi::proto::finsky::document::PersonDetails* Arena::CreateMaybeMessage<::playapi::proto::finsky::document::PersonDetails>(Arena*);
template<> ::playapi::proto::finsky::document::PlusOneData* Arena::CreateMaybeMessage<::playapi::proto::finsky::document::PlusOneData>(Arena*);
template<> ::playapi::proto::finsky::document::ProductDetails* Arena::CreateMaybeMessage<::playapi::proto::finsky::document::ProductDetails>(Arena*);
template<> ::playapi::proto::finsky::document::ProductDetailsDescription* Arena::CreateMaybeMessage<::playapi::proto::finsky::document::ProductDetailsDescription>(Arena*);
template<> ::playapi::proto::finsky::document::ProductDetailsSection* Arena::CreateMaybeMessage<::playapi::proto::finsky::document::ProductDetailsSection>(Arena*);
template<> ::playapi::proto::finsky::document::PromotedDoc* Arena::CreateMaybeMessage<::playapi::proto::finsky::document::PromotedDoc>(Arena*);
template<> ::playapi::proto::finsky::document::PurchaseDetails* Arena::CreateMaybeMessage<::playapi::proto::finsky::document::PurchaseDetails>(Arena*);
template<> ::playapi::proto::finsky::document::PurchaseHistoryDetails* Arena::CreateMaybeMessage<::playapi::proto::finsky::document::PurchaseHistoryDetails>(Arena*);
template<> ::playapi::proto::finsky::document::Review* Arena::CreateMaybeMessage<::playapi::proto::finsky::document::Review>(Arena*);
template<> ::playapi::proto::finsky::document::ReviewTip* Arena::CreateMaybeMessage<::playapi::proto::finsky::document::ReviewTip>(Arena*);
template<> ::playapi::proto::finsky::document::SectionMetadata* Arena::CreateMaybeMessage<::playapi::proto::finsky::document::SectionMetadata>(Arena*);
template<> ::playapi::proto::finsky::document::SelectedChild* Arena::CreateMaybeMessage<::playapi::proto::finsky::document::SelectedChild>(Arena*);
template<> ::playapi::proto::finsky::document::Snippet* Arena::CreateMaybeMessage<::playapi::proto::finsky::document::Snippet>(Arena*);
template<> ::playapi::proto::finsky::document::SongDetails* Arena::CreateMaybeMessage<::playapi::proto::finsky::document::SongDetails>(Arena*);
template<> ::playapi::proto::finsky::document::SubscriptionDetails* Arena::CreateMaybeMessage<::playapi::proto::finsky::document::SubscriptionDetails>(Arena*);
template<> ::playapi::proto::finsky::document::TalentDetails* Arena::CreateMaybeMessage<::playapi::proto::finsky::document::TalentDetails>(Arena*);
template<> ::playapi::proto::finsky::document::TalentExternalLinks* Arena::CreateMaybeMessage<::playapi::proto::finsky::document::TalentExternalLinks>(Arena*);
template<> ::playapi::proto::finsky::document::TestingProgramInfo* Arena::CreateMaybeMessage<::playapi::proto::finsky::document::TestingProgramInfo>(Arena*);
template<> ::playapi::proto::finsky::document::Trailer* Arena::CreateMaybeMessage<::playapi::proto::finsky::document::Trailer>(Arena*);
template<> ::playapi::proto::finsky::document::TvEpisodeDetails* Arena::CreateMaybeMessage<::playapi::proto::finsky::document::TvEpisodeDetails>(Arena*);
template<> ::playapi::proto::finsky::document::TvSeasonDetails* Arena::CreateMaybeMessage<::playapi::proto::finsky::document::TvSeasonDetails>(Arena*);
template<> ::playapi::proto::finsky::document::TvShowDetails* Arena::CreateMaybeMessage<::playapi::proto::finsky::document::TvShowDetails>(Arena*);
template<> ::playapi::proto::finsky::document::VideoAnnotations* Arena::CreateMaybeMessage<::playapi::proto::finsky::document::VideoAnnotations>(Arena*);
template<> ::playapi::proto::finsky::document::VideoCredit* Arena::CreateMaybeMessage<::playapi::proto::finsky::document::VideoCredit>(Arena*);
template<> ::playapi::proto::finsky::document::VideoDetails* Arena::CreateMaybeMessage<::playapi::proto::finsky::document::VideoDetails>(Arena*);
template<> ::playapi::proto::finsky::document::VideoRentalTerm* Arena::CreateMaybeMessage<::playapi::proto::finsky::document::VideoRentalTerm>(Arena*);
template<> ::playapi::proto::finsky::document::VideoRentalTerm_Term* Arena::CreateMaybeMessage<::playapi::proto::finsky::document::VideoRentalTerm_Term>(Arena*);
template<> ::playapi::proto::finsky::document::VoucherInfo* Arena::CreateMaybeMessage<::playapi::proto::finsky::document::VoucherInfo>(Arena*);
template<> ::playapi::proto::finsky::document::Warning* Arena::CreateMaybeMessage<::playapi::proto::finsky::document::Warning>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace playapi {
namespace proto {
namespace finsky {
namespace document {

// ===================================================================

class DocV2 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.document.DocV2) */ {
 public:
  inline DocV2() : DocV2(nullptr) {}
  ~DocV2() override;
  explicit PROTOBUF_CONSTEXPR DocV2(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DocV2(const DocV2& from);
  DocV2(DocV2&& from) noexcept
    : DocV2() {
    *this = ::std::move(from);
  }

  inline DocV2& operator=(const DocV2& from) {
    CopyFrom(from);
    return *this;
  }
  inline DocV2& operator=(DocV2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DocV2& default_instance() {
    return *internal_default_instance();
  }
  static inline const DocV2* internal_default_instance() {
    return reinterpret_cast<const DocV2*>(
               &_DocV2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DocV2& a, DocV2& b) {
    a.Swap(&b);
  }
  inline void Swap(DocV2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DocV2* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DocV2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DocV2>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DocV2& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DocV2& from) {
    DocV2::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DocV2* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.document.DocV2";
  }
  protected:
  explicit DocV2(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOfferFieldNumber = 8,
    kImageFieldNumber = 10,
    kChildFieldNumber = 11,
    kTipFieldNumber = 30,
    kDocidFieldNumber = 1,
    kBackendDocidFieldNumber = 2,
    kTitleFieldNumber = 5,
    kCreatorFieldNumber = 6,
    kDescriptionHtmlFieldNumber = 7,
    kDetailsUrlFieldNumber = 16,
    kShareUrlFieldNumber = 17,
    kReviewsUrlFieldNumber = 18,
    kBackendUrlFieldNumber = 19,
    kPurchaseDetailsUrlFieldNumber = 20,
    kSubtitleFieldNumber = 22,
    kTranslatedDescriptionHtmlFieldNumber = 23,
    kServerLogsCookieFieldNumber = 24,
    kPromotionalDescriptionFieldNumber = 27,
    kSnippetsUrlFieldNumber = 31,
    kAvailabilityFieldNumber = 9,
    kContainerMetadataFieldNumber = 12,
    kDetailsFieldNumber = 13,
    kAggregateRatingFieldNumber = 14,
    kAnnotationsFieldNumber = 15,
    kProductDetailsFieldNumber = 25,
    kDocTypeFieldNumber = 3,
    kBackendIdFieldNumber = 4,
    kDetailsReusableFieldNumber = 21,
    kMatureFieldNumber = 26,
    kAvailableForPreregistrationFieldNumber = 29,
    kForceShareabilityFieldNumber = 32,
    kUseWishlistAsPrimaryActionFieldNumber = 33,
  };
  // repeated .playapi.proto.finsky.Offer offer = 8;
  int offer_size() const;
  private:
  int _internal_offer_size() const;
  public:
  void clear_offer();
  ::playapi::proto::finsky::Offer* mutable_offer(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Offer >*
      mutable_offer();
  private:
  const ::playapi::proto::finsky::Offer& _internal_offer(int index) const;
  ::playapi::proto::finsky::Offer* _internal_add_offer();
  public:
  const ::playapi::proto::finsky::Offer& offer(int index) const;
  ::playapi::proto::finsky::Offer* add_offer();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Offer >&
      offer() const;

  // repeated .playapi.proto.finsky.Image image = 10;
  int image_size() const;
  private:
  int _internal_image_size() const;
  public:
  void clear_image();
  ::playapi::proto::finsky::Image* mutable_image(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Image >*
      mutable_image();
  private:
  const ::playapi::proto::finsky::Image& _internal_image(int index) const;
  ::playapi::proto::finsky::Image* _internal_add_image();
  public:
  const ::playapi::proto::finsky::Image& image(int index) const;
  ::playapi::proto::finsky::Image* add_image();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Image >&
      image() const;

  // repeated .playapi.proto.finsky.document.DocV2 child = 11;
  int child_size() const;
  private:
  int _internal_child_size() const;
  public:
  void clear_child();
  ::playapi::proto::finsky::document::DocV2* mutable_child(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::DocV2 >*
      mutable_child();
  private:
  const ::playapi::proto::finsky::document::DocV2& _internal_child(int index) const;
  ::playapi::proto::finsky::document::DocV2* _internal_add_child();
  public:
  const ::playapi::proto::finsky::document::DocV2& child(int index) const;
  ::playapi::proto::finsky::document::DocV2* add_child();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::DocV2 >&
      child() const;

  // repeated .playapi.proto.finsky.document.ReviewTip tip = 30;
  int tip_size() const;
  private:
  int _internal_tip_size() const;
  public:
  void clear_tip();
  ::playapi::proto::finsky::document::ReviewTip* mutable_tip(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::ReviewTip >*
      mutable_tip();
  private:
  const ::playapi::proto::finsky::document::ReviewTip& _internal_tip(int index) const;
  ::playapi::proto::finsky::document::ReviewTip* _internal_add_tip();
  public:
  const ::playapi::proto::finsky::document::ReviewTip& tip(int index) const;
  ::playapi::proto::finsky::document::ReviewTip* add_tip();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::ReviewTip >&
      tip() const;

  // optional string docid = 1;
  bool has_docid() const;
  private:
  bool _internal_has_docid() const;
  public:
  void clear_docid();
  const std::string& docid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_docid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_docid();
  PROTOBUF_NODISCARD std::string* release_docid();
  void set_allocated_docid(std::string* docid);
  private:
  const std::string& _internal_docid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_docid(const std::string& value);
  std::string* _internal_mutable_docid();
  public:

  // optional string backendDocid = 2;
  bool has_backenddocid() const;
  private:
  bool _internal_has_backenddocid() const;
  public:
  void clear_backenddocid();
  const std::string& backenddocid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_backenddocid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_backenddocid();
  PROTOBUF_NODISCARD std::string* release_backenddocid();
  void set_allocated_backenddocid(std::string* backenddocid);
  private:
  const std::string& _internal_backenddocid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_backenddocid(const std::string& value);
  std::string* _internal_mutable_backenddocid();
  public:

  // optional string title = 5;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // optional string creator = 6;
  bool has_creator() const;
  private:
  bool _internal_has_creator() const;
  public:
  void clear_creator();
  const std::string& creator() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_creator(ArgT0&& arg0, ArgT... args);
  std::string* mutable_creator();
  PROTOBUF_NODISCARD std::string* release_creator();
  void set_allocated_creator(std::string* creator);
  private:
  const std::string& _internal_creator() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_creator(const std::string& value);
  std::string* _internal_mutable_creator();
  public:

  // optional string descriptionHtml = 7;
  bool has_descriptionhtml() const;
  private:
  bool _internal_has_descriptionhtml() const;
  public:
  void clear_descriptionhtml();
  const std::string& descriptionhtml() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_descriptionhtml(ArgT0&& arg0, ArgT... args);
  std::string* mutable_descriptionhtml();
  PROTOBUF_NODISCARD std::string* release_descriptionhtml();
  void set_allocated_descriptionhtml(std::string* descriptionhtml);
  private:
  const std::string& _internal_descriptionhtml() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_descriptionhtml(const std::string& value);
  std::string* _internal_mutable_descriptionhtml();
  public:

  // optional string detailsUrl = 16;
  bool has_detailsurl() const;
  private:
  bool _internal_has_detailsurl() const;
  public:
  void clear_detailsurl();
  const std::string& detailsurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_detailsurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_detailsurl();
  PROTOBUF_NODISCARD std::string* release_detailsurl();
  void set_allocated_detailsurl(std::string* detailsurl);
  private:
  const std::string& _internal_detailsurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_detailsurl(const std::string& value);
  std::string* _internal_mutable_detailsurl();
  public:

  // optional string shareUrl = 17;
  bool has_shareurl() const;
  private:
  bool _internal_has_shareurl() const;
  public:
  void clear_shareurl();
  const std::string& shareurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_shareurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_shareurl();
  PROTOBUF_NODISCARD std::string* release_shareurl();
  void set_allocated_shareurl(std::string* shareurl);
  private:
  const std::string& _internal_shareurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_shareurl(const std::string& value);
  std::string* _internal_mutable_shareurl();
  public:

  // optional string reviewsUrl = 18;
  bool has_reviewsurl() const;
  private:
  bool _internal_has_reviewsurl() const;
  public:
  void clear_reviewsurl();
  const std::string& reviewsurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reviewsurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reviewsurl();
  PROTOBUF_NODISCARD std::string* release_reviewsurl();
  void set_allocated_reviewsurl(std::string* reviewsurl);
  private:
  const std::string& _internal_reviewsurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reviewsurl(const std::string& value);
  std::string* _internal_mutable_reviewsurl();
  public:

  // optional string backendUrl = 19;
  bool has_backendurl() const;
  private:
  bool _internal_has_backendurl() const;
  public:
  void clear_backendurl();
  const std::string& backendurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_backendurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_backendurl();
  PROTOBUF_NODISCARD std::string* release_backendurl();
  void set_allocated_backendurl(std::string* backendurl);
  private:
  const std::string& _internal_backendurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_backendurl(const std::string& value);
  std::string* _internal_mutable_backendurl();
  public:

  // optional string purchaseDetailsUrl = 20;
  bool has_purchasedetailsurl() const;
  private:
  bool _internal_has_purchasedetailsurl() const;
  public:
  void clear_purchasedetailsurl();
  const std::string& purchasedetailsurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_purchasedetailsurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_purchasedetailsurl();
  PROTOBUF_NODISCARD std::string* release_purchasedetailsurl();
  void set_allocated_purchasedetailsurl(std::string* purchasedetailsurl);
  private:
  const std::string& _internal_purchasedetailsurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_purchasedetailsurl(const std::string& value);
  std::string* _internal_mutable_purchasedetailsurl();
  public:

  // optional string subtitle = 22;
  bool has_subtitle() const;
  private:
  bool _internal_has_subtitle() const;
  public:
  void clear_subtitle();
  const std::string& subtitle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subtitle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subtitle();
  PROTOBUF_NODISCARD std::string* release_subtitle();
  void set_allocated_subtitle(std::string* subtitle);
  private:
  const std::string& _internal_subtitle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subtitle(const std::string& value);
  std::string* _internal_mutable_subtitle();
  public:

  // optional string translatedDescriptionHtml = 23;
  bool has_translateddescriptionhtml() const;
  private:
  bool _internal_has_translateddescriptionhtml() const;
  public:
  void clear_translateddescriptionhtml();
  const std::string& translateddescriptionhtml() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_translateddescriptionhtml(ArgT0&& arg0, ArgT... args);
  std::string* mutable_translateddescriptionhtml();
  PROTOBUF_NODISCARD std::string* release_translateddescriptionhtml();
  void set_allocated_translateddescriptionhtml(std::string* translateddescriptionhtml);
  private:
  const std::string& _internal_translateddescriptionhtml() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_translateddescriptionhtml(const std::string& value);
  std::string* _internal_mutable_translateddescriptionhtml();
  public:

  // optional bytes serverLogsCookie = 24;
  bool has_serverlogscookie() const;
  private:
  bool _internal_has_serverlogscookie() const;
  public:
  void clear_serverlogscookie();
  const std::string& serverlogscookie() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serverlogscookie(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serverlogscookie();
  PROTOBUF_NODISCARD std::string* release_serverlogscookie();
  void set_allocated_serverlogscookie(std::string* serverlogscookie);
  private:
  const std::string& _internal_serverlogscookie() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serverlogscookie(const std::string& value);
  std::string* _internal_mutable_serverlogscookie();
  public:

  // optional string promotionalDescription = 27;
  bool has_promotionaldescription() const;
  private:
  bool _internal_has_promotionaldescription() const;
  public:
  void clear_promotionaldescription();
  const std::string& promotionaldescription() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_promotionaldescription(ArgT0&& arg0, ArgT... args);
  std::string* mutable_promotionaldescription();
  PROTOBUF_NODISCARD std::string* release_promotionaldescription();
  void set_allocated_promotionaldescription(std::string* promotionaldescription);
  private:
  const std::string& _internal_promotionaldescription() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_promotionaldescription(const std::string& value);
  std::string* _internal_mutable_promotionaldescription();
  public:

  // optional string snippetsUrl = 31;
  bool has_snippetsurl() const;
  private:
  bool _internal_has_snippetsurl() const;
  public:
  void clear_snippetsurl();
  const std::string& snippetsurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_snippetsurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_snippetsurl();
  PROTOBUF_NODISCARD std::string* release_snippetsurl();
  void set_allocated_snippetsurl(std::string* snippetsurl);
  private:
  const std::string& _internal_snippetsurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_snippetsurl(const std::string& value);
  std::string* _internal_mutable_snippetsurl();
  public:

  // optional .playapi.proto.finsky.filter_rules.Availability availability = 9;
  bool has_availability() const;
  private:
  bool _internal_has_availability() const;
  public:
  void clear_availability();
  const ::playapi::proto::finsky::filter_rules::Availability& availability() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::filter_rules::Availability* release_availability();
  ::playapi::proto::finsky::filter_rules::Availability* mutable_availability();
  void set_allocated_availability(::playapi::proto::finsky::filter_rules::Availability* availability);
  private:
  const ::playapi::proto::finsky::filter_rules::Availability& _internal_availability() const;
  ::playapi::proto::finsky::filter_rules::Availability* _internal_mutable_availability();
  public:
  void unsafe_arena_set_allocated_availability(
      ::playapi::proto::finsky::filter_rules::Availability* availability);
  ::playapi::proto::finsky::filter_rules::Availability* unsafe_arena_release_availability();

  // optional .playapi.proto.finsky.containers.ContainerMetadata containerMetadata = 12;
  bool has_containermetadata() const;
  private:
  bool _internal_has_containermetadata() const;
  public:
  void clear_containermetadata();
  const ::playapi::proto::finsky::containers::ContainerMetadata& containermetadata() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::containers::ContainerMetadata* release_containermetadata();
  ::playapi::proto::finsky::containers::ContainerMetadata* mutable_containermetadata();
  void set_allocated_containermetadata(::playapi::proto::finsky::containers::ContainerMetadata* containermetadata);
  private:
  const ::playapi::proto::finsky::containers::ContainerMetadata& _internal_containermetadata() const;
  ::playapi::proto::finsky::containers::ContainerMetadata* _internal_mutable_containermetadata();
  public:
  void unsafe_arena_set_allocated_containermetadata(
      ::playapi::proto::finsky::containers::ContainerMetadata* containermetadata);
  ::playapi::proto::finsky::containers::ContainerMetadata* unsafe_arena_release_containermetadata();

  // optional .playapi.proto.finsky.document.DocumentDetails details = 13;
  bool has_details() const;
  private:
  bool _internal_has_details() const;
  public:
  void clear_details();
  const ::playapi::proto::finsky::document::DocumentDetails& details() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::DocumentDetails* release_details();
  ::playapi::proto::finsky::document::DocumentDetails* mutable_details();
  void set_allocated_details(::playapi::proto::finsky::document::DocumentDetails* details);
  private:
  const ::playapi::proto::finsky::document::DocumentDetails& _internal_details() const;
  ::playapi::proto::finsky::document::DocumentDetails* _internal_mutable_details();
  public:
  void unsafe_arena_set_allocated_details(
      ::playapi::proto::finsky::document::DocumentDetails* details);
  ::playapi::proto::finsky::document::DocumentDetails* unsafe_arena_release_details();

  // optional .playapi.proto.finsky.document.AggregateRating aggregateRating = 14;
  bool has_aggregaterating() const;
  private:
  bool _internal_has_aggregaterating() const;
  public:
  void clear_aggregaterating();
  const ::playapi::proto::finsky::document::AggregateRating& aggregaterating() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::AggregateRating* release_aggregaterating();
  ::playapi::proto::finsky::document::AggregateRating* mutable_aggregaterating();
  void set_allocated_aggregaterating(::playapi::proto::finsky::document::AggregateRating* aggregaterating);
  private:
  const ::playapi::proto::finsky::document::AggregateRating& _internal_aggregaterating() const;
  ::playapi::proto::finsky::document::AggregateRating* _internal_mutable_aggregaterating();
  public:
  void unsafe_arena_set_allocated_aggregaterating(
      ::playapi::proto::finsky::document::AggregateRating* aggregaterating);
  ::playapi::proto::finsky::document::AggregateRating* unsafe_arena_release_aggregaterating();

  // optional .playapi.proto.finsky.document.Annotations annotations = 15;
  bool has_annotations() const;
  private:
  bool _internal_has_annotations() const;
  public:
  void clear_annotations();
  const ::playapi::proto::finsky::document::Annotations& annotations() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::Annotations* release_annotations();
  ::playapi::proto::finsky::document::Annotations* mutable_annotations();
  void set_allocated_annotations(::playapi::proto::finsky::document::Annotations* annotations);
  private:
  const ::playapi::proto::finsky::document::Annotations& _internal_annotations() const;
  ::playapi::proto::finsky::document::Annotations* _internal_mutable_annotations();
  public:
  void unsafe_arena_set_allocated_annotations(
      ::playapi::proto::finsky::document::Annotations* annotations);
  ::playapi::proto::finsky::document::Annotations* unsafe_arena_release_annotations();

  // optional .playapi.proto.finsky.document.ProductDetails productDetails = 25;
  bool has_productdetails() const;
  private:
  bool _internal_has_productdetails() const;
  public:
  void clear_productdetails();
  const ::playapi::proto::finsky::document::ProductDetails& productdetails() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::ProductDetails* release_productdetails();
  ::playapi::proto::finsky::document::ProductDetails* mutable_productdetails();
  void set_allocated_productdetails(::playapi::proto::finsky::document::ProductDetails* productdetails);
  private:
  const ::playapi::proto::finsky::document::ProductDetails& _internal_productdetails() const;
  ::playapi::proto::finsky::document::ProductDetails* _internal_mutable_productdetails();
  public:
  void unsafe_arena_set_allocated_productdetails(
      ::playapi::proto::finsky::document::ProductDetails* productdetails);
  ::playapi::proto::finsky::document::ProductDetails* unsafe_arena_release_productdetails();

  // optional int32 docType = 3;
  bool has_doctype() const;
  private:
  bool _internal_has_doctype() const;
  public:
  void clear_doctype();
  int32_t doctype() const;
  void set_doctype(int32_t value);
  private:
  int32_t _internal_doctype() const;
  void _internal_set_doctype(int32_t value);
  public:

  // optional int32 backendId = 4;
  bool has_backendid() const;
  private:
  bool _internal_has_backendid() const;
  public:
  void clear_backendid();
  int32_t backendid() const;
  void set_backendid(int32_t value);
  private:
  int32_t _internal_backendid() const;
  void _internal_set_backendid(int32_t value);
  public:

  // optional bool detailsReusable = 21;
  bool has_detailsreusable() const;
  private:
  bool _internal_has_detailsreusable() const;
  public:
  void clear_detailsreusable();
  bool detailsreusable() const;
  void set_detailsreusable(bool value);
  private:
  bool _internal_detailsreusable() const;
  void _internal_set_detailsreusable(bool value);
  public:

  // optional bool mature = 26;
  bool has_mature() const;
  private:
  bool _internal_has_mature() const;
  public:
  void clear_mature();
  bool mature() const;
  void set_mature(bool value);
  private:
  bool _internal_mature() const;
  void _internal_set_mature(bool value);
  public:

  // optional bool availableForPreregistration = 29;
  bool has_availableforpreregistration() const;
  private:
  bool _internal_has_availableforpreregistration() const;
  public:
  void clear_availableforpreregistration();
  bool availableforpreregistration() const;
  void set_availableforpreregistration(bool value);
  private:
  bool _internal_availableforpreregistration() const;
  void _internal_set_availableforpreregistration(bool value);
  public:

  // optional bool forceShareability = 32;
  bool has_forceshareability() const;
  private:
  bool _internal_has_forceshareability() const;
  public:
  void clear_forceshareability();
  bool forceshareability() const;
  void set_forceshareability(bool value);
  private:
  bool _internal_forceshareability() const;
  void _internal_set_forceshareability(bool value);
  public:

  // optional bool useWishlistAsPrimaryAction = 33;
  bool has_usewishlistasprimaryaction() const;
  private:
  bool _internal_has_usewishlistasprimaryaction() const;
  public:
  void clear_usewishlistasprimaryaction();
  bool usewishlistasprimaryaction() const;
  void set_usewishlistasprimaryaction(bool value);
  private:
  bool _internal_usewishlistasprimaryaction() const;
  void _internal_set_usewishlistasprimaryaction(bool value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.document.DocV2)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Offer > offer_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Image > image_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::DocV2 > child_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::ReviewTip > tip_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr docid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr backenddocid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr creator_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr descriptionhtml_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr detailsurl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr shareurl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reviewsurl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr backendurl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr purchasedetailsurl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subtitle_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr translateddescriptionhtml_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serverlogscookie_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr promotionaldescription_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr snippetsurl_;
    ::playapi::proto::finsky::filter_rules::Availability* availability_;
    ::playapi::proto::finsky::containers::ContainerMetadata* containermetadata_;
    ::playapi::proto::finsky::document::DocumentDetails* details_;
    ::playapi::proto::finsky::document::AggregateRating* aggregaterating_;
    ::playapi::proto::finsky::document::Annotations* annotations_;
    ::playapi::proto::finsky::document::ProductDetails* productdetails_;
    int32_t doctype_;
    int32_t backendid_;
    bool detailsreusable_;
    bool mature_;
    bool availableforpreregistration_;
    bool forceshareability_;
    bool usewishlistasprimaryaction_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fdocument_2eproto;
};
// -------------------------------------------------------------------

class Annotations final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.document.Annotations) */ {
 public:
  inline Annotations() : Annotations(nullptr) {}
  ~Annotations() override;
  explicit PROTOBUF_CONSTEXPR Annotations(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Annotations(const Annotations& from);
  Annotations(Annotations&& from) noexcept
    : Annotations() {
    *this = ::std::move(from);
  }

  inline Annotations& operator=(const Annotations& from) {
    CopyFrom(from);
    return *this;
  }
  inline Annotations& operator=(Annotations&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Annotations& default_instance() {
    return *internal_default_instance();
  }
  static inline const Annotations* internal_default_instance() {
    return reinterpret_cast<const Annotations*>(
               &_Annotations_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Annotations& a, Annotations& b) {
    a.Swap(&b);
  }
  inline void Swap(Annotations* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Annotations* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Annotations* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Annotations>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Annotations& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Annotations& from) {
    Annotations::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Annotations* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.document.Annotations";
  }
  protected:
  explicit Annotations(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWarningFieldNumber = 4,
    kBadgeForCreatorFieldNumber = 8,
    kBadgeForDocFieldNumber = 9,
    kPromotedDocFieldNumber = 13,
    kSubscriptionFieldNumber = 16,
    kDocBadgeContainerFieldNumber = 21,
    kOverflowLinkFieldNumber = 25,
    kVoucherInfoFieldNumber = 30,
    kDetailsPageClusterFieldNumber = 34,
    kFeatureBadgeFieldNumber = 39,
    kOfferNoteFieldNumber = 14,
    kPrivacyPolicyUrlFieldNumber = 18,
    kAttributionHtmlFieldNumber = 27,
    kApplicableVoucherDescriptionFieldNumber = 33,
    kSectionRelatedFieldNumber = 1,
    kSectionMoreByFieldNumber = 2,
    kPlusOneDataFieldNumber = 3,
    kSectionBodyOfWorkFieldNumber = 5,
    kSectionCoreContentFieldNumber = 6,
    kLinkFieldNumber = 10,
    kSectionCrossSellFieldNumber = 11,
    kSectionRelatedDocTypeFieldNumber = 12,
    kOBSOLETEReasonFieldNumber = 17,
    kOptimalDeviceClassWarningFieldNumber = 20,
    kSectionSuggestForRatingFieldNumber = 22,
    kSectionPurchaseCrossSellFieldNumber = 24,
    kCreatorDocFieldNumber = 26,
    kPurchaseHistoryDetailsFieldNumber = 28,
    kBadgeForContentRatingFieldNumber = 29,
    kSectionFeaturedAppsFieldNumber = 32,
    kVideoAnnotationsFieldNumber = 35,
    kSectionPurchaseRelatedTopicsFieldNumber = 36,
    kMySubscriptionDetailsFieldNumber = 37,
    kMyRewardDetailsFieldNumber = 38,
    kSelectedChildFieldNumber = 40,
    kPurchaseDetailsFieldNumber = 41,
    kSnippetFieldNumber = 42,
  };
  // repeated .playapi.proto.finsky.document.Warning warning = 4;
  int warning_size() const;
  private:
  int _internal_warning_size() const;
  public:
  void clear_warning();
  ::playapi::proto::finsky::document::Warning* mutable_warning(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::Warning >*
      mutable_warning();
  private:
  const ::playapi::proto::finsky::document::Warning& _internal_warning(int index) const;
  ::playapi::proto::finsky::document::Warning* _internal_add_warning();
  public:
  const ::playapi::proto::finsky::document::Warning& warning(int index) const;
  ::playapi::proto::finsky::document::Warning* add_warning();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::Warning >&
      warning() const;

  // repeated .playapi.proto.finsky.document.Badge badgeForCreator = 8;
  int badgeforcreator_size() const;
  private:
  int _internal_badgeforcreator_size() const;
  public:
  void clear_badgeforcreator();
  ::playapi::proto::finsky::document::Badge* mutable_badgeforcreator(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::Badge >*
      mutable_badgeforcreator();
  private:
  const ::playapi::proto::finsky::document::Badge& _internal_badgeforcreator(int index) const;
  ::playapi::proto::finsky::document::Badge* _internal_add_badgeforcreator();
  public:
  const ::playapi::proto::finsky::document::Badge& badgeforcreator(int index) const;
  ::playapi::proto::finsky::document::Badge* add_badgeforcreator();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::Badge >&
      badgeforcreator() const;

  // repeated .playapi.proto.finsky.document.Badge badgeForDoc = 9;
  int badgefordoc_size() const;
  private:
  int _internal_badgefordoc_size() const;
  public:
  void clear_badgefordoc();
  ::playapi::proto::finsky::document::Badge* mutable_badgefordoc(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::Badge >*
      mutable_badgefordoc();
  private:
  const ::playapi::proto::finsky::document::Badge& _internal_badgefordoc(int index) const;
  ::playapi::proto::finsky::document::Badge* _internal_add_badgefordoc();
  public:
  const ::playapi::proto::finsky::document::Badge& badgefordoc(int index) const;
  ::playapi::proto::finsky::document::Badge* add_badgefordoc();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::Badge >&
      badgefordoc() const;

  // repeated .playapi.proto.finsky.document.PromotedDoc promotedDoc = 13;
  int promoteddoc_size() const;
  private:
  int _internal_promoteddoc_size() const;
  public:
  void clear_promoteddoc();
  ::playapi::proto::finsky::document::PromotedDoc* mutable_promoteddoc(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::PromotedDoc >*
      mutable_promoteddoc();
  private:
  const ::playapi::proto::finsky::document::PromotedDoc& _internal_promoteddoc(int index) const;
  ::playapi::proto::finsky::document::PromotedDoc* _internal_add_promoteddoc();
  public:
  const ::playapi::proto::finsky::document::PromotedDoc& promoteddoc(int index) const;
  ::playapi::proto::finsky::document::PromotedDoc* add_promoteddoc();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::PromotedDoc >&
      promoteddoc() const;

  // repeated .playapi.proto.finsky.document.DocV2 subscription = 16;
  int subscription_size() const;
  private:
  int _internal_subscription_size() const;
  public:
  void clear_subscription();
  ::playapi::proto::finsky::document::DocV2* mutable_subscription(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::DocV2 >*
      mutable_subscription();
  private:
  const ::playapi::proto::finsky::document::DocV2& _internal_subscription(int index) const;
  ::playapi::proto::finsky::document::DocV2* _internal_add_subscription();
  public:
  const ::playapi::proto::finsky::document::DocV2& subscription(int index) const;
  ::playapi::proto::finsky::document::DocV2* add_subscription();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::DocV2 >&
      subscription() const;

  // repeated .playapi.proto.finsky.document.BadgeContainer docBadgeContainer = 21;
  int docbadgecontainer_size() const;
  private:
  int _internal_docbadgecontainer_size() const;
  public:
  void clear_docbadgecontainer();
  ::playapi::proto::finsky::document::BadgeContainer* mutable_docbadgecontainer(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::BadgeContainer >*
      mutable_docbadgecontainer();
  private:
  const ::playapi::proto::finsky::document::BadgeContainer& _internal_docbadgecontainer(int index) const;
  ::playapi::proto::finsky::document::BadgeContainer* _internal_add_docbadgecontainer();
  public:
  const ::playapi::proto::finsky::document::BadgeContainer& docbadgecontainer(int index) const;
  ::playapi::proto::finsky::document::BadgeContainer* add_docbadgecontainer();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::BadgeContainer >&
      docbadgecontainer() const;

  // repeated .playapi.proto.finsky.link.OverflowLink overflowLink = 25;
  int overflowlink_size() const;
  private:
  int _internal_overflowlink_size() const;
  public:
  void clear_overflowlink();
  ::playapi::proto::finsky::link::OverflowLink* mutable_overflowlink(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::link::OverflowLink >*
      mutable_overflowlink();
  private:
  const ::playapi::proto::finsky::link::OverflowLink& _internal_overflowlink(int index) const;
  ::playapi::proto::finsky::link::OverflowLink* _internal_add_overflowlink();
  public:
  const ::playapi::proto::finsky::link::OverflowLink& overflowlink(int index) const;
  ::playapi::proto::finsky::link::OverflowLink* add_overflowlink();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::link::OverflowLink >&
      overflowlink() const;

  // repeated .playapi.proto.finsky.document.VoucherInfo voucherInfo = 30;
  int voucherinfo_size() const;
  private:
  int _internal_voucherinfo_size() const;
  public:
  void clear_voucherinfo();
  ::playapi::proto::finsky::document::VoucherInfo* mutable_voucherinfo(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::VoucherInfo >*
      mutable_voucherinfo();
  private:
  const ::playapi::proto::finsky::document::VoucherInfo& _internal_voucherinfo(int index) const;
  ::playapi::proto::finsky::document::VoucherInfo* _internal_add_voucherinfo();
  public:
  const ::playapi::proto::finsky::document::VoucherInfo& voucherinfo(int index) const;
  ::playapi::proto::finsky::document::VoucherInfo* add_voucherinfo();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::VoucherInfo >&
      voucherinfo() const;

  // repeated .playapi.proto.finsky.document.SectionMetadata detailsPageCluster = 34;
  int detailspagecluster_size() const;
  private:
  int _internal_detailspagecluster_size() const;
  public:
  void clear_detailspagecluster();
  ::playapi::proto::finsky::document::SectionMetadata* mutable_detailspagecluster(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::SectionMetadata >*
      mutable_detailspagecluster();
  private:
  const ::playapi::proto::finsky::document::SectionMetadata& _internal_detailspagecluster(int index) const;
  ::playapi::proto::finsky::document::SectionMetadata* _internal_add_detailspagecluster();
  public:
  const ::playapi::proto::finsky::document::SectionMetadata& detailspagecluster(int index) const;
  ::playapi::proto::finsky::document::SectionMetadata* add_detailspagecluster();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::SectionMetadata >&
      detailspagecluster() const;

  // repeated .playapi.proto.finsky.document.Badge featureBadge = 39;
  int featurebadge_size() const;
  private:
  int _internal_featurebadge_size() const;
  public:
  void clear_featurebadge();
  ::playapi::proto::finsky::document::Badge* mutable_featurebadge(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::Badge >*
      mutable_featurebadge();
  private:
  const ::playapi::proto::finsky::document::Badge& _internal_featurebadge(int index) const;
  ::playapi::proto::finsky::document::Badge* _internal_add_featurebadge();
  public:
  const ::playapi::proto::finsky::document::Badge& featurebadge(int index) const;
  ::playapi::proto::finsky::document::Badge* add_featurebadge();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::Badge >&
      featurebadge() const;

  // optional string offerNote = 14;
  bool has_offernote() const;
  private:
  bool _internal_has_offernote() const;
  public:
  void clear_offernote();
  const std::string& offernote() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_offernote(ArgT0&& arg0, ArgT... args);
  std::string* mutable_offernote();
  PROTOBUF_NODISCARD std::string* release_offernote();
  void set_allocated_offernote(std::string* offernote);
  private:
  const std::string& _internal_offernote() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_offernote(const std::string& value);
  std::string* _internal_mutable_offernote();
  public:

  // optional string privacyPolicyUrl = 18;
  bool has_privacypolicyurl() const;
  private:
  bool _internal_has_privacypolicyurl() const;
  public:
  void clear_privacypolicyurl();
  const std::string& privacypolicyurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_privacypolicyurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_privacypolicyurl();
  PROTOBUF_NODISCARD std::string* release_privacypolicyurl();
  void set_allocated_privacypolicyurl(std::string* privacypolicyurl);
  private:
  const std::string& _internal_privacypolicyurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_privacypolicyurl(const std::string& value);
  std::string* _internal_mutable_privacypolicyurl();
  public:

  // optional string attributionHtml = 27;
  bool has_attributionhtml() const;
  private:
  bool _internal_has_attributionhtml() const;
  public:
  void clear_attributionhtml();
  const std::string& attributionhtml() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attributionhtml(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attributionhtml();
  PROTOBUF_NODISCARD std::string* release_attributionhtml();
  void set_allocated_attributionhtml(std::string* attributionhtml);
  private:
  const std::string& _internal_attributionhtml() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attributionhtml(const std::string& value);
  std::string* _internal_mutable_attributionhtml();
  public:

  // optional string applicableVoucherDescription = 33;
  bool has_applicablevoucherdescription() const;
  private:
  bool _internal_has_applicablevoucherdescription() const;
  public:
  void clear_applicablevoucherdescription();
  const std::string& applicablevoucherdescription() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_applicablevoucherdescription(ArgT0&& arg0, ArgT... args);
  std::string* mutable_applicablevoucherdescription();
  PROTOBUF_NODISCARD std::string* release_applicablevoucherdescription();
  void set_allocated_applicablevoucherdescription(std::string* applicablevoucherdescription);
  private:
  const std::string& _internal_applicablevoucherdescription() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_applicablevoucherdescription(const std::string& value);
  std::string* _internal_mutable_applicablevoucherdescription();
  public:

  // optional .playapi.proto.finsky.document.SectionMetadata sectionRelated = 1;
  bool has_sectionrelated() const;
  private:
  bool _internal_has_sectionrelated() const;
  public:
  void clear_sectionrelated();
  const ::playapi::proto::finsky::document::SectionMetadata& sectionrelated() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::SectionMetadata* release_sectionrelated();
  ::playapi::proto::finsky::document::SectionMetadata* mutable_sectionrelated();
  void set_allocated_sectionrelated(::playapi::proto::finsky::document::SectionMetadata* sectionrelated);
  private:
  const ::playapi::proto::finsky::document::SectionMetadata& _internal_sectionrelated() const;
  ::playapi::proto::finsky::document::SectionMetadata* _internal_mutable_sectionrelated();
  public:
  void unsafe_arena_set_allocated_sectionrelated(
      ::playapi::proto::finsky::document::SectionMetadata* sectionrelated);
  ::playapi::proto::finsky::document::SectionMetadata* unsafe_arena_release_sectionrelated();

  // optional .playapi.proto.finsky.document.SectionMetadata sectionMoreBy = 2;
  bool has_sectionmoreby() const;
  private:
  bool _internal_has_sectionmoreby() const;
  public:
  void clear_sectionmoreby();
  const ::playapi::proto::finsky::document::SectionMetadata& sectionmoreby() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::SectionMetadata* release_sectionmoreby();
  ::playapi::proto::finsky::document::SectionMetadata* mutable_sectionmoreby();
  void set_allocated_sectionmoreby(::playapi::proto::finsky::document::SectionMetadata* sectionmoreby);
  private:
  const ::playapi::proto::finsky::document::SectionMetadata& _internal_sectionmoreby() const;
  ::playapi::proto::finsky::document::SectionMetadata* _internal_mutable_sectionmoreby();
  public:
  void unsafe_arena_set_allocated_sectionmoreby(
      ::playapi::proto::finsky::document::SectionMetadata* sectionmoreby);
  ::playapi::proto::finsky::document::SectionMetadata* unsafe_arena_release_sectionmoreby();

  // optional .playapi.proto.finsky.document.PlusOneData plusOneData = 3;
  bool has_plusonedata() const;
  private:
  bool _internal_has_plusonedata() const;
  public:
  void clear_plusonedata();
  const ::playapi::proto::finsky::document::PlusOneData& plusonedata() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::PlusOneData* release_plusonedata();
  ::playapi::proto::finsky::document::PlusOneData* mutable_plusonedata();
  void set_allocated_plusonedata(::playapi::proto::finsky::document::PlusOneData* plusonedata);
  private:
  const ::playapi::proto::finsky::document::PlusOneData& _internal_plusonedata() const;
  ::playapi::proto::finsky::document::PlusOneData* _internal_mutable_plusonedata();
  public:
  void unsafe_arena_set_allocated_plusonedata(
      ::playapi::proto::finsky::document::PlusOneData* plusonedata);
  ::playapi::proto::finsky::document::PlusOneData* unsafe_arena_release_plusonedata();

  // optional .playapi.proto.finsky.document.SectionMetadata sectionBodyOfWork = 5;
  bool has_sectionbodyofwork() const;
  private:
  bool _internal_has_sectionbodyofwork() const;
  public:
  void clear_sectionbodyofwork();
  const ::playapi::proto::finsky::document::SectionMetadata& sectionbodyofwork() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::SectionMetadata* release_sectionbodyofwork();
  ::playapi::proto::finsky::document::SectionMetadata* mutable_sectionbodyofwork();
  void set_allocated_sectionbodyofwork(::playapi::proto::finsky::document::SectionMetadata* sectionbodyofwork);
  private:
  const ::playapi::proto::finsky::document::SectionMetadata& _internal_sectionbodyofwork() const;
  ::playapi::proto::finsky::document::SectionMetadata* _internal_mutable_sectionbodyofwork();
  public:
  void unsafe_arena_set_allocated_sectionbodyofwork(
      ::playapi::proto::finsky::document::SectionMetadata* sectionbodyofwork);
  ::playapi::proto::finsky::document::SectionMetadata* unsafe_arena_release_sectionbodyofwork();

  // optional .playapi.proto.finsky.document.SectionMetadata sectionCoreContent = 6;
  bool has_sectioncorecontent() const;
  private:
  bool _internal_has_sectioncorecontent() const;
  public:
  void clear_sectioncorecontent();
  const ::playapi::proto::finsky::document::SectionMetadata& sectioncorecontent() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::SectionMetadata* release_sectioncorecontent();
  ::playapi::proto::finsky::document::SectionMetadata* mutable_sectioncorecontent();
  void set_allocated_sectioncorecontent(::playapi::proto::finsky::document::SectionMetadata* sectioncorecontent);
  private:
  const ::playapi::proto::finsky::document::SectionMetadata& _internal_sectioncorecontent() const;
  ::playapi::proto::finsky::document::SectionMetadata* _internal_mutable_sectioncorecontent();
  public:
  void unsafe_arena_set_allocated_sectioncorecontent(
      ::playapi::proto::finsky::document::SectionMetadata* sectioncorecontent);
  ::playapi::proto::finsky::document::SectionMetadata* unsafe_arena_release_sectioncorecontent();

  // optional .playapi.proto.finsky.link.Link link = 10;
  bool has_link() const;
  private:
  bool _internal_has_link() const;
  public:
  void clear_link();
  const ::playapi::proto::finsky::link::Link& link() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::link::Link* release_link();
  ::playapi::proto::finsky::link::Link* mutable_link();
  void set_allocated_link(::playapi::proto::finsky::link::Link* link);
  private:
  const ::playapi::proto::finsky::link::Link& _internal_link() const;
  ::playapi::proto::finsky::link::Link* _internal_mutable_link();
  public:
  void unsafe_arena_set_allocated_link(
      ::playapi::proto::finsky::link::Link* link);
  ::playapi::proto::finsky::link::Link* unsafe_arena_release_link();

  // optional .playapi.proto.finsky.document.SectionMetadata sectionCrossSell = 11;
  bool has_sectioncrosssell() const;
  private:
  bool _internal_has_sectioncrosssell() const;
  public:
  void clear_sectioncrosssell();
  const ::playapi::proto::finsky::document::SectionMetadata& sectioncrosssell() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::SectionMetadata* release_sectioncrosssell();
  ::playapi::proto::finsky::document::SectionMetadata* mutable_sectioncrosssell();
  void set_allocated_sectioncrosssell(::playapi::proto::finsky::document::SectionMetadata* sectioncrosssell);
  private:
  const ::playapi::proto::finsky::document::SectionMetadata& _internal_sectioncrosssell() const;
  ::playapi::proto::finsky::document::SectionMetadata* _internal_mutable_sectioncrosssell();
  public:
  void unsafe_arena_set_allocated_sectioncrosssell(
      ::playapi::proto::finsky::document::SectionMetadata* sectioncrosssell);
  ::playapi::proto::finsky::document::SectionMetadata* unsafe_arena_release_sectioncrosssell();

  // optional .playapi.proto.finsky.document.SectionMetadata sectionRelatedDocType = 12;
  bool has_sectionrelateddoctype() const;
  private:
  bool _internal_has_sectionrelateddoctype() const;
  public:
  void clear_sectionrelateddoctype();
  const ::playapi::proto::finsky::document::SectionMetadata& sectionrelateddoctype() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::SectionMetadata* release_sectionrelateddoctype();
  ::playapi::proto::finsky::document::SectionMetadata* mutable_sectionrelateddoctype();
  void set_allocated_sectionrelateddoctype(::playapi::proto::finsky::document::SectionMetadata* sectionrelateddoctype);
  private:
  const ::playapi::proto::finsky::document::SectionMetadata& _internal_sectionrelateddoctype() const;
  ::playapi::proto::finsky::document::SectionMetadata* _internal_mutable_sectionrelateddoctype();
  public:
  void unsafe_arena_set_allocated_sectionrelateddoctype(
      ::playapi::proto::finsky::document::SectionMetadata* sectionrelateddoctype);
  ::playapi::proto::finsky::document::SectionMetadata* unsafe_arena_release_sectionrelateddoctype();

  // optional .playapi.proto.finsky.document.OBSOLETE_Reason OBSOLETEReason = 17;
  bool has_obsoletereason() const;
  private:
  bool _internal_has_obsoletereason() const;
  public:
  void clear_obsoletereason();
  const ::playapi::proto::finsky::document::OBSOLETE_Reason& obsoletereason() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::OBSOLETE_Reason* release_obsoletereason();
  ::playapi::proto::finsky::document::OBSOLETE_Reason* mutable_obsoletereason();
  void set_allocated_obsoletereason(::playapi::proto::finsky::document::OBSOLETE_Reason* obsoletereason);
  private:
  const ::playapi::proto::finsky::document::OBSOLETE_Reason& _internal_obsoletereason() const;
  ::playapi::proto::finsky::document::OBSOLETE_Reason* _internal_mutable_obsoletereason();
  public:
  void unsafe_arena_set_allocated_obsoletereason(
      ::playapi::proto::finsky::document::OBSOLETE_Reason* obsoletereason);
  ::playapi::proto::finsky::document::OBSOLETE_Reason* unsafe_arena_release_obsoletereason();

  // optional .playapi.proto.finsky.document.Warning optimalDeviceClassWarning = 20;
  bool has_optimaldeviceclasswarning() const;
  private:
  bool _internal_has_optimaldeviceclasswarning() const;
  public:
  void clear_optimaldeviceclasswarning();
  const ::playapi::proto::finsky::document::Warning& optimaldeviceclasswarning() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::Warning* release_optimaldeviceclasswarning();
  ::playapi::proto::finsky::document::Warning* mutable_optimaldeviceclasswarning();
  void set_allocated_optimaldeviceclasswarning(::playapi::proto::finsky::document::Warning* optimaldeviceclasswarning);
  private:
  const ::playapi::proto::finsky::document::Warning& _internal_optimaldeviceclasswarning() const;
  ::playapi::proto::finsky::document::Warning* _internal_mutable_optimaldeviceclasswarning();
  public:
  void unsafe_arena_set_allocated_optimaldeviceclasswarning(
      ::playapi::proto::finsky::document::Warning* optimaldeviceclasswarning);
  ::playapi::proto::finsky::document::Warning* unsafe_arena_release_optimaldeviceclasswarning();

  // optional .playapi.proto.finsky.document.SectionMetadata sectionSuggestForRating = 22;
  bool has_sectionsuggestforrating() const;
  private:
  bool _internal_has_sectionsuggestforrating() const;
  public:
  void clear_sectionsuggestforrating();
  const ::playapi::proto::finsky::document::SectionMetadata& sectionsuggestforrating() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::SectionMetadata* release_sectionsuggestforrating();
  ::playapi::proto::finsky::document::SectionMetadata* mutable_sectionsuggestforrating();
  void set_allocated_sectionsuggestforrating(::playapi::proto::finsky::document::SectionMetadata* sectionsuggestforrating);
  private:
  const ::playapi::proto::finsky::document::SectionMetadata& _internal_sectionsuggestforrating() const;
  ::playapi::proto::finsky::document::SectionMetadata* _internal_mutable_sectionsuggestforrating();
  public:
  void unsafe_arena_set_allocated_sectionsuggestforrating(
      ::playapi::proto::finsky::document::SectionMetadata* sectionsuggestforrating);
  ::playapi::proto::finsky::document::SectionMetadata* unsafe_arena_release_sectionsuggestforrating();

  // optional .playapi.proto.finsky.document.SectionMetadata sectionPurchaseCrossSell = 24;
  bool has_sectionpurchasecrosssell() const;
  private:
  bool _internal_has_sectionpurchasecrosssell() const;
  public:
  void clear_sectionpurchasecrosssell();
  const ::playapi::proto::finsky::document::SectionMetadata& sectionpurchasecrosssell() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::SectionMetadata* release_sectionpurchasecrosssell();
  ::playapi::proto::finsky::document::SectionMetadata* mutable_sectionpurchasecrosssell();
  void set_allocated_sectionpurchasecrosssell(::playapi::proto::finsky::document::SectionMetadata* sectionpurchasecrosssell);
  private:
  const ::playapi::proto::finsky::document::SectionMetadata& _internal_sectionpurchasecrosssell() const;
  ::playapi::proto::finsky::document::SectionMetadata* _internal_mutable_sectionpurchasecrosssell();
  public:
  void unsafe_arena_set_allocated_sectionpurchasecrosssell(
      ::playapi::proto::finsky::document::SectionMetadata* sectionpurchasecrosssell);
  ::playapi::proto::finsky::document::SectionMetadata* unsafe_arena_release_sectionpurchasecrosssell();

  // optional .playapi.proto.finsky.document.DocV2 creatorDoc = 26;
  bool has_creatordoc() const;
  private:
  bool _internal_has_creatordoc() const;
  public:
  void clear_creatordoc();
  const ::playapi::proto::finsky::document::DocV2& creatordoc() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::DocV2* release_creatordoc();
  ::playapi::proto::finsky::document::DocV2* mutable_creatordoc();
  void set_allocated_creatordoc(::playapi::proto::finsky::document::DocV2* creatordoc);
  private:
  const ::playapi::proto::finsky::document::DocV2& _internal_creatordoc() const;
  ::playapi::proto::finsky::document::DocV2* _internal_mutable_creatordoc();
  public:
  void unsafe_arena_set_allocated_creatordoc(
      ::playapi::proto::finsky::document::DocV2* creatordoc);
  ::playapi::proto::finsky::document::DocV2* unsafe_arena_release_creatordoc();

  // optional .playapi.proto.finsky.document.PurchaseHistoryDetails purchaseHistoryDetails = 28;
  bool has_purchasehistorydetails() const;
  private:
  bool _internal_has_purchasehistorydetails() const;
  public:
  void clear_purchasehistorydetails();
  const ::playapi::proto::finsky::document::PurchaseHistoryDetails& purchasehistorydetails() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::PurchaseHistoryDetails* release_purchasehistorydetails();
  ::playapi::proto::finsky::document::PurchaseHistoryDetails* mutable_purchasehistorydetails();
  void set_allocated_purchasehistorydetails(::playapi::proto::finsky::document::PurchaseHistoryDetails* purchasehistorydetails);
  private:
  const ::playapi::proto::finsky::document::PurchaseHistoryDetails& _internal_purchasehistorydetails() const;
  ::playapi::proto::finsky::document::PurchaseHistoryDetails* _internal_mutable_purchasehistorydetails();
  public:
  void unsafe_arena_set_allocated_purchasehistorydetails(
      ::playapi::proto::finsky::document::PurchaseHistoryDetails* purchasehistorydetails);
  ::playapi::proto::finsky::document::PurchaseHistoryDetails* unsafe_arena_release_purchasehistorydetails();

  // optional .playapi.proto.finsky.document.Badge badgeForContentRating = 29;
  bool has_badgeforcontentrating() const;
  private:
  bool _internal_has_badgeforcontentrating() const;
  public:
  void clear_badgeforcontentrating();
  const ::playapi::proto::finsky::document::Badge& badgeforcontentrating() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::Badge* release_badgeforcontentrating();
  ::playapi::proto::finsky::document::Badge* mutable_badgeforcontentrating();
  void set_allocated_badgeforcontentrating(::playapi::proto::finsky::document::Badge* badgeforcontentrating);
  private:
  const ::playapi::proto::finsky::document::Badge& _internal_badgeforcontentrating() const;
  ::playapi::proto::finsky::document::Badge* _internal_mutable_badgeforcontentrating();
  public:
  void unsafe_arena_set_allocated_badgeforcontentrating(
      ::playapi::proto::finsky::document::Badge* badgeforcontentrating);
  ::playapi::proto::finsky::document::Badge* unsafe_arena_release_badgeforcontentrating();

  // optional .playapi.proto.finsky.document.SectionMetadata sectionFeaturedApps = 32;
  bool has_sectionfeaturedapps() const;
  private:
  bool _internal_has_sectionfeaturedapps() const;
  public:
  void clear_sectionfeaturedapps();
  const ::playapi::proto::finsky::document::SectionMetadata& sectionfeaturedapps() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::SectionMetadata* release_sectionfeaturedapps();
  ::playapi::proto::finsky::document::SectionMetadata* mutable_sectionfeaturedapps();
  void set_allocated_sectionfeaturedapps(::playapi::proto::finsky::document::SectionMetadata* sectionfeaturedapps);
  private:
  const ::playapi::proto::finsky::document::SectionMetadata& _internal_sectionfeaturedapps() const;
  ::playapi::proto::finsky::document::SectionMetadata* _internal_mutable_sectionfeaturedapps();
  public:
  void unsafe_arena_set_allocated_sectionfeaturedapps(
      ::playapi::proto::finsky::document::SectionMetadata* sectionfeaturedapps);
  ::playapi::proto::finsky::document::SectionMetadata* unsafe_arena_release_sectionfeaturedapps();

  // optional .playapi.proto.finsky.document.VideoAnnotations videoAnnotations = 35;
  bool has_videoannotations() const;
  private:
  bool _internal_has_videoannotations() const;
  public:
  void clear_videoannotations();
  const ::playapi::proto::finsky::document::VideoAnnotations& videoannotations() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::VideoAnnotations* release_videoannotations();
  ::playapi::proto::finsky::document::VideoAnnotations* mutable_videoannotations();
  void set_allocated_videoannotations(::playapi::proto::finsky::document::VideoAnnotations* videoannotations);
  private:
  const ::playapi::proto::finsky::document::VideoAnnotations& _internal_videoannotations() const;
  ::playapi::proto::finsky::document::VideoAnnotations* _internal_mutable_videoannotations();
  public:
  void unsafe_arena_set_allocated_videoannotations(
      ::playapi::proto::finsky::document::VideoAnnotations* videoannotations);
  ::playapi::proto::finsky::document::VideoAnnotations* unsafe_arena_release_videoannotations();

  // optional .playapi.proto.finsky.document.SectionMetadata sectionPurchaseRelatedTopics = 36;
  bool has_sectionpurchaserelatedtopics() const;
  private:
  bool _internal_has_sectionpurchaserelatedtopics() const;
  public:
  void clear_sectionpurchaserelatedtopics();
  const ::playapi::proto::finsky::document::SectionMetadata& sectionpurchaserelatedtopics() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::SectionMetadata* release_sectionpurchaserelatedtopics();
  ::playapi::proto::finsky::document::SectionMetadata* mutable_sectionpurchaserelatedtopics();
  void set_allocated_sectionpurchaserelatedtopics(::playapi::proto::finsky::document::SectionMetadata* sectionpurchaserelatedtopics);
  private:
  const ::playapi::proto::finsky::document::SectionMetadata& _internal_sectionpurchaserelatedtopics() const;
  ::playapi::proto::finsky::document::SectionMetadata* _internal_mutable_sectionpurchaserelatedtopics();
  public:
  void unsafe_arena_set_allocated_sectionpurchaserelatedtopics(
      ::playapi::proto::finsky::document::SectionMetadata* sectionpurchaserelatedtopics);
  ::playapi::proto::finsky::document::SectionMetadata* unsafe_arena_release_sectionpurchaserelatedtopics();

  // optional .playapi.proto.finsky.document.MySubscriptionDetails mySubscriptionDetails = 37;
  bool has_mysubscriptiondetails() const;
  private:
  bool _internal_has_mysubscriptiondetails() const;
  public:
  void clear_mysubscriptiondetails();
  const ::playapi::proto::finsky::document::MySubscriptionDetails& mysubscriptiondetails() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::MySubscriptionDetails* release_mysubscriptiondetails();
  ::playapi::proto::finsky::document::MySubscriptionDetails* mutable_mysubscriptiondetails();
  void set_allocated_mysubscriptiondetails(::playapi::proto::finsky::document::MySubscriptionDetails* mysubscriptiondetails);
  private:
  const ::playapi::proto::finsky::document::MySubscriptionDetails& _internal_mysubscriptiondetails() const;
  ::playapi::proto::finsky::document::MySubscriptionDetails* _internal_mutable_mysubscriptiondetails();
  public:
  void unsafe_arena_set_allocated_mysubscriptiondetails(
      ::playapi::proto::finsky::document::MySubscriptionDetails* mysubscriptiondetails);
  ::playapi::proto::finsky::document::MySubscriptionDetails* unsafe_arena_release_mysubscriptiondetails();

  // optional .playapi.proto.finsky.document.MyRewardDetails myRewardDetails = 38;
  bool has_myrewarddetails() const;
  private:
  bool _internal_has_myrewarddetails() const;
  public:
  void clear_myrewarddetails();
  const ::playapi::proto::finsky::document::MyRewardDetails& myrewarddetails() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::MyRewardDetails* release_myrewarddetails();
  ::playapi::proto::finsky::document::MyRewardDetails* mutable_myrewarddetails();
  void set_allocated_myrewarddetails(::playapi::proto::finsky::document::MyRewardDetails* myrewarddetails);
  private:
  const ::playapi::proto::finsky::document::MyRewardDetails& _internal_myrewarddetails() const;
  ::playapi::proto::finsky::document::MyRewardDetails* _internal_mutable_myrewarddetails();
  public:
  void unsafe_arena_set_allocated_myrewarddetails(
      ::playapi::proto::finsky::document::MyRewardDetails* myrewarddetails);
  ::playapi::proto::finsky::document::MyRewardDetails* unsafe_arena_release_myrewarddetails();

  // optional .playapi.proto.finsky.document.SelectedChild selectedChild = 40;
  bool has_selectedchild() const;
  private:
  bool _internal_has_selectedchild() const;
  public:
  void clear_selectedchild();
  const ::playapi::proto::finsky::document::SelectedChild& selectedchild() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::SelectedChild* release_selectedchild();
  ::playapi::proto::finsky::document::SelectedChild* mutable_selectedchild();
  void set_allocated_selectedchild(::playapi::proto::finsky::document::SelectedChild* selectedchild);
  private:
  const ::playapi::proto::finsky::document::SelectedChild& _internal_selectedchild() const;
  ::playapi::proto::finsky::document::SelectedChild* _internal_mutable_selectedchild();
  public:
  void unsafe_arena_set_allocated_selectedchild(
      ::playapi::proto::finsky::document::SelectedChild* selectedchild);
  ::playapi::proto::finsky::document::SelectedChild* unsafe_arena_release_selectedchild();

  // optional .playapi.proto.finsky.document.PurchaseDetails purchaseDetails = 41;
  bool has_purchasedetails() const;
  private:
  bool _internal_has_purchasedetails() const;
  public:
  void clear_purchasedetails();
  const ::playapi::proto::finsky::document::PurchaseDetails& purchasedetails() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::PurchaseDetails* release_purchasedetails();
  ::playapi::proto::finsky::document::PurchaseDetails* mutable_purchasedetails();
  void set_allocated_purchasedetails(::playapi::proto::finsky::document::PurchaseDetails* purchasedetails);
  private:
  const ::playapi::proto::finsky::document::PurchaseDetails& _internal_purchasedetails() const;
  ::playapi::proto::finsky::document::PurchaseDetails* _internal_mutable_purchasedetails();
  public:
  void unsafe_arena_set_allocated_purchasedetails(
      ::playapi::proto::finsky::document::PurchaseDetails* purchasedetails);
  ::playapi::proto::finsky::document::PurchaseDetails* unsafe_arena_release_purchasedetails();

  // optional .playapi.proto.finsky.document.Snippet snippet = 42;
  bool has_snippet() const;
  private:
  bool _internal_has_snippet() const;
  public:
  void clear_snippet();
  const ::playapi::proto::finsky::document::Snippet& snippet() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::Snippet* release_snippet();
  ::playapi::proto::finsky::document::Snippet* mutable_snippet();
  void set_allocated_snippet(::playapi::proto::finsky::document::Snippet* snippet);
  private:
  const ::playapi::proto::finsky::document::Snippet& _internal_snippet() const;
  ::playapi::proto::finsky::document::Snippet* _internal_mutable_snippet();
  public:
  void unsafe_arena_set_allocated_snippet(
      ::playapi::proto::finsky::document::Snippet* snippet);
  ::playapi::proto::finsky::document::Snippet* unsafe_arena_release_snippet();

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.document.Annotations)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::Warning > warning_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::Badge > badgeforcreator_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::Badge > badgefordoc_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::PromotedDoc > promoteddoc_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::DocV2 > subscription_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::BadgeContainer > docbadgecontainer_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::link::OverflowLink > overflowlink_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::VoucherInfo > voucherinfo_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::SectionMetadata > detailspagecluster_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::Badge > featurebadge_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr offernote_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr privacypolicyurl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attributionhtml_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr applicablevoucherdescription_;
    ::playapi::proto::finsky::document::SectionMetadata* sectionrelated_;
    ::playapi::proto::finsky::document::SectionMetadata* sectionmoreby_;
    ::playapi::proto::finsky::document::PlusOneData* plusonedata_;
    ::playapi::proto::finsky::document::SectionMetadata* sectionbodyofwork_;
    ::playapi::proto::finsky::document::SectionMetadata* sectioncorecontent_;
    ::playapi::proto::finsky::link::Link* link_;
    ::playapi::proto::finsky::document::SectionMetadata* sectioncrosssell_;
    ::playapi::proto::finsky::document::SectionMetadata* sectionrelateddoctype_;
    ::playapi::proto::finsky::document::OBSOLETE_Reason* obsoletereason_;
    ::playapi::proto::finsky::document::Warning* optimaldeviceclasswarning_;
    ::playapi::proto::finsky::document::SectionMetadata* sectionsuggestforrating_;
    ::playapi::proto::finsky::document::SectionMetadata* sectionpurchasecrosssell_;
    ::playapi::proto::finsky::document::DocV2* creatordoc_;
    ::playapi::proto::finsky::document::PurchaseHistoryDetails* purchasehistorydetails_;
    ::playapi::proto::finsky::document::Badge* badgeforcontentrating_;
    ::playapi::proto::finsky::document::SectionMetadata* sectionfeaturedapps_;
    ::playapi::proto::finsky::document::VideoAnnotations* videoannotations_;
    ::playapi::proto::finsky::document::SectionMetadata* sectionpurchaserelatedtopics_;
    ::playapi::proto::finsky::document::MySubscriptionDetails* mysubscriptiondetails_;
    ::playapi::proto::finsky::document::MyRewardDetails* myrewarddetails_;
    ::playapi::proto::finsky::document::SelectedChild* selectedchild_;
    ::playapi::proto::finsky::document::PurchaseDetails* purchasedetails_;
    ::playapi::proto::finsky::document::Snippet* snippet_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fdocument_2eproto;
};
// -------------------------------------------------------------------

class PlusOneData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.document.PlusOneData) */ {
 public:
  inline PlusOneData() : PlusOneData(nullptr) {}
  ~PlusOneData() override;
  explicit PROTOBUF_CONSTEXPR PlusOneData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlusOneData(const PlusOneData& from);
  PlusOneData(PlusOneData&& from) noexcept
    : PlusOneData() {
    *this = ::std::move(from);
  }

  inline PlusOneData& operator=(const PlusOneData& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlusOneData& operator=(PlusOneData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlusOneData& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlusOneData* internal_default_instance() {
    return reinterpret_cast<const PlusOneData*>(
               &_PlusOneData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PlusOneData& a, PlusOneData& b) {
    a.Swap(&b);
  }
  inline void Swap(PlusOneData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlusOneData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlusOneData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlusOneData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlusOneData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlusOneData& from) {
    PlusOneData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlusOneData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.document.PlusOneData";
  }
  protected:
  explicit PlusOneData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOBSOLETECirclesProfilesFieldNumber = 4,
    kCirclePersonFieldNumber = 5,
    kTotalFieldNumber = 2,
    kCirclesTotalFieldNumber = 3,
    kSetByUserFieldNumber = 1,
  };
  // repeated .playapi.proto.finsky.document.OBSOLETE_PlusProfile OBSOLETECirclesProfiles = 4;
  int obsoletecirclesprofiles_size() const;
  private:
  int _internal_obsoletecirclesprofiles_size() const;
  public:
  void clear_obsoletecirclesprofiles();
  ::playapi::proto::finsky::document::OBSOLETE_PlusProfile* mutable_obsoletecirclesprofiles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::OBSOLETE_PlusProfile >*
      mutable_obsoletecirclesprofiles();
  private:
  const ::playapi::proto::finsky::document::OBSOLETE_PlusProfile& _internal_obsoletecirclesprofiles(int index) const;
  ::playapi::proto::finsky::document::OBSOLETE_PlusProfile* _internal_add_obsoletecirclesprofiles();
  public:
  const ::playapi::proto::finsky::document::OBSOLETE_PlusProfile& obsoletecirclesprofiles(int index) const;
  ::playapi::proto::finsky::document::OBSOLETE_PlusProfile* add_obsoletecirclesprofiles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::OBSOLETE_PlusProfile >&
      obsoletecirclesprofiles() const;

  // repeated .playapi.proto.finsky.document.DocV2 circlePerson = 5;
  int circleperson_size() const;
  private:
  int _internal_circleperson_size() const;
  public:
  void clear_circleperson();
  ::playapi::proto::finsky::document::DocV2* mutable_circleperson(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::DocV2 >*
      mutable_circleperson();
  private:
  const ::playapi::proto::finsky::document::DocV2& _internal_circleperson(int index) const;
  ::playapi::proto::finsky::document::DocV2* _internal_add_circleperson();
  public:
  const ::playapi::proto::finsky::document::DocV2& circleperson(int index) const;
  ::playapi::proto::finsky::document::DocV2* add_circleperson();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::DocV2 >&
      circleperson() const;

  // optional int64 total = 2;
  bool has_total() const;
  private:
  bool _internal_has_total() const;
  public:
  void clear_total();
  int64_t total() const;
  void set_total(int64_t value);
  private:
  int64_t _internal_total() const;
  void _internal_set_total(int64_t value);
  public:

  // optional int64 circlesTotal = 3;
  bool has_circlestotal() const;
  private:
  bool _internal_has_circlestotal() const;
  public:
  void clear_circlestotal();
  int64_t circlestotal() const;
  void set_circlestotal(int64_t value);
  private:
  int64_t _internal_circlestotal() const;
  void _internal_set_circlestotal(int64_t value);
  public:

  // optional bool setByUser = 1;
  bool has_setbyuser() const;
  private:
  bool _internal_has_setbyuser() const;
  public:
  void clear_setbyuser();
  bool setbyuser() const;
  void set_setbyuser(bool value);
  private:
  bool _internal_setbyuser() const;
  void _internal_set_setbyuser(bool value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.document.PlusOneData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::OBSOLETE_PlusProfile > obsoletecirclesprofiles_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::DocV2 > circleperson_;
    int64_t total_;
    int64_t circlestotal_;
    bool setbyuser_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fdocument_2eproto;
};
// -------------------------------------------------------------------

class OBSOLETE_PlusProfile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.document.OBSOLETE_PlusProfile) */ {
 public:
  inline OBSOLETE_PlusProfile() : OBSOLETE_PlusProfile(nullptr) {}
  ~OBSOLETE_PlusProfile() override;
  explicit PROTOBUF_CONSTEXPR OBSOLETE_PlusProfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OBSOLETE_PlusProfile(const OBSOLETE_PlusProfile& from);
  OBSOLETE_PlusProfile(OBSOLETE_PlusProfile&& from) noexcept
    : OBSOLETE_PlusProfile() {
    *this = ::std::move(from);
  }

  inline OBSOLETE_PlusProfile& operator=(const OBSOLETE_PlusProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline OBSOLETE_PlusProfile& operator=(OBSOLETE_PlusProfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OBSOLETE_PlusProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const OBSOLETE_PlusProfile* internal_default_instance() {
    return reinterpret_cast<const OBSOLETE_PlusProfile*>(
               &_OBSOLETE_PlusProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(OBSOLETE_PlusProfile& a, OBSOLETE_PlusProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(OBSOLETE_PlusProfile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OBSOLETE_PlusProfile* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OBSOLETE_PlusProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OBSOLETE_PlusProfile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OBSOLETE_PlusProfile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OBSOLETE_PlusProfile& from) {
    OBSOLETE_PlusProfile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OBSOLETE_PlusProfile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.document.OBSOLETE_PlusProfile";
  }
  protected:
  explicit OBSOLETE_PlusProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDisplayNameFieldNumber = 2,
    kProfileImageUrlFieldNumber = 4,
    kProfileImageFieldNumber = 5,
  };
  // optional string displayName = 2;
  bool has_displayname() const;
  private:
  bool _internal_has_displayname() const;
  public:
  void clear_displayname();
  const std::string& displayname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_displayname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_displayname();
  PROTOBUF_NODISCARD std::string* release_displayname();
  void set_allocated_displayname(std::string* displayname);
  private:
  const std::string& _internal_displayname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_displayname(const std::string& value);
  std::string* _internal_mutable_displayname();
  public:

  // optional string profileImageUrl = 4;
  bool has_profileimageurl() const;
  private:
  bool _internal_has_profileimageurl() const;
  public:
  void clear_profileimageurl();
  const std::string& profileimageurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_profileimageurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_profileimageurl();
  PROTOBUF_NODISCARD std::string* release_profileimageurl();
  void set_allocated_profileimageurl(std::string* profileimageurl);
  private:
  const std::string& _internal_profileimageurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_profileimageurl(const std::string& value);
  std::string* _internal_mutable_profileimageurl();
  public:

  // optional .playapi.proto.finsky.Image profileImage = 5;
  bool has_profileimage() const;
  private:
  bool _internal_has_profileimage() const;
  public:
  void clear_profileimage();
  const ::playapi::proto::finsky::Image& profileimage() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::Image* release_profileimage();
  ::playapi::proto::finsky::Image* mutable_profileimage();
  void set_allocated_profileimage(::playapi::proto::finsky::Image* profileimage);
  private:
  const ::playapi::proto::finsky::Image& _internal_profileimage() const;
  ::playapi::proto::finsky::Image* _internal_mutable_profileimage();
  public:
  void unsafe_arena_set_allocated_profileimage(
      ::playapi::proto::finsky::Image* profileimage);
  ::playapi::proto::finsky::Image* unsafe_arena_release_profileimage();

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.document.OBSOLETE_PlusProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr displayname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr profileimageurl_;
    ::playapi::proto::finsky::Image* profileimage_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fdocument_2eproto;
};
// -------------------------------------------------------------------

class SectionMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.document.SectionMetadata) */ {
 public:
  inline SectionMetadata() : SectionMetadata(nullptr) {}
  ~SectionMetadata() override;
  explicit PROTOBUF_CONSTEXPR SectionMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SectionMetadata(const SectionMetadata& from);
  SectionMetadata(SectionMetadata&& from) noexcept
    : SectionMetadata() {
    *this = ::std::move(from);
  }

  inline SectionMetadata& operator=(const SectionMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline SectionMetadata& operator=(SectionMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SectionMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const SectionMetadata* internal_default_instance() {
    return reinterpret_cast<const SectionMetadata*>(
               &_SectionMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SectionMetadata& a, SectionMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(SectionMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SectionMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SectionMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SectionMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SectionMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SectionMetadata& from) {
    SectionMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SectionMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.document.SectionMetadata";
  }
  protected:
  explicit SectionMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kListUrlFieldNumber = 2,
    kBrowseUrlFieldNumber = 3,
    kDescriptionHtmlFieldNumber = 4,
  };
  // optional string header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const std::string& header() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_header(ArgT0&& arg0, ArgT... args);
  std::string* mutable_header();
  PROTOBUF_NODISCARD std::string* release_header();
  void set_allocated_header(std::string* header);
  private:
  const std::string& _internal_header() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_header(const std::string& value);
  std::string* _internal_mutable_header();
  public:

  // optional string listUrl = 2;
  bool has_listurl() const;
  private:
  bool _internal_has_listurl() const;
  public:
  void clear_listurl();
  const std::string& listurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_listurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_listurl();
  PROTOBUF_NODISCARD std::string* release_listurl();
  void set_allocated_listurl(std::string* listurl);
  private:
  const std::string& _internal_listurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_listurl(const std::string& value);
  std::string* _internal_mutable_listurl();
  public:

  // optional string browseUrl = 3;
  bool has_browseurl() const;
  private:
  bool _internal_has_browseurl() const;
  public:
  void clear_browseurl();
  const std::string& browseurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_browseurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_browseurl();
  PROTOBUF_NODISCARD std::string* release_browseurl();
  void set_allocated_browseurl(std::string* browseurl);
  private:
  const std::string& _internal_browseurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_browseurl(const std::string& value);
  std::string* _internal_mutable_browseurl();
  public:

  // optional string descriptionHtml = 4;
  bool has_descriptionhtml() const;
  private:
  bool _internal_has_descriptionhtml() const;
  public:
  void clear_descriptionhtml();
  const std::string& descriptionhtml() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_descriptionhtml(ArgT0&& arg0, ArgT... args);
  std::string* mutable_descriptionhtml();
  PROTOBUF_NODISCARD std::string* release_descriptionhtml();
  void set_allocated_descriptionhtml(std::string* descriptionhtml);
  private:
  const std::string& _internal_descriptionhtml() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_descriptionhtml(const std::string& value);
  std::string* _internal_mutable_descriptionhtml();
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.document.SectionMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr header_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr listurl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr browseurl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr descriptionhtml_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fdocument_2eproto;
};
// -------------------------------------------------------------------

class Warning final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.document.Warning) */ {
 public:
  inline Warning() : Warning(nullptr) {}
  ~Warning() override;
  explicit PROTOBUF_CONSTEXPR Warning(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Warning(const Warning& from);
  Warning(Warning&& from) noexcept
    : Warning() {
    *this = ::std::move(from);
  }

  inline Warning& operator=(const Warning& from) {
    CopyFrom(from);
    return *this;
  }
  inline Warning& operator=(Warning&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Warning& default_instance() {
    return *internal_default_instance();
  }
  static inline const Warning* internal_default_instance() {
    return reinterpret_cast<const Warning*>(
               &_Warning_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Warning& a, Warning& b) {
    a.Swap(&b);
  }
  inline void Swap(Warning* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Warning* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Warning* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Warning>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Warning& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Warning& from) {
    Warning::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Warning* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.document.Warning";
  }
  protected:
  explicit Warning(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocalizedMessageFieldNumber = 1,
    kShowIconFieldNumber = 2,
  };
  // optional string localizedMessage = 1;
  bool has_localizedmessage() const;
  private:
  bool _internal_has_localizedmessage() const;
  public:
  void clear_localizedmessage();
  const std::string& localizedmessage() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_localizedmessage(ArgT0&& arg0, ArgT... args);
  std::string* mutable_localizedmessage();
  PROTOBUF_NODISCARD std::string* release_localizedmessage();
  void set_allocated_localizedmessage(std::string* localizedmessage);
  private:
  const std::string& _internal_localizedmessage() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_localizedmessage(const std::string& value);
  std::string* _internal_mutable_localizedmessage();
  public:

  // optional bool showIcon = 2;
  bool has_showicon() const;
  private:
  bool _internal_has_showicon() const;
  public:
  void clear_showicon();
  bool showicon() const;
  void set_showicon(bool value);
  private:
  bool _internal_showicon() const;
  void _internal_set_showicon(bool value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.document.Warning)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr localizedmessage_;
    bool showicon_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fdocument_2eproto;
};
// -------------------------------------------------------------------

class Badge final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.document.Badge) */ {
 public:
  inline Badge() : Badge(nullptr) {}
  ~Badge() override;
  explicit PROTOBUF_CONSTEXPR Badge(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Badge(const Badge& from);
  Badge(Badge&& from) noexcept
    : Badge() {
    *this = ::std::move(from);
  }

  inline Badge& operator=(const Badge& from) {
    CopyFrom(from);
    return *this;
  }
  inline Badge& operator=(Badge&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Badge& default_instance() {
    return *internal_default_instance();
  }
  static inline const Badge* internal_default_instance() {
    return reinterpret_cast<const Badge*>(
               &_Badge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Badge& a, Badge& b) {
    a.Swap(&b);
  }
  inline void Swap(Badge* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Badge* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Badge* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Badge>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Badge& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Badge& from) {
    Badge::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Badge* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.document.Badge";
  }
  protected:
  explicit Badge(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImageFieldNumber = 2,
    kTitleFieldNumber = 1,
    kBrowseUrlFieldNumber = 3,
    kDescriptionFieldNumber = 4,
    kTextInTitleSectionFieldNumber = 5,
    kExpandedBadgeImageFieldNumber = 6,
  };
  // repeated .playapi.proto.finsky.Image image = 2;
  int image_size() const;
  private:
  int _internal_image_size() const;
  public:
  void clear_image();
  ::playapi::proto::finsky::Image* mutable_image(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Image >*
      mutable_image();
  private:
  const ::playapi::proto::finsky::Image& _internal_image(int index) const;
  ::playapi::proto::finsky::Image* _internal_add_image();
  public:
  const ::playapi::proto::finsky::Image& image(int index) const;
  ::playapi::proto::finsky::Image* add_image();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Image >&
      image() const;

  // optional string title = 1;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // optional string browseUrl = 3;
  bool has_browseurl() const;
  private:
  bool _internal_has_browseurl() const;
  public:
  void clear_browseurl();
  const std::string& browseurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_browseurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_browseurl();
  PROTOBUF_NODISCARD std::string* release_browseurl();
  void set_allocated_browseurl(std::string* browseurl);
  private:
  const std::string& _internal_browseurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_browseurl(const std::string& value);
  std::string* _internal_mutable_browseurl();
  public:

  // optional string description = 4;
  bool has_description() const;
  private:
  bool _internal_has_description() const;
  public:
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // optional string textInTitleSection = 5;
  bool has_textintitlesection() const;
  private:
  bool _internal_has_textintitlesection() const;
  public:
  void clear_textintitlesection();
  const std::string& textintitlesection() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_textintitlesection(ArgT0&& arg0, ArgT... args);
  std::string* mutable_textintitlesection();
  PROTOBUF_NODISCARD std::string* release_textintitlesection();
  void set_allocated_textintitlesection(std::string* textintitlesection);
  private:
  const std::string& _internal_textintitlesection() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_textintitlesection(const std::string& value);
  std::string* _internal_mutable_textintitlesection();
  public:

  // optional .playapi.proto.finsky.Image expandedBadgeImage = 6;
  bool has_expandedbadgeimage() const;
  private:
  bool _internal_has_expandedbadgeimage() const;
  public:
  void clear_expandedbadgeimage();
  const ::playapi::proto::finsky::Image& expandedbadgeimage() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::Image* release_expandedbadgeimage();
  ::playapi::proto::finsky::Image* mutable_expandedbadgeimage();
  void set_allocated_expandedbadgeimage(::playapi::proto::finsky::Image* expandedbadgeimage);
  private:
  const ::playapi::proto::finsky::Image& _internal_expandedbadgeimage() const;
  ::playapi::proto::finsky::Image* _internal_mutable_expandedbadgeimage();
  public:
  void unsafe_arena_set_allocated_expandedbadgeimage(
      ::playapi::proto::finsky::Image* expandedbadgeimage);
  ::playapi::proto::finsky::Image* unsafe_arena_release_expandedbadgeimage();

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.document.Badge)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Image > image_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr browseurl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr textintitlesection_;
    ::playapi::proto::finsky::Image* expandedbadgeimage_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fdocument_2eproto;
};
// -------------------------------------------------------------------

class BadgeContainer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.document.BadgeContainer) */ {
 public:
  inline BadgeContainer() : BadgeContainer(nullptr) {}
  ~BadgeContainer() override;
  explicit PROTOBUF_CONSTEXPR BadgeContainer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BadgeContainer(const BadgeContainer& from);
  BadgeContainer(BadgeContainer&& from) noexcept
    : BadgeContainer() {
    *this = ::std::move(from);
  }

  inline BadgeContainer& operator=(const BadgeContainer& from) {
    CopyFrom(from);
    return *this;
  }
  inline BadgeContainer& operator=(BadgeContainer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BadgeContainer& default_instance() {
    return *internal_default_instance();
  }
  static inline const BadgeContainer* internal_default_instance() {
    return reinterpret_cast<const BadgeContainer*>(
               &_BadgeContainer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(BadgeContainer& a, BadgeContainer& b) {
    a.Swap(&b);
  }
  inline void Swap(BadgeContainer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BadgeContainer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BadgeContainer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BadgeContainer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BadgeContainer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BadgeContainer& from) {
    BadgeContainer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BadgeContainer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.document.BadgeContainer";
  }
  protected:
  explicit BadgeContainer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImageFieldNumber = 2,
    kBadgeFieldNumber = 3,
    kTitleFieldNumber = 1,
  };
  // repeated .playapi.proto.finsky.Image image = 2;
  int image_size() const;
  private:
  int _internal_image_size() const;
  public:
  void clear_image();
  ::playapi::proto::finsky::Image* mutable_image(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Image >*
      mutable_image();
  private:
  const ::playapi::proto::finsky::Image& _internal_image(int index) const;
  ::playapi::proto::finsky::Image* _internal_add_image();
  public:
  const ::playapi::proto::finsky::Image& image(int index) const;
  ::playapi::proto::finsky::Image* add_image();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Image >&
      image() const;

  // repeated .playapi.proto.finsky.document.Badge badge = 3;
  int badge_size() const;
  private:
  int _internal_badge_size() const;
  public:
  void clear_badge();
  ::playapi::proto::finsky::document::Badge* mutable_badge(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::Badge >*
      mutable_badge();
  private:
  const ::playapi::proto::finsky::document::Badge& _internal_badge(int index) const;
  ::playapi::proto::finsky::document::Badge* _internal_add_badge();
  public:
  const ::playapi::proto::finsky::document::Badge& badge(int index) const;
  ::playapi::proto::finsky::document::Badge* add_badge();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::Badge >&
      badge() const;

  // optional string title = 1;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.document.BadgeContainer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Image > image_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::Badge > badge_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fdocument_2eproto;
};
// -------------------------------------------------------------------

class PurchaseDetails final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.document.PurchaseDetails) */ {
 public:
  inline PurchaseDetails() : PurchaseDetails(nullptr) {}
  ~PurchaseDetails() override;
  explicit PROTOBUF_CONSTEXPR PurchaseDetails(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PurchaseDetails(const PurchaseDetails& from);
  PurchaseDetails(PurchaseDetails&& from) noexcept
    : PurchaseDetails() {
    *this = ::std::move(from);
  }

  inline PurchaseDetails& operator=(const PurchaseDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline PurchaseDetails& operator=(PurchaseDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PurchaseDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const PurchaseDetails* internal_default_instance() {
    return reinterpret_cast<const PurchaseDetails*>(
               &_PurchaseDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(PurchaseDetails& a, PurchaseDetails& b) {
    a.Swap(&b);
  }
  inline void Swap(PurchaseDetails* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PurchaseDetails* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PurchaseDetails* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PurchaseDetails>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PurchaseDetails& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PurchaseDetails& from) {
    PurchaseDetails::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PurchaseDetails* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.document.PurchaseDetails";
  }
  protected:
  explicit PurchaseDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLegalDocumentBrokerIdFieldNumber = 1,
    kShowAgeConfirmationPromptFieldNumber = 33,
    kPurchaseAuthenticationRequiredFieldNumber = 34,
  };
  // optional int64 legalDocumentBrokerId = 1;
  bool has_legaldocumentbrokerid() const;
  private:
  bool _internal_has_legaldocumentbrokerid() const;
  public:
  void clear_legaldocumentbrokerid();
  int64_t legaldocumentbrokerid() const;
  void set_legaldocumentbrokerid(int64_t value);
  private:
  int64_t _internal_legaldocumentbrokerid() const;
  void _internal_set_legaldocumentbrokerid(int64_t value);
  public:

  // optional bool showAgeConfirmationPrompt = 33;
  bool has_showageconfirmationprompt() const;
  private:
  bool _internal_has_showageconfirmationprompt() const;
  public:
  void clear_showageconfirmationprompt();
  bool showageconfirmationprompt() const;
  void set_showageconfirmationprompt(bool value);
  private:
  bool _internal_showageconfirmationprompt() const;
  void _internal_set_showageconfirmationprompt(bool value);
  public:

  // optional bool purchaseAuthenticationRequired = 34;
  bool has_purchaseauthenticationrequired() const;
  private:
  bool _internal_has_purchaseauthenticationrequired() const;
  public:
  void clear_purchaseauthenticationrequired();
  bool purchaseauthenticationrequired() const;
  void set_purchaseauthenticationrequired(bool value);
  private:
  bool _internal_purchaseauthenticationrequired() const;
  void _internal_set_purchaseauthenticationrequired(bool value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.document.PurchaseDetails)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t legaldocumentbrokerid_;
    bool showageconfirmationprompt_;
    bool purchaseauthenticationrequired_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fdocument_2eproto;
};
// -------------------------------------------------------------------

class PurchaseHistoryDetails final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.document.PurchaseHistoryDetails) */ {
 public:
  inline PurchaseHistoryDetails() : PurchaseHistoryDetails(nullptr) {}
  ~PurchaseHistoryDetails() override;
  explicit PROTOBUF_CONSTEXPR PurchaseHistoryDetails(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PurchaseHistoryDetails(const PurchaseHistoryDetails& from);
  PurchaseHistoryDetails(PurchaseHistoryDetails&& from) noexcept
    : PurchaseHistoryDetails() {
    *this = ::std::move(from);
  }

  inline PurchaseHistoryDetails& operator=(const PurchaseHistoryDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline PurchaseHistoryDetails& operator=(PurchaseHistoryDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PurchaseHistoryDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const PurchaseHistoryDetails* internal_default_instance() {
    return reinterpret_cast<const PurchaseHistoryDetails*>(
               &_PurchaseHistoryDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(PurchaseHistoryDetails& a, PurchaseHistoryDetails& b) {
    a.Swap(&b);
  }
  inline void Swap(PurchaseHistoryDetails* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PurchaseHistoryDetails* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PurchaseHistoryDetails* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PurchaseHistoryDetails>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PurchaseHistoryDetails& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PurchaseHistoryDetails& from) {
    PurchaseHistoryDetails::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PurchaseHistoryDetails* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.document.PurchaseHistoryDetails";
  }
  protected:
  explicit PurchaseHistoryDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPurchaseDetailsHtmlFieldNumber = 3,
    kPurchaseStatusFieldNumber = 6,
    kTitleBylineHtmlFieldNumber = 7,
    kClientRefundContextFieldNumber = 8,
    kOfferFieldNumber = 5,
    kPurchaseDetailsImageFieldNumber = 9,
    kPurchaseTimestampMsecFieldNumber = 2,
  };
  // optional string purchaseDetailsHtml = 3;
  bool has_purchasedetailshtml() const;
  private:
  bool _internal_has_purchasedetailshtml() const;
  public:
  void clear_purchasedetailshtml();
  const std::string& purchasedetailshtml() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_purchasedetailshtml(ArgT0&& arg0, ArgT... args);
  std::string* mutable_purchasedetailshtml();
  PROTOBUF_NODISCARD std::string* release_purchasedetailshtml();
  void set_allocated_purchasedetailshtml(std::string* purchasedetailshtml);
  private:
  const std::string& _internal_purchasedetailshtml() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_purchasedetailshtml(const std::string& value);
  std::string* _internal_mutable_purchasedetailshtml();
  public:

  // optional string purchaseStatus = 6;
  bool has_purchasestatus() const;
  private:
  bool _internal_has_purchasestatus() const;
  public:
  void clear_purchasestatus();
  const std::string& purchasestatus() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_purchasestatus(ArgT0&& arg0, ArgT... args);
  std::string* mutable_purchasestatus();
  PROTOBUF_NODISCARD std::string* release_purchasestatus();
  void set_allocated_purchasestatus(std::string* purchasestatus);
  private:
  const std::string& _internal_purchasestatus() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_purchasestatus(const std::string& value);
  std::string* _internal_mutable_purchasestatus();
  public:

  // optional string titleBylineHtml = 7;
  bool has_titlebylinehtml() const;
  private:
  bool _internal_has_titlebylinehtml() const;
  public:
  void clear_titlebylinehtml();
  const std::string& titlebylinehtml() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_titlebylinehtml(ArgT0&& arg0, ArgT... args);
  std::string* mutable_titlebylinehtml();
  PROTOBUF_NODISCARD std::string* release_titlebylinehtml();
  void set_allocated_titlebylinehtml(std::string* titlebylinehtml);
  private:
  const std::string& _internal_titlebylinehtml() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_titlebylinehtml(const std::string& value);
  std::string* _internal_mutable_titlebylinehtml();
  public:

  // optional bytes clientRefundContext = 8;
  bool has_clientrefundcontext() const;
  private:
  bool _internal_has_clientrefundcontext() const;
  public:
  void clear_clientrefundcontext();
  const std::string& clientrefundcontext() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientrefundcontext(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientrefundcontext();
  PROTOBUF_NODISCARD std::string* release_clientrefundcontext();
  void set_allocated_clientrefundcontext(std::string* clientrefundcontext);
  private:
  const std::string& _internal_clientrefundcontext() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientrefundcontext(const std::string& value);
  std::string* _internal_mutable_clientrefundcontext();
  public:

  // optional .playapi.proto.finsky.Offer offer = 5;
  bool has_offer() const;
  private:
  bool _internal_has_offer() const;
  public:
  void clear_offer();
  const ::playapi::proto::finsky::Offer& offer() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::Offer* release_offer();
  ::playapi::proto::finsky::Offer* mutable_offer();
  void set_allocated_offer(::playapi::proto::finsky::Offer* offer);
  private:
  const ::playapi::proto::finsky::Offer& _internal_offer() const;
  ::playapi::proto::finsky::Offer* _internal_mutable_offer();
  public:
  void unsafe_arena_set_allocated_offer(
      ::playapi::proto::finsky::Offer* offer);
  ::playapi::proto::finsky::Offer* unsafe_arena_release_offer();

  // optional .playapi.proto.finsky.Image purchaseDetailsImage = 9;
  bool has_purchasedetailsimage() const;
  private:
  bool _internal_has_purchasedetailsimage() const;
  public:
  void clear_purchasedetailsimage();
  const ::playapi::proto::finsky::Image& purchasedetailsimage() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::Image* release_purchasedetailsimage();
  ::playapi::proto::finsky::Image* mutable_purchasedetailsimage();
  void set_allocated_purchasedetailsimage(::playapi::proto::finsky::Image* purchasedetailsimage);
  private:
  const ::playapi::proto::finsky::Image& _internal_purchasedetailsimage() const;
  ::playapi::proto::finsky::Image* _internal_mutable_purchasedetailsimage();
  public:
  void unsafe_arena_set_allocated_purchasedetailsimage(
      ::playapi::proto::finsky::Image* purchasedetailsimage);
  ::playapi::proto::finsky::Image* unsafe_arena_release_purchasedetailsimage();

  // optional int64 purchaseTimestampMsec = 2;
  bool has_purchasetimestampmsec() const;
  private:
  bool _internal_has_purchasetimestampmsec() const;
  public:
  void clear_purchasetimestampmsec();
  int64_t purchasetimestampmsec() const;
  void set_purchasetimestampmsec(int64_t value);
  private:
  int64_t _internal_purchasetimestampmsec() const;
  void _internal_set_purchasetimestampmsec(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.document.PurchaseHistoryDetails)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr purchasedetailshtml_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr purchasestatus_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr titlebylinehtml_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientrefundcontext_;
    ::playapi::proto::finsky::Offer* offer_;
    ::playapi::proto::finsky::Image* purchasedetailsimage_;
    int64_t purchasetimestampmsec_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fdocument_2eproto;
};
// -------------------------------------------------------------------

class OBSOLETE_Reason final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.document.OBSOLETE_Reason) */ {
 public:
  inline OBSOLETE_Reason() : OBSOLETE_Reason(nullptr) {}
  ~OBSOLETE_Reason() override;
  explicit PROTOBUF_CONSTEXPR OBSOLETE_Reason(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OBSOLETE_Reason(const OBSOLETE_Reason& from);
  OBSOLETE_Reason(OBSOLETE_Reason&& from) noexcept
    : OBSOLETE_Reason() {
    *this = ::std::move(from);
  }

  inline OBSOLETE_Reason& operator=(const OBSOLETE_Reason& from) {
    CopyFrom(from);
    return *this;
  }
  inline OBSOLETE_Reason& operator=(OBSOLETE_Reason&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OBSOLETE_Reason& default_instance() {
    return *internal_default_instance();
  }
  static inline const OBSOLETE_Reason* internal_default_instance() {
    return reinterpret_cast<const OBSOLETE_Reason*>(
               &_OBSOLETE_Reason_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(OBSOLETE_Reason& a, OBSOLETE_Reason& b) {
    a.Swap(&b);
  }
  inline void Swap(OBSOLETE_Reason* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OBSOLETE_Reason* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OBSOLETE_Reason* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OBSOLETE_Reason>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OBSOLETE_Reason& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OBSOLETE_Reason& from) {
    OBSOLETE_Reason::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OBSOLETE_Reason* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.document.OBSOLETE_Reason";
  }
  protected:
  explicit OBSOLETE_Reason(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBriefReasonFieldNumber = 1,
    kOBSOLETEDetailedReasonFieldNumber = 2,
    kUniqueIdFieldNumber = 3,
  };
  // optional string briefReason = 1;
  bool has_briefreason() const;
  private:
  bool _internal_has_briefreason() const;
  public:
  void clear_briefreason();
  const std::string& briefreason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_briefreason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_briefreason();
  PROTOBUF_NODISCARD std::string* release_briefreason();
  void set_allocated_briefreason(std::string* briefreason);
  private:
  const std::string& _internal_briefreason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_briefreason(const std::string& value);
  std::string* _internal_mutable_briefreason();
  public:

  // optional string OBSOLETEDetailedReason = 2;
  bool has_obsoletedetailedreason() const;
  private:
  bool _internal_has_obsoletedetailedreason() const;
  public:
  void clear_obsoletedetailedreason();
  const std::string& obsoletedetailedreason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_obsoletedetailedreason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_obsoletedetailedreason();
  PROTOBUF_NODISCARD std::string* release_obsoletedetailedreason();
  void set_allocated_obsoletedetailedreason(std::string* obsoletedetailedreason);
  private:
  const std::string& _internal_obsoletedetailedreason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_obsoletedetailedreason(const std::string& value);
  std::string* _internal_mutable_obsoletedetailedreason();
  public:

  // optional string uniqueId = 3;
  bool has_uniqueid() const;
  private:
  bool _internal_has_uniqueid() const;
  public:
  void clear_uniqueid();
  const std::string& uniqueid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uniqueid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uniqueid();
  PROTOBUF_NODISCARD std::string* release_uniqueid();
  void set_allocated_uniqueid(std::string* uniqueid);
  private:
  const std::string& _internal_uniqueid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uniqueid(const std::string& value);
  std::string* _internal_mutable_uniqueid();
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.document.OBSOLETE_Reason)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr briefreason_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr obsoletedetailedreason_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uniqueid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fdocument_2eproto;
};
// -------------------------------------------------------------------

class VoucherInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.document.VoucherInfo) */ {
 public:
  inline VoucherInfo() : VoucherInfo(nullptr) {}
  ~VoucherInfo() override;
  explicit PROTOBUF_CONSTEXPR VoucherInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VoucherInfo(const VoucherInfo& from);
  VoucherInfo(VoucherInfo&& from) noexcept
    : VoucherInfo() {
    *this = ::std::move(from);
  }

  inline VoucherInfo& operator=(const VoucherInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline VoucherInfo& operator=(VoucherInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VoucherInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const VoucherInfo* internal_default_instance() {
    return reinterpret_cast<const VoucherInfo*>(
               &_VoucherInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(VoucherInfo& a, VoucherInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(VoucherInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VoucherInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VoucherInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VoucherInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VoucherInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VoucherInfo& from) {
    VoucherInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VoucherInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.document.VoucherInfo";
  }
  protected:
  explicit VoucherInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOfferFieldNumber = 2,
    kDocFieldNumber = 1,
  };
  // repeated .playapi.proto.finsky.Offer offer = 2;
  int offer_size() const;
  private:
  int _internal_offer_size() const;
  public:
  void clear_offer();
  ::playapi::proto::finsky::Offer* mutable_offer(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Offer >*
      mutable_offer();
  private:
  const ::playapi::proto::finsky::Offer& _internal_offer(int index) const;
  ::playapi::proto::finsky::Offer* _internal_add_offer();
  public:
  const ::playapi::proto::finsky::Offer& offer(int index) const;
  ::playapi::proto::finsky::Offer* add_offer();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Offer >&
      offer() const;

  // optional .playapi.proto.finsky.document.DocV2 doc = 1;
  bool has_doc() const;
  private:
  bool _internal_has_doc() const;
  public:
  void clear_doc();
  const ::playapi::proto::finsky::document::DocV2& doc() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::DocV2* release_doc();
  ::playapi::proto::finsky::document::DocV2* mutable_doc();
  void set_allocated_doc(::playapi::proto::finsky::document::DocV2* doc);
  private:
  const ::playapi::proto::finsky::document::DocV2& _internal_doc() const;
  ::playapi::proto::finsky::document::DocV2* _internal_mutable_doc();
  public:
  void unsafe_arena_set_allocated_doc(
      ::playapi::proto::finsky::document::DocV2* doc);
  ::playapi::proto::finsky::document::DocV2* unsafe_arena_release_doc();

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.document.VoucherInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Offer > offer_;
    ::playapi::proto::finsky::document::DocV2* doc_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fdocument_2eproto;
};
// -------------------------------------------------------------------

class VideoAnnotations final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.document.VideoAnnotations) */ {
 public:
  inline VideoAnnotations() : VideoAnnotations(nullptr) {}
  ~VideoAnnotations() override;
  explicit PROTOBUF_CONSTEXPR VideoAnnotations(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VideoAnnotations(const VideoAnnotations& from);
  VideoAnnotations(VideoAnnotations&& from) noexcept
    : VideoAnnotations() {
    *this = ::std::move(from);
  }

  inline VideoAnnotations& operator=(const VideoAnnotations& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoAnnotations& operator=(VideoAnnotations&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VideoAnnotations& default_instance() {
    return *internal_default_instance();
  }
  static inline const VideoAnnotations* internal_default_instance() {
    return reinterpret_cast<const VideoAnnotations*>(
               &_VideoAnnotations_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(VideoAnnotations& a, VideoAnnotations& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoAnnotations* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoAnnotations* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VideoAnnotations* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VideoAnnotations>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VideoAnnotations& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VideoAnnotations& from) {
    VideoAnnotations::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoAnnotations* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.document.VideoAnnotations";
  }
  protected:
  explicit VideoAnnotations(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBundleDocidFieldNumber = 5,
    kBundleContentListUrlFieldNumber = 2,
    kExtrasContentListUrlFieldNumber = 3,
    kAlsoAvailableInListUrlFieldNumber = 4,
    kBundleFieldNumber = 1,
  };
  // repeated .playapi.proto.finsky.Docid bundleDocid = 5;
  int bundledocid_size() const;
  private:
  int _internal_bundledocid_size() const;
  public:
  void clear_bundledocid();
  ::playapi::proto::finsky::Docid* mutable_bundledocid(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Docid >*
      mutable_bundledocid();
  private:
  const ::playapi::proto::finsky::Docid& _internal_bundledocid(int index) const;
  ::playapi::proto::finsky::Docid* _internal_add_bundledocid();
  public:
  const ::playapi::proto::finsky::Docid& bundledocid(int index) const;
  ::playapi::proto::finsky::Docid* add_bundledocid();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Docid >&
      bundledocid() const;

  // optional string bundleContentListUrl = 2;
  bool has_bundlecontentlisturl() const;
  private:
  bool _internal_has_bundlecontentlisturl() const;
  public:
  void clear_bundlecontentlisturl();
  const std::string& bundlecontentlisturl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bundlecontentlisturl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bundlecontentlisturl();
  PROTOBUF_NODISCARD std::string* release_bundlecontentlisturl();
  void set_allocated_bundlecontentlisturl(std::string* bundlecontentlisturl);
  private:
  const std::string& _internal_bundlecontentlisturl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bundlecontentlisturl(const std::string& value);
  std::string* _internal_mutable_bundlecontentlisturl();
  public:

  // optional string extrasContentListUrl = 3;
  bool has_extrascontentlisturl() const;
  private:
  bool _internal_has_extrascontentlisturl() const;
  public:
  void clear_extrascontentlisturl();
  const std::string& extrascontentlisturl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_extrascontentlisturl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_extrascontentlisturl();
  PROTOBUF_NODISCARD std::string* release_extrascontentlisturl();
  void set_allocated_extrascontentlisturl(std::string* extrascontentlisturl);
  private:
  const std::string& _internal_extrascontentlisturl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_extrascontentlisturl(const std::string& value);
  std::string* _internal_mutable_extrascontentlisturl();
  public:

  // optional string alsoAvailableInListUrl = 4;
  bool has_alsoavailableinlisturl() const;
  private:
  bool _internal_has_alsoavailableinlisturl() const;
  public:
  void clear_alsoavailableinlisturl();
  const std::string& alsoavailableinlisturl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_alsoavailableinlisturl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_alsoavailableinlisturl();
  PROTOBUF_NODISCARD std::string* release_alsoavailableinlisturl();
  void set_allocated_alsoavailableinlisturl(std::string* alsoavailableinlisturl);
  private:
  const std::string& _internal_alsoavailableinlisturl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_alsoavailableinlisturl(const std::string& value);
  std::string* _internal_mutable_alsoavailableinlisturl();
  public:

  // optional bool bundle = 1;
  bool has_bundle() const;
  private:
  bool _internal_has_bundle() const;
  public:
  void clear_bundle();
  bool bundle() const;
  void set_bundle(bool value);
  private:
  bool _internal_bundle() const;
  void _internal_set_bundle(bool value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.document.VideoAnnotations)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Docid > bundledocid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bundlecontentlisturl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extrascontentlisturl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr alsoavailableinlisturl_;
    bool bundle_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fdocument_2eproto;
};
// -------------------------------------------------------------------

class MySubscriptionDetails final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.document.MySubscriptionDetails) */ {
 public:
  inline MySubscriptionDetails() : MySubscriptionDetails(nullptr) {}
  ~MySubscriptionDetails() override;
  explicit PROTOBUF_CONSTEXPR MySubscriptionDetails(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MySubscriptionDetails(const MySubscriptionDetails& from);
  MySubscriptionDetails(MySubscriptionDetails&& from) noexcept
    : MySubscriptionDetails() {
    *this = ::std::move(from);
  }

  inline MySubscriptionDetails& operator=(const MySubscriptionDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline MySubscriptionDetails& operator=(MySubscriptionDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MySubscriptionDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const MySubscriptionDetails* internal_default_instance() {
    return reinterpret_cast<const MySubscriptionDetails*>(
               &_MySubscriptionDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(MySubscriptionDetails& a, MySubscriptionDetails& b) {
    a.Swap(&b);
  }
  inline void Swap(MySubscriptionDetails* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MySubscriptionDetails* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MySubscriptionDetails* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MySubscriptionDetails>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MySubscriptionDetails& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MySubscriptionDetails& from) {
    MySubscriptionDetails::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MySubscriptionDetails* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.document.MySubscriptionDetails";
  }
  protected:
  explicit MySubscriptionDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubscriptionStatusHtmlFieldNumber = 1,
    kTitleFieldNumber = 2,
    kTitleBylineHtmlFieldNumber = 3,
    kFormattedPriceFieldNumber = 4,
    kPriceBylineHtmlFieldNumber = 5,
    kPaymentDeclinedLearnMoreLinkFieldNumber = 7,
    kTitleBylineIconFieldNumber = 9,
    kCancelSubscriptionFieldNumber = 6,
    kInTrialPeriodFieldNumber = 8,
  };
  // optional string subscriptionStatusHtml = 1;
  bool has_subscriptionstatushtml() const;
  private:
  bool _internal_has_subscriptionstatushtml() const;
  public:
  void clear_subscriptionstatushtml();
  const std::string& subscriptionstatushtml() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subscriptionstatushtml(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subscriptionstatushtml();
  PROTOBUF_NODISCARD std::string* release_subscriptionstatushtml();
  void set_allocated_subscriptionstatushtml(std::string* subscriptionstatushtml);
  private:
  const std::string& _internal_subscriptionstatushtml() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subscriptionstatushtml(const std::string& value);
  std::string* _internal_mutable_subscriptionstatushtml();
  public:

  // optional string title = 2;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // optional string titleBylineHtml = 3;
  bool has_titlebylinehtml() const;
  private:
  bool _internal_has_titlebylinehtml() const;
  public:
  void clear_titlebylinehtml();
  const std::string& titlebylinehtml() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_titlebylinehtml(ArgT0&& arg0, ArgT... args);
  std::string* mutable_titlebylinehtml();
  PROTOBUF_NODISCARD std::string* release_titlebylinehtml();
  void set_allocated_titlebylinehtml(std::string* titlebylinehtml);
  private:
  const std::string& _internal_titlebylinehtml() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_titlebylinehtml(const std::string& value);
  std::string* _internal_mutable_titlebylinehtml();
  public:

  // optional string formattedPrice = 4;
  bool has_formattedprice() const;
  private:
  bool _internal_has_formattedprice() const;
  public:
  void clear_formattedprice();
  const std::string& formattedprice() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_formattedprice(ArgT0&& arg0, ArgT... args);
  std::string* mutable_formattedprice();
  PROTOBUF_NODISCARD std::string* release_formattedprice();
  void set_allocated_formattedprice(std::string* formattedprice);
  private:
  const std::string& _internal_formattedprice() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_formattedprice(const std::string& value);
  std::string* _internal_mutable_formattedprice();
  public:

  // optional string priceBylineHtml = 5;
  bool has_pricebylinehtml() const;
  private:
  bool _internal_has_pricebylinehtml() const;
  public:
  void clear_pricebylinehtml();
  const std::string& pricebylinehtml() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pricebylinehtml(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pricebylinehtml();
  PROTOBUF_NODISCARD std::string* release_pricebylinehtml();
  void set_allocated_pricebylinehtml(std::string* pricebylinehtml);
  private:
  const std::string& _internal_pricebylinehtml() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pricebylinehtml(const std::string& value);
  std::string* _internal_mutable_pricebylinehtml();
  public:

  // optional .playapi.proto.finsky.link.Link paymentDeclinedLearnMoreLink = 7;
  bool has_paymentdeclinedlearnmorelink() const;
  private:
  bool _internal_has_paymentdeclinedlearnmorelink() const;
  public:
  void clear_paymentdeclinedlearnmorelink();
  const ::playapi::proto::finsky::link::Link& paymentdeclinedlearnmorelink() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::link::Link* release_paymentdeclinedlearnmorelink();
  ::playapi::proto::finsky::link::Link* mutable_paymentdeclinedlearnmorelink();
  void set_allocated_paymentdeclinedlearnmorelink(::playapi::proto::finsky::link::Link* paymentdeclinedlearnmorelink);
  private:
  const ::playapi::proto::finsky::link::Link& _internal_paymentdeclinedlearnmorelink() const;
  ::playapi::proto::finsky::link::Link* _internal_mutable_paymentdeclinedlearnmorelink();
  public:
  void unsafe_arena_set_allocated_paymentdeclinedlearnmorelink(
      ::playapi::proto::finsky::link::Link* paymentdeclinedlearnmorelink);
  ::playapi::proto::finsky::link::Link* unsafe_arena_release_paymentdeclinedlearnmorelink();

  // optional .playapi.proto.finsky.Image titleBylineIcon = 9;
  bool has_titlebylineicon() const;
  private:
  bool _internal_has_titlebylineicon() const;
  public:
  void clear_titlebylineicon();
  const ::playapi::proto::finsky::Image& titlebylineicon() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::Image* release_titlebylineicon();
  ::playapi::proto::finsky::Image* mutable_titlebylineicon();
  void set_allocated_titlebylineicon(::playapi::proto::finsky::Image* titlebylineicon);
  private:
  const ::playapi::proto::finsky::Image& _internal_titlebylineicon() const;
  ::playapi::proto::finsky::Image* _internal_mutable_titlebylineicon();
  public:
  void unsafe_arena_set_allocated_titlebylineicon(
      ::playapi::proto::finsky::Image* titlebylineicon);
  ::playapi::proto::finsky::Image* unsafe_arena_release_titlebylineicon();

  // optional bool cancelSubscription = 6;
  bool has_cancelsubscription() const;
  private:
  bool _internal_has_cancelsubscription() const;
  public:
  void clear_cancelsubscription();
  bool cancelsubscription() const;
  void set_cancelsubscription(bool value);
  private:
  bool _internal_cancelsubscription() const;
  void _internal_set_cancelsubscription(bool value);
  public:

  // optional bool inTrialPeriod = 8;
  bool has_intrialperiod() const;
  private:
  bool _internal_has_intrialperiod() const;
  public:
  void clear_intrialperiod();
  bool intrialperiod() const;
  void set_intrialperiod(bool value);
  private:
  bool _internal_intrialperiod() const;
  void _internal_set_intrialperiod(bool value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.document.MySubscriptionDetails)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subscriptionstatushtml_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr titlebylinehtml_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr formattedprice_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pricebylinehtml_;
    ::playapi::proto::finsky::link::Link* paymentdeclinedlearnmorelink_;
    ::playapi::proto::finsky::Image* titlebylineicon_;
    bool cancelsubscription_;
    bool intrialperiod_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fdocument_2eproto;
};
// -------------------------------------------------------------------

class MyRewardDetails final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.document.MyRewardDetails) */ {
 public:
  inline MyRewardDetails() : MyRewardDetails(nullptr) {}
  ~MyRewardDetails() override;
  explicit PROTOBUF_CONSTEXPR MyRewardDetails(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MyRewardDetails(const MyRewardDetails& from);
  MyRewardDetails(MyRewardDetails&& from) noexcept
    : MyRewardDetails() {
    *this = ::std::move(from);
  }

  inline MyRewardDetails& operator=(const MyRewardDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline MyRewardDetails& operator=(MyRewardDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MyRewardDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const MyRewardDetails* internal_default_instance() {
    return reinterpret_cast<const MyRewardDetails*>(
               &_MyRewardDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(MyRewardDetails& a, MyRewardDetails& b) {
    a.Swap(&b);
  }
  inline void Swap(MyRewardDetails* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MyRewardDetails* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MyRewardDetails* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MyRewardDetails>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MyRewardDetails& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MyRewardDetails& from) {
    MyRewardDetails::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MyRewardDetails* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.document.MyRewardDetails";
  }
  protected:
  explicit MyRewardDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExpirationDescriptionFieldNumber = 2,
    kButtonLabelFieldNumber = 3,
    kLinkActionFieldNumber = 4,
    kExpirationTimeMillisFieldNumber = 1,
  };
  // optional string expirationDescription = 2;
  bool has_expirationdescription() const;
  private:
  bool _internal_has_expirationdescription() const;
  public:
  void clear_expirationdescription();
  const std::string& expirationdescription() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_expirationdescription(ArgT0&& arg0, ArgT... args);
  std::string* mutable_expirationdescription();
  PROTOBUF_NODISCARD std::string* release_expirationdescription();
  void set_allocated_expirationdescription(std::string* expirationdescription);
  private:
  const std::string& _internal_expirationdescription() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_expirationdescription(const std::string& value);
  std::string* _internal_mutable_expirationdescription();
  public:

  // optional string buttonLabel = 3;
  bool has_buttonlabel() const;
  private:
  bool _internal_has_buttonlabel() const;
  public:
  void clear_buttonlabel();
  const std::string& buttonlabel() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_buttonlabel(ArgT0&& arg0, ArgT... args);
  std::string* mutable_buttonlabel();
  PROTOBUF_NODISCARD std::string* release_buttonlabel();
  void set_allocated_buttonlabel(std::string* buttonlabel);
  private:
  const std::string& _internal_buttonlabel() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_buttonlabel(const std::string& value);
  std::string* _internal_mutable_buttonlabel();
  public:

  // optional .playapi.proto.finsky.link.Link linkAction = 4;
  bool has_linkaction() const;
  private:
  bool _internal_has_linkaction() const;
  public:
  void clear_linkaction();
  const ::playapi::proto::finsky::link::Link& linkaction() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::link::Link* release_linkaction();
  ::playapi::proto::finsky::link::Link* mutable_linkaction();
  void set_allocated_linkaction(::playapi::proto::finsky::link::Link* linkaction);
  private:
  const ::playapi::proto::finsky::link::Link& _internal_linkaction() const;
  ::playapi::proto::finsky::link::Link* _internal_mutable_linkaction();
  public:
  void unsafe_arena_set_allocated_linkaction(
      ::playapi::proto::finsky::link::Link* linkaction);
  ::playapi::proto::finsky::link::Link* unsafe_arena_release_linkaction();

  // optional int64 expirationTimeMillis = 1;
  bool has_expirationtimemillis() const;
  private:
  bool _internal_has_expirationtimemillis() const;
  public:
  void clear_expirationtimemillis();
  int64_t expirationtimemillis() const;
  void set_expirationtimemillis(int64_t value);
  private:
  int64_t _internal_expirationtimemillis() const;
  void _internal_set_expirationtimemillis(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.document.MyRewardDetails)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr expirationdescription_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr buttonlabel_;
    ::playapi::proto::finsky::link::Link* linkaction_;
    int64_t expirationtimemillis_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fdocument_2eproto;
};
// -------------------------------------------------------------------

class SelectedChild final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.document.SelectedChild) */ {
 public:
  inline SelectedChild() : SelectedChild(nullptr) {}
  ~SelectedChild() override;
  explicit PROTOBUF_CONSTEXPR SelectedChild(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SelectedChild(const SelectedChild& from);
  SelectedChild(SelectedChild&& from) noexcept
    : SelectedChild() {
    *this = ::std::move(from);
  }

  inline SelectedChild& operator=(const SelectedChild& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelectedChild& operator=(SelectedChild&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SelectedChild& default_instance() {
    return *internal_default_instance();
  }
  static inline const SelectedChild* internal_default_instance() {
    return reinterpret_cast<const SelectedChild*>(
               &_SelectedChild_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(SelectedChild& a, SelectedChild& b) {
    a.Swap(&b);
  }
  inline void Swap(SelectedChild* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelectedChild* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SelectedChild* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SelectedChild>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SelectedChild& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SelectedChild& from) {
    SelectedChild::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SelectedChild* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.document.SelectedChild";
  }
  protected:
  explicit SelectedChild(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDocidFieldNumber = 1,
    kSelectedChildFieldNumber = 2,
  };
  // optional string docid = 1;
  bool has_docid() const;
  private:
  bool _internal_has_docid() const;
  public:
  void clear_docid();
  const std::string& docid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_docid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_docid();
  PROTOBUF_NODISCARD std::string* release_docid();
  void set_allocated_docid(std::string* docid);
  private:
  const std::string& _internal_docid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_docid(const std::string& value);
  std::string* _internal_mutable_docid();
  public:

  // optional .playapi.proto.finsky.document.SelectedChild selectedChild = 2;
  bool has_selectedchild() const;
  private:
  bool _internal_has_selectedchild() const;
  public:
  void clear_selectedchild();
  const ::playapi::proto::finsky::document::SelectedChild& selectedchild() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::SelectedChild* release_selectedchild();
  ::playapi::proto::finsky::document::SelectedChild* mutable_selectedchild();
  void set_allocated_selectedchild(::playapi::proto::finsky::document::SelectedChild* selectedchild);
  private:
  const ::playapi::proto::finsky::document::SelectedChild& _internal_selectedchild() const;
  ::playapi::proto::finsky::document::SelectedChild* _internal_mutable_selectedchild();
  public:
  void unsafe_arena_set_allocated_selectedchild(
      ::playapi::proto::finsky::document::SelectedChild* selectedchild);
  ::playapi::proto::finsky::document::SelectedChild* unsafe_arena_release_selectedchild();

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.document.SelectedChild)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr docid_;
    ::playapi::proto::finsky::document::SelectedChild* selectedchild_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fdocument_2eproto;
};
// -------------------------------------------------------------------

class Snippet final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.document.Snippet) */ {
 public:
  inline Snippet() : Snippet(nullptr) {}
  ~Snippet() override;
  explicit PROTOBUF_CONSTEXPR Snippet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Snippet(const Snippet& from);
  Snippet(Snippet&& from) noexcept
    : Snippet() {
    *this = ::std::move(from);
  }

  inline Snippet& operator=(const Snippet& from) {
    CopyFrom(from);
    return *this;
  }
  inline Snippet& operator=(Snippet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Snippet& default_instance() {
    return *internal_default_instance();
  }
  static inline const Snippet* internal_default_instance() {
    return reinterpret_cast<const Snippet*>(
               &_Snippet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Snippet& a, Snippet& b) {
    a.Swap(&b);
  }
  inline void Swap(Snippet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Snippet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Snippet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Snippet>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Snippet& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Snippet& from) {
    Snippet::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Snippet* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.document.Snippet";
  }
  protected:
  explicit Snippet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSnippetHtmlFieldNumber = 1,
  };
  // optional string snippetHtml = 1;
  bool has_snippethtml() const;
  private:
  bool _internal_has_snippethtml() const;
  public:
  void clear_snippethtml();
  const std::string& snippethtml() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_snippethtml(ArgT0&& arg0, ArgT... args);
  std::string* mutable_snippethtml();
  PROTOBUF_NODISCARD std::string* release_snippethtml();
  void set_allocated_snippethtml(std::string* snippethtml);
  private:
  const std::string& _internal_snippethtml() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_snippethtml(const std::string& value);
  std::string* _internal_mutable_snippethtml();
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.document.Snippet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr snippethtml_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fdocument_2eproto;
};
// -------------------------------------------------------------------

class ProductDetails final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.document.ProductDetails) */ {
 public:
  inline ProductDetails() : ProductDetails(nullptr) {}
  ~ProductDetails() override;
  explicit PROTOBUF_CONSTEXPR ProductDetails(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProductDetails(const ProductDetails& from);
  ProductDetails(ProductDetails&& from) noexcept
    : ProductDetails() {
    *this = ::std::move(from);
  }

  inline ProductDetails& operator=(const ProductDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProductDetails& operator=(ProductDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProductDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProductDetails* internal_default_instance() {
    return reinterpret_cast<const ProductDetails*>(
               &_ProductDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ProductDetails& a, ProductDetails& b) {
    a.Swap(&b);
  }
  inline void Swap(ProductDetails* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProductDetails* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProductDetails* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProductDetails>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProductDetails& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProductDetails& from) {
    ProductDetails::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProductDetails* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.document.ProductDetails";
  }
  protected:
  explicit ProductDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSectionFieldNumber = 2,
    kTitleFieldNumber = 1,
  };
  // repeated .playapi.proto.finsky.document.ProductDetailsSection section = 2;
  int section_size() const;
  private:
  int _internal_section_size() const;
  public:
  void clear_section();
  ::playapi::proto::finsky::document::ProductDetailsSection* mutable_section(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::ProductDetailsSection >*
      mutable_section();
  private:
  const ::playapi::proto::finsky::document::ProductDetailsSection& _internal_section(int index) const;
  ::playapi::proto::finsky::document::ProductDetailsSection* _internal_add_section();
  public:
  const ::playapi::proto::finsky::document::ProductDetailsSection& section(int index) const;
  ::playapi::proto::finsky::document::ProductDetailsSection* add_section();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::ProductDetailsSection >&
      section() const;

  // optional string title = 1;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.document.ProductDetails)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::ProductDetailsSection > section_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fdocument_2eproto;
};
// -------------------------------------------------------------------

class ProductDetailsSection final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.document.ProductDetailsSection) */ {
 public:
  inline ProductDetailsSection() : ProductDetailsSection(nullptr) {}
  ~ProductDetailsSection() override;
  explicit PROTOBUF_CONSTEXPR ProductDetailsSection(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProductDetailsSection(const ProductDetailsSection& from);
  ProductDetailsSection(ProductDetailsSection&& from) noexcept
    : ProductDetailsSection() {
    *this = ::std::move(from);
  }

  inline ProductDetailsSection& operator=(const ProductDetailsSection& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProductDetailsSection& operator=(ProductDetailsSection&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProductDetailsSection& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProductDetailsSection* internal_default_instance() {
    return reinterpret_cast<const ProductDetailsSection*>(
               &_ProductDetailsSection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ProductDetailsSection& a, ProductDetailsSection& b) {
    a.Swap(&b);
  }
  inline void Swap(ProductDetailsSection* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProductDetailsSection* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProductDetailsSection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProductDetailsSection>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProductDetailsSection& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProductDetailsSection& from) {
    ProductDetailsSection::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProductDetailsSection* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.document.ProductDetailsSection";
  }
  protected:
  explicit ProductDetailsSection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDescriptionFieldNumber = 3,
    kTitleFieldNumber = 1,
  };
  // repeated .playapi.proto.finsky.document.ProductDetailsDescription description = 3;
  int description_size() const;
  private:
  int _internal_description_size() const;
  public:
  void clear_description();
  ::playapi::proto::finsky::document::ProductDetailsDescription* mutable_description(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::ProductDetailsDescription >*
      mutable_description();
  private:
  const ::playapi::proto::finsky::document::ProductDetailsDescription& _internal_description(int index) const;
  ::playapi::proto::finsky::document::ProductDetailsDescription* _internal_add_description();
  public:
  const ::playapi::proto::finsky::document::ProductDetailsDescription& description(int index) const;
  ::playapi::proto::finsky::document::ProductDetailsDescription* add_description();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::ProductDetailsDescription >&
      description() const;

  // optional string title = 1;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.document.ProductDetailsSection)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::ProductDetailsDescription > description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fdocument_2eproto;
};
// -------------------------------------------------------------------

class ProductDetailsDescription final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.document.ProductDetailsDescription) */ {
 public:
  inline ProductDetailsDescription() : ProductDetailsDescription(nullptr) {}
  ~ProductDetailsDescription() override;
  explicit PROTOBUF_CONSTEXPR ProductDetailsDescription(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProductDetailsDescription(const ProductDetailsDescription& from);
  ProductDetailsDescription(ProductDetailsDescription&& from) noexcept
    : ProductDetailsDescription() {
    *this = ::std::move(from);
  }

  inline ProductDetailsDescription& operator=(const ProductDetailsDescription& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProductDetailsDescription& operator=(ProductDetailsDescription&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProductDetailsDescription& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProductDetailsDescription* internal_default_instance() {
    return reinterpret_cast<const ProductDetailsDescription*>(
               &_ProductDetailsDescription_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ProductDetailsDescription& a, ProductDetailsDescription& b) {
    a.Swap(&b);
  }
  inline void Swap(ProductDetailsDescription* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProductDetailsDescription* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProductDetailsDescription* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProductDetailsDescription>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProductDetailsDescription& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProductDetailsDescription& from) {
    ProductDetailsDescription::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProductDetailsDescription* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.document.ProductDetailsDescription";
  }
  protected:
  explicit ProductDetailsDescription(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDescriptionFieldNumber = 2,
    kImageFieldNumber = 1,
  };
  // optional string description = 2;
  bool has_description() const;
  private:
  bool _internal_has_description() const;
  public:
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // optional .playapi.proto.finsky.Image image = 1;
  bool has_image() const;
  private:
  bool _internal_has_image() const;
  public:
  void clear_image();
  const ::playapi::proto::finsky::Image& image() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::Image* release_image();
  ::playapi::proto::finsky::Image* mutable_image();
  void set_allocated_image(::playapi::proto::finsky::Image* image);
  private:
  const ::playapi::proto::finsky::Image& _internal_image() const;
  ::playapi::proto::finsky::Image* _internal_mutable_image();
  public:
  void unsafe_arena_set_allocated_image(
      ::playapi::proto::finsky::Image* image);
  ::playapi::proto::finsky::Image* unsafe_arena_release_image();

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.document.ProductDetailsDescription)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::playapi::proto::finsky::Image* image_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fdocument_2eproto;
};
// -------------------------------------------------------------------

class PromotedDoc final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.document.PromotedDoc) */ {
 public:
  inline PromotedDoc() : PromotedDoc(nullptr) {}
  ~PromotedDoc() override;
  explicit PROTOBUF_CONSTEXPR PromotedDoc(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PromotedDoc(const PromotedDoc& from);
  PromotedDoc(PromotedDoc&& from) noexcept
    : PromotedDoc() {
    *this = ::std::move(from);
  }

  inline PromotedDoc& operator=(const PromotedDoc& from) {
    CopyFrom(from);
    return *this;
  }
  inline PromotedDoc& operator=(PromotedDoc&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PromotedDoc& default_instance() {
    return *internal_default_instance();
  }
  static inline const PromotedDoc* internal_default_instance() {
    return reinterpret_cast<const PromotedDoc*>(
               &_PromotedDoc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(PromotedDoc& a, PromotedDoc& b) {
    a.Swap(&b);
  }
  inline void Swap(PromotedDoc* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PromotedDoc* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PromotedDoc* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PromotedDoc>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PromotedDoc& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PromotedDoc& from) {
    PromotedDoc::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PromotedDoc* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.document.PromotedDoc";
  }
  protected:
  explicit PromotedDoc(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImageFieldNumber = 3,
    kTitleFieldNumber = 1,
    kSubtitleFieldNumber = 2,
    kDescriptionHtmlFieldNumber = 4,
    kDetailsUrlFieldNumber = 5,
  };
  // repeated .playapi.proto.finsky.Image image = 3;
  int image_size() const;
  private:
  int _internal_image_size() const;
  public:
  void clear_image();
  ::playapi::proto::finsky::Image* mutable_image(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Image >*
      mutable_image();
  private:
  const ::playapi::proto::finsky::Image& _internal_image(int index) const;
  ::playapi::proto::finsky::Image* _internal_add_image();
  public:
  const ::playapi::proto::finsky::Image& image(int index) const;
  ::playapi::proto::finsky::Image* add_image();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Image >&
      image() const;

  // optional string title = 1;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // optional string subtitle = 2;
  bool has_subtitle() const;
  private:
  bool _internal_has_subtitle() const;
  public:
  void clear_subtitle();
  const std::string& subtitle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subtitle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subtitle();
  PROTOBUF_NODISCARD std::string* release_subtitle();
  void set_allocated_subtitle(std::string* subtitle);
  private:
  const std::string& _internal_subtitle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subtitle(const std::string& value);
  std::string* _internal_mutable_subtitle();
  public:

  // optional string descriptionHtml = 4;
  bool has_descriptionhtml() const;
  private:
  bool _internal_has_descriptionhtml() const;
  public:
  void clear_descriptionhtml();
  const std::string& descriptionhtml() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_descriptionhtml(ArgT0&& arg0, ArgT... args);
  std::string* mutable_descriptionhtml();
  PROTOBUF_NODISCARD std::string* release_descriptionhtml();
  void set_allocated_descriptionhtml(std::string* descriptionhtml);
  private:
  const std::string& _internal_descriptionhtml() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_descriptionhtml(const std::string& value);
  std::string* _internal_mutable_descriptionhtml();
  public:

  // optional string detailsUrl = 5;
  bool has_detailsurl() const;
  private:
  bool _internal_has_detailsurl() const;
  public:
  void clear_detailsurl();
  const std::string& detailsurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_detailsurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_detailsurl();
  PROTOBUF_NODISCARD std::string* release_detailsurl();
  void set_allocated_detailsurl(std::string* detailsurl);
  private:
  const std::string& _internal_detailsurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_detailsurl(const std::string& value);
  std::string* _internal_mutable_detailsurl();
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.document.PromotedDoc)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Image > image_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subtitle_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr descriptionhtml_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr detailsurl_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fdocument_2eproto;
};
// -------------------------------------------------------------------

class DocumentDetails final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.document.DocumentDetails) */ {
 public:
  inline DocumentDetails() : DocumentDetails(nullptr) {}
  ~DocumentDetails() override;
  explicit PROTOBUF_CONSTEXPR DocumentDetails(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DocumentDetails(const DocumentDetails& from);
  DocumentDetails(DocumentDetails&& from) noexcept
    : DocumentDetails() {
    *this = ::std::move(from);
  }

  inline DocumentDetails& operator=(const DocumentDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline DocumentDetails& operator=(DocumentDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DocumentDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const DocumentDetails* internal_default_instance() {
    return reinterpret_cast<const DocumentDetails*>(
               &_DocumentDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(DocumentDetails& a, DocumentDetails& b) {
    a.Swap(&b);
  }
  inline void Swap(DocumentDetails* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DocumentDetails* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DocumentDetails* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DocumentDetails>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DocumentDetails& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DocumentDetails& from) {
    DocumentDetails::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DocumentDetails* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.document.DocumentDetails";
  }
  protected:
  explicit DocumentDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppDetailsFieldNumber = 1,
    kAlbumDetailsFieldNumber = 2,
    kArtistDetailsFieldNumber = 3,
    kSongDetailsFieldNumber = 4,
    kBookDetailsFieldNumber = 5,
    kVideoDetailsFieldNumber = 6,
    kSubscriptionDetailsFieldNumber = 7,
    kMagazineDetailsFieldNumber = 8,
    kTvShowDetailsFieldNumber = 9,
    kTvSeasonDetailsFieldNumber = 10,
    kTvEpisodeDetailsFieldNumber = 11,
    kPersonDetailsFieldNumber = 12,
    kTalentDetailsFieldNumber = 13,
    kDeveloperDetailsFieldNumber = 14,
    kBookSeriesDetailsFieldNumber = 15,
  };
  // optional .playapi.proto.finsky.document.AppDetails appDetails = 1;
  bool has_appdetails() const;
  private:
  bool _internal_has_appdetails() const;
  public:
  void clear_appdetails();
  const ::playapi::proto::finsky::document::AppDetails& appdetails() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::AppDetails* release_appdetails();
  ::playapi::proto::finsky::document::AppDetails* mutable_appdetails();
  void set_allocated_appdetails(::playapi::proto::finsky::document::AppDetails* appdetails);
  private:
  const ::playapi::proto::finsky::document::AppDetails& _internal_appdetails() const;
  ::playapi::proto::finsky::document::AppDetails* _internal_mutable_appdetails();
  public:
  void unsafe_arena_set_allocated_appdetails(
      ::playapi::proto::finsky::document::AppDetails* appdetails);
  ::playapi::proto::finsky::document::AppDetails* unsafe_arena_release_appdetails();

  // optional .playapi.proto.finsky.document.AlbumDetails albumDetails = 2;
  bool has_albumdetails() const;
  private:
  bool _internal_has_albumdetails() const;
  public:
  void clear_albumdetails();
  const ::playapi::proto::finsky::document::AlbumDetails& albumdetails() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::AlbumDetails* release_albumdetails();
  ::playapi::proto::finsky::document::AlbumDetails* mutable_albumdetails();
  void set_allocated_albumdetails(::playapi::proto::finsky::document::AlbumDetails* albumdetails);
  private:
  const ::playapi::proto::finsky::document::AlbumDetails& _internal_albumdetails() const;
  ::playapi::proto::finsky::document::AlbumDetails* _internal_mutable_albumdetails();
  public:
  void unsafe_arena_set_allocated_albumdetails(
      ::playapi::proto::finsky::document::AlbumDetails* albumdetails);
  ::playapi::proto::finsky::document::AlbumDetails* unsafe_arena_release_albumdetails();

  // optional .playapi.proto.finsky.document.ArtistDetails artistDetails = 3;
  bool has_artistdetails() const;
  private:
  bool _internal_has_artistdetails() const;
  public:
  void clear_artistdetails();
  const ::playapi::proto::finsky::document::ArtistDetails& artistdetails() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::ArtistDetails* release_artistdetails();
  ::playapi::proto::finsky::document::ArtistDetails* mutable_artistdetails();
  void set_allocated_artistdetails(::playapi::proto::finsky::document::ArtistDetails* artistdetails);
  private:
  const ::playapi::proto::finsky::document::ArtistDetails& _internal_artistdetails() const;
  ::playapi::proto::finsky::document::ArtistDetails* _internal_mutable_artistdetails();
  public:
  void unsafe_arena_set_allocated_artistdetails(
      ::playapi::proto::finsky::document::ArtistDetails* artistdetails);
  ::playapi::proto::finsky::document::ArtistDetails* unsafe_arena_release_artistdetails();

  // optional .playapi.proto.finsky.document.SongDetails songDetails = 4;
  bool has_songdetails() const;
  private:
  bool _internal_has_songdetails() const;
  public:
  void clear_songdetails();
  const ::playapi::proto::finsky::document::SongDetails& songdetails() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::SongDetails* release_songdetails();
  ::playapi::proto::finsky::document::SongDetails* mutable_songdetails();
  void set_allocated_songdetails(::playapi::proto::finsky::document::SongDetails* songdetails);
  private:
  const ::playapi::proto::finsky::document::SongDetails& _internal_songdetails() const;
  ::playapi::proto::finsky::document::SongDetails* _internal_mutable_songdetails();
  public:
  void unsafe_arena_set_allocated_songdetails(
      ::playapi::proto::finsky::document::SongDetails* songdetails);
  ::playapi::proto::finsky::document::SongDetails* unsafe_arena_release_songdetails();

  // optional .playapi.proto.finsky.document.BookDetails bookDetails = 5;
  bool has_bookdetails() const;
  private:
  bool _internal_has_bookdetails() const;
  public:
  void clear_bookdetails();
  const ::playapi::proto::finsky::document::BookDetails& bookdetails() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::BookDetails* release_bookdetails();
  ::playapi::proto::finsky::document::BookDetails* mutable_bookdetails();
  void set_allocated_bookdetails(::playapi::proto::finsky::document::BookDetails* bookdetails);
  private:
  const ::playapi::proto::finsky::document::BookDetails& _internal_bookdetails() const;
  ::playapi::proto::finsky::document::BookDetails* _internal_mutable_bookdetails();
  public:
  void unsafe_arena_set_allocated_bookdetails(
      ::playapi::proto::finsky::document::BookDetails* bookdetails);
  ::playapi::proto::finsky::document::BookDetails* unsafe_arena_release_bookdetails();

  // optional .playapi.proto.finsky.document.VideoDetails videoDetails = 6;
  bool has_videodetails() const;
  private:
  bool _internal_has_videodetails() const;
  public:
  void clear_videodetails();
  const ::playapi::proto::finsky::document::VideoDetails& videodetails() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::VideoDetails* release_videodetails();
  ::playapi::proto::finsky::document::VideoDetails* mutable_videodetails();
  void set_allocated_videodetails(::playapi::proto::finsky::document::VideoDetails* videodetails);
  private:
  const ::playapi::proto::finsky::document::VideoDetails& _internal_videodetails() const;
  ::playapi::proto::finsky::document::VideoDetails* _internal_mutable_videodetails();
  public:
  void unsafe_arena_set_allocated_videodetails(
      ::playapi::proto::finsky::document::VideoDetails* videodetails);
  ::playapi::proto::finsky::document::VideoDetails* unsafe_arena_release_videodetails();

  // optional .playapi.proto.finsky.document.SubscriptionDetails subscriptionDetails = 7;
  bool has_subscriptiondetails() const;
  private:
  bool _internal_has_subscriptiondetails() const;
  public:
  void clear_subscriptiondetails();
  const ::playapi::proto::finsky::document::SubscriptionDetails& subscriptiondetails() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::SubscriptionDetails* release_subscriptiondetails();
  ::playapi::proto::finsky::document::SubscriptionDetails* mutable_subscriptiondetails();
  void set_allocated_subscriptiondetails(::playapi::proto::finsky::document::SubscriptionDetails* subscriptiondetails);
  private:
  const ::playapi::proto::finsky::document::SubscriptionDetails& _internal_subscriptiondetails() const;
  ::playapi::proto::finsky::document::SubscriptionDetails* _internal_mutable_subscriptiondetails();
  public:
  void unsafe_arena_set_allocated_subscriptiondetails(
      ::playapi::proto::finsky::document::SubscriptionDetails* subscriptiondetails);
  ::playapi::proto::finsky::document::SubscriptionDetails* unsafe_arena_release_subscriptiondetails();

  // optional .playapi.proto.finsky.document.MagazineDetails magazineDetails = 8;
  bool has_magazinedetails() const;
  private:
  bool _internal_has_magazinedetails() const;
  public:
  void clear_magazinedetails();
  const ::playapi::proto::finsky::document::MagazineDetails& magazinedetails() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::MagazineDetails* release_magazinedetails();
  ::playapi::proto::finsky::document::MagazineDetails* mutable_magazinedetails();
  void set_allocated_magazinedetails(::playapi::proto::finsky::document::MagazineDetails* magazinedetails);
  private:
  const ::playapi::proto::finsky::document::MagazineDetails& _internal_magazinedetails() const;
  ::playapi::proto::finsky::document::MagazineDetails* _internal_mutable_magazinedetails();
  public:
  void unsafe_arena_set_allocated_magazinedetails(
      ::playapi::proto::finsky::document::MagazineDetails* magazinedetails);
  ::playapi::proto::finsky::document::MagazineDetails* unsafe_arena_release_magazinedetails();

  // optional .playapi.proto.finsky.document.TvShowDetails tvShowDetails = 9;
  bool has_tvshowdetails() const;
  private:
  bool _internal_has_tvshowdetails() const;
  public:
  void clear_tvshowdetails();
  const ::playapi::proto::finsky::document::TvShowDetails& tvshowdetails() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::TvShowDetails* release_tvshowdetails();
  ::playapi::proto::finsky::document::TvShowDetails* mutable_tvshowdetails();
  void set_allocated_tvshowdetails(::playapi::proto::finsky::document::TvShowDetails* tvshowdetails);
  private:
  const ::playapi::proto::finsky::document::TvShowDetails& _internal_tvshowdetails() const;
  ::playapi::proto::finsky::document::TvShowDetails* _internal_mutable_tvshowdetails();
  public:
  void unsafe_arena_set_allocated_tvshowdetails(
      ::playapi::proto::finsky::document::TvShowDetails* tvshowdetails);
  ::playapi::proto::finsky::document::TvShowDetails* unsafe_arena_release_tvshowdetails();

  // optional .playapi.proto.finsky.document.TvSeasonDetails tvSeasonDetails = 10;
  bool has_tvseasondetails() const;
  private:
  bool _internal_has_tvseasondetails() const;
  public:
  void clear_tvseasondetails();
  const ::playapi::proto::finsky::document::TvSeasonDetails& tvseasondetails() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::TvSeasonDetails* release_tvseasondetails();
  ::playapi::proto::finsky::document::TvSeasonDetails* mutable_tvseasondetails();
  void set_allocated_tvseasondetails(::playapi::proto::finsky::document::TvSeasonDetails* tvseasondetails);
  private:
  const ::playapi::proto::finsky::document::TvSeasonDetails& _internal_tvseasondetails() const;
  ::playapi::proto::finsky::document::TvSeasonDetails* _internal_mutable_tvseasondetails();
  public:
  void unsafe_arena_set_allocated_tvseasondetails(
      ::playapi::proto::finsky::document::TvSeasonDetails* tvseasondetails);
  ::playapi::proto::finsky::document::TvSeasonDetails* unsafe_arena_release_tvseasondetails();

  // optional .playapi.proto.finsky.document.TvEpisodeDetails tvEpisodeDetails = 11;
  bool has_tvepisodedetails() const;
  private:
  bool _internal_has_tvepisodedetails() const;
  public:
  void clear_tvepisodedetails();
  const ::playapi::proto::finsky::document::TvEpisodeDetails& tvepisodedetails() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::TvEpisodeDetails* release_tvepisodedetails();
  ::playapi::proto::finsky::document::TvEpisodeDetails* mutable_tvepisodedetails();
  void set_allocated_tvepisodedetails(::playapi::proto::finsky::document::TvEpisodeDetails* tvepisodedetails);
  private:
  const ::playapi::proto::finsky::document::TvEpisodeDetails& _internal_tvepisodedetails() const;
  ::playapi::proto::finsky::document::TvEpisodeDetails* _internal_mutable_tvepisodedetails();
  public:
  void unsafe_arena_set_allocated_tvepisodedetails(
      ::playapi::proto::finsky::document::TvEpisodeDetails* tvepisodedetails);
  ::playapi::proto::finsky::document::TvEpisodeDetails* unsafe_arena_release_tvepisodedetails();

  // optional .playapi.proto.finsky.document.PersonDetails personDetails = 12;
  bool has_persondetails() const;
  private:
  bool _internal_has_persondetails() const;
  public:
  void clear_persondetails();
  const ::playapi::proto::finsky::document::PersonDetails& persondetails() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::PersonDetails* release_persondetails();
  ::playapi::proto::finsky::document::PersonDetails* mutable_persondetails();
  void set_allocated_persondetails(::playapi::proto::finsky::document::PersonDetails* persondetails);
  private:
  const ::playapi::proto::finsky::document::PersonDetails& _internal_persondetails() const;
  ::playapi::proto::finsky::document::PersonDetails* _internal_mutable_persondetails();
  public:
  void unsafe_arena_set_allocated_persondetails(
      ::playapi::proto::finsky::document::PersonDetails* persondetails);
  ::playapi::proto::finsky::document::PersonDetails* unsafe_arena_release_persondetails();

  // optional .playapi.proto.finsky.document.TalentDetails talentDetails = 13;
  bool has_talentdetails() const;
  private:
  bool _internal_has_talentdetails() const;
  public:
  void clear_talentdetails();
  const ::playapi::proto::finsky::document::TalentDetails& talentdetails() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::TalentDetails* release_talentdetails();
  ::playapi::proto::finsky::document::TalentDetails* mutable_talentdetails();
  void set_allocated_talentdetails(::playapi::proto::finsky::document::TalentDetails* talentdetails);
  private:
  const ::playapi::proto::finsky::document::TalentDetails& _internal_talentdetails() const;
  ::playapi::proto::finsky::document::TalentDetails* _internal_mutable_talentdetails();
  public:
  void unsafe_arena_set_allocated_talentdetails(
      ::playapi::proto::finsky::document::TalentDetails* talentdetails);
  ::playapi::proto::finsky::document::TalentDetails* unsafe_arena_release_talentdetails();

  // optional .playapi.proto.finsky.document.DeveloperDetails developerDetails = 14;
  bool has_developerdetails() const;
  private:
  bool _internal_has_developerdetails() const;
  public:
  void clear_developerdetails();
  const ::playapi::proto::finsky::document::DeveloperDetails& developerdetails() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::DeveloperDetails* release_developerdetails();
  ::playapi::proto::finsky::document::DeveloperDetails* mutable_developerdetails();
  void set_allocated_developerdetails(::playapi::proto::finsky::document::DeveloperDetails* developerdetails);
  private:
  const ::playapi::proto::finsky::document::DeveloperDetails& _internal_developerdetails() const;
  ::playapi::proto::finsky::document::DeveloperDetails* _internal_mutable_developerdetails();
  public:
  void unsafe_arena_set_allocated_developerdetails(
      ::playapi::proto::finsky::document::DeveloperDetails* developerdetails);
  ::playapi::proto::finsky::document::DeveloperDetails* unsafe_arena_release_developerdetails();

  // optional .playapi.proto.finsky.document.BookSeriesDetails bookSeriesDetails = 15;
  bool has_bookseriesdetails() const;
  private:
  bool _internal_has_bookseriesdetails() const;
  public:
  void clear_bookseriesdetails();
  const ::playapi::proto::finsky::document::BookSeriesDetails& bookseriesdetails() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::BookSeriesDetails* release_bookseriesdetails();
  ::playapi::proto::finsky::document::BookSeriesDetails* mutable_bookseriesdetails();
  void set_allocated_bookseriesdetails(::playapi::proto::finsky::document::BookSeriesDetails* bookseriesdetails);
  private:
  const ::playapi::proto::finsky::document::BookSeriesDetails& _internal_bookseriesdetails() const;
  ::playapi::proto::finsky::document::BookSeriesDetails* _internal_mutable_bookseriesdetails();
  public:
  void unsafe_arena_set_allocated_bookseriesdetails(
      ::playapi::proto::finsky::document::BookSeriesDetails* bookseriesdetails);
  ::playapi::proto::finsky::document::BookSeriesDetails* unsafe_arena_release_bookseriesdetails();

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.document.DocumentDetails)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::playapi::proto::finsky::document::AppDetails* appdetails_;
    ::playapi::proto::finsky::document::AlbumDetails* albumdetails_;
    ::playapi::proto::finsky::document::ArtistDetails* artistdetails_;
    ::playapi::proto::finsky::document::SongDetails* songdetails_;
    ::playapi::proto::finsky::document::BookDetails* bookdetails_;
    ::playapi::proto::finsky::document::VideoDetails* videodetails_;
    ::playapi::proto::finsky::document::SubscriptionDetails* subscriptiondetails_;
    ::playapi::proto::finsky::document::MagazineDetails* magazinedetails_;
    ::playapi::proto::finsky::document::TvShowDetails* tvshowdetails_;
    ::playapi::proto::finsky::document::TvSeasonDetails* tvseasondetails_;
    ::playapi::proto::finsky::document::TvEpisodeDetails* tvepisodedetails_;
    ::playapi::proto::finsky::document::PersonDetails* persondetails_;
    ::playapi::proto::finsky::document::TalentDetails* talentdetails_;
    ::playapi::proto::finsky::document::DeveloperDetails* developerdetails_;
    ::playapi::proto::finsky::document::BookSeriesDetails* bookseriesdetails_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fdocument_2eproto;
};
// -------------------------------------------------------------------

class AppDetails final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.document.AppDetails) */ {
 public:
  inline AppDetails() : AppDetails(nullptr) {}
  ~AppDetails() override;
  explicit PROTOBUF_CONSTEXPR AppDetails(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppDetails(const AppDetails& from);
  AppDetails(AppDetails&& from) noexcept
    : AppDetails() {
    *this = ::std::move(from);
  }

  inline AppDetails& operator=(const AppDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppDetails& operator=(AppDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppDetails* internal_default_instance() {
    return reinterpret_cast<const AppDetails*>(
               &_AppDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(AppDetails& a, AppDetails& b) {
    a.Swap(&b);
  }
  inline void Swap(AppDetails* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppDetails* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppDetails* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppDetails>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppDetails& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AppDetails& from) {
    AppDetails::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppDetails* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.document.AppDetails";
  }
  protected:
  explicit AppDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppCategoryFieldNumber = 7,
    kPermissionFieldNumber = 10,
    kFileFieldNumber = 17,
    kCertificateHashFieldNumber = 19,
    kCertificateSetFieldNumber = 22,
    kAutoAcquireFreeAppIfHigherVersionAvailableTagFieldNumber = 23,
    kSplitIdFieldNumber = 25,
    kDeveloperNameFieldNumber = 1,
    kVersionStringFieldNumber = 4,
    kTitleFieldNumber = 5,
    kDeveloperEmailFieldNumber = 11,
    kDeveloperWebsiteFieldNumber = 12,
    kNumDownloadsFieldNumber = 13,
    kPackageNameFieldNumber = 14,
    kRecentChangesHtmlFieldNumber = 15,
    kUploadDateFieldNumber = 16,
    kAppTypeFieldNumber = 18,
    kInstallNotesFieldNumber = 30,
    kPreregistrationPromoCodeFieldNumber = 33,
    kInstallDetailsFieldNumber = 34,
    kTestingProgramInfoFieldNumber = 35,
    kMajorVersionNumberFieldNumber = 2,
    kVersionCodeFieldNumber = 3,
    kInstallationSizeFieldNumber = 9,
    kContentRatingFieldNumber = 8,
    kVariesByAccountFieldNumber = 21,
    kDeclaresIabFieldNumber = 24,
    kGamepadRequiredFieldNumber = 26,
    kExternallyHostedFieldNumber = 27,
    kEverExternallyHostedFieldNumber = 28,
    kInstallLocationFieldNumber = 31,
    kTargetSdkVersionFieldNumber = 32,
  };
  // repeated string appCategory = 7;
  int appcategory_size() const;
  private:
  int _internal_appcategory_size() const;
  public:
  void clear_appcategory();
  const std::string& appcategory(int index) const;
  std::string* mutable_appcategory(int index);
  void set_appcategory(int index, const std::string& value);
  void set_appcategory(int index, std::string&& value);
  void set_appcategory(int index, const char* value);
  void set_appcategory(int index, const char* value, size_t size);
  std::string* add_appcategory();
  void add_appcategory(const std::string& value);
  void add_appcategory(std::string&& value);
  void add_appcategory(const char* value);
  void add_appcategory(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& appcategory() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_appcategory();
  private:
  const std::string& _internal_appcategory(int index) const;
  std::string* _internal_add_appcategory();
  public:

  // repeated string permission = 10;
  int permission_size() const;
  private:
  int _internal_permission_size() const;
  public:
  void clear_permission();
  const std::string& permission(int index) const;
  std::string* mutable_permission(int index);
  void set_permission(int index, const std::string& value);
  void set_permission(int index, std::string&& value);
  void set_permission(int index, const char* value);
  void set_permission(int index, const char* value, size_t size);
  std::string* add_permission();
  void add_permission(const std::string& value);
  void add_permission(std::string&& value);
  void add_permission(const char* value);
  void add_permission(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& permission() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_permission();
  private:
  const std::string& _internal_permission(int index) const;
  std::string* _internal_add_permission();
  public:

  // repeated .playapi.proto.finsky.download.FileMetadata file = 17;
  int file_size() const;
  private:
  int _internal_file_size() const;
  public:
  void clear_file();
  ::playapi::proto::finsky::download::FileMetadata* mutable_file(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::download::FileMetadata >*
      mutable_file();
  private:
  const ::playapi::proto::finsky::download::FileMetadata& _internal_file(int index) const;
  ::playapi::proto::finsky::download::FileMetadata* _internal_add_file();
  public:
  const ::playapi::proto::finsky::download::FileMetadata& file(int index) const;
  ::playapi::proto::finsky::download::FileMetadata* add_file();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::download::FileMetadata >&
      file() const;

  // repeated string certificateHash = 19;
  int certificatehash_size() const;
  private:
  int _internal_certificatehash_size() const;
  public:
  void clear_certificatehash();
  const std::string& certificatehash(int index) const;
  std::string* mutable_certificatehash(int index);
  void set_certificatehash(int index, const std::string& value);
  void set_certificatehash(int index, std::string&& value);
  void set_certificatehash(int index, const char* value);
  void set_certificatehash(int index, const char* value, size_t size);
  std::string* add_certificatehash();
  void add_certificatehash(const std::string& value);
  void add_certificatehash(std::string&& value);
  void add_certificatehash(const char* value);
  void add_certificatehash(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& certificatehash() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_certificatehash();
  private:
  const std::string& _internal_certificatehash(int index) const;
  std::string* _internal_add_certificatehash();
  public:

  // repeated .playapi.proto.finsky.CertificateSet certificateSet = 22;
  int certificateset_size() const;
  private:
  int _internal_certificateset_size() const;
  public:
  void clear_certificateset();
  ::playapi::proto::finsky::CertificateSet* mutable_certificateset(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::CertificateSet >*
      mutable_certificateset();
  private:
  const ::playapi::proto::finsky::CertificateSet& _internal_certificateset(int index) const;
  ::playapi::proto::finsky::CertificateSet* _internal_add_certificateset();
  public:
  const ::playapi::proto::finsky::CertificateSet& certificateset(int index) const;
  ::playapi::proto::finsky::CertificateSet* add_certificateset();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::CertificateSet >&
      certificateset() const;

  // repeated string autoAcquireFreeAppIfHigherVersionAvailableTag = 23;
  int autoacquirefreeappifhigherversionavailabletag_size() const;
  private:
  int _internal_autoacquirefreeappifhigherversionavailabletag_size() const;
  public:
  void clear_autoacquirefreeappifhigherversionavailabletag();
  const std::string& autoacquirefreeappifhigherversionavailabletag(int index) const;
  std::string* mutable_autoacquirefreeappifhigherversionavailabletag(int index);
  void set_autoacquirefreeappifhigherversionavailabletag(int index, const std::string& value);
  void set_autoacquirefreeappifhigherversionavailabletag(int index, std::string&& value);
  void set_autoacquirefreeappifhigherversionavailabletag(int index, const char* value);
  void set_autoacquirefreeappifhigherversionavailabletag(int index, const char* value, size_t size);
  std::string* add_autoacquirefreeappifhigherversionavailabletag();
  void add_autoacquirefreeappifhigherversionavailabletag(const std::string& value);
  void add_autoacquirefreeappifhigherversionavailabletag(std::string&& value);
  void add_autoacquirefreeappifhigherversionavailabletag(const char* value);
  void add_autoacquirefreeappifhigherversionavailabletag(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& autoacquirefreeappifhigherversionavailabletag() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_autoacquirefreeappifhigherversionavailabletag();
  private:
  const std::string& _internal_autoacquirefreeappifhigherversionavailabletag(int index) const;
  std::string* _internal_add_autoacquirefreeappifhigherversionavailabletag();
  public:

  // repeated string splitId = 25;
  int splitid_size() const;
  private:
  int _internal_splitid_size() const;
  public:
  void clear_splitid();
  const std::string& splitid(int index) const;
  std::string* mutable_splitid(int index);
  void set_splitid(int index, const std::string& value);
  void set_splitid(int index, std::string&& value);
  void set_splitid(int index, const char* value);
  void set_splitid(int index, const char* value, size_t size);
  std::string* add_splitid();
  void add_splitid(const std::string& value);
  void add_splitid(std::string&& value);
  void add_splitid(const char* value);
  void add_splitid(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& splitid() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_splitid();
  private:
  const std::string& _internal_splitid(int index) const;
  std::string* _internal_add_splitid();
  public:

  // optional string developerName = 1;
  bool has_developername() const;
  private:
  bool _internal_has_developername() const;
  public:
  void clear_developername();
  const std::string& developername() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_developername(ArgT0&& arg0, ArgT... args);
  std::string* mutable_developername();
  PROTOBUF_NODISCARD std::string* release_developername();
  void set_allocated_developername(std::string* developername);
  private:
  const std::string& _internal_developername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_developername(const std::string& value);
  std::string* _internal_mutable_developername();
  public:

  // optional string versionString = 4;
  bool has_versionstring() const;
  private:
  bool _internal_has_versionstring() const;
  public:
  void clear_versionstring();
  const std::string& versionstring() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_versionstring(ArgT0&& arg0, ArgT... args);
  std::string* mutable_versionstring();
  PROTOBUF_NODISCARD std::string* release_versionstring();
  void set_allocated_versionstring(std::string* versionstring);
  private:
  const std::string& _internal_versionstring() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_versionstring(const std::string& value);
  std::string* _internal_mutable_versionstring();
  public:

  // optional string title = 5;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // optional string developerEmail = 11;
  bool has_developeremail() const;
  private:
  bool _internal_has_developeremail() const;
  public:
  void clear_developeremail();
  const std::string& developeremail() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_developeremail(ArgT0&& arg0, ArgT... args);
  std::string* mutable_developeremail();
  PROTOBUF_NODISCARD std::string* release_developeremail();
  void set_allocated_developeremail(std::string* developeremail);
  private:
  const std::string& _internal_developeremail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_developeremail(const std::string& value);
  std::string* _internal_mutable_developeremail();
  public:

  // optional string developerWebsite = 12;
  bool has_developerwebsite() const;
  private:
  bool _internal_has_developerwebsite() const;
  public:
  void clear_developerwebsite();
  const std::string& developerwebsite() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_developerwebsite(ArgT0&& arg0, ArgT... args);
  std::string* mutable_developerwebsite();
  PROTOBUF_NODISCARD std::string* release_developerwebsite();
  void set_allocated_developerwebsite(std::string* developerwebsite);
  private:
  const std::string& _internal_developerwebsite() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_developerwebsite(const std::string& value);
  std::string* _internal_mutable_developerwebsite();
  public:

  // optional string numDownloads = 13;
  bool has_numdownloads() const;
  private:
  bool _internal_has_numdownloads() const;
  public:
  void clear_numdownloads();
  const std::string& numdownloads() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_numdownloads(ArgT0&& arg0, ArgT... args);
  std::string* mutable_numdownloads();
  PROTOBUF_NODISCARD std::string* release_numdownloads();
  void set_allocated_numdownloads(std::string* numdownloads);
  private:
  const std::string& _internal_numdownloads() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_numdownloads(const std::string& value);
  std::string* _internal_mutable_numdownloads();
  public:

  // optional string packageName = 14;
  bool has_packagename() const;
  private:
  bool _internal_has_packagename() const;
  public:
  void clear_packagename();
  const std::string& packagename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_packagename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_packagename();
  PROTOBUF_NODISCARD std::string* release_packagename();
  void set_allocated_packagename(std::string* packagename);
  private:
  const std::string& _internal_packagename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_packagename(const std::string& value);
  std::string* _internal_mutable_packagename();
  public:

  // optional string recentChangesHtml = 15;
  bool has_recentchangeshtml() const;
  private:
  bool _internal_has_recentchangeshtml() const;
  public:
  void clear_recentchangeshtml();
  const std::string& recentchangeshtml() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_recentchangeshtml(ArgT0&& arg0, ArgT... args);
  std::string* mutable_recentchangeshtml();
  PROTOBUF_NODISCARD std::string* release_recentchangeshtml();
  void set_allocated_recentchangeshtml(std::string* recentchangeshtml);
  private:
  const std::string& _internal_recentchangeshtml() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recentchangeshtml(const std::string& value);
  std::string* _internal_mutable_recentchangeshtml();
  public:

  // optional string uploadDate = 16;
  bool has_uploaddate() const;
  private:
  bool _internal_has_uploaddate() const;
  public:
  void clear_uploaddate();
  const std::string& uploaddate() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uploaddate(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uploaddate();
  PROTOBUF_NODISCARD std::string* release_uploaddate();
  void set_allocated_uploaddate(std::string* uploaddate);
  private:
  const std::string& _internal_uploaddate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uploaddate(const std::string& value);
  std::string* _internal_mutable_uploaddate();
  public:

  // optional string appType = 18;
  bool has_apptype() const;
  private:
  bool _internal_has_apptype() const;
  public:
  void clear_apptype();
  const std::string& apptype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_apptype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_apptype();
  PROTOBUF_NODISCARD std::string* release_apptype();
  void set_allocated_apptype(std::string* apptype);
  private:
  const std::string& _internal_apptype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_apptype(const std::string& value);
  std::string* _internal_mutable_apptype();
  public:

  // optional string installNotes = 30;
  bool has_installnotes() const;
  private:
  bool _internal_has_installnotes() const;
  public:
  void clear_installnotes();
  const std::string& installnotes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_installnotes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_installnotes();
  PROTOBUF_NODISCARD std::string* release_installnotes();
  void set_allocated_installnotes(std::string* installnotes);
  private:
  const std::string& _internal_installnotes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_installnotes(const std::string& value);
  std::string* _internal_mutable_installnotes();
  public:

  // optional string preregistrationPromoCode = 33;
  bool has_preregistrationpromocode() const;
  private:
  bool _internal_has_preregistrationpromocode() const;
  public:
  void clear_preregistrationpromocode();
  const std::string& preregistrationpromocode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_preregistrationpromocode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_preregistrationpromocode();
  PROTOBUF_NODISCARD std::string* release_preregistrationpromocode();
  void set_allocated_preregistrationpromocode(std::string* preregistrationpromocode);
  private:
  const std::string& _internal_preregistrationpromocode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_preregistrationpromocode(const std::string& value);
  std::string* _internal_mutable_preregistrationpromocode();
  public:

  // optional .playapi.proto.finsky.download.InstallDetails installDetails = 34;
  bool has_installdetails() const;
  private:
  bool _internal_has_installdetails() const;
  public:
  void clear_installdetails();
  const ::playapi::proto::finsky::download::InstallDetails& installdetails() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::download::InstallDetails* release_installdetails();
  ::playapi::proto::finsky::download::InstallDetails* mutable_installdetails();
  void set_allocated_installdetails(::playapi::proto::finsky::download::InstallDetails* installdetails);
  private:
  const ::playapi::proto::finsky::download::InstallDetails& _internal_installdetails() const;
  ::playapi::proto::finsky::download::InstallDetails* _internal_mutable_installdetails();
  public:
  void unsafe_arena_set_allocated_installdetails(
      ::playapi::proto::finsky::download::InstallDetails* installdetails);
  ::playapi::proto::finsky::download::InstallDetails* unsafe_arena_release_installdetails();

  // optional .playapi.proto.finsky.document.TestingProgramInfo testingProgramInfo = 35;
  bool has_testingprograminfo() const;
  private:
  bool _internal_has_testingprograminfo() const;
  public:
  void clear_testingprograminfo();
  const ::playapi::proto::finsky::document::TestingProgramInfo& testingprograminfo() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::TestingProgramInfo* release_testingprograminfo();
  ::playapi::proto::finsky::document::TestingProgramInfo* mutable_testingprograminfo();
  void set_allocated_testingprograminfo(::playapi::proto::finsky::document::TestingProgramInfo* testingprograminfo);
  private:
  const ::playapi::proto::finsky::document::TestingProgramInfo& _internal_testingprograminfo() const;
  ::playapi::proto::finsky::document::TestingProgramInfo* _internal_mutable_testingprograminfo();
  public:
  void unsafe_arena_set_allocated_testingprograminfo(
      ::playapi::proto::finsky::document::TestingProgramInfo* testingprograminfo);
  ::playapi::proto::finsky::document::TestingProgramInfo* unsafe_arena_release_testingprograminfo();

  // optional int32 majorVersionNumber = 2;
  bool has_majorversionnumber() const;
  private:
  bool _internal_has_majorversionnumber() const;
  public:
  void clear_majorversionnumber();
  int32_t majorversionnumber() const;
  void set_majorversionnumber(int32_t value);
  private:
  int32_t _internal_majorversionnumber() const;
  void _internal_set_majorversionnumber(int32_t value);
  public:

  // optional int32 versionCode = 3;
  bool has_versioncode() const;
  private:
  bool _internal_has_versioncode() const;
  public:
  void clear_versioncode();
  int32_t versioncode() const;
  void set_versioncode(int32_t value);
  private:
  int32_t _internal_versioncode() const;
  void _internal_set_versioncode(int32_t value);
  public:

  // optional int64 installationSize = 9;
  bool has_installationsize() const;
  private:
  bool _internal_has_installationsize() const;
  public:
  void clear_installationsize();
  int64_t installationsize() const;
  void set_installationsize(int64_t value);
  private:
  int64_t _internal_installationsize() const;
  void _internal_set_installationsize(int64_t value);
  public:

  // optional int32 contentRating = 8;
  bool has_contentrating() const;
  private:
  bool _internal_has_contentrating() const;
  public:
  void clear_contentrating();
  int32_t contentrating() const;
  void set_contentrating(int32_t value);
  private:
  int32_t _internal_contentrating() const;
  void _internal_set_contentrating(int32_t value);
  public:

  // optional bool variesByAccount = 21;
  bool has_variesbyaccount() const;
  private:
  bool _internal_has_variesbyaccount() const;
  public:
  void clear_variesbyaccount();
  bool variesbyaccount() const;
  void set_variesbyaccount(bool value);
  private:
  bool _internal_variesbyaccount() const;
  void _internal_set_variesbyaccount(bool value);
  public:

  // optional bool declaresIab = 24;
  bool has_declaresiab() const;
  private:
  bool _internal_has_declaresiab() const;
  public:
  void clear_declaresiab();
  bool declaresiab() const;
  void set_declaresiab(bool value);
  private:
  bool _internal_declaresiab() const;
  void _internal_set_declaresiab(bool value);
  public:

  // optional bool gamepadRequired = 26;
  bool has_gamepadrequired() const;
  private:
  bool _internal_has_gamepadrequired() const;
  public:
  void clear_gamepadrequired();
  bool gamepadrequired() const;
  void set_gamepadrequired(bool value);
  private:
  bool _internal_gamepadrequired() const;
  void _internal_set_gamepadrequired(bool value);
  public:

  // optional bool externallyHosted = 27;
  bool has_externallyhosted() const;
  private:
  bool _internal_has_externallyhosted() const;
  public:
  void clear_externallyhosted();
  bool externallyhosted() const;
  void set_externallyhosted(bool value);
  private:
  bool _internal_externallyhosted() const;
  void _internal_set_externallyhosted(bool value);
  public:

  // optional bool everExternallyHosted = 28;
  bool has_everexternallyhosted() const;
  private:
  bool _internal_has_everexternallyhosted() const;
  public:
  void clear_everexternallyhosted();
  bool everexternallyhosted() const;
  void set_everexternallyhosted(bool value);
  private:
  bool _internal_everexternallyhosted() const;
  void _internal_set_everexternallyhosted(bool value);
  public:

  // optional int32 installLocation = 31;
  bool has_installlocation() const;
  private:
  bool _internal_has_installlocation() const;
  public:
  void clear_installlocation();
  int32_t installlocation() const;
  void set_installlocation(int32_t value);
  private:
  int32_t _internal_installlocation() const;
  void _internal_set_installlocation(int32_t value);
  public:

  // optional int32 targetSdkVersion = 32;
  bool has_targetsdkversion() const;
  private:
  bool _internal_has_targetsdkversion() const;
  public:
  void clear_targetsdkversion();
  int32_t targetsdkversion() const;
  void set_targetsdkversion(int32_t value);
  private:
  int32_t _internal_targetsdkversion() const;
  void _internal_set_targetsdkversion(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.document.AppDetails)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> appcategory_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> permission_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::download::FileMetadata > file_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> certificatehash_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::CertificateSet > certificateset_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> autoacquirefreeappifhigherversionavailabletag_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> splitid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr developername_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr versionstring_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr developeremail_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr developerwebsite_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr numdownloads_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr packagename_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr recentchangeshtml_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uploaddate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr apptype_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr installnotes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr preregistrationpromocode_;
    ::playapi::proto::finsky::download::InstallDetails* installdetails_;
    ::playapi::proto::finsky::document::TestingProgramInfo* testingprograminfo_;
    int32_t majorversionnumber_;
    int32_t versioncode_;
    int64_t installationsize_;
    int32_t contentrating_;
    bool variesbyaccount_;
    bool declaresiab_;
    bool gamepadrequired_;
    bool externallyhosted_;
    bool everexternallyhosted_;
    int32_t installlocation_;
    int32_t targetsdkversion_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fdocument_2eproto;
};
// -------------------------------------------------------------------

class TestingProgramInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.document.TestingProgramInfo) */ {
 public:
  inline TestingProgramInfo() : TestingProgramInfo(nullptr) {}
  ~TestingProgramInfo() override;
  explicit PROTOBUF_CONSTEXPR TestingProgramInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestingProgramInfo(const TestingProgramInfo& from);
  TestingProgramInfo(TestingProgramInfo&& from) noexcept
    : TestingProgramInfo() {
    *this = ::std::move(from);
  }

  inline TestingProgramInfo& operator=(const TestingProgramInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestingProgramInfo& operator=(TestingProgramInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestingProgramInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestingProgramInfo* internal_default_instance() {
    return reinterpret_cast<const TestingProgramInfo*>(
               &_TestingProgramInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(TestingProgramInfo& a, TestingProgramInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TestingProgramInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestingProgramInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestingProgramInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestingProgramInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TestingProgramInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TestingProgramInfo& from) {
    TestingProgramInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestingProgramInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.document.TestingProgramInfo";
  }
  protected:
  explicit TestingProgramInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubscribedFieldNumber = 2,
    kSubscribed1FieldNumber = 3,
  };
  // optional bool subscribed = 2;
  bool has_subscribed() const;
  private:
  bool _internal_has_subscribed() const;
  public:
  void clear_subscribed();
  bool subscribed() const;
  void set_subscribed(bool value);
  private:
  bool _internal_subscribed() const;
  void _internal_set_subscribed(bool value);
  public:

  // optional bool subscribed1 = 3;
  bool has_subscribed1() const;
  private:
  bool _internal_has_subscribed1() const;
  public:
  void clear_subscribed1();
  bool subscribed1() const;
  void set_subscribed1(bool value);
  private:
  bool _internal_subscribed1() const;
  void _internal_set_subscribed1(bool value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.document.TestingProgramInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool subscribed_;
    bool subscribed1_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fdocument_2eproto;
};
// -------------------------------------------------------------------

class AlbumDetails final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.document.AlbumDetails) */ {
 public:
  inline AlbumDetails() : AlbumDetails(nullptr) {}
  ~AlbumDetails() override;
  explicit PROTOBUF_CONSTEXPR AlbumDetails(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AlbumDetails(const AlbumDetails& from);
  AlbumDetails(AlbumDetails&& from) noexcept
    : AlbumDetails() {
    *this = ::std::move(from);
  }

  inline AlbumDetails& operator=(const AlbumDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline AlbumDetails& operator=(AlbumDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AlbumDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const AlbumDetails* internal_default_instance() {
    return reinterpret_cast<const AlbumDetails*>(
               &_AlbumDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(AlbumDetails& a, AlbumDetails& b) {
    a.Swap(&b);
  }
  inline void Swap(AlbumDetails* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AlbumDetails* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AlbumDetails* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AlbumDetails>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AlbumDetails& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AlbumDetails& from) {
    AlbumDetails::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AlbumDetails* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.document.AlbumDetails";
  }
  protected:
  explicit AlbumDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDetailsFieldNumber = 2,
    kDisplayArtistFieldNumber = 3,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional .playapi.proto.finsky.document.MusicDetails details = 2;
  bool has_details() const;
  private:
  bool _internal_has_details() const;
  public:
  void clear_details();
  const ::playapi::proto::finsky::document::MusicDetails& details() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::MusicDetails* release_details();
  ::playapi::proto::finsky::document::MusicDetails* mutable_details();
  void set_allocated_details(::playapi::proto::finsky::document::MusicDetails* details);
  private:
  const ::playapi::proto::finsky::document::MusicDetails& _internal_details() const;
  ::playapi::proto::finsky::document::MusicDetails* _internal_mutable_details();
  public:
  void unsafe_arena_set_allocated_details(
      ::playapi::proto::finsky::document::MusicDetails* details);
  ::playapi::proto::finsky::document::MusicDetails* unsafe_arena_release_details();

  // optional .playapi.proto.finsky.document.ArtistDetails displayArtist = 3;
  bool has_displayartist() const;
  private:
  bool _internal_has_displayartist() const;
  public:
  void clear_displayartist();
  const ::playapi::proto::finsky::document::ArtistDetails& displayartist() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::ArtistDetails* release_displayartist();
  ::playapi::proto::finsky::document::ArtistDetails* mutable_displayartist();
  void set_allocated_displayartist(::playapi::proto::finsky::document::ArtistDetails* displayartist);
  private:
  const ::playapi::proto::finsky::document::ArtistDetails& _internal_displayartist() const;
  ::playapi::proto::finsky::document::ArtistDetails* _internal_mutable_displayartist();
  public:
  void unsafe_arena_set_allocated_displayartist(
      ::playapi::proto::finsky::document::ArtistDetails* displayartist);
  ::playapi::proto::finsky::document::ArtistDetails* unsafe_arena_release_displayartist();

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.document.AlbumDetails)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::playapi::proto::finsky::document::MusicDetails* details_;
    ::playapi::proto::finsky::document::ArtistDetails* displayartist_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fdocument_2eproto;
};
// -------------------------------------------------------------------

class MusicDetails final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.document.MusicDetails) */ {
 public:
  inline MusicDetails() : MusicDetails(nullptr) {}
  ~MusicDetails() override;
  explicit PROTOBUF_CONSTEXPR MusicDetails(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MusicDetails(const MusicDetails& from);
  MusicDetails(MusicDetails&& from) noexcept
    : MusicDetails() {
    *this = ::std::move(from);
  }

  inline MusicDetails& operator=(const MusicDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline MusicDetails& operator=(MusicDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MusicDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const MusicDetails* internal_default_instance() {
    return reinterpret_cast<const MusicDetails*>(
               &_MusicDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(MusicDetails& a, MusicDetails& b) {
    a.Swap(&b);
  }
  inline void Swap(MusicDetails* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MusicDetails* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MusicDetails* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MusicDetails>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MusicDetails& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MusicDetails& from) {
    MusicDetails::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MusicDetails* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.document.MusicDetails";
  }
  protected:
  explicit MusicDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArtistFieldNumber = 5,
    kGenreFieldNumber = 6,
    kReleaseTypeFieldNumber = 8,
    kOriginalReleaseDateFieldNumber = 3,
    kLabelFieldNumber = 4,
    kReleaseDateFieldNumber = 7,
    kCensoringFieldNumber = 1,
    kDurationSecFieldNumber = 2,
  };
  // repeated .playapi.proto.finsky.document.ArtistDetails artist = 5;
  int artist_size() const;
  private:
  int _internal_artist_size() const;
  public:
  void clear_artist();
  ::playapi::proto::finsky::document::ArtistDetails* mutable_artist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::ArtistDetails >*
      mutable_artist();
  private:
  const ::playapi::proto::finsky::document::ArtistDetails& _internal_artist(int index) const;
  ::playapi::proto::finsky::document::ArtistDetails* _internal_add_artist();
  public:
  const ::playapi::proto::finsky::document::ArtistDetails& artist(int index) const;
  ::playapi::proto::finsky::document::ArtistDetails* add_artist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::ArtistDetails >&
      artist() const;

  // repeated string genre = 6;
  int genre_size() const;
  private:
  int _internal_genre_size() const;
  public:
  void clear_genre();
  const std::string& genre(int index) const;
  std::string* mutable_genre(int index);
  void set_genre(int index, const std::string& value);
  void set_genre(int index, std::string&& value);
  void set_genre(int index, const char* value);
  void set_genre(int index, const char* value, size_t size);
  std::string* add_genre();
  void add_genre(const std::string& value);
  void add_genre(std::string&& value);
  void add_genre(const char* value);
  void add_genre(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& genre() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_genre();
  private:
  const std::string& _internal_genre(int index) const;
  std::string* _internal_add_genre();
  public:

  // repeated int32 releaseType = 8;
  int releasetype_size() const;
  private:
  int _internal_releasetype_size() const;
  public:
  void clear_releasetype();
  private:
  int32_t _internal_releasetype(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_releasetype() const;
  void _internal_add_releasetype(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_releasetype();
  public:
  int32_t releasetype(int index) const;
  void set_releasetype(int index, int32_t value);
  void add_releasetype(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      releasetype() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_releasetype();

  // optional string originalReleaseDate = 3;
  bool has_originalreleasedate() const;
  private:
  bool _internal_has_originalreleasedate() const;
  public:
  void clear_originalreleasedate();
  const std::string& originalreleasedate() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_originalreleasedate(ArgT0&& arg0, ArgT... args);
  std::string* mutable_originalreleasedate();
  PROTOBUF_NODISCARD std::string* release_originalreleasedate();
  void set_allocated_originalreleasedate(std::string* originalreleasedate);
  private:
  const std::string& _internal_originalreleasedate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_originalreleasedate(const std::string& value);
  std::string* _internal_mutable_originalreleasedate();
  public:

  // optional string label = 4;
  bool has_label() const;
  private:
  bool _internal_has_label() const;
  public:
  void clear_label();
  const std::string& label() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_label(ArgT0&& arg0, ArgT... args);
  std::string* mutable_label();
  PROTOBUF_NODISCARD std::string* release_label();
  void set_allocated_label(std::string* label);
  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(const std::string& value);
  std::string* _internal_mutable_label();
  public:

  // optional string releaseDate = 7;
  bool has_releasedate() const;
  private:
  bool _internal_has_releasedate() const;
  public:
  void clear_releasedate();
  const std::string& releasedate() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_releasedate(ArgT0&& arg0, ArgT... args);
  std::string* mutable_releasedate();
  PROTOBUF_NODISCARD std::string* release_releasedate();
  void set_allocated_releasedate(std::string* releasedate);
  private:
  const std::string& _internal_releasedate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_releasedate(const std::string& value);
  std::string* _internal_mutable_releasedate();
  public:

  // optional int32 censoring = 1;
  bool has_censoring() const;
  private:
  bool _internal_has_censoring() const;
  public:
  void clear_censoring();
  int32_t censoring() const;
  void set_censoring(int32_t value);
  private:
  int32_t _internal_censoring() const;
  void _internal_set_censoring(int32_t value);
  public:

  // optional int32 durationSec = 2;
  bool has_durationsec() const;
  private:
  bool _internal_has_durationsec() const;
  public:
  void clear_durationsec();
  int32_t durationsec() const;
  void set_durationsec(int32_t value);
  private:
  int32_t _internal_durationsec() const;
  void _internal_set_durationsec(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.document.MusicDetails)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::ArtistDetails > artist_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> genre_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > releasetype_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr originalreleasedate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr releasedate_;
    int32_t censoring_;
    int32_t durationsec_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fdocument_2eproto;
};
// -------------------------------------------------------------------

class ArtistDetails final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.document.ArtistDetails) */ {
 public:
  inline ArtistDetails() : ArtistDetails(nullptr) {}
  ~ArtistDetails() override;
  explicit PROTOBUF_CONSTEXPR ArtistDetails(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ArtistDetails(const ArtistDetails& from);
  ArtistDetails(ArtistDetails&& from) noexcept
    : ArtistDetails() {
    *this = ::std::move(from);
  }

  inline ArtistDetails& operator=(const ArtistDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArtistDetails& operator=(ArtistDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ArtistDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const ArtistDetails* internal_default_instance() {
    return reinterpret_cast<const ArtistDetails*>(
               &_ArtistDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(ArtistDetails& a, ArtistDetails& b) {
    a.Swap(&b);
  }
  inline void Swap(ArtistDetails* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArtistDetails* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ArtistDetails* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ArtistDetails>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ArtistDetails& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ArtistDetails& from) {
    ArtistDetails::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArtistDetails* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.document.ArtistDetails";
  }
  protected:
  explicit ArtistDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDetailsUrlFieldNumber = 1,
    kNameFieldNumber = 2,
    kExternalLinksFieldNumber = 3,
  };
  // optional string detailsUrl = 1;
  bool has_detailsurl() const;
  private:
  bool _internal_has_detailsurl() const;
  public:
  void clear_detailsurl();
  const std::string& detailsurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_detailsurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_detailsurl();
  PROTOBUF_NODISCARD std::string* release_detailsurl();
  void set_allocated_detailsurl(std::string* detailsurl);
  private:
  const std::string& _internal_detailsurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_detailsurl(const std::string& value);
  std::string* _internal_mutable_detailsurl();
  public:

  // optional string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional .playapi.proto.finsky.document.ArtistExternalLinks externalLinks = 3;
  bool has_externallinks() const;
  private:
  bool _internal_has_externallinks() const;
  public:
  void clear_externallinks();
  const ::playapi::proto::finsky::document::ArtistExternalLinks& externallinks() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::ArtistExternalLinks* release_externallinks();
  ::playapi::proto::finsky::document::ArtistExternalLinks* mutable_externallinks();
  void set_allocated_externallinks(::playapi::proto::finsky::document::ArtistExternalLinks* externallinks);
  private:
  const ::playapi::proto::finsky::document::ArtistExternalLinks& _internal_externallinks() const;
  ::playapi::proto::finsky::document::ArtistExternalLinks* _internal_mutable_externallinks();
  public:
  void unsafe_arena_set_allocated_externallinks(
      ::playapi::proto::finsky::document::ArtistExternalLinks* externallinks);
  ::playapi::proto::finsky::document::ArtistExternalLinks* unsafe_arena_release_externallinks();

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.document.ArtistDetails)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr detailsurl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::playapi::proto::finsky::document::ArtistExternalLinks* externallinks_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fdocument_2eproto;
};
// -------------------------------------------------------------------

class ArtistExternalLinks final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.document.ArtistExternalLinks) */ {
 public:
  inline ArtistExternalLinks() : ArtistExternalLinks(nullptr) {}
  ~ArtistExternalLinks() override;
  explicit PROTOBUF_CONSTEXPR ArtistExternalLinks(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ArtistExternalLinks(const ArtistExternalLinks& from);
  ArtistExternalLinks(ArtistExternalLinks&& from) noexcept
    : ArtistExternalLinks() {
    *this = ::std::move(from);
  }

  inline ArtistExternalLinks& operator=(const ArtistExternalLinks& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArtistExternalLinks& operator=(ArtistExternalLinks&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ArtistExternalLinks& default_instance() {
    return *internal_default_instance();
  }
  static inline const ArtistExternalLinks* internal_default_instance() {
    return reinterpret_cast<const ArtistExternalLinks*>(
               &_ArtistExternalLinks_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(ArtistExternalLinks& a, ArtistExternalLinks& b) {
    a.Swap(&b);
  }
  inline void Swap(ArtistExternalLinks* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArtistExternalLinks* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ArtistExternalLinks* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ArtistExternalLinks>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ArtistExternalLinks& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ArtistExternalLinks& from) {
    ArtistExternalLinks::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArtistExternalLinks* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.document.ArtistExternalLinks";
  }
  protected:
  explicit ArtistExternalLinks(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWebsiteUrlFieldNumber = 1,
    kGooglePlusProfileUrlFieldNumber = 2,
    kYoutubeChannelUrlFieldNumber = 3,
  };
  // repeated string websiteUrl = 1;
  int websiteurl_size() const;
  private:
  int _internal_websiteurl_size() const;
  public:
  void clear_websiteurl();
  const std::string& websiteurl(int index) const;
  std::string* mutable_websiteurl(int index);
  void set_websiteurl(int index, const std::string& value);
  void set_websiteurl(int index, std::string&& value);
  void set_websiteurl(int index, const char* value);
  void set_websiteurl(int index, const char* value, size_t size);
  std::string* add_websiteurl();
  void add_websiteurl(const std::string& value);
  void add_websiteurl(std::string&& value);
  void add_websiteurl(const char* value);
  void add_websiteurl(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& websiteurl() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_websiteurl();
  private:
  const std::string& _internal_websiteurl(int index) const;
  std::string* _internal_add_websiteurl();
  public:

  // optional string googlePlusProfileUrl = 2;
  bool has_googleplusprofileurl() const;
  private:
  bool _internal_has_googleplusprofileurl() const;
  public:
  void clear_googleplusprofileurl();
  const std::string& googleplusprofileurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_googleplusprofileurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_googleplusprofileurl();
  PROTOBUF_NODISCARD std::string* release_googleplusprofileurl();
  void set_allocated_googleplusprofileurl(std::string* googleplusprofileurl);
  private:
  const std::string& _internal_googleplusprofileurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_googleplusprofileurl(const std::string& value);
  std::string* _internal_mutable_googleplusprofileurl();
  public:

  // optional string youtubeChannelUrl = 3;
  bool has_youtubechannelurl() const;
  private:
  bool _internal_has_youtubechannelurl() const;
  public:
  void clear_youtubechannelurl();
  const std::string& youtubechannelurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_youtubechannelurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_youtubechannelurl();
  PROTOBUF_NODISCARD std::string* release_youtubechannelurl();
  void set_allocated_youtubechannelurl(std::string* youtubechannelurl);
  private:
  const std::string& _internal_youtubechannelurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_youtubechannelurl(const std::string& value);
  std::string* _internal_mutable_youtubechannelurl();
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.document.ArtistExternalLinks)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> websiteurl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr googleplusprofileurl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr youtubechannelurl_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fdocument_2eproto;
};
// -------------------------------------------------------------------

class SongDetails final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.document.SongDetails) */ {
 public:
  inline SongDetails() : SongDetails(nullptr) {}
  ~SongDetails() override;
  explicit PROTOBUF_CONSTEXPR SongDetails(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SongDetails(const SongDetails& from);
  SongDetails(SongDetails&& from) noexcept
    : SongDetails() {
    *this = ::std::move(from);
  }

  inline SongDetails& operator=(const SongDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline SongDetails& operator=(SongDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SongDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const SongDetails* internal_default_instance() {
    return reinterpret_cast<const SongDetails*>(
               &_SongDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(SongDetails& a, SongDetails& b) {
    a.Swap(&b);
  }
  inline void Swap(SongDetails* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SongDetails* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SongDetails* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SongDetails>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SongDetails& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SongDetails& from) {
    SongDetails::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SongDetails* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.document.SongDetails";
  }
  protected:
  explicit SongDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kAlbumNameFieldNumber = 3,
    kPreviewUrlFieldNumber = 5,
    kDetailsFieldNumber = 2,
    kDisplayArtistFieldNumber = 6,
    kBadgeFieldNumber = 7,
    kTrackNumberFieldNumber = 4,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string albumName = 3;
  bool has_albumname() const;
  private:
  bool _internal_has_albumname() const;
  public:
  void clear_albumname();
  const std::string& albumname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_albumname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_albumname();
  PROTOBUF_NODISCARD std::string* release_albumname();
  void set_allocated_albumname(std::string* albumname);
  private:
  const std::string& _internal_albumname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_albumname(const std::string& value);
  std::string* _internal_mutable_albumname();
  public:

  // optional string previewUrl = 5;
  bool has_previewurl() const;
  private:
  bool _internal_has_previewurl() const;
  public:
  void clear_previewurl();
  const std::string& previewurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_previewurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_previewurl();
  PROTOBUF_NODISCARD std::string* release_previewurl();
  void set_allocated_previewurl(std::string* previewurl);
  private:
  const std::string& _internal_previewurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_previewurl(const std::string& value);
  std::string* _internal_mutable_previewurl();
  public:

  // optional .playapi.proto.finsky.document.MusicDetails details = 2;
  bool has_details() const;
  private:
  bool _internal_has_details() const;
  public:
  void clear_details();
  const ::playapi::proto::finsky::document::MusicDetails& details() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::MusicDetails* release_details();
  ::playapi::proto::finsky::document::MusicDetails* mutable_details();
  void set_allocated_details(::playapi::proto::finsky::document::MusicDetails* details);
  private:
  const ::playapi::proto::finsky::document::MusicDetails& _internal_details() const;
  ::playapi::proto::finsky::document::MusicDetails* _internal_mutable_details();
  public:
  void unsafe_arena_set_allocated_details(
      ::playapi::proto::finsky::document::MusicDetails* details);
  ::playapi::proto::finsky::document::MusicDetails* unsafe_arena_release_details();

  // optional .playapi.proto.finsky.document.ArtistDetails displayArtist = 6;
  bool has_displayartist() const;
  private:
  bool _internal_has_displayartist() const;
  public:
  void clear_displayartist();
  const ::playapi::proto::finsky::document::ArtistDetails& displayartist() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::ArtistDetails* release_displayartist();
  ::playapi::proto::finsky::document::ArtistDetails* mutable_displayartist();
  void set_allocated_displayartist(::playapi::proto::finsky::document::ArtistDetails* displayartist);
  private:
  const ::playapi::proto::finsky::document::ArtistDetails& _internal_displayartist() const;
  ::playapi::proto::finsky::document::ArtistDetails* _internal_mutable_displayartist();
  public:
  void unsafe_arena_set_allocated_displayartist(
      ::playapi::proto::finsky::document::ArtistDetails* displayartist);
  ::playapi::proto::finsky::document::ArtistDetails* unsafe_arena_release_displayartist();

  // optional .playapi.proto.finsky.document.Badge badge = 7;
  bool has_badge() const;
  private:
  bool _internal_has_badge() const;
  public:
  void clear_badge();
  const ::playapi::proto::finsky::document::Badge& badge() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::Badge* release_badge();
  ::playapi::proto::finsky::document::Badge* mutable_badge();
  void set_allocated_badge(::playapi::proto::finsky::document::Badge* badge);
  private:
  const ::playapi::proto::finsky::document::Badge& _internal_badge() const;
  ::playapi::proto::finsky::document::Badge* _internal_mutable_badge();
  public:
  void unsafe_arena_set_allocated_badge(
      ::playapi::proto::finsky::document::Badge* badge);
  ::playapi::proto::finsky::document::Badge* unsafe_arena_release_badge();

  // optional int32 trackNumber = 4;
  bool has_tracknumber() const;
  private:
  bool _internal_has_tracknumber() const;
  public:
  void clear_tracknumber();
  int32_t tracknumber() const;
  void set_tracknumber(int32_t value);
  private:
  int32_t _internal_tracknumber() const;
  void _internal_set_tracknumber(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.document.SongDetails)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr albumname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr previewurl_;
    ::playapi::proto::finsky::document::MusicDetails* details_;
    ::playapi::proto::finsky::document::ArtistDetails* displayartist_;
    ::playapi::proto::finsky::document::Badge* badge_;
    int32_t tracknumber_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fdocument_2eproto;
};
// -------------------------------------------------------------------

class BookDetails final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.document.BookDetails) */ {
 public:
  inline BookDetails() : BookDetails(nullptr) {}
  ~BookDetails() override;
  explicit PROTOBUF_CONSTEXPR BookDetails(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BookDetails(const BookDetails& from);
  BookDetails(BookDetails&& from) noexcept
    : BookDetails() {
    *this = ::std::move(from);
  }

  inline BookDetails& operator=(const BookDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline BookDetails& operator=(BookDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BookDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const BookDetails* internal_default_instance() {
    return reinterpret_cast<const BookDetails*>(
               &_BookDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(BookDetails& a, BookDetails& b) {
    a.Swap(&b);
  }
  inline void Swap(BookDetails* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BookDetails* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BookDetails* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BookDetails>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BookDetails& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BookDetails& from) {
    BookDetails::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BookDetails* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.document.BookDetails";
  }
  protected:
  explicit BookDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublisherFieldNumber = 4,
    kPublicationDateFieldNumber = 5,
    kIsbnFieldNumber = 6,
    kAboutTheAuthorFieldNumber = 17,
    kSeriesLineFieldNumber = 28,
    kConciseTitleFieldNumber = 29,
    kShortTitleFieldNumber = 30,
    kSeriesTitleFieldNumber = 31,
    kNumberOfPagesFieldNumber = 7,
    kBookTypeFieldNumber = 27,
  };
  // optional string publisher = 4;
  bool has_publisher() const;
  private:
  bool _internal_has_publisher() const;
  public:
  void clear_publisher();
  const std::string& publisher() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_publisher(ArgT0&& arg0, ArgT... args);
  std::string* mutable_publisher();
  PROTOBUF_NODISCARD std::string* release_publisher();
  void set_allocated_publisher(std::string* publisher);
  private:
  const std::string& _internal_publisher() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_publisher(const std::string& value);
  std::string* _internal_mutable_publisher();
  public:

  // optional string publicationDate = 5;
  bool has_publicationdate() const;
  private:
  bool _internal_has_publicationdate() const;
  public:
  void clear_publicationdate();
  const std::string& publicationdate() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_publicationdate(ArgT0&& arg0, ArgT... args);
  std::string* mutable_publicationdate();
  PROTOBUF_NODISCARD std::string* release_publicationdate();
  void set_allocated_publicationdate(std::string* publicationdate);
  private:
  const std::string& _internal_publicationdate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_publicationdate(const std::string& value);
  std::string* _internal_mutable_publicationdate();
  public:

  // optional string isbn = 6;
  bool has_isbn() const;
  private:
  bool _internal_has_isbn() const;
  public:
  void clear_isbn();
  const std::string& isbn() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_isbn(ArgT0&& arg0, ArgT... args);
  std::string* mutable_isbn();
  PROTOBUF_NODISCARD std::string* release_isbn();
  void set_allocated_isbn(std::string* isbn);
  private:
  const std::string& _internal_isbn() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_isbn(const std::string& value);
  std::string* _internal_mutable_isbn();
  public:

  // optional string aboutTheAuthor = 17;
  bool has_abouttheauthor() const;
  private:
  bool _internal_has_abouttheauthor() const;
  public:
  void clear_abouttheauthor();
  const std::string& abouttheauthor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_abouttheauthor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_abouttheauthor();
  PROTOBUF_NODISCARD std::string* release_abouttheauthor();
  void set_allocated_abouttheauthor(std::string* abouttheauthor);
  private:
  const std::string& _internal_abouttheauthor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_abouttheauthor(const std::string& value);
  std::string* _internal_mutable_abouttheauthor();
  public:

  // optional string seriesLine = 28;
  bool has_seriesline() const;
  private:
  bool _internal_has_seriesline() const;
  public:
  void clear_seriesline();
  const std::string& seriesline() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_seriesline(ArgT0&& arg0, ArgT... args);
  std::string* mutable_seriesline();
  PROTOBUF_NODISCARD std::string* release_seriesline();
  void set_allocated_seriesline(std::string* seriesline);
  private:
  const std::string& _internal_seriesline() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_seriesline(const std::string& value);
  std::string* _internal_mutable_seriesline();
  public:

  // optional string conciseTitle = 29;
  bool has_concisetitle() const;
  private:
  bool _internal_has_concisetitle() const;
  public:
  void clear_concisetitle();
  const std::string& concisetitle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_concisetitle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_concisetitle();
  PROTOBUF_NODISCARD std::string* release_concisetitle();
  void set_allocated_concisetitle(std::string* concisetitle);
  private:
  const std::string& _internal_concisetitle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_concisetitle(const std::string& value);
  std::string* _internal_mutable_concisetitle();
  public:

  // optional string shortTitle = 30;
  bool has_shorttitle() const;
  private:
  bool _internal_has_shorttitle() const;
  public:
  void clear_shorttitle();
  const std::string& shorttitle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_shorttitle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_shorttitle();
  PROTOBUF_NODISCARD std::string* release_shorttitle();
  void set_allocated_shorttitle(std::string* shorttitle);
  private:
  const std::string& _internal_shorttitle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_shorttitle(const std::string& value);
  std::string* _internal_mutable_shorttitle();
  public:

  // optional string seriesTitle = 31;
  bool has_seriestitle() const;
  private:
  bool _internal_has_seriestitle() const;
  public:
  void clear_seriestitle();
  const std::string& seriestitle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_seriestitle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_seriestitle();
  PROTOBUF_NODISCARD std::string* release_seriestitle();
  void set_allocated_seriestitle(std::string* seriestitle);
  private:
  const std::string& _internal_seriestitle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_seriestitle(const std::string& value);
  std::string* _internal_mutable_seriestitle();
  public:

  // optional int32 numberOfPages = 7;
  bool has_numberofpages() const;
  private:
  bool _internal_has_numberofpages() const;
  public:
  void clear_numberofpages();
  int32_t numberofpages() const;
  void set_numberofpages(int32_t value);
  private:
  int32_t _internal_numberofpages() const;
  void _internal_set_numberofpages(int32_t value);
  public:

  // optional int32 bookType = 27;
  bool has_booktype() const;
  private:
  bool _internal_has_booktype() const;
  public:
  void clear_booktype();
  int32_t booktype() const;
  void set_booktype(int32_t value);
  private:
  int32_t _internal_booktype() const;
  void _internal_set_booktype(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.document.BookDetails)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr publisher_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr publicationdate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr isbn_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr abouttheauthor_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr seriesline_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr concisetitle_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr shorttitle_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr seriestitle_;
    int32_t numberofpages_;
    int32_t booktype_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fdocument_2eproto;
};
// -------------------------------------------------------------------

class VideoDetails final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.document.VideoDetails) */ {
 public:
  inline VideoDetails() : VideoDetails(nullptr) {}
  ~VideoDetails() override;
  explicit PROTOBUF_CONSTEXPR VideoDetails(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VideoDetails(const VideoDetails& from);
  VideoDetails(VideoDetails&& from) noexcept
    : VideoDetails() {
    *this = ::std::move(from);
  }

  inline VideoDetails& operator=(const VideoDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoDetails& operator=(VideoDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VideoDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const VideoDetails* internal_default_instance() {
    return reinterpret_cast<const VideoDetails*>(
               &_VideoDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(VideoDetails& a, VideoDetails& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoDetails* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoDetails* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VideoDetails* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VideoDetails>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VideoDetails& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VideoDetails& from) {
    VideoDetails::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoDetails* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.document.VideoDetails";
  }
  protected:
  explicit VideoDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCreditFieldNumber = 1,
    kGenreFieldNumber = 7,
    kTrailerFieldNumber = 8,
    kRentalTermFieldNumber = 9,
    kAudioLanguageFieldNumber = 10,
    kCaptionLanguageFieldNumber = 11,
    kDurationFieldNumber = 2,
    kReleaseDateFieldNumber = 3,
    kContentRatingFieldNumber = 4,
    kLikesFieldNumber = 5,
    kDislikesFieldNumber = 6,
  };
  // repeated .playapi.proto.finsky.document.VideoCredit credit = 1;
  int credit_size() const;
  private:
  int _internal_credit_size() const;
  public:
  void clear_credit();
  ::playapi::proto::finsky::document::VideoCredit* mutable_credit(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::VideoCredit >*
      mutable_credit();
  private:
  const ::playapi::proto::finsky::document::VideoCredit& _internal_credit(int index) const;
  ::playapi::proto::finsky::document::VideoCredit* _internal_add_credit();
  public:
  const ::playapi::proto::finsky::document::VideoCredit& credit(int index) const;
  ::playapi::proto::finsky::document::VideoCredit* add_credit();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::VideoCredit >&
      credit() const;

  // repeated string genre = 7;
  int genre_size() const;
  private:
  int _internal_genre_size() const;
  public:
  void clear_genre();
  const std::string& genre(int index) const;
  std::string* mutable_genre(int index);
  void set_genre(int index, const std::string& value);
  void set_genre(int index, std::string&& value);
  void set_genre(int index, const char* value);
  void set_genre(int index, const char* value, size_t size);
  std::string* add_genre();
  void add_genre(const std::string& value);
  void add_genre(std::string&& value);
  void add_genre(const char* value);
  void add_genre(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& genre() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_genre();
  private:
  const std::string& _internal_genre(int index) const;
  std::string* _internal_add_genre();
  public:

  // repeated .playapi.proto.finsky.document.Trailer trailer = 8;
  int trailer_size() const;
  private:
  int _internal_trailer_size() const;
  public:
  void clear_trailer();
  ::playapi::proto::finsky::document::Trailer* mutable_trailer(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::Trailer >*
      mutable_trailer();
  private:
  const ::playapi::proto::finsky::document::Trailer& _internal_trailer(int index) const;
  ::playapi::proto::finsky::document::Trailer* _internal_add_trailer();
  public:
  const ::playapi::proto::finsky::document::Trailer& trailer(int index) const;
  ::playapi::proto::finsky::document::Trailer* add_trailer();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::Trailer >&
      trailer() const;

  // repeated .playapi.proto.finsky.document.VideoRentalTerm rentalTerm = 9;
  int rentalterm_size() const;
  private:
  int _internal_rentalterm_size() const;
  public:
  void clear_rentalterm();
  ::playapi::proto::finsky::document::VideoRentalTerm* mutable_rentalterm(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::VideoRentalTerm >*
      mutable_rentalterm();
  private:
  const ::playapi::proto::finsky::document::VideoRentalTerm& _internal_rentalterm(int index) const;
  ::playapi::proto::finsky::document::VideoRentalTerm* _internal_add_rentalterm();
  public:
  const ::playapi::proto::finsky::document::VideoRentalTerm& rentalterm(int index) const;
  ::playapi::proto::finsky::document::VideoRentalTerm* add_rentalterm();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::VideoRentalTerm >&
      rentalterm() const;

  // repeated string audioLanguage = 10;
  int audiolanguage_size() const;
  private:
  int _internal_audiolanguage_size() const;
  public:
  void clear_audiolanguage();
  const std::string& audiolanguage(int index) const;
  std::string* mutable_audiolanguage(int index);
  void set_audiolanguage(int index, const std::string& value);
  void set_audiolanguage(int index, std::string&& value);
  void set_audiolanguage(int index, const char* value);
  void set_audiolanguage(int index, const char* value, size_t size);
  std::string* add_audiolanguage();
  void add_audiolanguage(const std::string& value);
  void add_audiolanguage(std::string&& value);
  void add_audiolanguage(const char* value);
  void add_audiolanguage(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& audiolanguage() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_audiolanguage();
  private:
  const std::string& _internal_audiolanguage(int index) const;
  std::string* _internal_add_audiolanguage();
  public:

  // repeated string captionLanguage = 11;
  int captionlanguage_size() const;
  private:
  int _internal_captionlanguage_size() const;
  public:
  void clear_captionlanguage();
  const std::string& captionlanguage(int index) const;
  std::string* mutable_captionlanguage(int index);
  void set_captionlanguage(int index, const std::string& value);
  void set_captionlanguage(int index, std::string&& value);
  void set_captionlanguage(int index, const char* value);
  void set_captionlanguage(int index, const char* value, size_t size);
  std::string* add_captionlanguage();
  void add_captionlanguage(const std::string& value);
  void add_captionlanguage(std::string&& value);
  void add_captionlanguage(const char* value);
  void add_captionlanguage(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& captionlanguage() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_captionlanguage();
  private:
  const std::string& _internal_captionlanguage(int index) const;
  std::string* _internal_add_captionlanguage();
  public:

  // optional string duration = 2;
  bool has_duration() const;
  private:
  bool _internal_has_duration() const;
  public:
  void clear_duration();
  const std::string& duration() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_duration(ArgT0&& arg0, ArgT... args);
  std::string* mutable_duration();
  PROTOBUF_NODISCARD std::string* release_duration();
  void set_allocated_duration(std::string* duration);
  private:
  const std::string& _internal_duration() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_duration(const std::string& value);
  std::string* _internal_mutable_duration();
  public:

  // optional string releaseDate = 3;
  bool has_releasedate() const;
  private:
  bool _internal_has_releasedate() const;
  public:
  void clear_releasedate();
  const std::string& releasedate() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_releasedate(ArgT0&& arg0, ArgT... args);
  std::string* mutable_releasedate();
  PROTOBUF_NODISCARD std::string* release_releasedate();
  void set_allocated_releasedate(std::string* releasedate);
  private:
  const std::string& _internal_releasedate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_releasedate(const std::string& value);
  std::string* _internal_mutable_releasedate();
  public:

  // optional string contentRating = 4;
  bool has_contentrating() const;
  private:
  bool _internal_has_contentrating() const;
  public:
  void clear_contentrating();
  const std::string& contentrating() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contentrating(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contentrating();
  PROTOBUF_NODISCARD std::string* release_contentrating();
  void set_allocated_contentrating(std::string* contentrating);
  private:
  const std::string& _internal_contentrating() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contentrating(const std::string& value);
  std::string* _internal_mutable_contentrating();
  public:

  // optional int64 likes = 5;
  bool has_likes() const;
  private:
  bool _internal_has_likes() const;
  public:
  void clear_likes();
  int64_t likes() const;
  void set_likes(int64_t value);
  private:
  int64_t _internal_likes() const;
  void _internal_set_likes(int64_t value);
  public:

  // optional int64 dislikes = 6;
  bool has_dislikes() const;
  private:
  bool _internal_has_dislikes() const;
  public:
  void clear_dislikes();
  int64_t dislikes() const;
  void set_dislikes(int64_t value);
  private:
  int64_t _internal_dislikes() const;
  void _internal_set_dislikes(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.document.VideoDetails)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::VideoCredit > credit_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> genre_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::Trailer > trailer_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::VideoRentalTerm > rentalterm_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> audiolanguage_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> captionlanguage_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr duration_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr releasedate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contentrating_;
    int64_t likes_;
    int64_t dislikes_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fdocument_2eproto;
};
// -------------------------------------------------------------------

class VideoCredit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.document.VideoCredit) */ {
 public:
  inline VideoCredit() : VideoCredit(nullptr) {}
  ~VideoCredit() override;
  explicit PROTOBUF_CONSTEXPR VideoCredit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VideoCredit(const VideoCredit& from);
  VideoCredit(VideoCredit&& from) noexcept
    : VideoCredit() {
    *this = ::std::move(from);
  }

  inline VideoCredit& operator=(const VideoCredit& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoCredit& operator=(VideoCredit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VideoCredit& default_instance() {
    return *internal_default_instance();
  }
  static inline const VideoCredit* internal_default_instance() {
    return reinterpret_cast<const VideoCredit*>(
               &_VideoCredit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(VideoCredit& a, VideoCredit& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoCredit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoCredit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VideoCredit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VideoCredit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VideoCredit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VideoCredit& from) {
    VideoCredit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoCredit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.document.VideoCredit";
  }
  protected:
  explicit VideoCredit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 3,
    kCreditFieldNumber = 2,
    kCreditTypeFieldNumber = 1,
  };
  // repeated string name = 3;
  int name_size() const;
  private:
  int _internal_name_size() const;
  public:
  void clear_name();
  const std::string& name(int index) const;
  std::string* mutable_name(int index);
  void set_name(int index, const std::string& value);
  void set_name(int index, std::string&& value);
  void set_name(int index, const char* value);
  void set_name(int index, const char* value, size_t size);
  std::string* add_name();
  void add_name(const std::string& value);
  void add_name(std::string&& value);
  void add_name(const char* value);
  void add_name(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& name() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_name();
  private:
  const std::string& _internal_name(int index) const;
  std::string* _internal_add_name();
  public:

  // optional string credit = 2;
  bool has_credit() const;
  private:
  bool _internal_has_credit() const;
  public:
  void clear_credit();
  const std::string& credit() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_credit(ArgT0&& arg0, ArgT... args);
  std::string* mutable_credit();
  PROTOBUF_NODISCARD std::string* release_credit();
  void set_allocated_credit(std::string* credit);
  private:
  const std::string& _internal_credit() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_credit(const std::string& value);
  std::string* _internal_mutable_credit();
  public:

  // optional int32 creditType = 1;
  bool has_credittype() const;
  private:
  bool _internal_has_credittype() const;
  public:
  void clear_credittype();
  int32_t credittype() const;
  void set_credittype(int32_t value);
  private:
  int32_t _internal_credittype() const;
  void _internal_set_credittype(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.document.VideoCredit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr credit_;
    int32_t credittype_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fdocument_2eproto;
};
// -------------------------------------------------------------------

class Trailer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.document.Trailer) */ {
 public:
  inline Trailer() : Trailer(nullptr) {}
  ~Trailer() override;
  explicit PROTOBUF_CONSTEXPR Trailer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Trailer(const Trailer& from);
  Trailer(Trailer&& from) noexcept
    : Trailer() {
    *this = ::std::move(from);
  }

  inline Trailer& operator=(const Trailer& from) {
    CopyFrom(from);
    return *this;
  }
  inline Trailer& operator=(Trailer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Trailer& default_instance() {
    return *internal_default_instance();
  }
  static inline const Trailer* internal_default_instance() {
    return reinterpret_cast<const Trailer*>(
               &_Trailer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(Trailer& a, Trailer& b) {
    a.Swap(&b);
  }
  inline void Swap(Trailer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Trailer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Trailer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Trailer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Trailer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Trailer& from) {
    Trailer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Trailer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.document.Trailer";
  }
  protected:
  explicit Trailer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrailerIdFieldNumber = 1,
    kTitleFieldNumber = 2,
    kThumbnailUrlFieldNumber = 3,
    kWatchUrlFieldNumber = 4,
    kDurationFieldNumber = 5,
  };
  // optional string trailerId = 1;
  bool has_trailerid() const;
  private:
  bool _internal_has_trailerid() const;
  public:
  void clear_trailerid();
  const std::string& trailerid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_trailerid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_trailerid();
  PROTOBUF_NODISCARD std::string* release_trailerid();
  void set_allocated_trailerid(std::string* trailerid);
  private:
  const std::string& _internal_trailerid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trailerid(const std::string& value);
  std::string* _internal_mutable_trailerid();
  public:

  // optional string title = 2;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // optional string thumbnailUrl = 3;
  bool has_thumbnailurl() const;
  private:
  bool _internal_has_thumbnailurl() const;
  public:
  void clear_thumbnailurl();
  const std::string& thumbnailurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_thumbnailurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_thumbnailurl();
  PROTOBUF_NODISCARD std::string* release_thumbnailurl();
  void set_allocated_thumbnailurl(std::string* thumbnailurl);
  private:
  const std::string& _internal_thumbnailurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_thumbnailurl(const std::string& value);
  std::string* _internal_mutable_thumbnailurl();
  public:

  // optional string watchUrl = 4;
  bool has_watchurl() const;
  private:
  bool _internal_has_watchurl() const;
  public:
  void clear_watchurl();
  const std::string& watchurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_watchurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_watchurl();
  PROTOBUF_NODISCARD std::string* release_watchurl();
  void set_allocated_watchurl(std::string* watchurl);
  private:
  const std::string& _internal_watchurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_watchurl(const std::string& value);
  std::string* _internal_mutable_watchurl();
  public:

  // optional string duration = 5;
  bool has_duration() const;
  private:
  bool _internal_has_duration() const;
  public:
  void clear_duration();
  const std::string& duration() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_duration(ArgT0&& arg0, ArgT... args);
  std::string* mutable_duration();
  PROTOBUF_NODISCARD std::string* release_duration();
  void set_allocated_duration(std::string* duration);
  private:
  const std::string& _internal_duration() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_duration(const std::string& value);
  std::string* _internal_mutable_duration();
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.document.Trailer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trailerid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr thumbnailurl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr watchurl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr duration_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fdocument_2eproto;
};
// -------------------------------------------------------------------

class VideoRentalTerm_Term final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.document.VideoRentalTerm.Term) */ {
 public:
  inline VideoRentalTerm_Term() : VideoRentalTerm_Term(nullptr) {}
  ~VideoRentalTerm_Term() override;
  explicit PROTOBUF_CONSTEXPR VideoRentalTerm_Term(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VideoRentalTerm_Term(const VideoRentalTerm_Term& from);
  VideoRentalTerm_Term(VideoRentalTerm_Term&& from) noexcept
    : VideoRentalTerm_Term() {
    *this = ::std::move(from);
  }

  inline VideoRentalTerm_Term& operator=(const VideoRentalTerm_Term& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoRentalTerm_Term& operator=(VideoRentalTerm_Term&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VideoRentalTerm_Term& default_instance() {
    return *internal_default_instance();
  }
  static inline const VideoRentalTerm_Term* internal_default_instance() {
    return reinterpret_cast<const VideoRentalTerm_Term*>(
               &_VideoRentalTerm_Term_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(VideoRentalTerm_Term& a, VideoRentalTerm_Term& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoRentalTerm_Term* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoRentalTerm_Term* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VideoRentalTerm_Term* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VideoRentalTerm_Term>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VideoRentalTerm_Term& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VideoRentalTerm_Term& from) {
    VideoRentalTerm_Term::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoRentalTerm_Term* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.document.VideoRentalTerm.Term";
  }
  protected:
  explicit VideoRentalTerm_Term(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 5,
    kBodyFieldNumber = 6,
  };
  // optional string header = 5;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const std::string& header() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_header(ArgT0&& arg0, ArgT... args);
  std::string* mutable_header();
  PROTOBUF_NODISCARD std::string* release_header();
  void set_allocated_header(std::string* header);
  private:
  const std::string& _internal_header() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_header(const std::string& value);
  std::string* _internal_mutable_header();
  public:

  // optional string body = 6;
  bool has_body() const;
  private:
  bool _internal_has_body() const;
  public:
  void clear_body();
  const std::string& body() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_body(ArgT0&& arg0, ArgT... args);
  std::string* mutable_body();
  PROTOBUF_NODISCARD std::string* release_body();
  void set_allocated_body(std::string* body);
  private:
  const std::string& _internal_body() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_body(const std::string& value);
  std::string* _internal_mutable_body();
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.document.VideoRentalTerm.Term)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr header_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr body_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fdocument_2eproto;
};
// -------------------------------------------------------------------

class VideoRentalTerm final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.document.VideoRentalTerm) */ {
 public:
  inline VideoRentalTerm() : VideoRentalTerm(nullptr) {}
  ~VideoRentalTerm() override;
  explicit PROTOBUF_CONSTEXPR VideoRentalTerm(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VideoRentalTerm(const VideoRentalTerm& from);
  VideoRentalTerm(VideoRentalTerm&& from) noexcept
    : VideoRentalTerm() {
    *this = ::std::move(from);
  }

  inline VideoRentalTerm& operator=(const VideoRentalTerm& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoRentalTerm& operator=(VideoRentalTerm&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VideoRentalTerm& default_instance() {
    return *internal_default_instance();
  }
  static inline const VideoRentalTerm* internal_default_instance() {
    return reinterpret_cast<const VideoRentalTerm*>(
               &_VideoRentalTerm_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(VideoRentalTerm& a, VideoRentalTerm& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoRentalTerm* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoRentalTerm* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VideoRentalTerm* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VideoRentalTerm>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VideoRentalTerm& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VideoRentalTerm& from) {
    VideoRentalTerm::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoRentalTerm* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.document.VideoRentalTerm";
  }
  protected:
  explicit VideoRentalTerm(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef VideoRentalTerm_Term Term;

  // accessors -------------------------------------------------------

  enum : int {
    kTermFieldNumber = 4,
    kOfferAbbreviationFieldNumber = 2,
    kRentalHeaderFieldNumber = 3,
    kOfferTypeFieldNumber = 1,
  };
  // repeated group Term = 4 { ... };
  int term_size() const;
  private:
  int _internal_term_size() const;
  public:
  void clear_term();
  ::playapi::proto::finsky::document::VideoRentalTerm_Term* mutable_term(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::VideoRentalTerm_Term >*
      mutable_term();
  private:
  const ::playapi::proto::finsky::document::VideoRentalTerm_Term& _internal_term(int index) const;
  ::playapi::proto::finsky::document::VideoRentalTerm_Term* _internal_add_term();
  public:
  const ::playapi::proto::finsky::document::VideoRentalTerm_Term& term(int index) const;
  ::playapi::proto::finsky::document::VideoRentalTerm_Term* add_term();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::VideoRentalTerm_Term >&
      term() const;

  // optional string offerAbbreviation = 2;
  bool has_offerabbreviation() const;
  private:
  bool _internal_has_offerabbreviation() const;
  public:
  void clear_offerabbreviation();
  const std::string& offerabbreviation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_offerabbreviation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_offerabbreviation();
  PROTOBUF_NODISCARD std::string* release_offerabbreviation();
  void set_allocated_offerabbreviation(std::string* offerabbreviation);
  private:
  const std::string& _internal_offerabbreviation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_offerabbreviation(const std::string& value);
  std::string* _internal_mutable_offerabbreviation();
  public:

  // optional string rentalHeader = 3;
  bool has_rentalheader() const;
  private:
  bool _internal_has_rentalheader() const;
  public:
  void clear_rentalheader();
  const std::string& rentalheader() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rentalheader(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rentalheader();
  PROTOBUF_NODISCARD std::string* release_rentalheader();
  void set_allocated_rentalheader(std::string* rentalheader);
  private:
  const std::string& _internal_rentalheader() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rentalheader(const std::string& value);
  std::string* _internal_mutable_rentalheader();
  public:

  // optional int32 offerType = 1;
  bool has_offertype() const;
  private:
  bool _internal_has_offertype() const;
  public:
  void clear_offertype();
  int32_t offertype() const;
  void set_offertype(int32_t value);
  private:
  int32_t _internal_offertype() const;
  void _internal_set_offertype(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.document.VideoRentalTerm)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::VideoRentalTerm_Term > term_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr offerabbreviation_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rentalheader_;
    int32_t offertype_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fdocument_2eproto;
};
// -------------------------------------------------------------------

class SubscriptionDetails final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.document.SubscriptionDetails) */ {
 public:
  inline SubscriptionDetails() : SubscriptionDetails(nullptr) {}
  ~SubscriptionDetails() override;
  explicit PROTOBUF_CONSTEXPR SubscriptionDetails(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscriptionDetails(const SubscriptionDetails& from);
  SubscriptionDetails(SubscriptionDetails&& from) noexcept
    : SubscriptionDetails() {
    *this = ::std::move(from);
  }

  inline SubscriptionDetails& operator=(const SubscriptionDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscriptionDetails& operator=(SubscriptionDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscriptionDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscriptionDetails* internal_default_instance() {
    return reinterpret_cast<const SubscriptionDetails*>(
               &_SubscriptionDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(SubscriptionDetails& a, SubscriptionDetails& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscriptionDetails* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscriptionDetails* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscriptionDetails* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscriptionDetails>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscriptionDetails& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubscriptionDetails& from) {
    SubscriptionDetails::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscriptionDetails* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.document.SubscriptionDetails";
  }
  protected:
  explicit SubscriptionDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubscriptionPeriodFieldNumber = 1,
  };
  // optional int32 subscriptionPeriod = 1;
  bool has_subscriptionperiod() const;
  private:
  bool _internal_has_subscriptionperiod() const;
  public:
  void clear_subscriptionperiod();
  int32_t subscriptionperiod() const;
  void set_subscriptionperiod(int32_t value);
  private:
  int32_t _internal_subscriptionperiod() const;
  void _internal_set_subscriptionperiod(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.document.SubscriptionDetails)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t subscriptionperiod_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fdocument_2eproto;
};
// -------------------------------------------------------------------

class MagazineDetails final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.document.MagazineDetails) */ {
 public:
  inline MagazineDetails() : MagazineDetails(nullptr) {}
  ~MagazineDetails() override;
  explicit PROTOBUF_CONSTEXPR MagazineDetails(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MagazineDetails(const MagazineDetails& from);
  MagazineDetails(MagazineDetails&& from) noexcept
    : MagazineDetails() {
    *this = ::std::move(from);
  }

  inline MagazineDetails& operator=(const MagazineDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline MagazineDetails& operator=(MagazineDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MagazineDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const MagazineDetails* internal_default_instance() {
    return reinterpret_cast<const MagazineDetails*>(
               &_MagazineDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(MagazineDetails& a, MagazineDetails& b) {
    a.Swap(&b);
  }
  inline void Swap(MagazineDetails* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MagazineDetails* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MagazineDetails* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MagazineDetails>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MagazineDetails& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MagazineDetails& from) {
    MagazineDetails::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MagazineDetails* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.document.MagazineDetails";
  }
  protected:
  explicit MagazineDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentDetailsUrlFieldNumber = 1,
    kDeviceAvailabilityDescriptionHtmlFieldNumber = 2,
    kPsvDescriptionFieldNumber = 3,
    kDeliveryFrequencyDescriptionFieldNumber = 4,
  };
  // optional string parentDetailsUrl = 1;
  bool has_parentdetailsurl() const;
  private:
  bool _internal_has_parentdetailsurl() const;
  public:
  void clear_parentdetailsurl();
  const std::string& parentdetailsurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parentdetailsurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parentdetailsurl();
  PROTOBUF_NODISCARD std::string* release_parentdetailsurl();
  void set_allocated_parentdetailsurl(std::string* parentdetailsurl);
  private:
  const std::string& _internal_parentdetailsurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parentdetailsurl(const std::string& value);
  std::string* _internal_mutable_parentdetailsurl();
  public:

  // optional string deviceAvailabilityDescriptionHtml = 2;
  bool has_deviceavailabilitydescriptionhtml() const;
  private:
  bool _internal_has_deviceavailabilitydescriptionhtml() const;
  public:
  void clear_deviceavailabilitydescriptionhtml();
  const std::string& deviceavailabilitydescriptionhtml() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_deviceavailabilitydescriptionhtml(ArgT0&& arg0, ArgT... args);
  std::string* mutable_deviceavailabilitydescriptionhtml();
  PROTOBUF_NODISCARD std::string* release_deviceavailabilitydescriptionhtml();
  void set_allocated_deviceavailabilitydescriptionhtml(std::string* deviceavailabilitydescriptionhtml);
  private:
  const std::string& _internal_deviceavailabilitydescriptionhtml() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deviceavailabilitydescriptionhtml(const std::string& value);
  std::string* _internal_mutable_deviceavailabilitydescriptionhtml();
  public:

  // optional string psvDescription = 3;
  bool has_psvdescription() const;
  private:
  bool _internal_has_psvdescription() const;
  public:
  void clear_psvdescription();
  const std::string& psvdescription() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_psvdescription(ArgT0&& arg0, ArgT... args);
  std::string* mutable_psvdescription();
  PROTOBUF_NODISCARD std::string* release_psvdescription();
  void set_allocated_psvdescription(std::string* psvdescription);
  private:
  const std::string& _internal_psvdescription() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_psvdescription(const std::string& value);
  std::string* _internal_mutable_psvdescription();
  public:

  // optional string deliveryFrequencyDescription = 4;
  bool has_deliveryfrequencydescription() const;
  private:
  bool _internal_has_deliveryfrequencydescription() const;
  public:
  void clear_deliveryfrequencydescription();
  const std::string& deliveryfrequencydescription() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_deliveryfrequencydescription(ArgT0&& arg0, ArgT... args);
  std::string* mutable_deliveryfrequencydescription();
  PROTOBUF_NODISCARD std::string* release_deliveryfrequencydescription();
  void set_allocated_deliveryfrequencydescription(std::string* deliveryfrequencydescription);
  private:
  const std::string& _internal_deliveryfrequencydescription() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deliveryfrequencydescription(const std::string& value);
  std::string* _internal_mutable_deliveryfrequencydescription();
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.document.MagazineDetails)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parentdetailsurl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deviceavailabilitydescriptionhtml_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr psvdescription_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deliveryfrequencydescription_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fdocument_2eproto;
};
// -------------------------------------------------------------------

class TvShowDetails final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.document.TvShowDetails) */ {
 public:
  inline TvShowDetails() : TvShowDetails(nullptr) {}
  ~TvShowDetails() override;
  explicit PROTOBUF_CONSTEXPR TvShowDetails(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TvShowDetails(const TvShowDetails& from);
  TvShowDetails(TvShowDetails&& from) noexcept
    : TvShowDetails() {
    *this = ::std::move(from);
  }

  inline TvShowDetails& operator=(const TvShowDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline TvShowDetails& operator=(TvShowDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TvShowDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const TvShowDetails* internal_default_instance() {
    return reinterpret_cast<const TvShowDetails*>(
               &_TvShowDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(TvShowDetails& a, TvShowDetails& b) {
    a.Swap(&b);
  }
  inline void Swap(TvShowDetails* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TvShowDetails* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TvShowDetails* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TvShowDetails>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TvShowDetails& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TvShowDetails& from) {
    TvShowDetails::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TvShowDetails* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.document.TvShowDetails";
  }
  protected:
  explicit TvShowDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBroadcasterFieldNumber = 4,
    kSeasonCountFieldNumber = 1,
    kStartYearFieldNumber = 2,
    kEndYearFieldNumber = 3,
  };
  // optional string broadcaster = 4;
  bool has_broadcaster() const;
  private:
  bool _internal_has_broadcaster() const;
  public:
  void clear_broadcaster();
  const std::string& broadcaster() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_broadcaster(ArgT0&& arg0, ArgT... args);
  std::string* mutable_broadcaster();
  PROTOBUF_NODISCARD std::string* release_broadcaster();
  void set_allocated_broadcaster(std::string* broadcaster);
  private:
  const std::string& _internal_broadcaster() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_broadcaster(const std::string& value);
  std::string* _internal_mutable_broadcaster();
  public:

  // optional int32 seasonCount = 1;
  bool has_seasoncount() const;
  private:
  bool _internal_has_seasoncount() const;
  public:
  void clear_seasoncount();
  int32_t seasoncount() const;
  void set_seasoncount(int32_t value);
  private:
  int32_t _internal_seasoncount() const;
  void _internal_set_seasoncount(int32_t value);
  public:

  // optional int32 startYear = 2;
  bool has_startyear() const;
  private:
  bool _internal_has_startyear() const;
  public:
  void clear_startyear();
  int32_t startyear() const;
  void set_startyear(int32_t value);
  private:
  int32_t _internal_startyear() const;
  void _internal_set_startyear(int32_t value);
  public:

  // optional int32 endYear = 3;
  bool has_endyear() const;
  private:
  bool _internal_has_endyear() const;
  public:
  void clear_endyear();
  int32_t endyear() const;
  void set_endyear(int32_t value);
  private:
  int32_t _internal_endyear() const;
  void _internal_set_endyear(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.document.TvShowDetails)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr broadcaster_;
    int32_t seasoncount_;
    int32_t startyear_;
    int32_t endyear_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fdocument_2eproto;
};
// -------------------------------------------------------------------

class TvSeasonDetails final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.document.TvSeasonDetails) */ {
 public:
  inline TvSeasonDetails() : TvSeasonDetails(nullptr) {}
  ~TvSeasonDetails() override;
  explicit PROTOBUF_CONSTEXPR TvSeasonDetails(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TvSeasonDetails(const TvSeasonDetails& from);
  TvSeasonDetails(TvSeasonDetails&& from) noexcept
    : TvSeasonDetails() {
    *this = ::std::move(from);
  }

  inline TvSeasonDetails& operator=(const TvSeasonDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline TvSeasonDetails& operator=(TvSeasonDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TvSeasonDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const TvSeasonDetails* internal_default_instance() {
    return reinterpret_cast<const TvSeasonDetails*>(
               &_TvSeasonDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(TvSeasonDetails& a, TvSeasonDetails& b) {
    a.Swap(&b);
  }
  inline void Swap(TvSeasonDetails* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TvSeasonDetails* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TvSeasonDetails* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TvSeasonDetails>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TvSeasonDetails& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TvSeasonDetails& from) {
    TvSeasonDetails::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TvSeasonDetails* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.document.TvSeasonDetails";
  }
  protected:
  explicit TvSeasonDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentDetailsUrlFieldNumber = 1,
    kReleaseDateFieldNumber = 3,
    kBroadcasterFieldNumber = 4,
    kSeasonIndexFieldNumber = 2,
    kEpisodeCountFieldNumber = 5,
    kExpectedEpisodeCountFieldNumber = 6,
    kInProgressFieldNumber = 7,
  };
  // optional string parentDetailsUrl = 1;
  bool has_parentdetailsurl() const;
  private:
  bool _internal_has_parentdetailsurl() const;
  public:
  void clear_parentdetailsurl();
  const std::string& parentdetailsurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parentdetailsurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parentdetailsurl();
  PROTOBUF_NODISCARD std::string* release_parentdetailsurl();
  void set_allocated_parentdetailsurl(std::string* parentdetailsurl);
  private:
  const std::string& _internal_parentdetailsurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parentdetailsurl(const std::string& value);
  std::string* _internal_mutable_parentdetailsurl();
  public:

  // optional string releaseDate = 3;
  bool has_releasedate() const;
  private:
  bool _internal_has_releasedate() const;
  public:
  void clear_releasedate();
  const std::string& releasedate() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_releasedate(ArgT0&& arg0, ArgT... args);
  std::string* mutable_releasedate();
  PROTOBUF_NODISCARD std::string* release_releasedate();
  void set_allocated_releasedate(std::string* releasedate);
  private:
  const std::string& _internal_releasedate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_releasedate(const std::string& value);
  std::string* _internal_mutable_releasedate();
  public:

  // optional string broadcaster = 4;
  bool has_broadcaster() const;
  private:
  bool _internal_has_broadcaster() const;
  public:
  void clear_broadcaster();
  const std::string& broadcaster() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_broadcaster(ArgT0&& arg0, ArgT... args);
  std::string* mutable_broadcaster();
  PROTOBUF_NODISCARD std::string* release_broadcaster();
  void set_allocated_broadcaster(std::string* broadcaster);
  private:
  const std::string& _internal_broadcaster() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_broadcaster(const std::string& value);
  std::string* _internal_mutable_broadcaster();
  public:

  // optional int32 seasonIndex = 2;
  bool has_seasonindex() const;
  private:
  bool _internal_has_seasonindex() const;
  public:
  void clear_seasonindex();
  int32_t seasonindex() const;
  void set_seasonindex(int32_t value);
  private:
  int32_t _internal_seasonindex() const;
  void _internal_set_seasonindex(int32_t value);
  public:

  // optional int32 episodeCount = 5;
  bool has_episodecount() const;
  private:
  bool _internal_has_episodecount() const;
  public:
  void clear_episodecount();
  int32_t episodecount() const;
  void set_episodecount(int32_t value);
  private:
  int32_t _internal_episodecount() const;
  void _internal_set_episodecount(int32_t value);
  public:

  // optional int32 expectedEpisodeCount = 6;
  bool has_expectedepisodecount() const;
  private:
  bool _internal_has_expectedepisodecount() const;
  public:
  void clear_expectedepisodecount();
  int32_t expectedepisodecount() const;
  void set_expectedepisodecount(int32_t value);
  private:
  int32_t _internal_expectedepisodecount() const;
  void _internal_set_expectedepisodecount(int32_t value);
  public:

  // optional bool inProgress = 7;
  bool has_inprogress() const;
  private:
  bool _internal_has_inprogress() const;
  public:
  void clear_inprogress();
  bool inprogress() const;
  void set_inprogress(bool value);
  private:
  bool _internal_inprogress() const;
  void _internal_set_inprogress(bool value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.document.TvSeasonDetails)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parentdetailsurl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr releasedate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr broadcaster_;
    int32_t seasonindex_;
    int32_t episodecount_;
    int32_t expectedepisodecount_;
    bool inprogress_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fdocument_2eproto;
};
// -------------------------------------------------------------------

class TvEpisodeDetails final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.document.TvEpisodeDetails) */ {
 public:
  inline TvEpisodeDetails() : TvEpisodeDetails(nullptr) {}
  ~TvEpisodeDetails() override;
  explicit PROTOBUF_CONSTEXPR TvEpisodeDetails(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TvEpisodeDetails(const TvEpisodeDetails& from);
  TvEpisodeDetails(TvEpisodeDetails&& from) noexcept
    : TvEpisodeDetails() {
    *this = ::std::move(from);
  }

  inline TvEpisodeDetails& operator=(const TvEpisodeDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline TvEpisodeDetails& operator=(TvEpisodeDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TvEpisodeDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const TvEpisodeDetails* internal_default_instance() {
    return reinterpret_cast<const TvEpisodeDetails*>(
               &_TvEpisodeDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(TvEpisodeDetails& a, TvEpisodeDetails& b) {
    a.Swap(&b);
  }
  inline void Swap(TvEpisodeDetails* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TvEpisodeDetails* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TvEpisodeDetails* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TvEpisodeDetails>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TvEpisodeDetails& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TvEpisodeDetails& from) {
    TvEpisodeDetails::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TvEpisodeDetails* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.document.TvEpisodeDetails";
  }
  protected:
  explicit TvEpisodeDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentDetailsUrlFieldNumber = 1,
    kReleaseDateFieldNumber = 3,
    kEpisodeIndexFieldNumber = 2,
  };
  // optional string parentDetailsUrl = 1;
  bool has_parentdetailsurl() const;
  private:
  bool _internal_has_parentdetailsurl() const;
  public:
  void clear_parentdetailsurl();
  const std::string& parentdetailsurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parentdetailsurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parentdetailsurl();
  PROTOBUF_NODISCARD std::string* release_parentdetailsurl();
  void set_allocated_parentdetailsurl(std::string* parentdetailsurl);
  private:
  const std::string& _internal_parentdetailsurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parentdetailsurl(const std::string& value);
  std::string* _internal_mutable_parentdetailsurl();
  public:

  // optional string releaseDate = 3;
  bool has_releasedate() const;
  private:
  bool _internal_has_releasedate() const;
  public:
  void clear_releasedate();
  const std::string& releasedate() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_releasedate(ArgT0&& arg0, ArgT... args);
  std::string* mutable_releasedate();
  PROTOBUF_NODISCARD std::string* release_releasedate();
  void set_allocated_releasedate(std::string* releasedate);
  private:
  const std::string& _internal_releasedate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_releasedate(const std::string& value);
  std::string* _internal_mutable_releasedate();
  public:

  // optional int32 episodeIndex = 2;
  bool has_episodeindex() const;
  private:
  bool _internal_has_episodeindex() const;
  public:
  void clear_episodeindex();
  int32_t episodeindex() const;
  void set_episodeindex(int32_t value);
  private:
  int32_t _internal_episodeindex() const;
  void _internal_set_episodeindex(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.document.TvEpisodeDetails)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parentdetailsurl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr releasedate_;
    int32_t episodeindex_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fdocument_2eproto;
};
// -------------------------------------------------------------------

class PersonDetails final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.document.PersonDetails) */ {
 public:
  inline PersonDetails() : PersonDetails(nullptr) {}
  ~PersonDetails() override;
  explicit PROTOBUF_CONSTEXPR PersonDetails(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PersonDetails(const PersonDetails& from);
  PersonDetails(PersonDetails&& from) noexcept
    : PersonDetails() {
    *this = ::std::move(from);
  }

  inline PersonDetails& operator=(const PersonDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline PersonDetails& operator=(PersonDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PersonDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const PersonDetails* internal_default_instance() {
    return reinterpret_cast<const PersonDetails*>(
               &_PersonDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(PersonDetails& a, PersonDetails& b) {
    a.Swap(&b);
  }
  inline void Swap(PersonDetails* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PersonDetails* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PersonDetails* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PersonDetails>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PersonDetails& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PersonDetails& from) {
    PersonDetails::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PersonDetails* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.document.PersonDetails";
  }
  protected:
  explicit PersonDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPersonIsRequesterFieldNumber = 1,
    kIsGplusUserFieldNumber = 2,
  };
  // optional bool personIsRequester = 1;
  bool has_personisrequester() const;
  private:
  bool _internal_has_personisrequester() const;
  public:
  void clear_personisrequester();
  bool personisrequester() const;
  void set_personisrequester(bool value);
  private:
  bool _internal_personisrequester() const;
  void _internal_set_personisrequester(bool value);
  public:

  // optional bool isGplusUser = 2;
  bool has_isgplususer() const;
  private:
  bool _internal_has_isgplususer() const;
  public:
  void clear_isgplususer();
  bool isgplususer() const;
  void set_isgplususer(bool value);
  private:
  bool _internal_isgplususer() const;
  void _internal_set_isgplususer(bool value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.document.PersonDetails)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool personisrequester_;
    bool isgplususer_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fdocument_2eproto;
};
// -------------------------------------------------------------------

class TalentDetails final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.document.TalentDetails) */ {
 public:
  inline TalentDetails() : TalentDetails(nullptr) {}
  ~TalentDetails() override;
  explicit PROTOBUF_CONSTEXPR TalentDetails(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TalentDetails(const TalentDetails& from);
  TalentDetails(TalentDetails&& from) noexcept
    : TalentDetails() {
    *this = ::std::move(from);
  }

  inline TalentDetails& operator=(const TalentDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline TalentDetails& operator=(TalentDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TalentDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const TalentDetails* internal_default_instance() {
    return reinterpret_cast<const TalentDetails*>(
               &_TalentDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(TalentDetails& a, TalentDetails& b) {
    a.Swap(&b);
  }
  inline void Swap(TalentDetails* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TalentDetails* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TalentDetails* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TalentDetails>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TalentDetails& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TalentDetails& from) {
    TalentDetails::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TalentDetails* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.document.TalentDetails";
  }
  protected:
  explicit TalentDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExternalLinksFieldNumber = 1,
    kPrimaryRoleIdFieldNumber = 2,
  };
  // optional .playapi.proto.finsky.document.TalentExternalLinks externalLinks = 1;
  bool has_externallinks() const;
  private:
  bool _internal_has_externallinks() const;
  public:
  void clear_externallinks();
  const ::playapi::proto::finsky::document::TalentExternalLinks& externallinks() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::TalentExternalLinks* release_externallinks();
  ::playapi::proto::finsky::document::TalentExternalLinks* mutable_externallinks();
  void set_allocated_externallinks(::playapi::proto::finsky::document::TalentExternalLinks* externallinks);
  private:
  const ::playapi::proto::finsky::document::TalentExternalLinks& _internal_externallinks() const;
  ::playapi::proto::finsky::document::TalentExternalLinks* _internal_mutable_externallinks();
  public:
  void unsafe_arena_set_allocated_externallinks(
      ::playapi::proto::finsky::document::TalentExternalLinks* externallinks);
  ::playapi::proto::finsky::document::TalentExternalLinks* unsafe_arena_release_externallinks();

  // optional int32 primaryRoleId = 2;
  bool has_primaryroleid() const;
  private:
  bool _internal_has_primaryroleid() const;
  public:
  void clear_primaryroleid();
  int32_t primaryroleid() const;
  void set_primaryroleid(int32_t value);
  private:
  int32_t _internal_primaryroleid() const;
  void _internal_set_primaryroleid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.document.TalentDetails)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::playapi::proto::finsky::document::TalentExternalLinks* externallinks_;
    int32_t primaryroleid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fdocument_2eproto;
};
// -------------------------------------------------------------------

class TalentExternalLinks final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.document.TalentExternalLinks) */ {
 public:
  inline TalentExternalLinks() : TalentExternalLinks(nullptr) {}
  ~TalentExternalLinks() override;
  explicit PROTOBUF_CONSTEXPR TalentExternalLinks(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TalentExternalLinks(const TalentExternalLinks& from);
  TalentExternalLinks(TalentExternalLinks&& from) noexcept
    : TalentExternalLinks() {
    *this = ::std::move(from);
  }

  inline TalentExternalLinks& operator=(const TalentExternalLinks& from) {
    CopyFrom(from);
    return *this;
  }
  inline TalentExternalLinks& operator=(TalentExternalLinks&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TalentExternalLinks& default_instance() {
    return *internal_default_instance();
  }
  static inline const TalentExternalLinks* internal_default_instance() {
    return reinterpret_cast<const TalentExternalLinks*>(
               &_TalentExternalLinks_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(TalentExternalLinks& a, TalentExternalLinks& b) {
    a.Swap(&b);
  }
  inline void Swap(TalentExternalLinks* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TalentExternalLinks* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TalentExternalLinks* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TalentExternalLinks>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TalentExternalLinks& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TalentExternalLinks& from) {
    TalentExternalLinks::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TalentExternalLinks* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.document.TalentExternalLinks";
  }
  protected:
  explicit TalentExternalLinks(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWebsiteUrlFieldNumber = 1,
    kGooglePlusProfileUrlFieldNumber = 2,
    kYoutubeChannelUrlFieldNumber = 3,
  };
  // repeated .playapi.proto.finsky.link.Link websiteUrl = 1;
  int websiteurl_size() const;
  private:
  int _internal_websiteurl_size() const;
  public:
  void clear_websiteurl();
  ::playapi::proto::finsky::link::Link* mutable_websiteurl(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::link::Link >*
      mutable_websiteurl();
  private:
  const ::playapi::proto::finsky::link::Link& _internal_websiteurl(int index) const;
  ::playapi::proto::finsky::link::Link* _internal_add_websiteurl();
  public:
  const ::playapi::proto::finsky::link::Link& websiteurl(int index) const;
  ::playapi::proto::finsky::link::Link* add_websiteurl();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::link::Link >&
      websiteurl() const;

  // optional .playapi.proto.finsky.link.Link googlePlusProfileUrl = 2;
  bool has_googleplusprofileurl() const;
  private:
  bool _internal_has_googleplusprofileurl() const;
  public:
  void clear_googleplusprofileurl();
  const ::playapi::proto::finsky::link::Link& googleplusprofileurl() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::link::Link* release_googleplusprofileurl();
  ::playapi::proto::finsky::link::Link* mutable_googleplusprofileurl();
  void set_allocated_googleplusprofileurl(::playapi::proto::finsky::link::Link* googleplusprofileurl);
  private:
  const ::playapi::proto::finsky::link::Link& _internal_googleplusprofileurl() const;
  ::playapi::proto::finsky::link::Link* _internal_mutable_googleplusprofileurl();
  public:
  void unsafe_arena_set_allocated_googleplusprofileurl(
      ::playapi::proto::finsky::link::Link* googleplusprofileurl);
  ::playapi::proto::finsky::link::Link* unsafe_arena_release_googleplusprofileurl();

  // optional .playapi.proto.finsky.link.Link youtubeChannelUrl = 3;
  bool has_youtubechannelurl() const;
  private:
  bool _internal_has_youtubechannelurl() const;
  public:
  void clear_youtubechannelurl();
  const ::playapi::proto::finsky::link::Link& youtubechannelurl() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::link::Link* release_youtubechannelurl();
  ::playapi::proto::finsky::link::Link* mutable_youtubechannelurl();
  void set_allocated_youtubechannelurl(::playapi::proto::finsky::link::Link* youtubechannelurl);
  private:
  const ::playapi::proto::finsky::link::Link& _internal_youtubechannelurl() const;
  ::playapi::proto::finsky::link::Link* _internal_mutable_youtubechannelurl();
  public:
  void unsafe_arena_set_allocated_youtubechannelurl(
      ::playapi::proto::finsky::link::Link* youtubechannelurl);
  ::playapi::proto::finsky::link::Link* unsafe_arena_release_youtubechannelurl();

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.document.TalentExternalLinks)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::link::Link > websiteurl_;
    ::playapi::proto::finsky::link::Link* googleplusprofileurl_;
    ::playapi::proto::finsky::link::Link* youtubechannelurl_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fdocument_2eproto;
};
// -------------------------------------------------------------------

class DeveloperDetails final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.document.DeveloperDetails) */ {
 public:
  inline DeveloperDetails() : DeveloperDetails(nullptr) {}
  ~DeveloperDetails() override;
  explicit PROTOBUF_CONSTEXPR DeveloperDetails(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeveloperDetails(const DeveloperDetails& from);
  DeveloperDetails(DeveloperDetails&& from) noexcept
    : DeveloperDetails() {
    *this = ::std::move(from);
  }

  inline DeveloperDetails& operator=(const DeveloperDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeveloperDetails& operator=(DeveloperDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeveloperDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeveloperDetails* internal_default_instance() {
    return reinterpret_cast<const DeveloperDetails*>(
               &_DeveloperDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(DeveloperDetails& a, DeveloperDetails& b) {
    a.Swap(&b);
  }
  inline void Swap(DeveloperDetails* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeveloperDetails* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeveloperDetails* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeveloperDetails>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeveloperDetails& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeveloperDetails& from) {
    DeveloperDetails::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeveloperDetails* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.document.DeveloperDetails";
  }
  protected:
  explicit DeveloperDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWebsiteUrlFieldNumber = 1,
  };
  // optional string websiteUrl = 1;
  bool has_websiteurl() const;
  private:
  bool _internal_has_websiteurl() const;
  public:
  void clear_websiteurl();
  const std::string& websiteurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_websiteurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_websiteurl();
  PROTOBUF_NODISCARD std::string* release_websiteurl();
  void set_allocated_websiteurl(std::string* websiteurl);
  private:
  const std::string& _internal_websiteurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_websiteurl(const std::string& value);
  std::string* _internal_mutable_websiteurl();
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.document.DeveloperDetails)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr websiteurl_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fdocument_2eproto;
};
// -------------------------------------------------------------------

class BookSeriesDetails final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.document.BookSeriesDetails) */ {
 public:
  inline BookSeriesDetails() : BookSeriesDetails(nullptr) {}
  ~BookSeriesDetails() override;
  explicit PROTOBUF_CONSTEXPR BookSeriesDetails(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BookSeriesDetails(const BookSeriesDetails& from);
  BookSeriesDetails(BookSeriesDetails&& from) noexcept
    : BookSeriesDetails() {
    *this = ::std::move(from);
  }

  inline BookSeriesDetails& operator=(const BookSeriesDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline BookSeriesDetails& operator=(BookSeriesDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BookSeriesDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const BookSeriesDetails* internal_default_instance() {
    return reinterpret_cast<const BookSeriesDetails*>(
               &_BookSeriesDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(BookSeriesDetails& a, BookSeriesDetails& b) {
    a.Swap(&b);
  }
  inline void Swap(BookSeriesDetails* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BookSeriesDetails* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BookSeriesDetails* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BookSeriesDetails>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BookSeriesDetails& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BookSeriesDetails& from) {
    BookSeriesDetails::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BookSeriesDetails* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.document.BookSeriesDetails";
  }
  protected:
  explicit BookSeriesDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublisherFieldNumber = 1,
    kSeriesCompositionFieldNumber = 2,
    kSeriesCardCompositionFieldNumber = 3,
  };
  // optional string publisher = 1;
  bool has_publisher() const;
  private:
  bool _internal_has_publisher() const;
  public:
  void clear_publisher();
  const std::string& publisher() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_publisher(ArgT0&& arg0, ArgT... args);
  std::string* mutable_publisher();
  PROTOBUF_NODISCARD std::string* release_publisher();
  void set_allocated_publisher(std::string* publisher);
  private:
  const std::string& _internal_publisher() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_publisher(const std::string& value);
  std::string* _internal_mutable_publisher();
  public:

  // optional string seriesComposition = 2;
  bool has_seriescomposition() const;
  private:
  bool _internal_has_seriescomposition() const;
  public:
  void clear_seriescomposition();
  const std::string& seriescomposition() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_seriescomposition(ArgT0&& arg0, ArgT... args);
  std::string* mutable_seriescomposition();
  PROTOBUF_NODISCARD std::string* release_seriescomposition();
  void set_allocated_seriescomposition(std::string* seriescomposition);
  private:
  const std::string& _internal_seriescomposition() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_seriescomposition(const std::string& value);
  std::string* _internal_mutable_seriescomposition();
  public:

  // optional string seriesCardComposition = 3;
  bool has_seriescardcomposition() const;
  private:
  bool _internal_has_seriescardcomposition() const;
  public:
  void clear_seriescardcomposition();
  const std::string& seriescardcomposition() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_seriescardcomposition(ArgT0&& arg0, ArgT... args);
  std::string* mutable_seriescardcomposition();
  PROTOBUF_NODISCARD std::string* release_seriescardcomposition();
  void set_allocated_seriescardcomposition(std::string* seriescardcomposition);
  private:
  const std::string& _internal_seriescardcomposition() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_seriescardcomposition(const std::string& value);
  std::string* _internal_mutable_seriescardcomposition();
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.document.BookSeriesDetails)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr publisher_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr seriescomposition_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr seriescardcomposition_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fdocument_2eproto;
};
// -------------------------------------------------------------------

class AggregateRating final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.document.AggregateRating) */ {
 public:
  inline AggregateRating() : AggregateRating(nullptr) {}
  ~AggregateRating() override;
  explicit PROTOBUF_CONSTEXPR AggregateRating(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AggregateRating(const AggregateRating& from);
  AggregateRating(AggregateRating&& from) noexcept
    : AggregateRating() {
    *this = ::std::move(from);
  }

  inline AggregateRating& operator=(const AggregateRating& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggregateRating& operator=(AggregateRating&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggregateRating& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggregateRating* internal_default_instance() {
    return reinterpret_cast<const AggregateRating*>(
               &_AggregateRating_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(AggregateRating& a, AggregateRating& b) {
    a.Swap(&b);
  }
  inline void Swap(AggregateRating* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggregateRating* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggregateRating* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggregateRating>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AggregateRating& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AggregateRating& from) {
    AggregateRating::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AggregateRating* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.document.AggregateRating";
  }
  protected:
  explicit AggregateRating(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTipFieldNumber = 13,
    kTypeFieldNumber = 1,
    kStarRatingFieldNumber = 2,
    kRatingsCountFieldNumber = 3,
    kOneStarRatingsFieldNumber = 4,
    kTwoStarRatingsFieldNumber = 5,
    kThreeStarRatingsFieldNumber = 6,
    kFourStarRatingsFieldNumber = 7,
    kFiveStarRatingsFieldNumber = 8,
    kThumbsUpCountFieldNumber = 9,
    kThumbsDownCountFieldNumber = 10,
    kCommentCountFieldNumber = 11,
    kBayesianMeanRatingFieldNumber = 12,
  };
  // repeated .playapi.proto.finsky.document.AggregateRatingTip tip = 13;
  int tip_size() const;
  private:
  int _internal_tip_size() const;
  public:
  void clear_tip();
  ::playapi::proto::finsky::document::AggregateRatingTip* mutable_tip(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::AggregateRatingTip >*
      mutable_tip();
  private:
  const ::playapi::proto::finsky::document::AggregateRatingTip& _internal_tip(int index) const;
  ::playapi::proto::finsky::document::AggregateRatingTip* _internal_add_tip();
  public:
  const ::playapi::proto::finsky::document::AggregateRatingTip& tip(int index) const;
  ::playapi::proto::finsky::document::AggregateRatingTip* add_tip();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::AggregateRatingTip >&
      tip() const;

  // optional int32 type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  int32_t type() const;
  void set_type(int32_t value);
  private:
  int32_t _internal_type() const;
  void _internal_set_type(int32_t value);
  public:

  // optional float starRating = 2;
  bool has_starrating() const;
  private:
  bool _internal_has_starrating() const;
  public:
  void clear_starrating();
  float starrating() const;
  void set_starrating(float value);
  private:
  float _internal_starrating() const;
  void _internal_set_starrating(float value);
  public:

  // optional int64 ratingsCount = 3;
  bool has_ratingscount() const;
  private:
  bool _internal_has_ratingscount() const;
  public:
  void clear_ratingscount();
  int64_t ratingscount() const;
  void set_ratingscount(int64_t value);
  private:
  int64_t _internal_ratingscount() const;
  void _internal_set_ratingscount(int64_t value);
  public:

  // optional int64 oneStarRatings = 4;
  bool has_onestarratings() const;
  private:
  bool _internal_has_onestarratings() const;
  public:
  void clear_onestarratings();
  int64_t onestarratings() const;
  void set_onestarratings(int64_t value);
  private:
  int64_t _internal_onestarratings() const;
  void _internal_set_onestarratings(int64_t value);
  public:

  // optional int64 twoStarRatings = 5;
  bool has_twostarratings() const;
  private:
  bool _internal_has_twostarratings() const;
  public:
  void clear_twostarratings();
  int64_t twostarratings() const;
  void set_twostarratings(int64_t value);
  private:
  int64_t _internal_twostarratings() const;
  void _internal_set_twostarratings(int64_t value);
  public:

  // optional int64 threeStarRatings = 6;
  bool has_threestarratings() const;
  private:
  bool _internal_has_threestarratings() const;
  public:
  void clear_threestarratings();
  int64_t threestarratings() const;
  void set_threestarratings(int64_t value);
  private:
  int64_t _internal_threestarratings() const;
  void _internal_set_threestarratings(int64_t value);
  public:

  // optional int64 fourStarRatings = 7;
  bool has_fourstarratings() const;
  private:
  bool _internal_has_fourstarratings() const;
  public:
  void clear_fourstarratings();
  int64_t fourstarratings() const;
  void set_fourstarratings(int64_t value);
  private:
  int64_t _internal_fourstarratings() const;
  void _internal_set_fourstarratings(int64_t value);
  public:

  // optional int64 fiveStarRatings = 8;
  bool has_fivestarratings() const;
  private:
  bool _internal_has_fivestarratings() const;
  public:
  void clear_fivestarratings();
  int64_t fivestarratings() const;
  void set_fivestarratings(int64_t value);
  private:
  int64_t _internal_fivestarratings() const;
  void _internal_set_fivestarratings(int64_t value);
  public:

  // optional int64 thumbsUpCount = 9;
  bool has_thumbsupcount() const;
  private:
  bool _internal_has_thumbsupcount() const;
  public:
  void clear_thumbsupcount();
  int64_t thumbsupcount() const;
  void set_thumbsupcount(int64_t value);
  private:
  int64_t _internal_thumbsupcount() const;
  void _internal_set_thumbsupcount(int64_t value);
  public:

  // optional int64 thumbsDownCount = 10;
  bool has_thumbsdowncount() const;
  private:
  bool _internal_has_thumbsdowncount() const;
  public:
  void clear_thumbsdowncount();
  int64_t thumbsdowncount() const;
  void set_thumbsdowncount(int64_t value);
  private:
  int64_t _internal_thumbsdowncount() const;
  void _internal_set_thumbsdowncount(int64_t value);
  public:

  // optional int64 commentCount = 11;
  bool has_commentcount() const;
  private:
  bool _internal_has_commentcount() const;
  public:
  void clear_commentcount();
  int64_t commentcount() const;
  void set_commentcount(int64_t value);
  private:
  int64_t _internal_commentcount() const;
  void _internal_set_commentcount(int64_t value);
  public:

  // optional double bayesianMeanRating = 12;
  bool has_bayesianmeanrating() const;
  private:
  bool _internal_has_bayesianmeanrating() const;
  public:
  void clear_bayesianmeanrating();
  double bayesianmeanrating() const;
  void set_bayesianmeanrating(double value);
  private:
  double _internal_bayesianmeanrating() const;
  void _internal_set_bayesianmeanrating(double value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.document.AggregateRating)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::AggregateRatingTip > tip_;
    int32_t type_;
    float starrating_;
    int64_t ratingscount_;
    int64_t onestarratings_;
    int64_t twostarratings_;
    int64_t threestarratings_;
    int64_t fourstarratings_;
    int64_t fivestarratings_;
    int64_t thumbsupcount_;
    int64_t thumbsdowncount_;
    int64_t commentcount_;
    double bayesianmeanrating_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fdocument_2eproto;
};
// -------------------------------------------------------------------

class AggregateRatingTip final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.document.AggregateRatingTip) */ {
 public:
  inline AggregateRatingTip() : AggregateRatingTip(nullptr) {}
  ~AggregateRatingTip() override;
  explicit PROTOBUF_CONSTEXPR AggregateRatingTip(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AggregateRatingTip(const AggregateRatingTip& from);
  AggregateRatingTip(AggregateRatingTip&& from) noexcept
    : AggregateRatingTip() {
    *this = ::std::move(from);
  }

  inline AggregateRatingTip& operator=(const AggregateRatingTip& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggregateRatingTip& operator=(AggregateRatingTip&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggregateRatingTip& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggregateRatingTip* internal_default_instance() {
    return reinterpret_cast<const AggregateRatingTip*>(
               &_AggregateRatingTip_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(AggregateRatingTip& a, AggregateRatingTip& b) {
    a.Swap(&b);
  }
  inline void Swap(AggregateRatingTip* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggregateRatingTip* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggregateRatingTip* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggregateRatingTip>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AggregateRatingTip& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AggregateRatingTip& from) {
    AggregateRatingTip::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AggregateRatingTip* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.document.AggregateRatingTip";
  }
  protected:
  explicit AggregateRatingTip(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSnippetReviewIdFieldNumber = 6,
    kTipIdFieldNumber = 1,
    kTextFieldNumber = 2,
    kLanguageFieldNumber = 5,
    kReviewCountFieldNumber = 4,
    kPolarityFieldNumber = 3,
  };
  // repeated string snippetReviewId = 6;
  int snippetreviewid_size() const;
  private:
  int _internal_snippetreviewid_size() const;
  public:
  void clear_snippetreviewid();
  const std::string& snippetreviewid(int index) const;
  std::string* mutable_snippetreviewid(int index);
  void set_snippetreviewid(int index, const std::string& value);
  void set_snippetreviewid(int index, std::string&& value);
  void set_snippetreviewid(int index, const char* value);
  void set_snippetreviewid(int index, const char* value, size_t size);
  std::string* add_snippetreviewid();
  void add_snippetreviewid(const std::string& value);
  void add_snippetreviewid(std::string&& value);
  void add_snippetreviewid(const char* value);
  void add_snippetreviewid(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& snippetreviewid() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_snippetreviewid();
  private:
  const std::string& _internal_snippetreviewid(int index) const;
  std::string* _internal_add_snippetreviewid();
  public:

  // optional string tipId = 1;
  bool has_tipid() const;
  private:
  bool _internal_has_tipid() const;
  public:
  void clear_tipid();
  const std::string& tipid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tipid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tipid();
  PROTOBUF_NODISCARD std::string* release_tipid();
  void set_allocated_tipid(std::string* tipid);
  private:
  const std::string& _internal_tipid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tipid(const std::string& value);
  std::string* _internal_mutable_tipid();
  public:

  // optional string text = 2;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // optional string language = 5;
  bool has_language() const;
  private:
  bool _internal_has_language() const;
  public:
  void clear_language();
  const std::string& language() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language();
  PROTOBUF_NODISCARD std::string* release_language();
  void set_allocated_language(std::string* language);
  private:
  const std::string& _internal_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(const std::string& value);
  std::string* _internal_mutable_language();
  public:

  // optional int64 reviewCount = 4;
  bool has_reviewcount() const;
  private:
  bool _internal_has_reviewcount() const;
  public:
  void clear_reviewcount();
  int64_t reviewcount() const;
  void set_reviewcount(int64_t value);
  private:
  int64_t _internal_reviewcount() const;
  void _internal_set_reviewcount(int64_t value);
  public:

  // optional int32 polarity = 3;
  bool has_polarity() const;
  private:
  bool _internal_has_polarity() const;
  public:
  void clear_polarity();
  int32_t polarity() const;
  void set_polarity(int32_t value);
  private:
  int32_t _internal_polarity() const;
  void _internal_set_polarity(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.document.AggregateRatingTip)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> snippetreviewid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tipid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
    int64_t reviewcount_;
    int32_t polarity_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fdocument_2eproto;
};
// -------------------------------------------------------------------

class Review final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.document.Review) */ {
 public:
  inline Review() : Review(nullptr) {}
  ~Review() override;
  explicit PROTOBUF_CONSTEXPR Review(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Review(const Review& from);
  Review(Review&& from) noexcept
    : Review() {
    *this = ::std::move(from);
  }

  inline Review& operator=(const Review& from) {
    CopyFrom(from);
    return *this;
  }
  inline Review& operator=(Review&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Review& default_instance() {
    return *internal_default_instance();
  }
  static inline const Review* internal_default_instance() {
    return reinterpret_cast<const Review*>(
               &_Review_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(Review& a, Review& b) {
    a.Swap(&b);
  }
  inline void Swap(Review* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Review* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Review* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Review>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Review& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Review& from) {
    Review::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Review* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.document.Review";
  }
  protected:
  explicit Review(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthorNameFieldNumber = 1,
    kUrlFieldNumber = 2,
    kSourceFieldNumber = 3,
    kDocumentVersionFieldNumber = 4,
    kTitleFieldNumber = 7,
    kCommentFieldNumber = 8,
    kCommentIdFieldNumber = 9,
    kDeviceNameFieldNumber = 19,
    kReplyTextFieldNumber = 29,
    kOBSOLETEPlusProfileFieldNumber = 31,
    kAuthorFieldNumber = 33,
    kSentimentFieldNumber = 34,
    kTimestampMsecFieldNumber = 5,
    kStarRatingFieldNumber = 6,
    kHelpfulCountFieldNumber = 35,
    kReplyTimestampMsecFieldNumber = 30,
    kThumbsUpCountFieldNumber = 38,
  };
  // optional string authorName = 1;
  bool has_authorname() const;
  private:
  bool _internal_has_authorname() const;
  public:
  void clear_authorname();
  const std::string& authorname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_authorname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_authorname();
  PROTOBUF_NODISCARD std::string* release_authorname();
  void set_allocated_authorname(std::string* authorname);
  private:
  const std::string& _internal_authorname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_authorname(const std::string& value);
  std::string* _internal_mutable_authorname();
  public:

  // optional string url = 2;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // optional string source = 3;
  bool has_source() const;
  private:
  bool _internal_has_source() const;
  public:
  void clear_source();
  const std::string& source() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_source(ArgT0&& arg0, ArgT... args);
  std::string* mutable_source();
  PROTOBUF_NODISCARD std::string* release_source();
  void set_allocated_source(std::string* source);
  private:
  const std::string& _internal_source() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source(const std::string& value);
  std::string* _internal_mutable_source();
  public:

  // optional string documentVersion = 4;
  bool has_documentversion() const;
  private:
  bool _internal_has_documentversion() const;
  public:
  void clear_documentversion();
  const std::string& documentversion() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_documentversion(ArgT0&& arg0, ArgT... args);
  std::string* mutable_documentversion();
  PROTOBUF_NODISCARD std::string* release_documentversion();
  void set_allocated_documentversion(std::string* documentversion);
  private:
  const std::string& _internal_documentversion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_documentversion(const std::string& value);
  std::string* _internal_mutable_documentversion();
  public:

  // optional string title = 7;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // optional string comment = 8;
  bool has_comment() const;
  private:
  bool _internal_has_comment() const;
  public:
  void clear_comment();
  const std::string& comment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comment();
  PROTOBUF_NODISCARD std::string* release_comment();
  void set_allocated_comment(std::string* comment);
  private:
  const std::string& _internal_comment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment(const std::string& value);
  std::string* _internal_mutable_comment();
  public:

  // optional string commentId = 9;
  bool has_commentid() const;
  private:
  bool _internal_has_commentid() const;
  public:
  void clear_commentid();
  const std::string& commentid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_commentid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_commentid();
  PROTOBUF_NODISCARD std::string* release_commentid();
  void set_allocated_commentid(std::string* commentid);
  private:
  const std::string& _internal_commentid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_commentid(const std::string& value);
  std::string* _internal_mutable_commentid();
  public:

  // optional string deviceName = 19;
  bool has_devicename() const;
  private:
  bool _internal_has_devicename() const;
  public:
  void clear_devicename();
  const std::string& devicename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_devicename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_devicename();
  PROTOBUF_NODISCARD std::string* release_devicename();
  void set_allocated_devicename(std::string* devicename);
  private:
  const std::string& _internal_devicename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_devicename(const std::string& value);
  std::string* _internal_mutable_devicename();
  public:

  // optional string replyText = 29;
  bool has_replytext() const;
  private:
  bool _internal_has_replytext() const;
  public:
  void clear_replytext();
  const std::string& replytext() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_replytext(ArgT0&& arg0, ArgT... args);
  std::string* mutable_replytext();
  PROTOBUF_NODISCARD std::string* release_replytext();
  void set_allocated_replytext(std::string* replytext);
  private:
  const std::string& _internal_replytext() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_replytext(const std::string& value);
  std::string* _internal_mutable_replytext();
  public:

  // optional .playapi.proto.finsky.document.OBSOLETE_PlusProfile OBSOLETEPlusProfile = 31;
  bool has_obsoleteplusprofile() const;
  private:
  bool _internal_has_obsoleteplusprofile() const;
  public:
  void clear_obsoleteplusprofile();
  const ::playapi::proto::finsky::document::OBSOLETE_PlusProfile& obsoleteplusprofile() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::OBSOLETE_PlusProfile* release_obsoleteplusprofile();
  ::playapi::proto::finsky::document::OBSOLETE_PlusProfile* mutable_obsoleteplusprofile();
  void set_allocated_obsoleteplusprofile(::playapi::proto::finsky::document::OBSOLETE_PlusProfile* obsoleteplusprofile);
  private:
  const ::playapi::proto::finsky::document::OBSOLETE_PlusProfile& _internal_obsoleteplusprofile() const;
  ::playapi::proto::finsky::document::OBSOLETE_PlusProfile* _internal_mutable_obsoleteplusprofile();
  public:
  void unsafe_arena_set_allocated_obsoleteplusprofile(
      ::playapi::proto::finsky::document::OBSOLETE_PlusProfile* obsoleteplusprofile);
  ::playapi::proto::finsky::document::OBSOLETE_PlusProfile* unsafe_arena_release_obsoleteplusprofile();

  // optional .playapi.proto.finsky.document.DocV2 author = 33;
  bool has_author() const;
  private:
  bool _internal_has_author() const;
  public:
  void clear_author();
  const ::playapi::proto::finsky::document::DocV2& author() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::DocV2* release_author();
  ::playapi::proto::finsky::document::DocV2* mutable_author();
  void set_allocated_author(::playapi::proto::finsky::document::DocV2* author);
  private:
  const ::playapi::proto::finsky::document::DocV2& _internal_author() const;
  ::playapi::proto::finsky::document::DocV2* _internal_mutable_author();
  public:
  void unsafe_arena_set_allocated_author(
      ::playapi::proto::finsky::document::DocV2* author);
  ::playapi::proto::finsky::document::DocV2* unsafe_arena_release_author();

  // optional .playapi.proto.finsky.Image sentiment = 34;
  bool has_sentiment() const;
  private:
  bool _internal_has_sentiment() const;
  public:
  void clear_sentiment();
  const ::playapi::proto::finsky::Image& sentiment() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::Image* release_sentiment();
  ::playapi::proto::finsky::Image* mutable_sentiment();
  void set_allocated_sentiment(::playapi::proto::finsky::Image* sentiment);
  private:
  const ::playapi::proto::finsky::Image& _internal_sentiment() const;
  ::playapi::proto::finsky::Image* _internal_mutable_sentiment();
  public:
  void unsafe_arena_set_allocated_sentiment(
      ::playapi::proto::finsky::Image* sentiment);
  ::playapi::proto::finsky::Image* unsafe_arena_release_sentiment();

  // optional int64 timestampMsec = 5;
  bool has_timestampmsec() const;
  private:
  bool _internal_has_timestampmsec() const;
  public:
  void clear_timestampmsec();
  int64_t timestampmsec() const;
  void set_timestampmsec(int64_t value);
  private:
  int64_t _internal_timestampmsec() const;
  void _internal_set_timestampmsec(int64_t value);
  public:

  // optional int32 starRating = 6;
  bool has_starrating() const;
  private:
  bool _internal_has_starrating() const;
  public:
  void clear_starrating();
  int32_t starrating() const;
  void set_starrating(int32_t value);
  private:
  int32_t _internal_starrating() const;
  void _internal_set_starrating(int32_t value);
  public:

  // optional int32 helpfulCount = 35;
  bool has_helpfulcount() const;
  private:
  bool _internal_has_helpfulcount() const;
  public:
  void clear_helpfulcount();
  int32_t helpfulcount() const;
  void set_helpfulcount(int32_t value);
  private:
  int32_t _internal_helpfulcount() const;
  void _internal_set_helpfulcount(int32_t value);
  public:

  // optional int64 replyTimestampMsec = 30;
  bool has_replytimestampmsec() const;
  private:
  bool _internal_has_replytimestampmsec() const;
  public:
  void clear_replytimestampmsec();
  int64_t replytimestampmsec() const;
  void set_replytimestampmsec(int64_t value);
  private:
  int64_t _internal_replytimestampmsec() const;
  void _internal_set_replytimestampmsec(int64_t value);
  public:

  // optional int64 thumbsUpCount = 38;
  bool has_thumbsupcount() const;
  private:
  bool _internal_has_thumbsupcount() const;
  public:
  void clear_thumbsupcount();
  int64_t thumbsupcount() const;
  void set_thumbsupcount(int64_t value);
  private:
  int64_t _internal_thumbsupcount() const;
  void _internal_set_thumbsupcount(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.document.Review)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr authorname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr documentversion_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr commentid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr devicename_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr replytext_;
    ::playapi::proto::finsky::document::OBSOLETE_PlusProfile* obsoleteplusprofile_;
    ::playapi::proto::finsky::document::DocV2* author_;
    ::playapi::proto::finsky::Image* sentiment_;
    int64_t timestampmsec_;
    int32_t starrating_;
    int32_t helpfulcount_;
    int64_t replytimestampmsec_;
    int64_t thumbsupcount_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fdocument_2eproto;
};
// -------------------------------------------------------------------

class ReviewTip final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.document.ReviewTip) */ {
 public:
  inline ReviewTip() : ReviewTip(nullptr) {}
  ~ReviewTip() override;
  explicit PROTOBUF_CONSTEXPR ReviewTip(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReviewTip(const ReviewTip& from);
  ReviewTip(ReviewTip&& from) noexcept
    : ReviewTip() {
    *this = ::std::move(from);
  }

  inline ReviewTip& operator=(const ReviewTip& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReviewTip& operator=(ReviewTip&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReviewTip& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReviewTip* internal_default_instance() {
    return reinterpret_cast<const ReviewTip*>(
               &_ReviewTip_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(ReviewTip& a, ReviewTip& b) {
    a.Swap(&b);
  }
  inline void Swap(ReviewTip* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReviewTip* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReviewTip* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReviewTip>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReviewTip& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReviewTip& from) {
    ReviewTip::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReviewTip* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.document.ReviewTip";
  }
  protected:
  explicit ReviewTip(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTipUrlFieldNumber = 1,
    kTextFieldNumber = 2,
    kReviewCountFieldNumber = 4,
    kPolarityFieldNumber = 3,
  };
  // optional string tipUrl = 1;
  bool has_tipurl() const;
  private:
  bool _internal_has_tipurl() const;
  public:
  void clear_tipurl();
  const std::string& tipurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tipurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tipurl();
  PROTOBUF_NODISCARD std::string* release_tipurl();
  void set_allocated_tipurl(std::string* tipurl);
  private:
  const std::string& _internal_tipurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tipurl(const std::string& value);
  std::string* _internal_mutable_tipurl();
  public:

  // optional string text = 2;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // optional int64 reviewCount = 4;
  bool has_reviewcount() const;
  private:
  bool _internal_has_reviewcount() const;
  public:
  void clear_reviewcount();
  int64_t reviewcount() const;
  void set_reviewcount(int64_t value);
  private:
  int64_t _internal_reviewcount() const;
  void _internal_set_reviewcount(int64_t value);
  public:

  // optional int32 polarity = 3;
  bool has_polarity() const;
  private:
  bool _internal_has_polarity() const;
  public:
  void clear_polarity();
  int32_t polarity() const;
  void set_polarity(int32_t value);
  private:
  int32_t _internal_polarity() const;
  void _internal_set_polarity(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.document.ReviewTip)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tipurl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    int64_t reviewcount_;
    int32_t polarity_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fdocument_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DocV2

// optional string docid = 1;
inline bool DocV2::_internal_has_docid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DocV2::has_docid() const {
  return _internal_has_docid();
}
inline void DocV2::clear_docid() {
  _impl_.docid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DocV2::docid() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.DocV2.docid)
  return _internal_docid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocV2::set_docid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.docid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.DocV2.docid)
}
inline std::string* DocV2::mutable_docid() {
  std::string* _s = _internal_mutable_docid();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.DocV2.docid)
  return _s;
}
inline const std::string& DocV2::_internal_docid() const {
  return _impl_.docid_.Get();
}
inline void DocV2::_internal_set_docid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.docid_.Set(value, GetArenaForAllocation());
}
inline std::string* DocV2::_internal_mutable_docid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.docid_.Mutable(GetArenaForAllocation());
}
inline std::string* DocV2::release_docid() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.DocV2.docid)
  if (!_internal_has_docid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.docid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.docid_.IsDefault()) {
    _impl_.docid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DocV2::set_allocated_docid(std::string* docid) {
  if (docid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.docid_.SetAllocated(docid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.docid_.IsDefault()) {
    _impl_.docid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.DocV2.docid)
}

// optional string backendDocid = 2;
inline bool DocV2::_internal_has_backenddocid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DocV2::has_backenddocid() const {
  return _internal_has_backenddocid();
}
inline void DocV2::clear_backenddocid() {
  _impl_.backenddocid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DocV2::backenddocid() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.DocV2.backendDocid)
  return _internal_backenddocid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocV2::set_backenddocid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.backenddocid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.DocV2.backendDocid)
}
inline std::string* DocV2::mutable_backenddocid() {
  std::string* _s = _internal_mutable_backenddocid();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.DocV2.backendDocid)
  return _s;
}
inline const std::string& DocV2::_internal_backenddocid() const {
  return _impl_.backenddocid_.Get();
}
inline void DocV2::_internal_set_backenddocid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.backenddocid_.Set(value, GetArenaForAllocation());
}
inline std::string* DocV2::_internal_mutable_backenddocid() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.backenddocid_.Mutable(GetArenaForAllocation());
}
inline std::string* DocV2::release_backenddocid() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.DocV2.backendDocid)
  if (!_internal_has_backenddocid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.backenddocid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.backenddocid_.IsDefault()) {
    _impl_.backenddocid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DocV2::set_allocated_backenddocid(std::string* backenddocid) {
  if (backenddocid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.backenddocid_.SetAllocated(backenddocid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.backenddocid_.IsDefault()) {
    _impl_.backenddocid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.DocV2.backendDocid)
}

// optional int32 docType = 3;
inline bool DocV2::_internal_has_doctype() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool DocV2::has_doctype() const {
  return _internal_has_doctype();
}
inline void DocV2::clear_doctype() {
  _impl_.doctype_ = 0;
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline int32_t DocV2::_internal_doctype() const {
  return _impl_.doctype_;
}
inline int32_t DocV2::doctype() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.DocV2.docType)
  return _internal_doctype();
}
inline void DocV2::_internal_set_doctype(int32_t value) {
  _impl_._has_bits_[0] |= 0x00200000u;
  _impl_.doctype_ = value;
}
inline void DocV2::set_doctype(int32_t value) {
  _internal_set_doctype(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.DocV2.docType)
}

// optional int32 backendId = 4;
inline bool DocV2::_internal_has_backendid() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool DocV2::has_backendid() const {
  return _internal_has_backendid();
}
inline void DocV2::clear_backendid() {
  _impl_.backendid_ = 0;
  _impl_._has_bits_[0] &= ~0x00400000u;
}
inline int32_t DocV2::_internal_backendid() const {
  return _impl_.backendid_;
}
inline int32_t DocV2::backendid() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.DocV2.backendId)
  return _internal_backendid();
}
inline void DocV2::_internal_set_backendid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00400000u;
  _impl_.backendid_ = value;
}
inline void DocV2::set_backendid(int32_t value) {
  _internal_set_backendid(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.DocV2.backendId)
}

// optional string title = 5;
inline bool DocV2::_internal_has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DocV2::has_title() const {
  return _internal_has_title();
}
inline void DocV2::clear_title() {
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& DocV2::title() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.DocV2.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocV2::set_title(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.DocV2.title)
}
inline std::string* DocV2::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.DocV2.title)
  return _s;
}
inline const std::string& DocV2::_internal_title() const {
  return _impl_.title_.Get();
}
inline void DocV2::_internal_set_title(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* DocV2::_internal_mutable_title() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* DocV2::release_title() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.DocV2.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.title_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DocV2::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.DocV2.title)
}

// optional string creator = 6;
inline bool DocV2::_internal_has_creator() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DocV2::has_creator() const {
  return _internal_has_creator();
}
inline void DocV2::clear_creator() {
  _impl_.creator_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& DocV2::creator() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.DocV2.creator)
  return _internal_creator();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocV2::set_creator(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.creator_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.DocV2.creator)
}
inline std::string* DocV2::mutable_creator() {
  std::string* _s = _internal_mutable_creator();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.DocV2.creator)
  return _s;
}
inline const std::string& DocV2::_internal_creator() const {
  return _impl_.creator_.Get();
}
inline void DocV2::_internal_set_creator(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.creator_.Set(value, GetArenaForAllocation());
}
inline std::string* DocV2::_internal_mutable_creator() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.creator_.Mutable(GetArenaForAllocation());
}
inline std::string* DocV2::release_creator() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.DocV2.creator)
  if (!_internal_has_creator()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.creator_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.creator_.IsDefault()) {
    _impl_.creator_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DocV2::set_allocated_creator(std::string* creator) {
  if (creator != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.creator_.SetAllocated(creator, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.creator_.IsDefault()) {
    _impl_.creator_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.DocV2.creator)
}

// optional string descriptionHtml = 7;
inline bool DocV2::_internal_has_descriptionhtml() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DocV2::has_descriptionhtml() const {
  return _internal_has_descriptionhtml();
}
inline void DocV2::clear_descriptionhtml() {
  _impl_.descriptionhtml_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& DocV2::descriptionhtml() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.DocV2.descriptionHtml)
  return _internal_descriptionhtml();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocV2::set_descriptionhtml(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.descriptionhtml_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.DocV2.descriptionHtml)
}
inline std::string* DocV2::mutable_descriptionhtml() {
  std::string* _s = _internal_mutable_descriptionhtml();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.DocV2.descriptionHtml)
  return _s;
}
inline const std::string& DocV2::_internal_descriptionhtml() const {
  return _impl_.descriptionhtml_.Get();
}
inline void DocV2::_internal_set_descriptionhtml(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.descriptionhtml_.Set(value, GetArenaForAllocation());
}
inline std::string* DocV2::_internal_mutable_descriptionhtml() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.descriptionhtml_.Mutable(GetArenaForAllocation());
}
inline std::string* DocV2::release_descriptionhtml() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.DocV2.descriptionHtml)
  if (!_internal_has_descriptionhtml()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.descriptionhtml_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.descriptionhtml_.IsDefault()) {
    _impl_.descriptionhtml_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DocV2::set_allocated_descriptionhtml(std::string* descriptionhtml) {
  if (descriptionhtml != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.descriptionhtml_.SetAllocated(descriptionhtml, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.descriptionhtml_.IsDefault()) {
    _impl_.descriptionhtml_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.DocV2.descriptionHtml)
}

// repeated .playapi.proto.finsky.Offer offer = 8;
inline int DocV2::_internal_offer_size() const {
  return _impl_.offer_.size();
}
inline int DocV2::offer_size() const {
  return _internal_offer_size();
}
inline ::playapi::proto::finsky::Offer* DocV2::mutable_offer(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.DocV2.offer)
  return _impl_.offer_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Offer >*
DocV2::mutable_offer() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.document.DocV2.offer)
  return &_impl_.offer_;
}
inline const ::playapi::proto::finsky::Offer& DocV2::_internal_offer(int index) const {
  return _impl_.offer_.Get(index);
}
inline const ::playapi::proto::finsky::Offer& DocV2::offer(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.DocV2.offer)
  return _internal_offer(index);
}
inline ::playapi::proto::finsky::Offer* DocV2::_internal_add_offer() {
  return _impl_.offer_.Add();
}
inline ::playapi::proto::finsky::Offer* DocV2::add_offer() {
  ::playapi::proto::finsky::Offer* _add = _internal_add_offer();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.DocV2.offer)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Offer >&
DocV2::offer() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.document.DocV2.offer)
  return _impl_.offer_;
}

// optional .playapi.proto.finsky.filter_rules.Availability availability = 9;
inline bool DocV2::_internal_has_availability() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.availability_ != nullptr);
  return value;
}
inline bool DocV2::has_availability() const {
  return _internal_has_availability();
}
inline const ::playapi::proto::finsky::filter_rules::Availability& DocV2::_internal_availability() const {
  const ::playapi::proto::finsky::filter_rules::Availability* p = _impl_.availability_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::filter_rules::Availability&>(
      ::playapi::proto::finsky::filter_rules::_Availability_default_instance_);
}
inline const ::playapi::proto::finsky::filter_rules::Availability& DocV2::availability() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.DocV2.availability)
  return _internal_availability();
}
inline void DocV2::unsafe_arena_set_allocated_availability(
    ::playapi::proto::finsky::filter_rules::Availability* availability) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.availability_);
  }
  _impl_.availability_ = availability;
  if (availability) {
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.DocV2.availability)
}
inline ::playapi::proto::finsky::filter_rules::Availability* DocV2::release_availability() {
  _impl_._has_bits_[0] &= ~0x00008000u;
  ::playapi::proto::finsky::filter_rules::Availability* temp = _impl_.availability_;
  _impl_.availability_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::filter_rules::Availability* DocV2::unsafe_arena_release_availability() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.DocV2.availability)
  _impl_._has_bits_[0] &= ~0x00008000u;
  ::playapi::proto::finsky::filter_rules::Availability* temp = _impl_.availability_;
  _impl_.availability_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::filter_rules::Availability* DocV2::_internal_mutable_availability() {
  _impl_._has_bits_[0] |= 0x00008000u;
  if (_impl_.availability_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::filter_rules::Availability>(GetArenaForAllocation());
    _impl_.availability_ = p;
  }
  return _impl_.availability_;
}
inline ::playapi::proto::finsky::filter_rules::Availability* DocV2::mutable_availability() {
  ::playapi::proto::finsky::filter_rules::Availability* _msg = _internal_mutable_availability();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.DocV2.availability)
  return _msg;
}
inline void DocV2::set_allocated_availability(::playapi::proto::finsky::filter_rules::Availability* availability) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.availability_);
  }
  if (availability) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(availability));
    if (message_arena != submessage_arena) {
      availability = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, availability, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }
  _impl_.availability_ = availability;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.DocV2.availability)
}

// repeated .playapi.proto.finsky.Image image = 10;
inline int DocV2::_internal_image_size() const {
  return _impl_.image_.size();
}
inline int DocV2::image_size() const {
  return _internal_image_size();
}
inline ::playapi::proto::finsky::Image* DocV2::mutable_image(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.DocV2.image)
  return _impl_.image_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Image >*
DocV2::mutable_image() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.document.DocV2.image)
  return &_impl_.image_;
}
inline const ::playapi::proto::finsky::Image& DocV2::_internal_image(int index) const {
  return _impl_.image_.Get(index);
}
inline const ::playapi::proto::finsky::Image& DocV2::image(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.DocV2.image)
  return _internal_image(index);
}
inline ::playapi::proto::finsky::Image* DocV2::_internal_add_image() {
  return _impl_.image_.Add();
}
inline ::playapi::proto::finsky::Image* DocV2::add_image() {
  ::playapi::proto::finsky::Image* _add = _internal_add_image();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.DocV2.image)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Image >&
DocV2::image() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.document.DocV2.image)
  return _impl_.image_;
}

// repeated .playapi.proto.finsky.document.DocV2 child = 11;
inline int DocV2::_internal_child_size() const {
  return _impl_.child_.size();
}
inline int DocV2::child_size() const {
  return _internal_child_size();
}
inline void DocV2::clear_child() {
  _impl_.child_.Clear();
}
inline ::playapi::proto::finsky::document::DocV2* DocV2::mutable_child(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.DocV2.child)
  return _impl_.child_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::DocV2 >*
DocV2::mutable_child() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.document.DocV2.child)
  return &_impl_.child_;
}
inline const ::playapi::proto::finsky::document::DocV2& DocV2::_internal_child(int index) const {
  return _impl_.child_.Get(index);
}
inline const ::playapi::proto::finsky::document::DocV2& DocV2::child(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.DocV2.child)
  return _internal_child(index);
}
inline ::playapi::proto::finsky::document::DocV2* DocV2::_internal_add_child() {
  return _impl_.child_.Add();
}
inline ::playapi::proto::finsky::document::DocV2* DocV2::add_child() {
  ::playapi::proto::finsky::document::DocV2* _add = _internal_add_child();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.DocV2.child)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::DocV2 >&
DocV2::child() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.document.DocV2.child)
  return _impl_.child_;
}

// optional .playapi.proto.finsky.containers.ContainerMetadata containerMetadata = 12;
inline bool DocV2::_internal_has_containermetadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.containermetadata_ != nullptr);
  return value;
}
inline bool DocV2::has_containermetadata() const {
  return _internal_has_containermetadata();
}
inline const ::playapi::proto::finsky::containers::ContainerMetadata& DocV2::_internal_containermetadata() const {
  const ::playapi::proto::finsky::containers::ContainerMetadata* p = _impl_.containermetadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::containers::ContainerMetadata&>(
      ::playapi::proto::finsky::containers::_ContainerMetadata_default_instance_);
}
inline const ::playapi::proto::finsky::containers::ContainerMetadata& DocV2::containermetadata() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.DocV2.containerMetadata)
  return _internal_containermetadata();
}
inline void DocV2::unsafe_arena_set_allocated_containermetadata(
    ::playapi::proto::finsky::containers::ContainerMetadata* containermetadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.containermetadata_);
  }
  _impl_.containermetadata_ = containermetadata;
  if (containermetadata) {
    _impl_._has_bits_[0] |= 0x00010000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00010000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.DocV2.containerMetadata)
}
inline ::playapi::proto::finsky::containers::ContainerMetadata* DocV2::release_containermetadata() {
  _impl_._has_bits_[0] &= ~0x00010000u;
  ::playapi::proto::finsky::containers::ContainerMetadata* temp = _impl_.containermetadata_;
  _impl_.containermetadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::containers::ContainerMetadata* DocV2::unsafe_arena_release_containermetadata() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.DocV2.containerMetadata)
  _impl_._has_bits_[0] &= ~0x00010000u;
  ::playapi::proto::finsky::containers::ContainerMetadata* temp = _impl_.containermetadata_;
  _impl_.containermetadata_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::containers::ContainerMetadata* DocV2::_internal_mutable_containermetadata() {
  _impl_._has_bits_[0] |= 0x00010000u;
  if (_impl_.containermetadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::containers::ContainerMetadata>(GetArenaForAllocation());
    _impl_.containermetadata_ = p;
  }
  return _impl_.containermetadata_;
}
inline ::playapi::proto::finsky::containers::ContainerMetadata* DocV2::mutable_containermetadata() {
  ::playapi::proto::finsky::containers::ContainerMetadata* _msg = _internal_mutable_containermetadata();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.DocV2.containerMetadata)
  return _msg;
}
inline void DocV2::set_allocated_containermetadata(::playapi::proto::finsky::containers::ContainerMetadata* containermetadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.containermetadata_);
  }
  if (containermetadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(containermetadata));
    if (message_arena != submessage_arena) {
      containermetadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, containermetadata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00010000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00010000u;
  }
  _impl_.containermetadata_ = containermetadata;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.DocV2.containerMetadata)
}

// optional .playapi.proto.finsky.document.DocumentDetails details = 13;
inline bool DocV2::_internal_has_details() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.details_ != nullptr);
  return value;
}
inline bool DocV2::has_details() const {
  return _internal_has_details();
}
inline void DocV2::clear_details() {
  if (_impl_.details_ != nullptr) _impl_.details_->Clear();
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline const ::playapi::proto::finsky::document::DocumentDetails& DocV2::_internal_details() const {
  const ::playapi::proto::finsky::document::DocumentDetails* p = _impl_.details_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::DocumentDetails&>(
      ::playapi::proto::finsky::document::_DocumentDetails_default_instance_);
}
inline const ::playapi::proto::finsky::document::DocumentDetails& DocV2::details() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.DocV2.details)
  return _internal_details();
}
inline void DocV2::unsafe_arena_set_allocated_details(
    ::playapi::proto::finsky::document::DocumentDetails* details) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.details_);
  }
  _impl_.details_ = details;
  if (details) {
    _impl_._has_bits_[0] |= 0x00020000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00020000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.DocV2.details)
}
inline ::playapi::proto::finsky::document::DocumentDetails* DocV2::release_details() {
  _impl_._has_bits_[0] &= ~0x00020000u;
  ::playapi::proto::finsky::document::DocumentDetails* temp = _impl_.details_;
  _impl_.details_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::DocumentDetails* DocV2::unsafe_arena_release_details() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.DocV2.details)
  _impl_._has_bits_[0] &= ~0x00020000u;
  ::playapi::proto::finsky::document::DocumentDetails* temp = _impl_.details_;
  _impl_.details_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::DocumentDetails* DocV2::_internal_mutable_details() {
  _impl_._has_bits_[0] |= 0x00020000u;
  if (_impl_.details_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::DocumentDetails>(GetArenaForAllocation());
    _impl_.details_ = p;
  }
  return _impl_.details_;
}
inline ::playapi::proto::finsky::document::DocumentDetails* DocV2::mutable_details() {
  ::playapi::proto::finsky::document::DocumentDetails* _msg = _internal_mutable_details();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.DocV2.details)
  return _msg;
}
inline void DocV2::set_allocated_details(::playapi::proto::finsky::document::DocumentDetails* details) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.details_;
  }
  if (details) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(details);
    if (message_arena != submessage_arena) {
      details = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, details, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00020000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00020000u;
  }
  _impl_.details_ = details;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.DocV2.details)
}

// optional .playapi.proto.finsky.document.AggregateRating aggregateRating = 14;
inline bool DocV2::_internal_has_aggregaterating() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.aggregaterating_ != nullptr);
  return value;
}
inline bool DocV2::has_aggregaterating() const {
  return _internal_has_aggregaterating();
}
inline void DocV2::clear_aggregaterating() {
  if (_impl_.aggregaterating_ != nullptr) _impl_.aggregaterating_->Clear();
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline const ::playapi::proto::finsky::document::AggregateRating& DocV2::_internal_aggregaterating() const {
  const ::playapi::proto::finsky::document::AggregateRating* p = _impl_.aggregaterating_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::AggregateRating&>(
      ::playapi::proto::finsky::document::_AggregateRating_default_instance_);
}
inline const ::playapi::proto::finsky::document::AggregateRating& DocV2::aggregaterating() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.DocV2.aggregateRating)
  return _internal_aggregaterating();
}
inline void DocV2::unsafe_arena_set_allocated_aggregaterating(
    ::playapi::proto::finsky::document::AggregateRating* aggregaterating) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.aggregaterating_);
  }
  _impl_.aggregaterating_ = aggregaterating;
  if (aggregaterating) {
    _impl_._has_bits_[0] |= 0x00040000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00040000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.DocV2.aggregateRating)
}
inline ::playapi::proto::finsky::document::AggregateRating* DocV2::release_aggregaterating() {
  _impl_._has_bits_[0] &= ~0x00040000u;
  ::playapi::proto::finsky::document::AggregateRating* temp = _impl_.aggregaterating_;
  _impl_.aggregaterating_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::AggregateRating* DocV2::unsafe_arena_release_aggregaterating() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.DocV2.aggregateRating)
  _impl_._has_bits_[0] &= ~0x00040000u;
  ::playapi::proto::finsky::document::AggregateRating* temp = _impl_.aggregaterating_;
  _impl_.aggregaterating_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::AggregateRating* DocV2::_internal_mutable_aggregaterating() {
  _impl_._has_bits_[0] |= 0x00040000u;
  if (_impl_.aggregaterating_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::AggregateRating>(GetArenaForAllocation());
    _impl_.aggregaterating_ = p;
  }
  return _impl_.aggregaterating_;
}
inline ::playapi::proto::finsky::document::AggregateRating* DocV2::mutable_aggregaterating() {
  ::playapi::proto::finsky::document::AggregateRating* _msg = _internal_mutable_aggregaterating();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.DocV2.aggregateRating)
  return _msg;
}
inline void DocV2::set_allocated_aggregaterating(::playapi::proto::finsky::document::AggregateRating* aggregaterating) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.aggregaterating_;
  }
  if (aggregaterating) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(aggregaterating);
    if (message_arena != submessage_arena) {
      aggregaterating = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, aggregaterating, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00040000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00040000u;
  }
  _impl_.aggregaterating_ = aggregaterating;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.DocV2.aggregateRating)
}

// optional .playapi.proto.finsky.document.Annotations annotations = 15;
inline bool DocV2::_internal_has_annotations() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.annotations_ != nullptr);
  return value;
}
inline bool DocV2::has_annotations() const {
  return _internal_has_annotations();
}
inline void DocV2::clear_annotations() {
  if (_impl_.annotations_ != nullptr) _impl_.annotations_->Clear();
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline const ::playapi::proto::finsky::document::Annotations& DocV2::_internal_annotations() const {
  const ::playapi::proto::finsky::document::Annotations* p = _impl_.annotations_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::Annotations&>(
      ::playapi::proto::finsky::document::_Annotations_default_instance_);
}
inline const ::playapi::proto::finsky::document::Annotations& DocV2::annotations() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.DocV2.annotations)
  return _internal_annotations();
}
inline void DocV2::unsafe_arena_set_allocated_annotations(
    ::playapi::proto::finsky::document::Annotations* annotations) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.annotations_);
  }
  _impl_.annotations_ = annotations;
  if (annotations) {
    _impl_._has_bits_[0] |= 0x00080000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00080000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.DocV2.annotations)
}
inline ::playapi::proto::finsky::document::Annotations* DocV2::release_annotations() {
  _impl_._has_bits_[0] &= ~0x00080000u;
  ::playapi::proto::finsky::document::Annotations* temp = _impl_.annotations_;
  _impl_.annotations_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::Annotations* DocV2::unsafe_arena_release_annotations() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.DocV2.annotations)
  _impl_._has_bits_[0] &= ~0x00080000u;
  ::playapi::proto::finsky::document::Annotations* temp = _impl_.annotations_;
  _impl_.annotations_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::Annotations* DocV2::_internal_mutable_annotations() {
  _impl_._has_bits_[0] |= 0x00080000u;
  if (_impl_.annotations_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::Annotations>(GetArenaForAllocation());
    _impl_.annotations_ = p;
  }
  return _impl_.annotations_;
}
inline ::playapi::proto::finsky::document::Annotations* DocV2::mutable_annotations() {
  ::playapi::proto::finsky::document::Annotations* _msg = _internal_mutable_annotations();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.DocV2.annotations)
  return _msg;
}
inline void DocV2::set_allocated_annotations(::playapi::proto::finsky::document::Annotations* annotations) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.annotations_;
  }
  if (annotations) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(annotations);
    if (message_arena != submessage_arena) {
      annotations = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, annotations, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00080000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00080000u;
  }
  _impl_.annotations_ = annotations;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.DocV2.annotations)
}

// optional string detailsUrl = 16;
inline bool DocV2::_internal_has_detailsurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool DocV2::has_detailsurl() const {
  return _internal_has_detailsurl();
}
inline void DocV2::clear_detailsurl() {
  _impl_.detailsurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& DocV2::detailsurl() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.DocV2.detailsUrl)
  return _internal_detailsurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocV2::set_detailsurl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.detailsurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.DocV2.detailsUrl)
}
inline std::string* DocV2::mutable_detailsurl() {
  std::string* _s = _internal_mutable_detailsurl();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.DocV2.detailsUrl)
  return _s;
}
inline const std::string& DocV2::_internal_detailsurl() const {
  return _impl_.detailsurl_.Get();
}
inline void DocV2::_internal_set_detailsurl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.detailsurl_.Set(value, GetArenaForAllocation());
}
inline std::string* DocV2::_internal_mutable_detailsurl() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.detailsurl_.Mutable(GetArenaForAllocation());
}
inline std::string* DocV2::release_detailsurl() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.DocV2.detailsUrl)
  if (!_internal_has_detailsurl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.detailsurl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.detailsurl_.IsDefault()) {
    _impl_.detailsurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DocV2::set_allocated_detailsurl(std::string* detailsurl) {
  if (detailsurl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.detailsurl_.SetAllocated(detailsurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.detailsurl_.IsDefault()) {
    _impl_.detailsurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.DocV2.detailsUrl)
}

// optional string shareUrl = 17;
inline bool DocV2::_internal_has_shareurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool DocV2::has_shareurl() const {
  return _internal_has_shareurl();
}
inline void DocV2::clear_shareurl() {
  _impl_.shareurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& DocV2::shareurl() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.DocV2.shareUrl)
  return _internal_shareurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocV2::set_shareurl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000040u;
 _impl_.shareurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.DocV2.shareUrl)
}
inline std::string* DocV2::mutable_shareurl() {
  std::string* _s = _internal_mutable_shareurl();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.DocV2.shareUrl)
  return _s;
}
inline const std::string& DocV2::_internal_shareurl() const {
  return _impl_.shareurl_.Get();
}
inline void DocV2::_internal_set_shareurl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.shareurl_.Set(value, GetArenaForAllocation());
}
inline std::string* DocV2::_internal_mutable_shareurl() {
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.shareurl_.Mutable(GetArenaForAllocation());
}
inline std::string* DocV2::release_shareurl() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.DocV2.shareUrl)
  if (!_internal_has_shareurl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* p = _impl_.shareurl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.shareurl_.IsDefault()) {
    _impl_.shareurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DocV2::set_allocated_shareurl(std::string* shareurl) {
  if (shareurl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.shareurl_.SetAllocated(shareurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.shareurl_.IsDefault()) {
    _impl_.shareurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.DocV2.shareUrl)
}

// optional string reviewsUrl = 18;
inline bool DocV2::_internal_has_reviewsurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool DocV2::has_reviewsurl() const {
  return _internal_has_reviewsurl();
}
inline void DocV2::clear_reviewsurl() {
  _impl_.reviewsurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& DocV2::reviewsurl() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.DocV2.reviewsUrl)
  return _internal_reviewsurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocV2::set_reviewsurl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000080u;
 _impl_.reviewsurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.DocV2.reviewsUrl)
}
inline std::string* DocV2::mutable_reviewsurl() {
  std::string* _s = _internal_mutable_reviewsurl();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.DocV2.reviewsUrl)
  return _s;
}
inline const std::string& DocV2::_internal_reviewsurl() const {
  return _impl_.reviewsurl_.Get();
}
inline void DocV2::_internal_set_reviewsurl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.reviewsurl_.Set(value, GetArenaForAllocation());
}
inline std::string* DocV2::_internal_mutable_reviewsurl() {
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.reviewsurl_.Mutable(GetArenaForAllocation());
}
inline std::string* DocV2::release_reviewsurl() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.DocV2.reviewsUrl)
  if (!_internal_has_reviewsurl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* p = _impl_.reviewsurl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reviewsurl_.IsDefault()) {
    _impl_.reviewsurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DocV2::set_allocated_reviewsurl(std::string* reviewsurl) {
  if (reviewsurl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.reviewsurl_.SetAllocated(reviewsurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reviewsurl_.IsDefault()) {
    _impl_.reviewsurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.DocV2.reviewsUrl)
}

// optional string backendUrl = 19;
inline bool DocV2::_internal_has_backendurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool DocV2::has_backendurl() const {
  return _internal_has_backendurl();
}
inline void DocV2::clear_backendurl() {
  _impl_.backendurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const std::string& DocV2::backendurl() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.DocV2.backendUrl)
  return _internal_backendurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocV2::set_backendurl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000100u;
 _impl_.backendurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.DocV2.backendUrl)
}
inline std::string* DocV2::mutable_backendurl() {
  std::string* _s = _internal_mutable_backendurl();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.DocV2.backendUrl)
  return _s;
}
inline const std::string& DocV2::_internal_backendurl() const {
  return _impl_.backendurl_.Get();
}
inline void DocV2::_internal_set_backendurl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.backendurl_.Set(value, GetArenaForAllocation());
}
inline std::string* DocV2::_internal_mutable_backendurl() {
  _impl_._has_bits_[0] |= 0x00000100u;
  return _impl_.backendurl_.Mutable(GetArenaForAllocation());
}
inline std::string* DocV2::release_backendurl() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.DocV2.backendUrl)
  if (!_internal_has_backendurl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000100u;
  auto* p = _impl_.backendurl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.backendurl_.IsDefault()) {
    _impl_.backendurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DocV2::set_allocated_backendurl(std::string* backendurl) {
  if (backendurl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.backendurl_.SetAllocated(backendurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.backendurl_.IsDefault()) {
    _impl_.backendurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.DocV2.backendUrl)
}

// optional string purchaseDetailsUrl = 20;
inline bool DocV2::_internal_has_purchasedetailsurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool DocV2::has_purchasedetailsurl() const {
  return _internal_has_purchasedetailsurl();
}
inline void DocV2::clear_purchasedetailsurl() {
  _impl_.purchasedetailsurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const std::string& DocV2::purchasedetailsurl() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.DocV2.purchaseDetailsUrl)
  return _internal_purchasedetailsurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocV2::set_purchasedetailsurl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000200u;
 _impl_.purchasedetailsurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.DocV2.purchaseDetailsUrl)
}
inline std::string* DocV2::mutable_purchasedetailsurl() {
  std::string* _s = _internal_mutable_purchasedetailsurl();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.DocV2.purchaseDetailsUrl)
  return _s;
}
inline const std::string& DocV2::_internal_purchasedetailsurl() const {
  return _impl_.purchasedetailsurl_.Get();
}
inline void DocV2::_internal_set_purchasedetailsurl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.purchasedetailsurl_.Set(value, GetArenaForAllocation());
}
inline std::string* DocV2::_internal_mutable_purchasedetailsurl() {
  _impl_._has_bits_[0] |= 0x00000200u;
  return _impl_.purchasedetailsurl_.Mutable(GetArenaForAllocation());
}
inline std::string* DocV2::release_purchasedetailsurl() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.DocV2.purchaseDetailsUrl)
  if (!_internal_has_purchasedetailsurl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000200u;
  auto* p = _impl_.purchasedetailsurl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.purchasedetailsurl_.IsDefault()) {
    _impl_.purchasedetailsurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DocV2::set_allocated_purchasedetailsurl(std::string* purchasedetailsurl) {
  if (purchasedetailsurl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.purchasedetailsurl_.SetAllocated(purchasedetailsurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.purchasedetailsurl_.IsDefault()) {
    _impl_.purchasedetailsurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.DocV2.purchaseDetailsUrl)
}

// optional bool detailsReusable = 21;
inline bool DocV2::_internal_has_detailsreusable() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool DocV2::has_detailsreusable() const {
  return _internal_has_detailsreusable();
}
inline void DocV2::clear_detailsreusable() {
  _impl_.detailsreusable_ = false;
  _impl_._has_bits_[0] &= ~0x00800000u;
}
inline bool DocV2::_internal_detailsreusable() const {
  return _impl_.detailsreusable_;
}
inline bool DocV2::detailsreusable() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.DocV2.detailsReusable)
  return _internal_detailsreusable();
}
inline void DocV2::_internal_set_detailsreusable(bool value) {
  _impl_._has_bits_[0] |= 0x00800000u;
  _impl_.detailsreusable_ = value;
}
inline void DocV2::set_detailsreusable(bool value) {
  _internal_set_detailsreusable(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.DocV2.detailsReusable)
}

// optional string subtitle = 22;
inline bool DocV2::_internal_has_subtitle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool DocV2::has_subtitle() const {
  return _internal_has_subtitle();
}
inline void DocV2::clear_subtitle() {
  _impl_.subtitle_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const std::string& DocV2::subtitle() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.DocV2.subtitle)
  return _internal_subtitle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocV2::set_subtitle(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000400u;
 _impl_.subtitle_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.DocV2.subtitle)
}
inline std::string* DocV2::mutable_subtitle() {
  std::string* _s = _internal_mutable_subtitle();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.DocV2.subtitle)
  return _s;
}
inline const std::string& DocV2::_internal_subtitle() const {
  return _impl_.subtitle_.Get();
}
inline void DocV2::_internal_set_subtitle(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.subtitle_.Set(value, GetArenaForAllocation());
}
inline std::string* DocV2::_internal_mutable_subtitle() {
  _impl_._has_bits_[0] |= 0x00000400u;
  return _impl_.subtitle_.Mutable(GetArenaForAllocation());
}
inline std::string* DocV2::release_subtitle() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.DocV2.subtitle)
  if (!_internal_has_subtitle()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000400u;
  auto* p = _impl_.subtitle_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.subtitle_.IsDefault()) {
    _impl_.subtitle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DocV2::set_allocated_subtitle(std::string* subtitle) {
  if (subtitle != nullptr) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.subtitle_.SetAllocated(subtitle, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.subtitle_.IsDefault()) {
    _impl_.subtitle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.DocV2.subtitle)
}

// optional string translatedDescriptionHtml = 23;
inline bool DocV2::_internal_has_translateddescriptionhtml() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool DocV2::has_translateddescriptionhtml() const {
  return _internal_has_translateddescriptionhtml();
}
inline void DocV2::clear_translateddescriptionhtml() {
  _impl_.translateddescriptionhtml_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline const std::string& DocV2::translateddescriptionhtml() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.DocV2.translatedDescriptionHtml)
  return _internal_translateddescriptionhtml();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocV2::set_translateddescriptionhtml(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000800u;
 _impl_.translateddescriptionhtml_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.DocV2.translatedDescriptionHtml)
}
inline std::string* DocV2::mutable_translateddescriptionhtml() {
  std::string* _s = _internal_mutable_translateddescriptionhtml();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.DocV2.translatedDescriptionHtml)
  return _s;
}
inline const std::string& DocV2::_internal_translateddescriptionhtml() const {
  return _impl_.translateddescriptionhtml_.Get();
}
inline void DocV2::_internal_set_translateddescriptionhtml(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.translateddescriptionhtml_.Set(value, GetArenaForAllocation());
}
inline std::string* DocV2::_internal_mutable_translateddescriptionhtml() {
  _impl_._has_bits_[0] |= 0x00000800u;
  return _impl_.translateddescriptionhtml_.Mutable(GetArenaForAllocation());
}
inline std::string* DocV2::release_translateddescriptionhtml() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.DocV2.translatedDescriptionHtml)
  if (!_internal_has_translateddescriptionhtml()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000800u;
  auto* p = _impl_.translateddescriptionhtml_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.translateddescriptionhtml_.IsDefault()) {
    _impl_.translateddescriptionhtml_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DocV2::set_allocated_translateddescriptionhtml(std::string* translateddescriptionhtml) {
  if (translateddescriptionhtml != nullptr) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  _impl_.translateddescriptionhtml_.SetAllocated(translateddescriptionhtml, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.translateddescriptionhtml_.IsDefault()) {
    _impl_.translateddescriptionhtml_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.DocV2.translatedDescriptionHtml)
}

// optional bytes serverLogsCookie = 24;
inline bool DocV2::_internal_has_serverlogscookie() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool DocV2::has_serverlogscookie() const {
  return _internal_has_serverlogscookie();
}
inline void DocV2::clear_serverlogscookie() {
  _impl_.serverlogscookie_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline const std::string& DocV2::serverlogscookie() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.DocV2.serverLogsCookie)
  return _internal_serverlogscookie();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocV2::set_serverlogscookie(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00001000u;
 _impl_.serverlogscookie_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.DocV2.serverLogsCookie)
}
inline std::string* DocV2::mutable_serverlogscookie() {
  std::string* _s = _internal_mutable_serverlogscookie();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.DocV2.serverLogsCookie)
  return _s;
}
inline const std::string& DocV2::_internal_serverlogscookie() const {
  return _impl_.serverlogscookie_.Get();
}
inline void DocV2::_internal_set_serverlogscookie(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.serverlogscookie_.Set(value, GetArenaForAllocation());
}
inline std::string* DocV2::_internal_mutable_serverlogscookie() {
  _impl_._has_bits_[0] |= 0x00001000u;
  return _impl_.serverlogscookie_.Mutable(GetArenaForAllocation());
}
inline std::string* DocV2::release_serverlogscookie() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.DocV2.serverLogsCookie)
  if (!_internal_has_serverlogscookie()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00001000u;
  auto* p = _impl_.serverlogscookie_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.serverlogscookie_.IsDefault()) {
    _impl_.serverlogscookie_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DocV2::set_allocated_serverlogscookie(std::string* serverlogscookie) {
  if (serverlogscookie != nullptr) {
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  _impl_.serverlogscookie_.SetAllocated(serverlogscookie, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.serverlogscookie_.IsDefault()) {
    _impl_.serverlogscookie_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.DocV2.serverLogsCookie)
}

// optional .playapi.proto.finsky.document.ProductDetails productDetails = 25;
inline bool DocV2::_internal_has_productdetails() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.productdetails_ != nullptr);
  return value;
}
inline bool DocV2::has_productdetails() const {
  return _internal_has_productdetails();
}
inline void DocV2::clear_productdetails() {
  if (_impl_.productdetails_ != nullptr) _impl_.productdetails_->Clear();
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline const ::playapi::proto::finsky::document::ProductDetails& DocV2::_internal_productdetails() const {
  const ::playapi::proto::finsky::document::ProductDetails* p = _impl_.productdetails_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::ProductDetails&>(
      ::playapi::proto::finsky::document::_ProductDetails_default_instance_);
}
inline const ::playapi::proto::finsky::document::ProductDetails& DocV2::productdetails() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.DocV2.productDetails)
  return _internal_productdetails();
}
inline void DocV2::unsafe_arena_set_allocated_productdetails(
    ::playapi::proto::finsky::document::ProductDetails* productdetails) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.productdetails_);
  }
  _impl_.productdetails_ = productdetails;
  if (productdetails) {
    _impl_._has_bits_[0] |= 0x00100000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00100000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.DocV2.productDetails)
}
inline ::playapi::proto::finsky::document::ProductDetails* DocV2::release_productdetails() {
  _impl_._has_bits_[0] &= ~0x00100000u;
  ::playapi::proto::finsky::document::ProductDetails* temp = _impl_.productdetails_;
  _impl_.productdetails_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::ProductDetails* DocV2::unsafe_arena_release_productdetails() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.DocV2.productDetails)
  _impl_._has_bits_[0] &= ~0x00100000u;
  ::playapi::proto::finsky::document::ProductDetails* temp = _impl_.productdetails_;
  _impl_.productdetails_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::ProductDetails* DocV2::_internal_mutable_productdetails() {
  _impl_._has_bits_[0] |= 0x00100000u;
  if (_impl_.productdetails_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::ProductDetails>(GetArenaForAllocation());
    _impl_.productdetails_ = p;
  }
  return _impl_.productdetails_;
}
inline ::playapi::proto::finsky::document::ProductDetails* DocV2::mutable_productdetails() {
  ::playapi::proto::finsky::document::ProductDetails* _msg = _internal_mutable_productdetails();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.DocV2.productDetails)
  return _msg;
}
inline void DocV2::set_allocated_productdetails(::playapi::proto::finsky::document::ProductDetails* productdetails) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.productdetails_;
  }
  if (productdetails) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(productdetails);
    if (message_arena != submessage_arena) {
      productdetails = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, productdetails, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00100000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00100000u;
  }
  _impl_.productdetails_ = productdetails;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.DocV2.productDetails)
}

// optional bool mature = 26;
inline bool DocV2::_internal_has_mature() const {
  bool value = (_impl_._has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool DocV2::has_mature() const {
  return _internal_has_mature();
}
inline void DocV2::clear_mature() {
  _impl_.mature_ = false;
  _impl_._has_bits_[0] &= ~0x01000000u;
}
inline bool DocV2::_internal_mature() const {
  return _impl_.mature_;
}
inline bool DocV2::mature() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.DocV2.mature)
  return _internal_mature();
}
inline void DocV2::_internal_set_mature(bool value) {
  _impl_._has_bits_[0] |= 0x01000000u;
  _impl_.mature_ = value;
}
inline void DocV2::set_mature(bool value) {
  _internal_set_mature(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.DocV2.mature)
}

// optional string promotionalDescription = 27;
inline bool DocV2::_internal_has_promotionaldescription() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool DocV2::has_promotionaldescription() const {
  return _internal_has_promotionaldescription();
}
inline void DocV2::clear_promotionaldescription() {
  _impl_.promotionaldescription_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline const std::string& DocV2::promotionaldescription() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.DocV2.promotionalDescription)
  return _internal_promotionaldescription();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocV2::set_promotionaldescription(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00002000u;
 _impl_.promotionaldescription_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.DocV2.promotionalDescription)
}
inline std::string* DocV2::mutable_promotionaldescription() {
  std::string* _s = _internal_mutable_promotionaldescription();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.DocV2.promotionalDescription)
  return _s;
}
inline const std::string& DocV2::_internal_promotionaldescription() const {
  return _impl_.promotionaldescription_.Get();
}
inline void DocV2::_internal_set_promotionaldescription(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.promotionaldescription_.Set(value, GetArenaForAllocation());
}
inline std::string* DocV2::_internal_mutable_promotionaldescription() {
  _impl_._has_bits_[0] |= 0x00002000u;
  return _impl_.promotionaldescription_.Mutable(GetArenaForAllocation());
}
inline std::string* DocV2::release_promotionaldescription() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.DocV2.promotionalDescription)
  if (!_internal_has_promotionaldescription()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00002000u;
  auto* p = _impl_.promotionaldescription_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.promotionaldescription_.IsDefault()) {
    _impl_.promotionaldescription_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DocV2::set_allocated_promotionaldescription(std::string* promotionaldescription) {
  if (promotionaldescription != nullptr) {
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  _impl_.promotionaldescription_.SetAllocated(promotionaldescription, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.promotionaldescription_.IsDefault()) {
    _impl_.promotionaldescription_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.DocV2.promotionalDescription)
}

// optional bool availableForPreregistration = 29;
inline bool DocV2::_internal_has_availableforpreregistration() const {
  bool value = (_impl_._has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline bool DocV2::has_availableforpreregistration() const {
  return _internal_has_availableforpreregistration();
}
inline void DocV2::clear_availableforpreregistration() {
  _impl_.availableforpreregistration_ = false;
  _impl_._has_bits_[0] &= ~0x02000000u;
}
inline bool DocV2::_internal_availableforpreregistration() const {
  return _impl_.availableforpreregistration_;
}
inline bool DocV2::availableforpreregistration() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.DocV2.availableForPreregistration)
  return _internal_availableforpreregistration();
}
inline void DocV2::_internal_set_availableforpreregistration(bool value) {
  _impl_._has_bits_[0] |= 0x02000000u;
  _impl_.availableforpreregistration_ = value;
}
inline void DocV2::set_availableforpreregistration(bool value) {
  _internal_set_availableforpreregistration(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.DocV2.availableForPreregistration)
}

// repeated .playapi.proto.finsky.document.ReviewTip tip = 30;
inline int DocV2::_internal_tip_size() const {
  return _impl_.tip_.size();
}
inline int DocV2::tip_size() const {
  return _internal_tip_size();
}
inline void DocV2::clear_tip() {
  _impl_.tip_.Clear();
}
inline ::playapi::proto::finsky::document::ReviewTip* DocV2::mutable_tip(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.DocV2.tip)
  return _impl_.tip_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::ReviewTip >*
DocV2::mutable_tip() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.document.DocV2.tip)
  return &_impl_.tip_;
}
inline const ::playapi::proto::finsky::document::ReviewTip& DocV2::_internal_tip(int index) const {
  return _impl_.tip_.Get(index);
}
inline const ::playapi::proto::finsky::document::ReviewTip& DocV2::tip(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.DocV2.tip)
  return _internal_tip(index);
}
inline ::playapi::proto::finsky::document::ReviewTip* DocV2::_internal_add_tip() {
  return _impl_.tip_.Add();
}
inline ::playapi::proto::finsky::document::ReviewTip* DocV2::add_tip() {
  ::playapi::proto::finsky::document::ReviewTip* _add = _internal_add_tip();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.DocV2.tip)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::ReviewTip >&
DocV2::tip() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.document.DocV2.tip)
  return _impl_.tip_;
}

// optional string snippetsUrl = 31;
inline bool DocV2::_internal_has_snippetsurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool DocV2::has_snippetsurl() const {
  return _internal_has_snippetsurl();
}
inline void DocV2::clear_snippetsurl() {
  _impl_.snippetsurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline const std::string& DocV2::snippetsurl() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.DocV2.snippetsUrl)
  return _internal_snippetsurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DocV2::set_snippetsurl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00004000u;
 _impl_.snippetsurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.DocV2.snippetsUrl)
}
inline std::string* DocV2::mutable_snippetsurl() {
  std::string* _s = _internal_mutable_snippetsurl();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.DocV2.snippetsUrl)
  return _s;
}
inline const std::string& DocV2::_internal_snippetsurl() const {
  return _impl_.snippetsurl_.Get();
}
inline void DocV2::_internal_set_snippetsurl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.snippetsurl_.Set(value, GetArenaForAllocation());
}
inline std::string* DocV2::_internal_mutable_snippetsurl() {
  _impl_._has_bits_[0] |= 0x00004000u;
  return _impl_.snippetsurl_.Mutable(GetArenaForAllocation());
}
inline std::string* DocV2::release_snippetsurl() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.DocV2.snippetsUrl)
  if (!_internal_has_snippetsurl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00004000u;
  auto* p = _impl_.snippetsurl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.snippetsurl_.IsDefault()) {
    _impl_.snippetsurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DocV2::set_allocated_snippetsurl(std::string* snippetsurl) {
  if (snippetsurl != nullptr) {
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }
  _impl_.snippetsurl_.SetAllocated(snippetsurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.snippetsurl_.IsDefault()) {
    _impl_.snippetsurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.DocV2.snippetsUrl)
}

// optional bool forceShareability = 32;
inline bool DocV2::_internal_has_forceshareability() const {
  bool value = (_impl_._has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline bool DocV2::has_forceshareability() const {
  return _internal_has_forceshareability();
}
inline void DocV2::clear_forceshareability() {
  _impl_.forceshareability_ = false;
  _impl_._has_bits_[0] &= ~0x04000000u;
}
inline bool DocV2::_internal_forceshareability() const {
  return _impl_.forceshareability_;
}
inline bool DocV2::forceshareability() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.DocV2.forceShareability)
  return _internal_forceshareability();
}
inline void DocV2::_internal_set_forceshareability(bool value) {
  _impl_._has_bits_[0] |= 0x04000000u;
  _impl_.forceshareability_ = value;
}
inline void DocV2::set_forceshareability(bool value) {
  _internal_set_forceshareability(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.DocV2.forceShareability)
}

// optional bool useWishlistAsPrimaryAction = 33;
inline bool DocV2::_internal_has_usewishlistasprimaryaction() const {
  bool value = (_impl_._has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline bool DocV2::has_usewishlistasprimaryaction() const {
  return _internal_has_usewishlistasprimaryaction();
}
inline void DocV2::clear_usewishlistasprimaryaction() {
  _impl_.usewishlistasprimaryaction_ = false;
  _impl_._has_bits_[0] &= ~0x08000000u;
}
inline bool DocV2::_internal_usewishlistasprimaryaction() const {
  return _impl_.usewishlistasprimaryaction_;
}
inline bool DocV2::usewishlistasprimaryaction() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.DocV2.useWishlistAsPrimaryAction)
  return _internal_usewishlistasprimaryaction();
}
inline void DocV2::_internal_set_usewishlistasprimaryaction(bool value) {
  _impl_._has_bits_[0] |= 0x08000000u;
  _impl_.usewishlistasprimaryaction_ = value;
}
inline void DocV2::set_usewishlistasprimaryaction(bool value) {
  _internal_set_usewishlistasprimaryaction(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.DocV2.useWishlistAsPrimaryAction)
}

// -------------------------------------------------------------------

// Annotations

// optional .playapi.proto.finsky.document.SectionMetadata sectionRelated = 1;
inline bool Annotations::_internal_has_sectionrelated() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sectionrelated_ != nullptr);
  return value;
}
inline bool Annotations::has_sectionrelated() const {
  return _internal_has_sectionrelated();
}
inline void Annotations::clear_sectionrelated() {
  if (_impl_.sectionrelated_ != nullptr) _impl_.sectionrelated_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::playapi::proto::finsky::document::SectionMetadata& Annotations::_internal_sectionrelated() const {
  const ::playapi::proto::finsky::document::SectionMetadata* p = _impl_.sectionrelated_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::SectionMetadata&>(
      ::playapi::proto::finsky::document::_SectionMetadata_default_instance_);
}
inline const ::playapi::proto::finsky::document::SectionMetadata& Annotations::sectionrelated() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Annotations.sectionRelated)
  return _internal_sectionrelated();
}
inline void Annotations::unsafe_arena_set_allocated_sectionrelated(
    ::playapi::proto::finsky::document::SectionMetadata* sectionrelated) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sectionrelated_);
  }
  _impl_.sectionrelated_ = sectionrelated;
  if (sectionrelated) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.Annotations.sectionRelated)
}
inline ::playapi::proto::finsky::document::SectionMetadata* Annotations::release_sectionrelated() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::playapi::proto::finsky::document::SectionMetadata* temp = _impl_.sectionrelated_;
  _impl_.sectionrelated_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::SectionMetadata* Annotations::unsafe_arena_release_sectionrelated() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.Annotations.sectionRelated)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::playapi::proto::finsky::document::SectionMetadata* temp = _impl_.sectionrelated_;
  _impl_.sectionrelated_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::SectionMetadata* Annotations::_internal_mutable_sectionrelated() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.sectionrelated_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::SectionMetadata>(GetArenaForAllocation());
    _impl_.sectionrelated_ = p;
  }
  return _impl_.sectionrelated_;
}
inline ::playapi::proto::finsky::document::SectionMetadata* Annotations::mutable_sectionrelated() {
  ::playapi::proto::finsky::document::SectionMetadata* _msg = _internal_mutable_sectionrelated();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Annotations.sectionRelated)
  return _msg;
}
inline void Annotations::set_allocated_sectionrelated(::playapi::proto::finsky::document::SectionMetadata* sectionrelated) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.sectionrelated_;
  }
  if (sectionrelated) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sectionrelated);
    if (message_arena != submessage_arena) {
      sectionrelated = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sectionrelated, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.sectionrelated_ = sectionrelated;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.Annotations.sectionRelated)
}

// optional .playapi.proto.finsky.document.SectionMetadata sectionMoreBy = 2;
inline bool Annotations::_internal_has_sectionmoreby() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sectionmoreby_ != nullptr);
  return value;
}
inline bool Annotations::has_sectionmoreby() const {
  return _internal_has_sectionmoreby();
}
inline void Annotations::clear_sectionmoreby() {
  if (_impl_.sectionmoreby_ != nullptr) _impl_.sectionmoreby_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::playapi::proto::finsky::document::SectionMetadata& Annotations::_internal_sectionmoreby() const {
  const ::playapi::proto::finsky::document::SectionMetadata* p = _impl_.sectionmoreby_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::SectionMetadata&>(
      ::playapi::proto::finsky::document::_SectionMetadata_default_instance_);
}
inline const ::playapi::proto::finsky::document::SectionMetadata& Annotations::sectionmoreby() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Annotations.sectionMoreBy)
  return _internal_sectionmoreby();
}
inline void Annotations::unsafe_arena_set_allocated_sectionmoreby(
    ::playapi::proto::finsky::document::SectionMetadata* sectionmoreby) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sectionmoreby_);
  }
  _impl_.sectionmoreby_ = sectionmoreby;
  if (sectionmoreby) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.Annotations.sectionMoreBy)
}
inline ::playapi::proto::finsky::document::SectionMetadata* Annotations::release_sectionmoreby() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::playapi::proto::finsky::document::SectionMetadata* temp = _impl_.sectionmoreby_;
  _impl_.sectionmoreby_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::SectionMetadata* Annotations::unsafe_arena_release_sectionmoreby() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.Annotations.sectionMoreBy)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::playapi::proto::finsky::document::SectionMetadata* temp = _impl_.sectionmoreby_;
  _impl_.sectionmoreby_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::SectionMetadata* Annotations::_internal_mutable_sectionmoreby() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.sectionmoreby_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::SectionMetadata>(GetArenaForAllocation());
    _impl_.sectionmoreby_ = p;
  }
  return _impl_.sectionmoreby_;
}
inline ::playapi::proto::finsky::document::SectionMetadata* Annotations::mutable_sectionmoreby() {
  ::playapi::proto::finsky::document::SectionMetadata* _msg = _internal_mutable_sectionmoreby();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Annotations.sectionMoreBy)
  return _msg;
}
inline void Annotations::set_allocated_sectionmoreby(::playapi::proto::finsky::document::SectionMetadata* sectionmoreby) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.sectionmoreby_;
  }
  if (sectionmoreby) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sectionmoreby);
    if (message_arena != submessage_arena) {
      sectionmoreby = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sectionmoreby, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.sectionmoreby_ = sectionmoreby;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.Annotations.sectionMoreBy)
}

// optional .playapi.proto.finsky.document.PlusOneData plusOneData = 3;
inline bool Annotations::_internal_has_plusonedata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.plusonedata_ != nullptr);
  return value;
}
inline bool Annotations::has_plusonedata() const {
  return _internal_has_plusonedata();
}
inline void Annotations::clear_plusonedata() {
  if (_impl_.plusonedata_ != nullptr) _impl_.plusonedata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::playapi::proto::finsky::document::PlusOneData& Annotations::_internal_plusonedata() const {
  const ::playapi::proto::finsky::document::PlusOneData* p = _impl_.plusonedata_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::PlusOneData&>(
      ::playapi::proto::finsky::document::_PlusOneData_default_instance_);
}
inline const ::playapi::proto::finsky::document::PlusOneData& Annotations::plusonedata() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Annotations.plusOneData)
  return _internal_plusonedata();
}
inline void Annotations::unsafe_arena_set_allocated_plusonedata(
    ::playapi::proto::finsky::document::PlusOneData* plusonedata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.plusonedata_);
  }
  _impl_.plusonedata_ = plusonedata;
  if (plusonedata) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.Annotations.plusOneData)
}
inline ::playapi::proto::finsky::document::PlusOneData* Annotations::release_plusonedata() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::playapi::proto::finsky::document::PlusOneData* temp = _impl_.plusonedata_;
  _impl_.plusonedata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::PlusOneData* Annotations::unsafe_arena_release_plusonedata() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.Annotations.plusOneData)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::playapi::proto::finsky::document::PlusOneData* temp = _impl_.plusonedata_;
  _impl_.plusonedata_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::PlusOneData* Annotations::_internal_mutable_plusonedata() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.plusonedata_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::PlusOneData>(GetArenaForAllocation());
    _impl_.plusonedata_ = p;
  }
  return _impl_.plusonedata_;
}
inline ::playapi::proto::finsky::document::PlusOneData* Annotations::mutable_plusonedata() {
  ::playapi::proto::finsky::document::PlusOneData* _msg = _internal_mutable_plusonedata();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Annotations.plusOneData)
  return _msg;
}
inline void Annotations::set_allocated_plusonedata(::playapi::proto::finsky::document::PlusOneData* plusonedata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.plusonedata_;
  }
  if (plusonedata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(plusonedata);
    if (message_arena != submessage_arena) {
      plusonedata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, plusonedata, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.plusonedata_ = plusonedata;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.Annotations.plusOneData)
}

// repeated .playapi.proto.finsky.document.Warning warning = 4;
inline int Annotations::_internal_warning_size() const {
  return _impl_.warning_.size();
}
inline int Annotations::warning_size() const {
  return _internal_warning_size();
}
inline void Annotations::clear_warning() {
  _impl_.warning_.Clear();
}
inline ::playapi::proto::finsky::document::Warning* Annotations::mutable_warning(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Annotations.warning)
  return _impl_.warning_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::Warning >*
Annotations::mutable_warning() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.document.Annotations.warning)
  return &_impl_.warning_;
}
inline const ::playapi::proto::finsky::document::Warning& Annotations::_internal_warning(int index) const {
  return _impl_.warning_.Get(index);
}
inline const ::playapi::proto::finsky::document::Warning& Annotations::warning(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Annotations.warning)
  return _internal_warning(index);
}
inline ::playapi::proto::finsky::document::Warning* Annotations::_internal_add_warning() {
  return _impl_.warning_.Add();
}
inline ::playapi::proto::finsky::document::Warning* Annotations::add_warning() {
  ::playapi::proto::finsky::document::Warning* _add = _internal_add_warning();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.Annotations.warning)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::Warning >&
Annotations::warning() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.document.Annotations.warning)
  return _impl_.warning_;
}

// optional .playapi.proto.finsky.document.SectionMetadata sectionBodyOfWork = 5;
inline bool Annotations::_internal_has_sectionbodyofwork() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sectionbodyofwork_ != nullptr);
  return value;
}
inline bool Annotations::has_sectionbodyofwork() const {
  return _internal_has_sectionbodyofwork();
}
inline void Annotations::clear_sectionbodyofwork() {
  if (_impl_.sectionbodyofwork_ != nullptr) _impl_.sectionbodyofwork_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::playapi::proto::finsky::document::SectionMetadata& Annotations::_internal_sectionbodyofwork() const {
  const ::playapi::proto::finsky::document::SectionMetadata* p = _impl_.sectionbodyofwork_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::SectionMetadata&>(
      ::playapi::proto::finsky::document::_SectionMetadata_default_instance_);
}
inline const ::playapi::proto::finsky::document::SectionMetadata& Annotations::sectionbodyofwork() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Annotations.sectionBodyOfWork)
  return _internal_sectionbodyofwork();
}
inline void Annotations::unsafe_arena_set_allocated_sectionbodyofwork(
    ::playapi::proto::finsky::document::SectionMetadata* sectionbodyofwork) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sectionbodyofwork_);
  }
  _impl_.sectionbodyofwork_ = sectionbodyofwork;
  if (sectionbodyofwork) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.Annotations.sectionBodyOfWork)
}
inline ::playapi::proto::finsky::document::SectionMetadata* Annotations::release_sectionbodyofwork() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::playapi::proto::finsky::document::SectionMetadata* temp = _impl_.sectionbodyofwork_;
  _impl_.sectionbodyofwork_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::SectionMetadata* Annotations::unsafe_arena_release_sectionbodyofwork() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.Annotations.sectionBodyOfWork)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::playapi::proto::finsky::document::SectionMetadata* temp = _impl_.sectionbodyofwork_;
  _impl_.sectionbodyofwork_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::SectionMetadata* Annotations::_internal_mutable_sectionbodyofwork() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.sectionbodyofwork_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::SectionMetadata>(GetArenaForAllocation());
    _impl_.sectionbodyofwork_ = p;
  }
  return _impl_.sectionbodyofwork_;
}
inline ::playapi::proto::finsky::document::SectionMetadata* Annotations::mutable_sectionbodyofwork() {
  ::playapi::proto::finsky::document::SectionMetadata* _msg = _internal_mutable_sectionbodyofwork();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Annotations.sectionBodyOfWork)
  return _msg;
}
inline void Annotations::set_allocated_sectionbodyofwork(::playapi::proto::finsky::document::SectionMetadata* sectionbodyofwork) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.sectionbodyofwork_;
  }
  if (sectionbodyofwork) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sectionbodyofwork);
    if (message_arena != submessage_arena) {
      sectionbodyofwork = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sectionbodyofwork, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.sectionbodyofwork_ = sectionbodyofwork;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.Annotations.sectionBodyOfWork)
}

// optional .playapi.proto.finsky.document.SectionMetadata sectionCoreContent = 6;
inline bool Annotations::_internal_has_sectioncorecontent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sectioncorecontent_ != nullptr);
  return value;
}
inline bool Annotations::has_sectioncorecontent() const {
  return _internal_has_sectioncorecontent();
}
inline void Annotations::clear_sectioncorecontent() {
  if (_impl_.sectioncorecontent_ != nullptr) _impl_.sectioncorecontent_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::playapi::proto::finsky::document::SectionMetadata& Annotations::_internal_sectioncorecontent() const {
  const ::playapi::proto::finsky::document::SectionMetadata* p = _impl_.sectioncorecontent_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::SectionMetadata&>(
      ::playapi::proto::finsky::document::_SectionMetadata_default_instance_);
}
inline const ::playapi::proto::finsky::document::SectionMetadata& Annotations::sectioncorecontent() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Annotations.sectionCoreContent)
  return _internal_sectioncorecontent();
}
inline void Annotations::unsafe_arena_set_allocated_sectioncorecontent(
    ::playapi::proto::finsky::document::SectionMetadata* sectioncorecontent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sectioncorecontent_);
  }
  _impl_.sectioncorecontent_ = sectioncorecontent;
  if (sectioncorecontent) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.Annotations.sectionCoreContent)
}
inline ::playapi::proto::finsky::document::SectionMetadata* Annotations::release_sectioncorecontent() {
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::playapi::proto::finsky::document::SectionMetadata* temp = _impl_.sectioncorecontent_;
  _impl_.sectioncorecontent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::SectionMetadata* Annotations::unsafe_arena_release_sectioncorecontent() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.Annotations.sectionCoreContent)
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::playapi::proto::finsky::document::SectionMetadata* temp = _impl_.sectioncorecontent_;
  _impl_.sectioncorecontent_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::SectionMetadata* Annotations::_internal_mutable_sectioncorecontent() {
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.sectioncorecontent_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::SectionMetadata>(GetArenaForAllocation());
    _impl_.sectioncorecontent_ = p;
  }
  return _impl_.sectioncorecontent_;
}
inline ::playapi::proto::finsky::document::SectionMetadata* Annotations::mutable_sectioncorecontent() {
  ::playapi::proto::finsky::document::SectionMetadata* _msg = _internal_mutable_sectioncorecontent();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Annotations.sectionCoreContent)
  return _msg;
}
inline void Annotations::set_allocated_sectioncorecontent(::playapi::proto::finsky::document::SectionMetadata* sectioncorecontent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.sectioncorecontent_;
  }
  if (sectioncorecontent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sectioncorecontent);
    if (message_arena != submessage_arena) {
      sectioncorecontent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sectioncorecontent, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.sectioncorecontent_ = sectioncorecontent;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.Annotations.sectionCoreContent)
}

// repeated .playapi.proto.finsky.document.Badge badgeForCreator = 8;
inline int Annotations::_internal_badgeforcreator_size() const {
  return _impl_.badgeforcreator_.size();
}
inline int Annotations::badgeforcreator_size() const {
  return _internal_badgeforcreator_size();
}
inline void Annotations::clear_badgeforcreator() {
  _impl_.badgeforcreator_.Clear();
}
inline ::playapi::proto::finsky::document::Badge* Annotations::mutable_badgeforcreator(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Annotations.badgeForCreator)
  return _impl_.badgeforcreator_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::Badge >*
Annotations::mutable_badgeforcreator() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.document.Annotations.badgeForCreator)
  return &_impl_.badgeforcreator_;
}
inline const ::playapi::proto::finsky::document::Badge& Annotations::_internal_badgeforcreator(int index) const {
  return _impl_.badgeforcreator_.Get(index);
}
inline const ::playapi::proto::finsky::document::Badge& Annotations::badgeforcreator(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Annotations.badgeForCreator)
  return _internal_badgeforcreator(index);
}
inline ::playapi::proto::finsky::document::Badge* Annotations::_internal_add_badgeforcreator() {
  return _impl_.badgeforcreator_.Add();
}
inline ::playapi::proto::finsky::document::Badge* Annotations::add_badgeforcreator() {
  ::playapi::proto::finsky::document::Badge* _add = _internal_add_badgeforcreator();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.Annotations.badgeForCreator)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::Badge >&
Annotations::badgeforcreator() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.document.Annotations.badgeForCreator)
  return _impl_.badgeforcreator_;
}

// repeated .playapi.proto.finsky.document.Badge badgeForDoc = 9;
inline int Annotations::_internal_badgefordoc_size() const {
  return _impl_.badgefordoc_.size();
}
inline int Annotations::badgefordoc_size() const {
  return _internal_badgefordoc_size();
}
inline void Annotations::clear_badgefordoc() {
  _impl_.badgefordoc_.Clear();
}
inline ::playapi::proto::finsky::document::Badge* Annotations::mutable_badgefordoc(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Annotations.badgeForDoc)
  return _impl_.badgefordoc_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::Badge >*
Annotations::mutable_badgefordoc() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.document.Annotations.badgeForDoc)
  return &_impl_.badgefordoc_;
}
inline const ::playapi::proto::finsky::document::Badge& Annotations::_internal_badgefordoc(int index) const {
  return _impl_.badgefordoc_.Get(index);
}
inline const ::playapi::proto::finsky::document::Badge& Annotations::badgefordoc(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Annotations.badgeForDoc)
  return _internal_badgefordoc(index);
}
inline ::playapi::proto::finsky::document::Badge* Annotations::_internal_add_badgefordoc() {
  return _impl_.badgefordoc_.Add();
}
inline ::playapi::proto::finsky::document::Badge* Annotations::add_badgefordoc() {
  ::playapi::proto::finsky::document::Badge* _add = _internal_add_badgefordoc();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.Annotations.badgeForDoc)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::Badge >&
Annotations::badgefordoc() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.document.Annotations.badgeForDoc)
  return _impl_.badgefordoc_;
}

// optional .playapi.proto.finsky.link.Link link = 10;
inline bool Annotations::_internal_has_link() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.link_ != nullptr);
  return value;
}
inline bool Annotations::has_link() const {
  return _internal_has_link();
}
inline const ::playapi::proto::finsky::link::Link& Annotations::_internal_link() const {
  const ::playapi::proto::finsky::link::Link* p = _impl_.link_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::link::Link&>(
      ::playapi::proto::finsky::link::_Link_default_instance_);
}
inline const ::playapi::proto::finsky::link::Link& Annotations::link() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Annotations.link)
  return _internal_link();
}
inline void Annotations::unsafe_arena_set_allocated_link(
    ::playapi::proto::finsky::link::Link* link) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.link_);
  }
  _impl_.link_ = link;
  if (link) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.Annotations.link)
}
inline ::playapi::proto::finsky::link::Link* Annotations::release_link() {
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::playapi::proto::finsky::link::Link* temp = _impl_.link_;
  _impl_.link_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::link::Link* Annotations::unsafe_arena_release_link() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.Annotations.link)
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::playapi::proto::finsky::link::Link* temp = _impl_.link_;
  _impl_.link_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::link::Link* Annotations::_internal_mutable_link() {
  _impl_._has_bits_[0] |= 0x00000200u;
  if (_impl_.link_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::link::Link>(GetArenaForAllocation());
    _impl_.link_ = p;
  }
  return _impl_.link_;
}
inline ::playapi::proto::finsky::link::Link* Annotations::mutable_link() {
  ::playapi::proto::finsky::link::Link* _msg = _internal_mutable_link();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Annotations.link)
  return _msg;
}
inline void Annotations::set_allocated_link(::playapi::proto::finsky::link::Link* link) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.link_);
  }
  if (link) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(link));
    if (message_arena != submessage_arena) {
      link = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, link, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.link_ = link;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.Annotations.link)
}

// optional .playapi.proto.finsky.document.SectionMetadata sectionCrossSell = 11;
inline bool Annotations::_internal_has_sectioncrosssell() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sectioncrosssell_ != nullptr);
  return value;
}
inline bool Annotations::has_sectioncrosssell() const {
  return _internal_has_sectioncrosssell();
}
inline void Annotations::clear_sectioncrosssell() {
  if (_impl_.sectioncrosssell_ != nullptr) _impl_.sectioncrosssell_->Clear();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const ::playapi::proto::finsky::document::SectionMetadata& Annotations::_internal_sectioncrosssell() const {
  const ::playapi::proto::finsky::document::SectionMetadata* p = _impl_.sectioncrosssell_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::SectionMetadata&>(
      ::playapi::proto::finsky::document::_SectionMetadata_default_instance_);
}
inline const ::playapi::proto::finsky::document::SectionMetadata& Annotations::sectioncrosssell() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Annotations.sectionCrossSell)
  return _internal_sectioncrosssell();
}
inline void Annotations::unsafe_arena_set_allocated_sectioncrosssell(
    ::playapi::proto::finsky::document::SectionMetadata* sectioncrosssell) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sectioncrosssell_);
  }
  _impl_.sectioncrosssell_ = sectioncrosssell;
  if (sectioncrosssell) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.Annotations.sectionCrossSell)
}
inline ::playapi::proto::finsky::document::SectionMetadata* Annotations::release_sectioncrosssell() {
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::playapi::proto::finsky::document::SectionMetadata* temp = _impl_.sectioncrosssell_;
  _impl_.sectioncrosssell_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::SectionMetadata* Annotations::unsafe_arena_release_sectioncrosssell() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.Annotations.sectionCrossSell)
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::playapi::proto::finsky::document::SectionMetadata* temp = _impl_.sectioncrosssell_;
  _impl_.sectioncrosssell_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::SectionMetadata* Annotations::_internal_mutable_sectioncrosssell() {
  _impl_._has_bits_[0] |= 0x00000400u;
  if (_impl_.sectioncrosssell_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::SectionMetadata>(GetArenaForAllocation());
    _impl_.sectioncrosssell_ = p;
  }
  return _impl_.sectioncrosssell_;
}
inline ::playapi::proto::finsky::document::SectionMetadata* Annotations::mutable_sectioncrosssell() {
  ::playapi::proto::finsky::document::SectionMetadata* _msg = _internal_mutable_sectioncrosssell();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Annotations.sectionCrossSell)
  return _msg;
}
inline void Annotations::set_allocated_sectioncrosssell(::playapi::proto::finsky::document::SectionMetadata* sectioncrosssell) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.sectioncrosssell_;
  }
  if (sectioncrosssell) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sectioncrosssell);
    if (message_arena != submessage_arena) {
      sectioncrosssell = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sectioncrosssell, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.sectioncrosssell_ = sectioncrosssell;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.Annotations.sectionCrossSell)
}

// optional .playapi.proto.finsky.document.SectionMetadata sectionRelatedDocType = 12;
inline bool Annotations::_internal_has_sectionrelateddoctype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sectionrelateddoctype_ != nullptr);
  return value;
}
inline bool Annotations::has_sectionrelateddoctype() const {
  return _internal_has_sectionrelateddoctype();
}
inline void Annotations::clear_sectionrelateddoctype() {
  if (_impl_.sectionrelateddoctype_ != nullptr) _impl_.sectionrelateddoctype_->Clear();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline const ::playapi::proto::finsky::document::SectionMetadata& Annotations::_internal_sectionrelateddoctype() const {
  const ::playapi::proto::finsky::document::SectionMetadata* p = _impl_.sectionrelateddoctype_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::SectionMetadata&>(
      ::playapi::proto::finsky::document::_SectionMetadata_default_instance_);
}
inline const ::playapi::proto::finsky::document::SectionMetadata& Annotations::sectionrelateddoctype() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Annotations.sectionRelatedDocType)
  return _internal_sectionrelateddoctype();
}
inline void Annotations::unsafe_arena_set_allocated_sectionrelateddoctype(
    ::playapi::proto::finsky::document::SectionMetadata* sectionrelateddoctype) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sectionrelateddoctype_);
  }
  _impl_.sectionrelateddoctype_ = sectionrelateddoctype;
  if (sectionrelateddoctype) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.Annotations.sectionRelatedDocType)
}
inline ::playapi::proto::finsky::document::SectionMetadata* Annotations::release_sectionrelateddoctype() {
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::playapi::proto::finsky::document::SectionMetadata* temp = _impl_.sectionrelateddoctype_;
  _impl_.sectionrelateddoctype_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::SectionMetadata* Annotations::unsafe_arena_release_sectionrelateddoctype() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.Annotations.sectionRelatedDocType)
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::playapi::proto::finsky::document::SectionMetadata* temp = _impl_.sectionrelateddoctype_;
  _impl_.sectionrelateddoctype_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::SectionMetadata* Annotations::_internal_mutable_sectionrelateddoctype() {
  _impl_._has_bits_[0] |= 0x00000800u;
  if (_impl_.sectionrelateddoctype_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::SectionMetadata>(GetArenaForAllocation());
    _impl_.sectionrelateddoctype_ = p;
  }
  return _impl_.sectionrelateddoctype_;
}
inline ::playapi::proto::finsky::document::SectionMetadata* Annotations::mutable_sectionrelateddoctype() {
  ::playapi::proto::finsky::document::SectionMetadata* _msg = _internal_mutable_sectionrelateddoctype();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Annotations.sectionRelatedDocType)
  return _msg;
}
inline void Annotations::set_allocated_sectionrelateddoctype(::playapi::proto::finsky::document::SectionMetadata* sectionrelateddoctype) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.sectionrelateddoctype_;
  }
  if (sectionrelateddoctype) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sectionrelateddoctype);
    if (message_arena != submessage_arena) {
      sectionrelateddoctype = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sectionrelateddoctype, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  _impl_.sectionrelateddoctype_ = sectionrelateddoctype;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.Annotations.sectionRelatedDocType)
}

// repeated .playapi.proto.finsky.document.PromotedDoc promotedDoc = 13;
inline int Annotations::_internal_promoteddoc_size() const {
  return _impl_.promoteddoc_.size();
}
inline int Annotations::promoteddoc_size() const {
  return _internal_promoteddoc_size();
}
inline void Annotations::clear_promoteddoc() {
  _impl_.promoteddoc_.Clear();
}
inline ::playapi::proto::finsky::document::PromotedDoc* Annotations::mutable_promoteddoc(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Annotations.promotedDoc)
  return _impl_.promoteddoc_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::PromotedDoc >*
Annotations::mutable_promoteddoc() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.document.Annotations.promotedDoc)
  return &_impl_.promoteddoc_;
}
inline const ::playapi::proto::finsky::document::PromotedDoc& Annotations::_internal_promoteddoc(int index) const {
  return _impl_.promoteddoc_.Get(index);
}
inline const ::playapi::proto::finsky::document::PromotedDoc& Annotations::promoteddoc(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Annotations.promotedDoc)
  return _internal_promoteddoc(index);
}
inline ::playapi::proto::finsky::document::PromotedDoc* Annotations::_internal_add_promoteddoc() {
  return _impl_.promoteddoc_.Add();
}
inline ::playapi::proto::finsky::document::PromotedDoc* Annotations::add_promoteddoc() {
  ::playapi::proto::finsky::document::PromotedDoc* _add = _internal_add_promoteddoc();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.Annotations.promotedDoc)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::PromotedDoc >&
Annotations::promoteddoc() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.document.Annotations.promotedDoc)
  return _impl_.promoteddoc_;
}

// optional string offerNote = 14;
inline bool Annotations::_internal_has_offernote() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Annotations::has_offernote() const {
  return _internal_has_offernote();
}
inline void Annotations::clear_offernote() {
  _impl_.offernote_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Annotations::offernote() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Annotations.offerNote)
  return _internal_offernote();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Annotations::set_offernote(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.offernote_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.Annotations.offerNote)
}
inline std::string* Annotations::mutable_offernote() {
  std::string* _s = _internal_mutable_offernote();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Annotations.offerNote)
  return _s;
}
inline const std::string& Annotations::_internal_offernote() const {
  return _impl_.offernote_.Get();
}
inline void Annotations::_internal_set_offernote(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.offernote_.Set(value, GetArenaForAllocation());
}
inline std::string* Annotations::_internal_mutable_offernote() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.offernote_.Mutable(GetArenaForAllocation());
}
inline std::string* Annotations::release_offernote() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.Annotations.offerNote)
  if (!_internal_has_offernote()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.offernote_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.offernote_.IsDefault()) {
    _impl_.offernote_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Annotations::set_allocated_offernote(std::string* offernote) {
  if (offernote != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.offernote_.SetAllocated(offernote, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.offernote_.IsDefault()) {
    _impl_.offernote_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.Annotations.offerNote)
}

// repeated .playapi.proto.finsky.document.DocV2 subscription = 16;
inline int Annotations::_internal_subscription_size() const {
  return _impl_.subscription_.size();
}
inline int Annotations::subscription_size() const {
  return _internal_subscription_size();
}
inline void Annotations::clear_subscription() {
  _impl_.subscription_.Clear();
}
inline ::playapi::proto::finsky::document::DocV2* Annotations::mutable_subscription(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Annotations.subscription)
  return _impl_.subscription_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::DocV2 >*
Annotations::mutable_subscription() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.document.Annotations.subscription)
  return &_impl_.subscription_;
}
inline const ::playapi::proto::finsky::document::DocV2& Annotations::_internal_subscription(int index) const {
  return _impl_.subscription_.Get(index);
}
inline const ::playapi::proto::finsky::document::DocV2& Annotations::subscription(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Annotations.subscription)
  return _internal_subscription(index);
}
inline ::playapi::proto::finsky::document::DocV2* Annotations::_internal_add_subscription() {
  return _impl_.subscription_.Add();
}
inline ::playapi::proto::finsky::document::DocV2* Annotations::add_subscription() {
  ::playapi::proto::finsky::document::DocV2* _add = _internal_add_subscription();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.Annotations.subscription)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::DocV2 >&
Annotations::subscription() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.document.Annotations.subscription)
  return _impl_.subscription_;
}

// optional .playapi.proto.finsky.document.OBSOLETE_Reason OBSOLETEReason = 17;
inline bool Annotations::_internal_has_obsoletereason() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.obsoletereason_ != nullptr);
  return value;
}
inline bool Annotations::has_obsoletereason() const {
  return _internal_has_obsoletereason();
}
inline void Annotations::clear_obsoletereason() {
  if (_impl_.obsoletereason_ != nullptr) _impl_.obsoletereason_->Clear();
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline const ::playapi::proto::finsky::document::OBSOLETE_Reason& Annotations::_internal_obsoletereason() const {
  const ::playapi::proto::finsky::document::OBSOLETE_Reason* p = _impl_.obsoletereason_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::OBSOLETE_Reason&>(
      ::playapi::proto::finsky::document::_OBSOLETE_Reason_default_instance_);
}
inline const ::playapi::proto::finsky::document::OBSOLETE_Reason& Annotations::obsoletereason() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Annotations.OBSOLETEReason)
  return _internal_obsoletereason();
}
inline void Annotations::unsafe_arena_set_allocated_obsoletereason(
    ::playapi::proto::finsky::document::OBSOLETE_Reason* obsoletereason) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.obsoletereason_);
  }
  _impl_.obsoletereason_ = obsoletereason;
  if (obsoletereason) {
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.Annotations.OBSOLETEReason)
}
inline ::playapi::proto::finsky::document::OBSOLETE_Reason* Annotations::release_obsoletereason() {
  _impl_._has_bits_[0] &= ~0x00001000u;
  ::playapi::proto::finsky::document::OBSOLETE_Reason* temp = _impl_.obsoletereason_;
  _impl_.obsoletereason_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::OBSOLETE_Reason* Annotations::unsafe_arena_release_obsoletereason() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.Annotations.OBSOLETEReason)
  _impl_._has_bits_[0] &= ~0x00001000u;
  ::playapi::proto::finsky::document::OBSOLETE_Reason* temp = _impl_.obsoletereason_;
  _impl_.obsoletereason_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::OBSOLETE_Reason* Annotations::_internal_mutable_obsoletereason() {
  _impl_._has_bits_[0] |= 0x00001000u;
  if (_impl_.obsoletereason_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::OBSOLETE_Reason>(GetArenaForAllocation());
    _impl_.obsoletereason_ = p;
  }
  return _impl_.obsoletereason_;
}
inline ::playapi::proto::finsky::document::OBSOLETE_Reason* Annotations::mutable_obsoletereason() {
  ::playapi::proto::finsky::document::OBSOLETE_Reason* _msg = _internal_mutable_obsoletereason();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Annotations.OBSOLETEReason)
  return _msg;
}
inline void Annotations::set_allocated_obsoletereason(::playapi::proto::finsky::document::OBSOLETE_Reason* obsoletereason) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.obsoletereason_;
  }
  if (obsoletereason) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(obsoletereason);
    if (message_arena != submessage_arena) {
      obsoletereason = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, obsoletereason, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  _impl_.obsoletereason_ = obsoletereason;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.Annotations.OBSOLETEReason)
}

// optional string privacyPolicyUrl = 18;
inline bool Annotations::_internal_has_privacypolicyurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Annotations::has_privacypolicyurl() const {
  return _internal_has_privacypolicyurl();
}
inline void Annotations::clear_privacypolicyurl() {
  _impl_.privacypolicyurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Annotations::privacypolicyurl() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Annotations.privacyPolicyUrl)
  return _internal_privacypolicyurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Annotations::set_privacypolicyurl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.privacypolicyurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.Annotations.privacyPolicyUrl)
}
inline std::string* Annotations::mutable_privacypolicyurl() {
  std::string* _s = _internal_mutable_privacypolicyurl();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Annotations.privacyPolicyUrl)
  return _s;
}
inline const std::string& Annotations::_internal_privacypolicyurl() const {
  return _impl_.privacypolicyurl_.Get();
}
inline void Annotations::_internal_set_privacypolicyurl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.privacypolicyurl_.Set(value, GetArenaForAllocation());
}
inline std::string* Annotations::_internal_mutable_privacypolicyurl() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.privacypolicyurl_.Mutable(GetArenaForAllocation());
}
inline std::string* Annotations::release_privacypolicyurl() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.Annotations.privacyPolicyUrl)
  if (!_internal_has_privacypolicyurl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.privacypolicyurl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.privacypolicyurl_.IsDefault()) {
    _impl_.privacypolicyurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Annotations::set_allocated_privacypolicyurl(std::string* privacypolicyurl) {
  if (privacypolicyurl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.privacypolicyurl_.SetAllocated(privacypolicyurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.privacypolicyurl_.IsDefault()) {
    _impl_.privacypolicyurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.Annotations.privacyPolicyUrl)
}

// optional .playapi.proto.finsky.document.Warning optimalDeviceClassWarning = 20;
inline bool Annotations::_internal_has_optimaldeviceclasswarning() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.optimaldeviceclasswarning_ != nullptr);
  return value;
}
inline bool Annotations::has_optimaldeviceclasswarning() const {
  return _internal_has_optimaldeviceclasswarning();
}
inline void Annotations::clear_optimaldeviceclasswarning() {
  if (_impl_.optimaldeviceclasswarning_ != nullptr) _impl_.optimaldeviceclasswarning_->Clear();
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline const ::playapi::proto::finsky::document::Warning& Annotations::_internal_optimaldeviceclasswarning() const {
  const ::playapi::proto::finsky::document::Warning* p = _impl_.optimaldeviceclasswarning_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::Warning&>(
      ::playapi::proto::finsky::document::_Warning_default_instance_);
}
inline const ::playapi::proto::finsky::document::Warning& Annotations::optimaldeviceclasswarning() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Annotations.optimalDeviceClassWarning)
  return _internal_optimaldeviceclasswarning();
}
inline void Annotations::unsafe_arena_set_allocated_optimaldeviceclasswarning(
    ::playapi::proto::finsky::document::Warning* optimaldeviceclasswarning) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.optimaldeviceclasswarning_);
  }
  _impl_.optimaldeviceclasswarning_ = optimaldeviceclasswarning;
  if (optimaldeviceclasswarning) {
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.Annotations.optimalDeviceClassWarning)
}
inline ::playapi::proto::finsky::document::Warning* Annotations::release_optimaldeviceclasswarning() {
  _impl_._has_bits_[0] &= ~0x00002000u;
  ::playapi::proto::finsky::document::Warning* temp = _impl_.optimaldeviceclasswarning_;
  _impl_.optimaldeviceclasswarning_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::Warning* Annotations::unsafe_arena_release_optimaldeviceclasswarning() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.Annotations.optimalDeviceClassWarning)
  _impl_._has_bits_[0] &= ~0x00002000u;
  ::playapi::proto::finsky::document::Warning* temp = _impl_.optimaldeviceclasswarning_;
  _impl_.optimaldeviceclasswarning_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::Warning* Annotations::_internal_mutable_optimaldeviceclasswarning() {
  _impl_._has_bits_[0] |= 0x00002000u;
  if (_impl_.optimaldeviceclasswarning_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::Warning>(GetArenaForAllocation());
    _impl_.optimaldeviceclasswarning_ = p;
  }
  return _impl_.optimaldeviceclasswarning_;
}
inline ::playapi::proto::finsky::document::Warning* Annotations::mutable_optimaldeviceclasswarning() {
  ::playapi::proto::finsky::document::Warning* _msg = _internal_mutable_optimaldeviceclasswarning();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Annotations.optimalDeviceClassWarning)
  return _msg;
}
inline void Annotations::set_allocated_optimaldeviceclasswarning(::playapi::proto::finsky::document::Warning* optimaldeviceclasswarning) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.optimaldeviceclasswarning_;
  }
  if (optimaldeviceclasswarning) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(optimaldeviceclasswarning);
    if (message_arena != submessage_arena) {
      optimaldeviceclasswarning = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, optimaldeviceclasswarning, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  _impl_.optimaldeviceclasswarning_ = optimaldeviceclasswarning;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.Annotations.optimalDeviceClassWarning)
}

// repeated .playapi.proto.finsky.document.BadgeContainer docBadgeContainer = 21;
inline int Annotations::_internal_docbadgecontainer_size() const {
  return _impl_.docbadgecontainer_.size();
}
inline int Annotations::docbadgecontainer_size() const {
  return _internal_docbadgecontainer_size();
}
inline void Annotations::clear_docbadgecontainer() {
  _impl_.docbadgecontainer_.Clear();
}
inline ::playapi::proto::finsky::document::BadgeContainer* Annotations::mutable_docbadgecontainer(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Annotations.docBadgeContainer)
  return _impl_.docbadgecontainer_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::BadgeContainer >*
Annotations::mutable_docbadgecontainer() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.document.Annotations.docBadgeContainer)
  return &_impl_.docbadgecontainer_;
}
inline const ::playapi::proto::finsky::document::BadgeContainer& Annotations::_internal_docbadgecontainer(int index) const {
  return _impl_.docbadgecontainer_.Get(index);
}
inline const ::playapi::proto::finsky::document::BadgeContainer& Annotations::docbadgecontainer(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Annotations.docBadgeContainer)
  return _internal_docbadgecontainer(index);
}
inline ::playapi::proto::finsky::document::BadgeContainer* Annotations::_internal_add_docbadgecontainer() {
  return _impl_.docbadgecontainer_.Add();
}
inline ::playapi::proto::finsky::document::BadgeContainer* Annotations::add_docbadgecontainer() {
  ::playapi::proto::finsky::document::BadgeContainer* _add = _internal_add_docbadgecontainer();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.Annotations.docBadgeContainer)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::BadgeContainer >&
Annotations::docbadgecontainer() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.document.Annotations.docBadgeContainer)
  return _impl_.docbadgecontainer_;
}

// optional .playapi.proto.finsky.document.SectionMetadata sectionSuggestForRating = 22;
inline bool Annotations::_internal_has_sectionsuggestforrating() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sectionsuggestforrating_ != nullptr);
  return value;
}
inline bool Annotations::has_sectionsuggestforrating() const {
  return _internal_has_sectionsuggestforrating();
}
inline void Annotations::clear_sectionsuggestforrating() {
  if (_impl_.sectionsuggestforrating_ != nullptr) _impl_.sectionsuggestforrating_->Clear();
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline const ::playapi::proto::finsky::document::SectionMetadata& Annotations::_internal_sectionsuggestforrating() const {
  const ::playapi::proto::finsky::document::SectionMetadata* p = _impl_.sectionsuggestforrating_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::SectionMetadata&>(
      ::playapi::proto::finsky::document::_SectionMetadata_default_instance_);
}
inline const ::playapi::proto::finsky::document::SectionMetadata& Annotations::sectionsuggestforrating() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Annotations.sectionSuggestForRating)
  return _internal_sectionsuggestforrating();
}
inline void Annotations::unsafe_arena_set_allocated_sectionsuggestforrating(
    ::playapi::proto::finsky::document::SectionMetadata* sectionsuggestforrating) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sectionsuggestforrating_);
  }
  _impl_.sectionsuggestforrating_ = sectionsuggestforrating;
  if (sectionsuggestforrating) {
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.Annotations.sectionSuggestForRating)
}
inline ::playapi::proto::finsky::document::SectionMetadata* Annotations::release_sectionsuggestforrating() {
  _impl_._has_bits_[0] &= ~0x00004000u;
  ::playapi::proto::finsky::document::SectionMetadata* temp = _impl_.sectionsuggestforrating_;
  _impl_.sectionsuggestforrating_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::SectionMetadata* Annotations::unsafe_arena_release_sectionsuggestforrating() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.Annotations.sectionSuggestForRating)
  _impl_._has_bits_[0] &= ~0x00004000u;
  ::playapi::proto::finsky::document::SectionMetadata* temp = _impl_.sectionsuggestforrating_;
  _impl_.sectionsuggestforrating_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::SectionMetadata* Annotations::_internal_mutable_sectionsuggestforrating() {
  _impl_._has_bits_[0] |= 0x00004000u;
  if (_impl_.sectionsuggestforrating_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::SectionMetadata>(GetArenaForAllocation());
    _impl_.sectionsuggestforrating_ = p;
  }
  return _impl_.sectionsuggestforrating_;
}
inline ::playapi::proto::finsky::document::SectionMetadata* Annotations::mutable_sectionsuggestforrating() {
  ::playapi::proto::finsky::document::SectionMetadata* _msg = _internal_mutable_sectionsuggestforrating();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Annotations.sectionSuggestForRating)
  return _msg;
}
inline void Annotations::set_allocated_sectionsuggestforrating(::playapi::proto::finsky::document::SectionMetadata* sectionsuggestforrating) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.sectionsuggestforrating_;
  }
  if (sectionsuggestforrating) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sectionsuggestforrating);
    if (message_arena != submessage_arena) {
      sectionsuggestforrating = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sectionsuggestforrating, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }
  _impl_.sectionsuggestforrating_ = sectionsuggestforrating;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.Annotations.sectionSuggestForRating)
}

// optional .playapi.proto.finsky.document.SectionMetadata sectionPurchaseCrossSell = 24;
inline bool Annotations::_internal_has_sectionpurchasecrosssell() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sectionpurchasecrosssell_ != nullptr);
  return value;
}
inline bool Annotations::has_sectionpurchasecrosssell() const {
  return _internal_has_sectionpurchasecrosssell();
}
inline void Annotations::clear_sectionpurchasecrosssell() {
  if (_impl_.sectionpurchasecrosssell_ != nullptr) _impl_.sectionpurchasecrosssell_->Clear();
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline const ::playapi::proto::finsky::document::SectionMetadata& Annotations::_internal_sectionpurchasecrosssell() const {
  const ::playapi::proto::finsky::document::SectionMetadata* p = _impl_.sectionpurchasecrosssell_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::SectionMetadata&>(
      ::playapi::proto::finsky::document::_SectionMetadata_default_instance_);
}
inline const ::playapi::proto::finsky::document::SectionMetadata& Annotations::sectionpurchasecrosssell() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Annotations.sectionPurchaseCrossSell)
  return _internal_sectionpurchasecrosssell();
}
inline void Annotations::unsafe_arena_set_allocated_sectionpurchasecrosssell(
    ::playapi::proto::finsky::document::SectionMetadata* sectionpurchasecrosssell) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sectionpurchasecrosssell_);
  }
  _impl_.sectionpurchasecrosssell_ = sectionpurchasecrosssell;
  if (sectionpurchasecrosssell) {
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.Annotations.sectionPurchaseCrossSell)
}
inline ::playapi::proto::finsky::document::SectionMetadata* Annotations::release_sectionpurchasecrosssell() {
  _impl_._has_bits_[0] &= ~0x00008000u;
  ::playapi::proto::finsky::document::SectionMetadata* temp = _impl_.sectionpurchasecrosssell_;
  _impl_.sectionpurchasecrosssell_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::SectionMetadata* Annotations::unsafe_arena_release_sectionpurchasecrosssell() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.Annotations.sectionPurchaseCrossSell)
  _impl_._has_bits_[0] &= ~0x00008000u;
  ::playapi::proto::finsky::document::SectionMetadata* temp = _impl_.sectionpurchasecrosssell_;
  _impl_.sectionpurchasecrosssell_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::SectionMetadata* Annotations::_internal_mutable_sectionpurchasecrosssell() {
  _impl_._has_bits_[0] |= 0x00008000u;
  if (_impl_.sectionpurchasecrosssell_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::SectionMetadata>(GetArenaForAllocation());
    _impl_.sectionpurchasecrosssell_ = p;
  }
  return _impl_.sectionpurchasecrosssell_;
}
inline ::playapi::proto::finsky::document::SectionMetadata* Annotations::mutable_sectionpurchasecrosssell() {
  ::playapi::proto::finsky::document::SectionMetadata* _msg = _internal_mutable_sectionpurchasecrosssell();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Annotations.sectionPurchaseCrossSell)
  return _msg;
}
inline void Annotations::set_allocated_sectionpurchasecrosssell(::playapi::proto::finsky::document::SectionMetadata* sectionpurchasecrosssell) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.sectionpurchasecrosssell_;
  }
  if (sectionpurchasecrosssell) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sectionpurchasecrosssell);
    if (message_arena != submessage_arena) {
      sectionpurchasecrosssell = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sectionpurchasecrosssell, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }
  _impl_.sectionpurchasecrosssell_ = sectionpurchasecrosssell;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.Annotations.sectionPurchaseCrossSell)
}

// repeated .playapi.proto.finsky.link.OverflowLink overflowLink = 25;
inline int Annotations::_internal_overflowlink_size() const {
  return _impl_.overflowlink_.size();
}
inline int Annotations::overflowlink_size() const {
  return _internal_overflowlink_size();
}
inline ::playapi::proto::finsky::link::OverflowLink* Annotations::mutable_overflowlink(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Annotations.overflowLink)
  return _impl_.overflowlink_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::link::OverflowLink >*
Annotations::mutable_overflowlink() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.document.Annotations.overflowLink)
  return &_impl_.overflowlink_;
}
inline const ::playapi::proto::finsky::link::OverflowLink& Annotations::_internal_overflowlink(int index) const {
  return _impl_.overflowlink_.Get(index);
}
inline const ::playapi::proto::finsky::link::OverflowLink& Annotations::overflowlink(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Annotations.overflowLink)
  return _internal_overflowlink(index);
}
inline ::playapi::proto::finsky::link::OverflowLink* Annotations::_internal_add_overflowlink() {
  return _impl_.overflowlink_.Add();
}
inline ::playapi::proto::finsky::link::OverflowLink* Annotations::add_overflowlink() {
  ::playapi::proto::finsky::link::OverflowLink* _add = _internal_add_overflowlink();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.Annotations.overflowLink)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::link::OverflowLink >&
Annotations::overflowlink() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.document.Annotations.overflowLink)
  return _impl_.overflowlink_;
}

// optional .playapi.proto.finsky.document.DocV2 creatorDoc = 26;
inline bool Annotations::_internal_has_creatordoc() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.creatordoc_ != nullptr);
  return value;
}
inline bool Annotations::has_creatordoc() const {
  return _internal_has_creatordoc();
}
inline void Annotations::clear_creatordoc() {
  if (_impl_.creatordoc_ != nullptr) _impl_.creatordoc_->Clear();
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline const ::playapi::proto::finsky::document::DocV2& Annotations::_internal_creatordoc() const {
  const ::playapi::proto::finsky::document::DocV2* p = _impl_.creatordoc_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::DocV2&>(
      ::playapi::proto::finsky::document::_DocV2_default_instance_);
}
inline const ::playapi::proto::finsky::document::DocV2& Annotations::creatordoc() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Annotations.creatorDoc)
  return _internal_creatordoc();
}
inline void Annotations::unsafe_arena_set_allocated_creatordoc(
    ::playapi::proto::finsky::document::DocV2* creatordoc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.creatordoc_);
  }
  _impl_.creatordoc_ = creatordoc;
  if (creatordoc) {
    _impl_._has_bits_[0] |= 0x00010000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00010000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.Annotations.creatorDoc)
}
inline ::playapi::proto::finsky::document::DocV2* Annotations::release_creatordoc() {
  _impl_._has_bits_[0] &= ~0x00010000u;
  ::playapi::proto::finsky::document::DocV2* temp = _impl_.creatordoc_;
  _impl_.creatordoc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::DocV2* Annotations::unsafe_arena_release_creatordoc() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.Annotations.creatorDoc)
  _impl_._has_bits_[0] &= ~0x00010000u;
  ::playapi::proto::finsky::document::DocV2* temp = _impl_.creatordoc_;
  _impl_.creatordoc_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::DocV2* Annotations::_internal_mutable_creatordoc() {
  _impl_._has_bits_[0] |= 0x00010000u;
  if (_impl_.creatordoc_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::DocV2>(GetArenaForAllocation());
    _impl_.creatordoc_ = p;
  }
  return _impl_.creatordoc_;
}
inline ::playapi::proto::finsky::document::DocV2* Annotations::mutable_creatordoc() {
  ::playapi::proto::finsky::document::DocV2* _msg = _internal_mutable_creatordoc();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Annotations.creatorDoc)
  return _msg;
}
inline void Annotations::set_allocated_creatordoc(::playapi::proto::finsky::document::DocV2* creatordoc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.creatordoc_;
  }
  if (creatordoc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(creatordoc);
    if (message_arena != submessage_arena) {
      creatordoc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, creatordoc, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00010000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00010000u;
  }
  _impl_.creatordoc_ = creatordoc;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.Annotations.creatorDoc)
}

// optional string attributionHtml = 27;
inline bool Annotations::_internal_has_attributionhtml() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Annotations::has_attributionhtml() const {
  return _internal_has_attributionhtml();
}
inline void Annotations::clear_attributionhtml() {
  _impl_.attributionhtml_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Annotations::attributionhtml() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Annotations.attributionHtml)
  return _internal_attributionhtml();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Annotations::set_attributionhtml(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.attributionhtml_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.Annotations.attributionHtml)
}
inline std::string* Annotations::mutable_attributionhtml() {
  std::string* _s = _internal_mutable_attributionhtml();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Annotations.attributionHtml)
  return _s;
}
inline const std::string& Annotations::_internal_attributionhtml() const {
  return _impl_.attributionhtml_.Get();
}
inline void Annotations::_internal_set_attributionhtml(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.attributionhtml_.Set(value, GetArenaForAllocation());
}
inline std::string* Annotations::_internal_mutable_attributionhtml() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.attributionhtml_.Mutable(GetArenaForAllocation());
}
inline std::string* Annotations::release_attributionhtml() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.Annotations.attributionHtml)
  if (!_internal_has_attributionhtml()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.attributionhtml_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attributionhtml_.IsDefault()) {
    _impl_.attributionhtml_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Annotations::set_allocated_attributionhtml(std::string* attributionhtml) {
  if (attributionhtml != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.attributionhtml_.SetAllocated(attributionhtml, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attributionhtml_.IsDefault()) {
    _impl_.attributionhtml_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.Annotations.attributionHtml)
}

// optional .playapi.proto.finsky.document.PurchaseHistoryDetails purchaseHistoryDetails = 28;
inline bool Annotations::_internal_has_purchasehistorydetails() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.purchasehistorydetails_ != nullptr);
  return value;
}
inline bool Annotations::has_purchasehistorydetails() const {
  return _internal_has_purchasehistorydetails();
}
inline void Annotations::clear_purchasehistorydetails() {
  if (_impl_.purchasehistorydetails_ != nullptr) _impl_.purchasehistorydetails_->Clear();
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline const ::playapi::proto::finsky::document::PurchaseHistoryDetails& Annotations::_internal_purchasehistorydetails() const {
  const ::playapi::proto::finsky::document::PurchaseHistoryDetails* p = _impl_.purchasehistorydetails_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::PurchaseHistoryDetails&>(
      ::playapi::proto::finsky::document::_PurchaseHistoryDetails_default_instance_);
}
inline const ::playapi::proto::finsky::document::PurchaseHistoryDetails& Annotations::purchasehistorydetails() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Annotations.purchaseHistoryDetails)
  return _internal_purchasehistorydetails();
}
inline void Annotations::unsafe_arena_set_allocated_purchasehistorydetails(
    ::playapi::proto::finsky::document::PurchaseHistoryDetails* purchasehistorydetails) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.purchasehistorydetails_);
  }
  _impl_.purchasehistorydetails_ = purchasehistorydetails;
  if (purchasehistorydetails) {
    _impl_._has_bits_[0] |= 0x00020000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00020000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.Annotations.purchaseHistoryDetails)
}
inline ::playapi::proto::finsky::document::PurchaseHistoryDetails* Annotations::release_purchasehistorydetails() {
  _impl_._has_bits_[0] &= ~0x00020000u;
  ::playapi::proto::finsky::document::PurchaseHistoryDetails* temp = _impl_.purchasehistorydetails_;
  _impl_.purchasehistorydetails_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::PurchaseHistoryDetails* Annotations::unsafe_arena_release_purchasehistorydetails() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.Annotations.purchaseHistoryDetails)
  _impl_._has_bits_[0] &= ~0x00020000u;
  ::playapi::proto::finsky::document::PurchaseHistoryDetails* temp = _impl_.purchasehistorydetails_;
  _impl_.purchasehistorydetails_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::PurchaseHistoryDetails* Annotations::_internal_mutable_purchasehistorydetails() {
  _impl_._has_bits_[0] |= 0x00020000u;
  if (_impl_.purchasehistorydetails_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::PurchaseHistoryDetails>(GetArenaForAllocation());
    _impl_.purchasehistorydetails_ = p;
  }
  return _impl_.purchasehistorydetails_;
}
inline ::playapi::proto::finsky::document::PurchaseHistoryDetails* Annotations::mutable_purchasehistorydetails() {
  ::playapi::proto::finsky::document::PurchaseHistoryDetails* _msg = _internal_mutable_purchasehistorydetails();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Annotations.purchaseHistoryDetails)
  return _msg;
}
inline void Annotations::set_allocated_purchasehistorydetails(::playapi::proto::finsky::document::PurchaseHistoryDetails* purchasehistorydetails) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.purchasehistorydetails_;
  }
  if (purchasehistorydetails) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(purchasehistorydetails);
    if (message_arena != submessage_arena) {
      purchasehistorydetails = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, purchasehistorydetails, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00020000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00020000u;
  }
  _impl_.purchasehistorydetails_ = purchasehistorydetails;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.Annotations.purchaseHistoryDetails)
}

// optional .playapi.proto.finsky.document.Badge badgeForContentRating = 29;
inline bool Annotations::_internal_has_badgeforcontentrating() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.badgeforcontentrating_ != nullptr);
  return value;
}
inline bool Annotations::has_badgeforcontentrating() const {
  return _internal_has_badgeforcontentrating();
}
inline void Annotations::clear_badgeforcontentrating() {
  if (_impl_.badgeforcontentrating_ != nullptr) _impl_.badgeforcontentrating_->Clear();
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline const ::playapi::proto::finsky::document::Badge& Annotations::_internal_badgeforcontentrating() const {
  const ::playapi::proto::finsky::document::Badge* p = _impl_.badgeforcontentrating_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::Badge&>(
      ::playapi::proto::finsky::document::_Badge_default_instance_);
}
inline const ::playapi::proto::finsky::document::Badge& Annotations::badgeforcontentrating() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Annotations.badgeForContentRating)
  return _internal_badgeforcontentrating();
}
inline void Annotations::unsafe_arena_set_allocated_badgeforcontentrating(
    ::playapi::proto::finsky::document::Badge* badgeforcontentrating) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.badgeforcontentrating_);
  }
  _impl_.badgeforcontentrating_ = badgeforcontentrating;
  if (badgeforcontentrating) {
    _impl_._has_bits_[0] |= 0x00040000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00040000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.Annotations.badgeForContentRating)
}
inline ::playapi::proto::finsky::document::Badge* Annotations::release_badgeforcontentrating() {
  _impl_._has_bits_[0] &= ~0x00040000u;
  ::playapi::proto::finsky::document::Badge* temp = _impl_.badgeforcontentrating_;
  _impl_.badgeforcontentrating_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::Badge* Annotations::unsafe_arena_release_badgeforcontentrating() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.Annotations.badgeForContentRating)
  _impl_._has_bits_[0] &= ~0x00040000u;
  ::playapi::proto::finsky::document::Badge* temp = _impl_.badgeforcontentrating_;
  _impl_.badgeforcontentrating_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::Badge* Annotations::_internal_mutable_badgeforcontentrating() {
  _impl_._has_bits_[0] |= 0x00040000u;
  if (_impl_.badgeforcontentrating_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::Badge>(GetArenaForAllocation());
    _impl_.badgeforcontentrating_ = p;
  }
  return _impl_.badgeforcontentrating_;
}
inline ::playapi::proto::finsky::document::Badge* Annotations::mutable_badgeforcontentrating() {
  ::playapi::proto::finsky::document::Badge* _msg = _internal_mutable_badgeforcontentrating();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Annotations.badgeForContentRating)
  return _msg;
}
inline void Annotations::set_allocated_badgeforcontentrating(::playapi::proto::finsky::document::Badge* badgeforcontentrating) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.badgeforcontentrating_;
  }
  if (badgeforcontentrating) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(badgeforcontentrating);
    if (message_arena != submessage_arena) {
      badgeforcontentrating = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, badgeforcontentrating, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00040000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00040000u;
  }
  _impl_.badgeforcontentrating_ = badgeforcontentrating;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.Annotations.badgeForContentRating)
}

// repeated .playapi.proto.finsky.document.VoucherInfo voucherInfo = 30;
inline int Annotations::_internal_voucherinfo_size() const {
  return _impl_.voucherinfo_.size();
}
inline int Annotations::voucherinfo_size() const {
  return _internal_voucherinfo_size();
}
inline void Annotations::clear_voucherinfo() {
  _impl_.voucherinfo_.Clear();
}
inline ::playapi::proto::finsky::document::VoucherInfo* Annotations::mutable_voucherinfo(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Annotations.voucherInfo)
  return _impl_.voucherinfo_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::VoucherInfo >*
Annotations::mutable_voucherinfo() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.document.Annotations.voucherInfo)
  return &_impl_.voucherinfo_;
}
inline const ::playapi::proto::finsky::document::VoucherInfo& Annotations::_internal_voucherinfo(int index) const {
  return _impl_.voucherinfo_.Get(index);
}
inline const ::playapi::proto::finsky::document::VoucherInfo& Annotations::voucherinfo(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Annotations.voucherInfo)
  return _internal_voucherinfo(index);
}
inline ::playapi::proto::finsky::document::VoucherInfo* Annotations::_internal_add_voucherinfo() {
  return _impl_.voucherinfo_.Add();
}
inline ::playapi::proto::finsky::document::VoucherInfo* Annotations::add_voucherinfo() {
  ::playapi::proto::finsky::document::VoucherInfo* _add = _internal_add_voucherinfo();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.Annotations.voucherInfo)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::VoucherInfo >&
Annotations::voucherinfo() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.document.Annotations.voucherInfo)
  return _impl_.voucherinfo_;
}

// optional .playapi.proto.finsky.document.SectionMetadata sectionFeaturedApps = 32;
inline bool Annotations::_internal_has_sectionfeaturedapps() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sectionfeaturedapps_ != nullptr);
  return value;
}
inline bool Annotations::has_sectionfeaturedapps() const {
  return _internal_has_sectionfeaturedapps();
}
inline void Annotations::clear_sectionfeaturedapps() {
  if (_impl_.sectionfeaturedapps_ != nullptr) _impl_.sectionfeaturedapps_->Clear();
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline const ::playapi::proto::finsky::document::SectionMetadata& Annotations::_internal_sectionfeaturedapps() const {
  const ::playapi::proto::finsky::document::SectionMetadata* p = _impl_.sectionfeaturedapps_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::SectionMetadata&>(
      ::playapi::proto::finsky::document::_SectionMetadata_default_instance_);
}
inline const ::playapi::proto::finsky::document::SectionMetadata& Annotations::sectionfeaturedapps() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Annotations.sectionFeaturedApps)
  return _internal_sectionfeaturedapps();
}
inline void Annotations::unsafe_arena_set_allocated_sectionfeaturedapps(
    ::playapi::proto::finsky::document::SectionMetadata* sectionfeaturedapps) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sectionfeaturedapps_);
  }
  _impl_.sectionfeaturedapps_ = sectionfeaturedapps;
  if (sectionfeaturedapps) {
    _impl_._has_bits_[0] |= 0x00080000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00080000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.Annotations.sectionFeaturedApps)
}
inline ::playapi::proto::finsky::document::SectionMetadata* Annotations::release_sectionfeaturedapps() {
  _impl_._has_bits_[0] &= ~0x00080000u;
  ::playapi::proto::finsky::document::SectionMetadata* temp = _impl_.sectionfeaturedapps_;
  _impl_.sectionfeaturedapps_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::SectionMetadata* Annotations::unsafe_arena_release_sectionfeaturedapps() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.Annotations.sectionFeaturedApps)
  _impl_._has_bits_[0] &= ~0x00080000u;
  ::playapi::proto::finsky::document::SectionMetadata* temp = _impl_.sectionfeaturedapps_;
  _impl_.sectionfeaturedapps_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::SectionMetadata* Annotations::_internal_mutable_sectionfeaturedapps() {
  _impl_._has_bits_[0] |= 0x00080000u;
  if (_impl_.sectionfeaturedapps_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::SectionMetadata>(GetArenaForAllocation());
    _impl_.sectionfeaturedapps_ = p;
  }
  return _impl_.sectionfeaturedapps_;
}
inline ::playapi::proto::finsky::document::SectionMetadata* Annotations::mutable_sectionfeaturedapps() {
  ::playapi::proto::finsky::document::SectionMetadata* _msg = _internal_mutable_sectionfeaturedapps();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Annotations.sectionFeaturedApps)
  return _msg;
}
inline void Annotations::set_allocated_sectionfeaturedapps(::playapi::proto::finsky::document::SectionMetadata* sectionfeaturedapps) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.sectionfeaturedapps_;
  }
  if (sectionfeaturedapps) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sectionfeaturedapps);
    if (message_arena != submessage_arena) {
      sectionfeaturedapps = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sectionfeaturedapps, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00080000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00080000u;
  }
  _impl_.sectionfeaturedapps_ = sectionfeaturedapps;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.Annotations.sectionFeaturedApps)
}

// optional string applicableVoucherDescription = 33;
inline bool Annotations::_internal_has_applicablevoucherdescription() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Annotations::has_applicablevoucherdescription() const {
  return _internal_has_applicablevoucherdescription();
}
inline void Annotations::clear_applicablevoucherdescription() {
  _impl_.applicablevoucherdescription_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& Annotations::applicablevoucherdescription() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Annotations.applicableVoucherDescription)
  return _internal_applicablevoucherdescription();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Annotations::set_applicablevoucherdescription(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.applicablevoucherdescription_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.Annotations.applicableVoucherDescription)
}
inline std::string* Annotations::mutable_applicablevoucherdescription() {
  std::string* _s = _internal_mutable_applicablevoucherdescription();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Annotations.applicableVoucherDescription)
  return _s;
}
inline const std::string& Annotations::_internal_applicablevoucherdescription() const {
  return _impl_.applicablevoucherdescription_.Get();
}
inline void Annotations::_internal_set_applicablevoucherdescription(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.applicablevoucherdescription_.Set(value, GetArenaForAllocation());
}
inline std::string* Annotations::_internal_mutable_applicablevoucherdescription() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.applicablevoucherdescription_.Mutable(GetArenaForAllocation());
}
inline std::string* Annotations::release_applicablevoucherdescription() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.Annotations.applicableVoucherDescription)
  if (!_internal_has_applicablevoucherdescription()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.applicablevoucherdescription_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.applicablevoucherdescription_.IsDefault()) {
    _impl_.applicablevoucherdescription_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Annotations::set_allocated_applicablevoucherdescription(std::string* applicablevoucherdescription) {
  if (applicablevoucherdescription != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.applicablevoucherdescription_.SetAllocated(applicablevoucherdescription, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.applicablevoucherdescription_.IsDefault()) {
    _impl_.applicablevoucherdescription_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.Annotations.applicableVoucherDescription)
}

// repeated .playapi.proto.finsky.document.SectionMetadata detailsPageCluster = 34;
inline int Annotations::_internal_detailspagecluster_size() const {
  return _impl_.detailspagecluster_.size();
}
inline int Annotations::detailspagecluster_size() const {
  return _internal_detailspagecluster_size();
}
inline void Annotations::clear_detailspagecluster() {
  _impl_.detailspagecluster_.Clear();
}
inline ::playapi::proto::finsky::document::SectionMetadata* Annotations::mutable_detailspagecluster(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Annotations.detailsPageCluster)
  return _impl_.detailspagecluster_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::SectionMetadata >*
Annotations::mutable_detailspagecluster() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.document.Annotations.detailsPageCluster)
  return &_impl_.detailspagecluster_;
}
inline const ::playapi::proto::finsky::document::SectionMetadata& Annotations::_internal_detailspagecluster(int index) const {
  return _impl_.detailspagecluster_.Get(index);
}
inline const ::playapi::proto::finsky::document::SectionMetadata& Annotations::detailspagecluster(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Annotations.detailsPageCluster)
  return _internal_detailspagecluster(index);
}
inline ::playapi::proto::finsky::document::SectionMetadata* Annotations::_internal_add_detailspagecluster() {
  return _impl_.detailspagecluster_.Add();
}
inline ::playapi::proto::finsky::document::SectionMetadata* Annotations::add_detailspagecluster() {
  ::playapi::proto::finsky::document::SectionMetadata* _add = _internal_add_detailspagecluster();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.Annotations.detailsPageCluster)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::SectionMetadata >&
Annotations::detailspagecluster() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.document.Annotations.detailsPageCluster)
  return _impl_.detailspagecluster_;
}

// optional .playapi.proto.finsky.document.VideoAnnotations videoAnnotations = 35;
inline bool Annotations::_internal_has_videoannotations() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.videoannotations_ != nullptr);
  return value;
}
inline bool Annotations::has_videoannotations() const {
  return _internal_has_videoannotations();
}
inline void Annotations::clear_videoannotations() {
  if (_impl_.videoannotations_ != nullptr) _impl_.videoannotations_->Clear();
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline const ::playapi::proto::finsky::document::VideoAnnotations& Annotations::_internal_videoannotations() const {
  const ::playapi::proto::finsky::document::VideoAnnotations* p = _impl_.videoannotations_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::VideoAnnotations&>(
      ::playapi::proto::finsky::document::_VideoAnnotations_default_instance_);
}
inline const ::playapi::proto::finsky::document::VideoAnnotations& Annotations::videoannotations() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Annotations.videoAnnotations)
  return _internal_videoannotations();
}
inline void Annotations::unsafe_arena_set_allocated_videoannotations(
    ::playapi::proto::finsky::document::VideoAnnotations* videoannotations) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.videoannotations_);
  }
  _impl_.videoannotations_ = videoannotations;
  if (videoannotations) {
    _impl_._has_bits_[0] |= 0x00100000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00100000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.Annotations.videoAnnotations)
}
inline ::playapi::proto::finsky::document::VideoAnnotations* Annotations::release_videoannotations() {
  _impl_._has_bits_[0] &= ~0x00100000u;
  ::playapi::proto::finsky::document::VideoAnnotations* temp = _impl_.videoannotations_;
  _impl_.videoannotations_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::VideoAnnotations* Annotations::unsafe_arena_release_videoannotations() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.Annotations.videoAnnotations)
  _impl_._has_bits_[0] &= ~0x00100000u;
  ::playapi::proto::finsky::document::VideoAnnotations* temp = _impl_.videoannotations_;
  _impl_.videoannotations_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::VideoAnnotations* Annotations::_internal_mutable_videoannotations() {
  _impl_._has_bits_[0] |= 0x00100000u;
  if (_impl_.videoannotations_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::VideoAnnotations>(GetArenaForAllocation());
    _impl_.videoannotations_ = p;
  }
  return _impl_.videoannotations_;
}
inline ::playapi::proto::finsky::document::VideoAnnotations* Annotations::mutable_videoannotations() {
  ::playapi::proto::finsky::document::VideoAnnotations* _msg = _internal_mutable_videoannotations();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Annotations.videoAnnotations)
  return _msg;
}
inline void Annotations::set_allocated_videoannotations(::playapi::proto::finsky::document::VideoAnnotations* videoannotations) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.videoannotations_;
  }
  if (videoannotations) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(videoannotations);
    if (message_arena != submessage_arena) {
      videoannotations = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, videoannotations, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00100000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00100000u;
  }
  _impl_.videoannotations_ = videoannotations;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.Annotations.videoAnnotations)
}

// optional .playapi.proto.finsky.document.SectionMetadata sectionPurchaseRelatedTopics = 36;
inline bool Annotations::_internal_has_sectionpurchaserelatedtopics() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sectionpurchaserelatedtopics_ != nullptr);
  return value;
}
inline bool Annotations::has_sectionpurchaserelatedtopics() const {
  return _internal_has_sectionpurchaserelatedtopics();
}
inline void Annotations::clear_sectionpurchaserelatedtopics() {
  if (_impl_.sectionpurchaserelatedtopics_ != nullptr) _impl_.sectionpurchaserelatedtopics_->Clear();
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline const ::playapi::proto::finsky::document::SectionMetadata& Annotations::_internal_sectionpurchaserelatedtopics() const {
  const ::playapi::proto::finsky::document::SectionMetadata* p = _impl_.sectionpurchaserelatedtopics_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::SectionMetadata&>(
      ::playapi::proto::finsky::document::_SectionMetadata_default_instance_);
}
inline const ::playapi::proto::finsky::document::SectionMetadata& Annotations::sectionpurchaserelatedtopics() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Annotations.sectionPurchaseRelatedTopics)
  return _internal_sectionpurchaserelatedtopics();
}
inline void Annotations::unsafe_arena_set_allocated_sectionpurchaserelatedtopics(
    ::playapi::proto::finsky::document::SectionMetadata* sectionpurchaserelatedtopics) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sectionpurchaserelatedtopics_);
  }
  _impl_.sectionpurchaserelatedtopics_ = sectionpurchaserelatedtopics;
  if (sectionpurchaserelatedtopics) {
    _impl_._has_bits_[0] |= 0x00200000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00200000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.Annotations.sectionPurchaseRelatedTopics)
}
inline ::playapi::proto::finsky::document::SectionMetadata* Annotations::release_sectionpurchaserelatedtopics() {
  _impl_._has_bits_[0] &= ~0x00200000u;
  ::playapi::proto::finsky::document::SectionMetadata* temp = _impl_.sectionpurchaserelatedtopics_;
  _impl_.sectionpurchaserelatedtopics_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::SectionMetadata* Annotations::unsafe_arena_release_sectionpurchaserelatedtopics() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.Annotations.sectionPurchaseRelatedTopics)
  _impl_._has_bits_[0] &= ~0x00200000u;
  ::playapi::proto::finsky::document::SectionMetadata* temp = _impl_.sectionpurchaserelatedtopics_;
  _impl_.sectionpurchaserelatedtopics_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::SectionMetadata* Annotations::_internal_mutable_sectionpurchaserelatedtopics() {
  _impl_._has_bits_[0] |= 0x00200000u;
  if (_impl_.sectionpurchaserelatedtopics_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::SectionMetadata>(GetArenaForAllocation());
    _impl_.sectionpurchaserelatedtopics_ = p;
  }
  return _impl_.sectionpurchaserelatedtopics_;
}
inline ::playapi::proto::finsky::document::SectionMetadata* Annotations::mutable_sectionpurchaserelatedtopics() {
  ::playapi::proto::finsky::document::SectionMetadata* _msg = _internal_mutable_sectionpurchaserelatedtopics();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Annotations.sectionPurchaseRelatedTopics)
  return _msg;
}
inline void Annotations::set_allocated_sectionpurchaserelatedtopics(::playapi::proto::finsky::document::SectionMetadata* sectionpurchaserelatedtopics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.sectionpurchaserelatedtopics_;
  }
  if (sectionpurchaserelatedtopics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sectionpurchaserelatedtopics);
    if (message_arena != submessage_arena) {
      sectionpurchaserelatedtopics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sectionpurchaserelatedtopics, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00200000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00200000u;
  }
  _impl_.sectionpurchaserelatedtopics_ = sectionpurchaserelatedtopics;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.Annotations.sectionPurchaseRelatedTopics)
}

// optional .playapi.proto.finsky.document.MySubscriptionDetails mySubscriptionDetails = 37;
inline bool Annotations::_internal_has_mysubscriptiondetails() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.mysubscriptiondetails_ != nullptr);
  return value;
}
inline bool Annotations::has_mysubscriptiondetails() const {
  return _internal_has_mysubscriptiondetails();
}
inline void Annotations::clear_mysubscriptiondetails() {
  if (_impl_.mysubscriptiondetails_ != nullptr) _impl_.mysubscriptiondetails_->Clear();
  _impl_._has_bits_[0] &= ~0x00400000u;
}
inline const ::playapi::proto::finsky::document::MySubscriptionDetails& Annotations::_internal_mysubscriptiondetails() const {
  const ::playapi::proto::finsky::document::MySubscriptionDetails* p = _impl_.mysubscriptiondetails_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::MySubscriptionDetails&>(
      ::playapi::proto::finsky::document::_MySubscriptionDetails_default_instance_);
}
inline const ::playapi::proto::finsky::document::MySubscriptionDetails& Annotations::mysubscriptiondetails() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Annotations.mySubscriptionDetails)
  return _internal_mysubscriptiondetails();
}
inline void Annotations::unsafe_arena_set_allocated_mysubscriptiondetails(
    ::playapi::proto::finsky::document::MySubscriptionDetails* mysubscriptiondetails) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mysubscriptiondetails_);
  }
  _impl_.mysubscriptiondetails_ = mysubscriptiondetails;
  if (mysubscriptiondetails) {
    _impl_._has_bits_[0] |= 0x00400000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00400000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.Annotations.mySubscriptionDetails)
}
inline ::playapi::proto::finsky::document::MySubscriptionDetails* Annotations::release_mysubscriptiondetails() {
  _impl_._has_bits_[0] &= ~0x00400000u;
  ::playapi::proto::finsky::document::MySubscriptionDetails* temp = _impl_.mysubscriptiondetails_;
  _impl_.mysubscriptiondetails_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::MySubscriptionDetails* Annotations::unsafe_arena_release_mysubscriptiondetails() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.Annotations.mySubscriptionDetails)
  _impl_._has_bits_[0] &= ~0x00400000u;
  ::playapi::proto::finsky::document::MySubscriptionDetails* temp = _impl_.mysubscriptiondetails_;
  _impl_.mysubscriptiondetails_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::MySubscriptionDetails* Annotations::_internal_mutable_mysubscriptiondetails() {
  _impl_._has_bits_[0] |= 0x00400000u;
  if (_impl_.mysubscriptiondetails_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::MySubscriptionDetails>(GetArenaForAllocation());
    _impl_.mysubscriptiondetails_ = p;
  }
  return _impl_.mysubscriptiondetails_;
}
inline ::playapi::proto::finsky::document::MySubscriptionDetails* Annotations::mutable_mysubscriptiondetails() {
  ::playapi::proto::finsky::document::MySubscriptionDetails* _msg = _internal_mutable_mysubscriptiondetails();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Annotations.mySubscriptionDetails)
  return _msg;
}
inline void Annotations::set_allocated_mysubscriptiondetails(::playapi::proto::finsky::document::MySubscriptionDetails* mysubscriptiondetails) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.mysubscriptiondetails_;
  }
  if (mysubscriptiondetails) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(mysubscriptiondetails);
    if (message_arena != submessage_arena) {
      mysubscriptiondetails = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mysubscriptiondetails, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00400000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00400000u;
  }
  _impl_.mysubscriptiondetails_ = mysubscriptiondetails;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.Annotations.mySubscriptionDetails)
}

// optional .playapi.proto.finsky.document.MyRewardDetails myRewardDetails = 38;
inline bool Annotations::_internal_has_myrewarddetails() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.myrewarddetails_ != nullptr);
  return value;
}
inline bool Annotations::has_myrewarddetails() const {
  return _internal_has_myrewarddetails();
}
inline void Annotations::clear_myrewarddetails() {
  if (_impl_.myrewarddetails_ != nullptr) _impl_.myrewarddetails_->Clear();
  _impl_._has_bits_[0] &= ~0x00800000u;
}
inline const ::playapi::proto::finsky::document::MyRewardDetails& Annotations::_internal_myrewarddetails() const {
  const ::playapi::proto::finsky::document::MyRewardDetails* p = _impl_.myrewarddetails_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::MyRewardDetails&>(
      ::playapi::proto::finsky::document::_MyRewardDetails_default_instance_);
}
inline const ::playapi::proto::finsky::document::MyRewardDetails& Annotations::myrewarddetails() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Annotations.myRewardDetails)
  return _internal_myrewarddetails();
}
inline void Annotations::unsafe_arena_set_allocated_myrewarddetails(
    ::playapi::proto::finsky::document::MyRewardDetails* myrewarddetails) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.myrewarddetails_);
  }
  _impl_.myrewarddetails_ = myrewarddetails;
  if (myrewarddetails) {
    _impl_._has_bits_[0] |= 0x00800000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00800000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.Annotations.myRewardDetails)
}
inline ::playapi::proto::finsky::document::MyRewardDetails* Annotations::release_myrewarddetails() {
  _impl_._has_bits_[0] &= ~0x00800000u;
  ::playapi::proto::finsky::document::MyRewardDetails* temp = _impl_.myrewarddetails_;
  _impl_.myrewarddetails_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::MyRewardDetails* Annotations::unsafe_arena_release_myrewarddetails() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.Annotations.myRewardDetails)
  _impl_._has_bits_[0] &= ~0x00800000u;
  ::playapi::proto::finsky::document::MyRewardDetails* temp = _impl_.myrewarddetails_;
  _impl_.myrewarddetails_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::MyRewardDetails* Annotations::_internal_mutable_myrewarddetails() {
  _impl_._has_bits_[0] |= 0x00800000u;
  if (_impl_.myrewarddetails_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::MyRewardDetails>(GetArenaForAllocation());
    _impl_.myrewarddetails_ = p;
  }
  return _impl_.myrewarddetails_;
}
inline ::playapi::proto::finsky::document::MyRewardDetails* Annotations::mutable_myrewarddetails() {
  ::playapi::proto::finsky::document::MyRewardDetails* _msg = _internal_mutable_myrewarddetails();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Annotations.myRewardDetails)
  return _msg;
}
inline void Annotations::set_allocated_myrewarddetails(::playapi::proto::finsky::document::MyRewardDetails* myrewarddetails) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.myrewarddetails_;
  }
  if (myrewarddetails) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(myrewarddetails);
    if (message_arena != submessage_arena) {
      myrewarddetails = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, myrewarddetails, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00800000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00800000u;
  }
  _impl_.myrewarddetails_ = myrewarddetails;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.Annotations.myRewardDetails)
}

// repeated .playapi.proto.finsky.document.Badge featureBadge = 39;
inline int Annotations::_internal_featurebadge_size() const {
  return _impl_.featurebadge_.size();
}
inline int Annotations::featurebadge_size() const {
  return _internal_featurebadge_size();
}
inline void Annotations::clear_featurebadge() {
  _impl_.featurebadge_.Clear();
}
inline ::playapi::proto::finsky::document::Badge* Annotations::mutable_featurebadge(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Annotations.featureBadge)
  return _impl_.featurebadge_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::Badge >*
Annotations::mutable_featurebadge() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.document.Annotations.featureBadge)
  return &_impl_.featurebadge_;
}
inline const ::playapi::proto::finsky::document::Badge& Annotations::_internal_featurebadge(int index) const {
  return _impl_.featurebadge_.Get(index);
}
inline const ::playapi::proto::finsky::document::Badge& Annotations::featurebadge(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Annotations.featureBadge)
  return _internal_featurebadge(index);
}
inline ::playapi::proto::finsky::document::Badge* Annotations::_internal_add_featurebadge() {
  return _impl_.featurebadge_.Add();
}
inline ::playapi::proto::finsky::document::Badge* Annotations::add_featurebadge() {
  ::playapi::proto::finsky::document::Badge* _add = _internal_add_featurebadge();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.Annotations.featureBadge)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::Badge >&
Annotations::featurebadge() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.document.Annotations.featureBadge)
  return _impl_.featurebadge_;
}

// optional .playapi.proto.finsky.document.SelectedChild selectedChild = 40;
inline bool Annotations::_internal_has_selectedchild() const {
  bool value = (_impl_._has_bits_[0] & 0x01000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.selectedchild_ != nullptr);
  return value;
}
inline bool Annotations::has_selectedchild() const {
  return _internal_has_selectedchild();
}
inline void Annotations::clear_selectedchild() {
  if (_impl_.selectedchild_ != nullptr) _impl_.selectedchild_->Clear();
  _impl_._has_bits_[0] &= ~0x01000000u;
}
inline const ::playapi::proto::finsky::document::SelectedChild& Annotations::_internal_selectedchild() const {
  const ::playapi::proto::finsky::document::SelectedChild* p = _impl_.selectedchild_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::SelectedChild&>(
      ::playapi::proto::finsky::document::_SelectedChild_default_instance_);
}
inline const ::playapi::proto::finsky::document::SelectedChild& Annotations::selectedchild() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Annotations.selectedChild)
  return _internal_selectedchild();
}
inline void Annotations::unsafe_arena_set_allocated_selectedchild(
    ::playapi::proto::finsky::document::SelectedChild* selectedchild) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.selectedchild_);
  }
  _impl_.selectedchild_ = selectedchild;
  if (selectedchild) {
    _impl_._has_bits_[0] |= 0x01000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x01000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.Annotations.selectedChild)
}
inline ::playapi::proto::finsky::document::SelectedChild* Annotations::release_selectedchild() {
  _impl_._has_bits_[0] &= ~0x01000000u;
  ::playapi::proto::finsky::document::SelectedChild* temp = _impl_.selectedchild_;
  _impl_.selectedchild_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::SelectedChild* Annotations::unsafe_arena_release_selectedchild() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.Annotations.selectedChild)
  _impl_._has_bits_[0] &= ~0x01000000u;
  ::playapi::proto::finsky::document::SelectedChild* temp = _impl_.selectedchild_;
  _impl_.selectedchild_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::SelectedChild* Annotations::_internal_mutable_selectedchild() {
  _impl_._has_bits_[0] |= 0x01000000u;
  if (_impl_.selectedchild_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::SelectedChild>(GetArenaForAllocation());
    _impl_.selectedchild_ = p;
  }
  return _impl_.selectedchild_;
}
inline ::playapi::proto::finsky::document::SelectedChild* Annotations::mutable_selectedchild() {
  ::playapi::proto::finsky::document::SelectedChild* _msg = _internal_mutable_selectedchild();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Annotations.selectedChild)
  return _msg;
}
inline void Annotations::set_allocated_selectedchild(::playapi::proto::finsky::document::SelectedChild* selectedchild) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.selectedchild_;
  }
  if (selectedchild) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(selectedchild);
    if (message_arena != submessage_arena) {
      selectedchild = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, selectedchild, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x01000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x01000000u;
  }
  _impl_.selectedchild_ = selectedchild;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.Annotations.selectedChild)
}

// optional .playapi.proto.finsky.document.PurchaseDetails purchaseDetails = 41;
inline bool Annotations::_internal_has_purchasedetails() const {
  bool value = (_impl_._has_bits_[0] & 0x02000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.purchasedetails_ != nullptr);
  return value;
}
inline bool Annotations::has_purchasedetails() const {
  return _internal_has_purchasedetails();
}
inline void Annotations::clear_purchasedetails() {
  if (_impl_.purchasedetails_ != nullptr) _impl_.purchasedetails_->Clear();
  _impl_._has_bits_[0] &= ~0x02000000u;
}
inline const ::playapi::proto::finsky::document::PurchaseDetails& Annotations::_internal_purchasedetails() const {
  const ::playapi::proto::finsky::document::PurchaseDetails* p = _impl_.purchasedetails_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::PurchaseDetails&>(
      ::playapi::proto::finsky::document::_PurchaseDetails_default_instance_);
}
inline const ::playapi::proto::finsky::document::PurchaseDetails& Annotations::purchasedetails() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Annotations.purchaseDetails)
  return _internal_purchasedetails();
}
inline void Annotations::unsafe_arena_set_allocated_purchasedetails(
    ::playapi::proto::finsky::document::PurchaseDetails* purchasedetails) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.purchasedetails_);
  }
  _impl_.purchasedetails_ = purchasedetails;
  if (purchasedetails) {
    _impl_._has_bits_[0] |= 0x02000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x02000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.Annotations.purchaseDetails)
}
inline ::playapi::proto::finsky::document::PurchaseDetails* Annotations::release_purchasedetails() {
  _impl_._has_bits_[0] &= ~0x02000000u;
  ::playapi::proto::finsky::document::PurchaseDetails* temp = _impl_.purchasedetails_;
  _impl_.purchasedetails_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::PurchaseDetails* Annotations::unsafe_arena_release_purchasedetails() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.Annotations.purchaseDetails)
  _impl_._has_bits_[0] &= ~0x02000000u;
  ::playapi::proto::finsky::document::PurchaseDetails* temp = _impl_.purchasedetails_;
  _impl_.purchasedetails_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::PurchaseDetails* Annotations::_internal_mutable_purchasedetails() {
  _impl_._has_bits_[0] |= 0x02000000u;
  if (_impl_.purchasedetails_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::PurchaseDetails>(GetArenaForAllocation());
    _impl_.purchasedetails_ = p;
  }
  return _impl_.purchasedetails_;
}
inline ::playapi::proto::finsky::document::PurchaseDetails* Annotations::mutable_purchasedetails() {
  ::playapi::proto::finsky::document::PurchaseDetails* _msg = _internal_mutable_purchasedetails();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Annotations.purchaseDetails)
  return _msg;
}
inline void Annotations::set_allocated_purchasedetails(::playapi::proto::finsky::document::PurchaseDetails* purchasedetails) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.purchasedetails_;
  }
  if (purchasedetails) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(purchasedetails);
    if (message_arena != submessage_arena) {
      purchasedetails = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, purchasedetails, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x02000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x02000000u;
  }
  _impl_.purchasedetails_ = purchasedetails;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.Annotations.purchaseDetails)
}

// optional .playapi.proto.finsky.document.Snippet snippet = 42;
inline bool Annotations::_internal_has_snippet() const {
  bool value = (_impl_._has_bits_[0] & 0x04000000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.snippet_ != nullptr);
  return value;
}
inline bool Annotations::has_snippet() const {
  return _internal_has_snippet();
}
inline void Annotations::clear_snippet() {
  if (_impl_.snippet_ != nullptr) _impl_.snippet_->Clear();
  _impl_._has_bits_[0] &= ~0x04000000u;
}
inline const ::playapi::proto::finsky::document::Snippet& Annotations::_internal_snippet() const {
  const ::playapi::proto::finsky::document::Snippet* p = _impl_.snippet_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::Snippet&>(
      ::playapi::proto::finsky::document::_Snippet_default_instance_);
}
inline const ::playapi::proto::finsky::document::Snippet& Annotations::snippet() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Annotations.snippet)
  return _internal_snippet();
}
inline void Annotations::unsafe_arena_set_allocated_snippet(
    ::playapi::proto::finsky::document::Snippet* snippet) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.snippet_);
  }
  _impl_.snippet_ = snippet;
  if (snippet) {
    _impl_._has_bits_[0] |= 0x04000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x04000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.Annotations.snippet)
}
inline ::playapi::proto::finsky::document::Snippet* Annotations::release_snippet() {
  _impl_._has_bits_[0] &= ~0x04000000u;
  ::playapi::proto::finsky::document::Snippet* temp = _impl_.snippet_;
  _impl_.snippet_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::Snippet* Annotations::unsafe_arena_release_snippet() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.Annotations.snippet)
  _impl_._has_bits_[0] &= ~0x04000000u;
  ::playapi::proto::finsky::document::Snippet* temp = _impl_.snippet_;
  _impl_.snippet_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::Snippet* Annotations::_internal_mutable_snippet() {
  _impl_._has_bits_[0] |= 0x04000000u;
  if (_impl_.snippet_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::Snippet>(GetArenaForAllocation());
    _impl_.snippet_ = p;
  }
  return _impl_.snippet_;
}
inline ::playapi::proto::finsky::document::Snippet* Annotations::mutable_snippet() {
  ::playapi::proto::finsky::document::Snippet* _msg = _internal_mutable_snippet();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Annotations.snippet)
  return _msg;
}
inline void Annotations::set_allocated_snippet(::playapi::proto::finsky::document::Snippet* snippet) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.snippet_;
  }
  if (snippet) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(snippet);
    if (message_arena != submessage_arena) {
      snippet = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, snippet, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x04000000u;
  } else {
    _impl_._has_bits_[0] &= ~0x04000000u;
  }
  _impl_.snippet_ = snippet;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.Annotations.snippet)
}

// -------------------------------------------------------------------

// PlusOneData

// optional bool setByUser = 1;
inline bool PlusOneData::_internal_has_setbyuser() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PlusOneData::has_setbyuser() const {
  return _internal_has_setbyuser();
}
inline void PlusOneData::clear_setbyuser() {
  _impl_.setbyuser_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool PlusOneData::_internal_setbyuser() const {
  return _impl_.setbyuser_;
}
inline bool PlusOneData::setbyuser() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.PlusOneData.setByUser)
  return _internal_setbyuser();
}
inline void PlusOneData::_internal_set_setbyuser(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.setbyuser_ = value;
}
inline void PlusOneData::set_setbyuser(bool value) {
  _internal_set_setbyuser(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.PlusOneData.setByUser)
}

// optional int64 total = 2;
inline bool PlusOneData::_internal_has_total() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PlusOneData::has_total() const {
  return _internal_has_total();
}
inline void PlusOneData::clear_total() {
  _impl_.total_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t PlusOneData::_internal_total() const {
  return _impl_.total_;
}
inline int64_t PlusOneData::total() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.PlusOneData.total)
  return _internal_total();
}
inline void PlusOneData::_internal_set_total(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.total_ = value;
}
inline void PlusOneData::set_total(int64_t value) {
  _internal_set_total(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.PlusOneData.total)
}

// optional int64 circlesTotal = 3;
inline bool PlusOneData::_internal_has_circlestotal() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PlusOneData::has_circlestotal() const {
  return _internal_has_circlestotal();
}
inline void PlusOneData::clear_circlestotal() {
  _impl_.circlestotal_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t PlusOneData::_internal_circlestotal() const {
  return _impl_.circlestotal_;
}
inline int64_t PlusOneData::circlestotal() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.PlusOneData.circlesTotal)
  return _internal_circlestotal();
}
inline void PlusOneData::_internal_set_circlestotal(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.circlestotal_ = value;
}
inline void PlusOneData::set_circlestotal(int64_t value) {
  _internal_set_circlestotal(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.PlusOneData.circlesTotal)
}

// repeated .playapi.proto.finsky.document.OBSOLETE_PlusProfile OBSOLETECirclesProfiles = 4;
inline int PlusOneData::_internal_obsoletecirclesprofiles_size() const {
  return _impl_.obsoletecirclesprofiles_.size();
}
inline int PlusOneData::obsoletecirclesprofiles_size() const {
  return _internal_obsoletecirclesprofiles_size();
}
inline void PlusOneData::clear_obsoletecirclesprofiles() {
  _impl_.obsoletecirclesprofiles_.Clear();
}
inline ::playapi::proto::finsky::document::OBSOLETE_PlusProfile* PlusOneData::mutable_obsoletecirclesprofiles(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.PlusOneData.OBSOLETECirclesProfiles)
  return _impl_.obsoletecirclesprofiles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::OBSOLETE_PlusProfile >*
PlusOneData::mutable_obsoletecirclesprofiles() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.document.PlusOneData.OBSOLETECirclesProfiles)
  return &_impl_.obsoletecirclesprofiles_;
}
inline const ::playapi::proto::finsky::document::OBSOLETE_PlusProfile& PlusOneData::_internal_obsoletecirclesprofiles(int index) const {
  return _impl_.obsoletecirclesprofiles_.Get(index);
}
inline const ::playapi::proto::finsky::document::OBSOLETE_PlusProfile& PlusOneData::obsoletecirclesprofiles(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.PlusOneData.OBSOLETECirclesProfiles)
  return _internal_obsoletecirclesprofiles(index);
}
inline ::playapi::proto::finsky::document::OBSOLETE_PlusProfile* PlusOneData::_internal_add_obsoletecirclesprofiles() {
  return _impl_.obsoletecirclesprofiles_.Add();
}
inline ::playapi::proto::finsky::document::OBSOLETE_PlusProfile* PlusOneData::add_obsoletecirclesprofiles() {
  ::playapi::proto::finsky::document::OBSOLETE_PlusProfile* _add = _internal_add_obsoletecirclesprofiles();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.PlusOneData.OBSOLETECirclesProfiles)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::OBSOLETE_PlusProfile >&
PlusOneData::obsoletecirclesprofiles() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.document.PlusOneData.OBSOLETECirclesProfiles)
  return _impl_.obsoletecirclesprofiles_;
}

// repeated .playapi.proto.finsky.document.DocV2 circlePerson = 5;
inline int PlusOneData::_internal_circleperson_size() const {
  return _impl_.circleperson_.size();
}
inline int PlusOneData::circleperson_size() const {
  return _internal_circleperson_size();
}
inline void PlusOneData::clear_circleperson() {
  _impl_.circleperson_.Clear();
}
inline ::playapi::proto::finsky::document::DocV2* PlusOneData::mutable_circleperson(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.PlusOneData.circlePerson)
  return _impl_.circleperson_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::DocV2 >*
PlusOneData::mutable_circleperson() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.document.PlusOneData.circlePerson)
  return &_impl_.circleperson_;
}
inline const ::playapi::proto::finsky::document::DocV2& PlusOneData::_internal_circleperson(int index) const {
  return _impl_.circleperson_.Get(index);
}
inline const ::playapi::proto::finsky::document::DocV2& PlusOneData::circleperson(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.PlusOneData.circlePerson)
  return _internal_circleperson(index);
}
inline ::playapi::proto::finsky::document::DocV2* PlusOneData::_internal_add_circleperson() {
  return _impl_.circleperson_.Add();
}
inline ::playapi::proto::finsky::document::DocV2* PlusOneData::add_circleperson() {
  ::playapi::proto::finsky::document::DocV2* _add = _internal_add_circleperson();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.PlusOneData.circlePerson)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::DocV2 >&
PlusOneData::circleperson() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.document.PlusOneData.circlePerson)
  return _impl_.circleperson_;
}

// -------------------------------------------------------------------

// OBSOLETE_PlusProfile

// optional string displayName = 2;
inline bool OBSOLETE_PlusProfile::_internal_has_displayname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OBSOLETE_PlusProfile::has_displayname() const {
  return _internal_has_displayname();
}
inline void OBSOLETE_PlusProfile::clear_displayname() {
  _impl_.displayname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OBSOLETE_PlusProfile::displayname() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.OBSOLETE_PlusProfile.displayName)
  return _internal_displayname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OBSOLETE_PlusProfile::set_displayname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.displayname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.OBSOLETE_PlusProfile.displayName)
}
inline std::string* OBSOLETE_PlusProfile::mutable_displayname() {
  std::string* _s = _internal_mutable_displayname();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.OBSOLETE_PlusProfile.displayName)
  return _s;
}
inline const std::string& OBSOLETE_PlusProfile::_internal_displayname() const {
  return _impl_.displayname_.Get();
}
inline void OBSOLETE_PlusProfile::_internal_set_displayname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.displayname_.Set(value, GetArenaForAllocation());
}
inline std::string* OBSOLETE_PlusProfile::_internal_mutable_displayname() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.displayname_.Mutable(GetArenaForAllocation());
}
inline std::string* OBSOLETE_PlusProfile::release_displayname() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.OBSOLETE_PlusProfile.displayName)
  if (!_internal_has_displayname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.displayname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.displayname_.IsDefault()) {
    _impl_.displayname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OBSOLETE_PlusProfile::set_allocated_displayname(std::string* displayname) {
  if (displayname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.displayname_.SetAllocated(displayname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.displayname_.IsDefault()) {
    _impl_.displayname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.OBSOLETE_PlusProfile.displayName)
}

// optional string profileImageUrl = 4;
inline bool OBSOLETE_PlusProfile::_internal_has_profileimageurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool OBSOLETE_PlusProfile::has_profileimageurl() const {
  return _internal_has_profileimageurl();
}
inline void OBSOLETE_PlusProfile::clear_profileimageurl() {
  _impl_.profileimageurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& OBSOLETE_PlusProfile::profileimageurl() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.OBSOLETE_PlusProfile.profileImageUrl)
  return _internal_profileimageurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OBSOLETE_PlusProfile::set_profileimageurl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.profileimageurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.OBSOLETE_PlusProfile.profileImageUrl)
}
inline std::string* OBSOLETE_PlusProfile::mutable_profileimageurl() {
  std::string* _s = _internal_mutable_profileimageurl();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.OBSOLETE_PlusProfile.profileImageUrl)
  return _s;
}
inline const std::string& OBSOLETE_PlusProfile::_internal_profileimageurl() const {
  return _impl_.profileimageurl_.Get();
}
inline void OBSOLETE_PlusProfile::_internal_set_profileimageurl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.profileimageurl_.Set(value, GetArenaForAllocation());
}
inline std::string* OBSOLETE_PlusProfile::_internal_mutable_profileimageurl() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.profileimageurl_.Mutable(GetArenaForAllocation());
}
inline std::string* OBSOLETE_PlusProfile::release_profileimageurl() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.OBSOLETE_PlusProfile.profileImageUrl)
  if (!_internal_has_profileimageurl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.profileimageurl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.profileimageurl_.IsDefault()) {
    _impl_.profileimageurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OBSOLETE_PlusProfile::set_allocated_profileimageurl(std::string* profileimageurl) {
  if (profileimageurl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.profileimageurl_.SetAllocated(profileimageurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.profileimageurl_.IsDefault()) {
    _impl_.profileimageurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.OBSOLETE_PlusProfile.profileImageUrl)
}

// optional .playapi.proto.finsky.Image profileImage = 5;
inline bool OBSOLETE_PlusProfile::_internal_has_profileimage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.profileimage_ != nullptr);
  return value;
}
inline bool OBSOLETE_PlusProfile::has_profileimage() const {
  return _internal_has_profileimage();
}
inline const ::playapi::proto::finsky::Image& OBSOLETE_PlusProfile::_internal_profileimage() const {
  const ::playapi::proto::finsky::Image* p = _impl_.profileimage_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::Image&>(
      ::playapi::proto::finsky::_Image_default_instance_);
}
inline const ::playapi::proto::finsky::Image& OBSOLETE_PlusProfile::profileimage() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.OBSOLETE_PlusProfile.profileImage)
  return _internal_profileimage();
}
inline void OBSOLETE_PlusProfile::unsafe_arena_set_allocated_profileimage(
    ::playapi::proto::finsky::Image* profileimage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.profileimage_);
  }
  _impl_.profileimage_ = profileimage;
  if (profileimage) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.OBSOLETE_PlusProfile.profileImage)
}
inline ::playapi::proto::finsky::Image* OBSOLETE_PlusProfile::release_profileimage() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::playapi::proto::finsky::Image* temp = _impl_.profileimage_;
  _impl_.profileimage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::Image* OBSOLETE_PlusProfile::unsafe_arena_release_profileimage() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.OBSOLETE_PlusProfile.profileImage)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::playapi::proto::finsky::Image* temp = _impl_.profileimage_;
  _impl_.profileimage_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::Image* OBSOLETE_PlusProfile::_internal_mutable_profileimage() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.profileimage_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::Image>(GetArenaForAllocation());
    _impl_.profileimage_ = p;
  }
  return _impl_.profileimage_;
}
inline ::playapi::proto::finsky::Image* OBSOLETE_PlusProfile::mutable_profileimage() {
  ::playapi::proto::finsky::Image* _msg = _internal_mutable_profileimage();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.OBSOLETE_PlusProfile.profileImage)
  return _msg;
}
inline void OBSOLETE_PlusProfile::set_allocated_profileimage(::playapi::proto::finsky::Image* profileimage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.profileimage_);
  }
  if (profileimage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(profileimage));
    if (message_arena != submessage_arena) {
      profileimage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, profileimage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.profileimage_ = profileimage;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.OBSOLETE_PlusProfile.profileImage)
}

// -------------------------------------------------------------------

// SectionMetadata

// optional string header = 1;
inline bool SectionMetadata::_internal_has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SectionMetadata::has_header() const {
  return _internal_has_header();
}
inline void SectionMetadata::clear_header() {
  _impl_.header_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SectionMetadata::header() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.SectionMetadata.header)
  return _internal_header();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SectionMetadata::set_header(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.header_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.SectionMetadata.header)
}
inline std::string* SectionMetadata::mutable_header() {
  std::string* _s = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.SectionMetadata.header)
  return _s;
}
inline const std::string& SectionMetadata::_internal_header() const {
  return _impl_.header_.Get();
}
inline void SectionMetadata::_internal_set_header(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.header_.Set(value, GetArenaForAllocation());
}
inline std::string* SectionMetadata::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.header_.Mutable(GetArenaForAllocation());
}
inline std::string* SectionMetadata::release_header() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.SectionMetadata.header)
  if (!_internal_has_header()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.header_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.header_.IsDefault()) {
    _impl_.header_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SectionMetadata::set_allocated_header(std::string* header) {
  if (header != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_.SetAllocated(header, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.header_.IsDefault()) {
    _impl_.header_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.SectionMetadata.header)
}

// optional string listUrl = 2;
inline bool SectionMetadata::_internal_has_listurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SectionMetadata::has_listurl() const {
  return _internal_has_listurl();
}
inline void SectionMetadata::clear_listurl() {
  _impl_.listurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SectionMetadata::listurl() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.SectionMetadata.listUrl)
  return _internal_listurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SectionMetadata::set_listurl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.listurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.SectionMetadata.listUrl)
}
inline std::string* SectionMetadata::mutable_listurl() {
  std::string* _s = _internal_mutable_listurl();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.SectionMetadata.listUrl)
  return _s;
}
inline const std::string& SectionMetadata::_internal_listurl() const {
  return _impl_.listurl_.Get();
}
inline void SectionMetadata::_internal_set_listurl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.listurl_.Set(value, GetArenaForAllocation());
}
inline std::string* SectionMetadata::_internal_mutable_listurl() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.listurl_.Mutable(GetArenaForAllocation());
}
inline std::string* SectionMetadata::release_listurl() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.SectionMetadata.listUrl)
  if (!_internal_has_listurl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.listurl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.listurl_.IsDefault()) {
    _impl_.listurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SectionMetadata::set_allocated_listurl(std::string* listurl) {
  if (listurl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.listurl_.SetAllocated(listurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.listurl_.IsDefault()) {
    _impl_.listurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.SectionMetadata.listUrl)
}

// optional string browseUrl = 3;
inline bool SectionMetadata::_internal_has_browseurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SectionMetadata::has_browseurl() const {
  return _internal_has_browseurl();
}
inline void SectionMetadata::clear_browseurl() {
  _impl_.browseurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& SectionMetadata::browseurl() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.SectionMetadata.browseUrl)
  return _internal_browseurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SectionMetadata::set_browseurl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.browseurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.SectionMetadata.browseUrl)
}
inline std::string* SectionMetadata::mutable_browseurl() {
  std::string* _s = _internal_mutable_browseurl();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.SectionMetadata.browseUrl)
  return _s;
}
inline const std::string& SectionMetadata::_internal_browseurl() const {
  return _impl_.browseurl_.Get();
}
inline void SectionMetadata::_internal_set_browseurl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.browseurl_.Set(value, GetArenaForAllocation());
}
inline std::string* SectionMetadata::_internal_mutable_browseurl() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.browseurl_.Mutable(GetArenaForAllocation());
}
inline std::string* SectionMetadata::release_browseurl() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.SectionMetadata.browseUrl)
  if (!_internal_has_browseurl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.browseurl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.browseurl_.IsDefault()) {
    _impl_.browseurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SectionMetadata::set_allocated_browseurl(std::string* browseurl) {
  if (browseurl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.browseurl_.SetAllocated(browseurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.browseurl_.IsDefault()) {
    _impl_.browseurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.SectionMetadata.browseUrl)
}

// optional string descriptionHtml = 4;
inline bool SectionMetadata::_internal_has_descriptionhtml() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SectionMetadata::has_descriptionhtml() const {
  return _internal_has_descriptionhtml();
}
inline void SectionMetadata::clear_descriptionhtml() {
  _impl_.descriptionhtml_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& SectionMetadata::descriptionhtml() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.SectionMetadata.descriptionHtml)
  return _internal_descriptionhtml();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SectionMetadata::set_descriptionhtml(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.descriptionhtml_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.SectionMetadata.descriptionHtml)
}
inline std::string* SectionMetadata::mutable_descriptionhtml() {
  std::string* _s = _internal_mutable_descriptionhtml();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.SectionMetadata.descriptionHtml)
  return _s;
}
inline const std::string& SectionMetadata::_internal_descriptionhtml() const {
  return _impl_.descriptionhtml_.Get();
}
inline void SectionMetadata::_internal_set_descriptionhtml(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.descriptionhtml_.Set(value, GetArenaForAllocation());
}
inline std::string* SectionMetadata::_internal_mutable_descriptionhtml() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.descriptionhtml_.Mutable(GetArenaForAllocation());
}
inline std::string* SectionMetadata::release_descriptionhtml() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.SectionMetadata.descriptionHtml)
  if (!_internal_has_descriptionhtml()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.descriptionhtml_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.descriptionhtml_.IsDefault()) {
    _impl_.descriptionhtml_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SectionMetadata::set_allocated_descriptionhtml(std::string* descriptionhtml) {
  if (descriptionhtml != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.descriptionhtml_.SetAllocated(descriptionhtml, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.descriptionhtml_.IsDefault()) {
    _impl_.descriptionhtml_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.SectionMetadata.descriptionHtml)
}

// -------------------------------------------------------------------

// Warning

// optional string localizedMessage = 1;
inline bool Warning::_internal_has_localizedmessage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Warning::has_localizedmessage() const {
  return _internal_has_localizedmessage();
}
inline void Warning::clear_localizedmessage() {
  _impl_.localizedmessage_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Warning::localizedmessage() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Warning.localizedMessage)
  return _internal_localizedmessage();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Warning::set_localizedmessage(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.localizedmessage_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.Warning.localizedMessage)
}
inline std::string* Warning::mutable_localizedmessage() {
  std::string* _s = _internal_mutable_localizedmessage();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Warning.localizedMessage)
  return _s;
}
inline const std::string& Warning::_internal_localizedmessage() const {
  return _impl_.localizedmessage_.Get();
}
inline void Warning::_internal_set_localizedmessage(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.localizedmessage_.Set(value, GetArenaForAllocation());
}
inline std::string* Warning::_internal_mutable_localizedmessage() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.localizedmessage_.Mutable(GetArenaForAllocation());
}
inline std::string* Warning::release_localizedmessage() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.Warning.localizedMessage)
  if (!_internal_has_localizedmessage()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.localizedmessage_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.localizedmessage_.IsDefault()) {
    _impl_.localizedmessage_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Warning::set_allocated_localizedmessage(std::string* localizedmessage) {
  if (localizedmessage != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.localizedmessage_.SetAllocated(localizedmessage, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.localizedmessage_.IsDefault()) {
    _impl_.localizedmessage_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.Warning.localizedMessage)
}

// optional bool showIcon = 2;
inline bool Warning::_internal_has_showicon() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Warning::has_showicon() const {
  return _internal_has_showicon();
}
inline void Warning::clear_showicon() {
  _impl_.showicon_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool Warning::_internal_showicon() const {
  return _impl_.showicon_;
}
inline bool Warning::showicon() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Warning.showIcon)
  return _internal_showicon();
}
inline void Warning::_internal_set_showicon(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.showicon_ = value;
}
inline void Warning::set_showicon(bool value) {
  _internal_set_showicon(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.Warning.showIcon)
}

// -------------------------------------------------------------------

// Badge

// optional string title = 1;
inline bool Badge::_internal_has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Badge::has_title() const {
  return _internal_has_title();
}
inline void Badge::clear_title() {
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Badge::title() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Badge.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Badge::set_title(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.Badge.title)
}
inline std::string* Badge::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Badge.title)
  return _s;
}
inline const std::string& Badge::_internal_title() const {
  return _impl_.title_.Get();
}
inline void Badge::_internal_set_title(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* Badge::_internal_mutable_title() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* Badge::release_title() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.Badge.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.title_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Badge::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.Badge.title)
}

// repeated .playapi.proto.finsky.Image image = 2;
inline int Badge::_internal_image_size() const {
  return _impl_.image_.size();
}
inline int Badge::image_size() const {
  return _internal_image_size();
}
inline ::playapi::proto::finsky::Image* Badge::mutable_image(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Badge.image)
  return _impl_.image_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Image >*
Badge::mutable_image() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.document.Badge.image)
  return &_impl_.image_;
}
inline const ::playapi::proto::finsky::Image& Badge::_internal_image(int index) const {
  return _impl_.image_.Get(index);
}
inline const ::playapi::proto::finsky::Image& Badge::image(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Badge.image)
  return _internal_image(index);
}
inline ::playapi::proto::finsky::Image* Badge::_internal_add_image() {
  return _impl_.image_.Add();
}
inline ::playapi::proto::finsky::Image* Badge::add_image() {
  ::playapi::proto::finsky::Image* _add = _internal_add_image();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.Badge.image)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Image >&
Badge::image() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.document.Badge.image)
  return _impl_.image_;
}

// optional string browseUrl = 3;
inline bool Badge::_internal_has_browseurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Badge::has_browseurl() const {
  return _internal_has_browseurl();
}
inline void Badge::clear_browseurl() {
  _impl_.browseurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Badge::browseurl() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Badge.browseUrl)
  return _internal_browseurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Badge::set_browseurl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.browseurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.Badge.browseUrl)
}
inline std::string* Badge::mutable_browseurl() {
  std::string* _s = _internal_mutable_browseurl();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Badge.browseUrl)
  return _s;
}
inline const std::string& Badge::_internal_browseurl() const {
  return _impl_.browseurl_.Get();
}
inline void Badge::_internal_set_browseurl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.browseurl_.Set(value, GetArenaForAllocation());
}
inline std::string* Badge::_internal_mutable_browseurl() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.browseurl_.Mutable(GetArenaForAllocation());
}
inline std::string* Badge::release_browseurl() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.Badge.browseUrl)
  if (!_internal_has_browseurl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.browseurl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.browseurl_.IsDefault()) {
    _impl_.browseurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Badge::set_allocated_browseurl(std::string* browseurl) {
  if (browseurl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.browseurl_.SetAllocated(browseurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.browseurl_.IsDefault()) {
    _impl_.browseurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.Badge.browseUrl)
}

// optional string description = 4;
inline bool Badge::_internal_has_description() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Badge::has_description() const {
  return _internal_has_description();
}
inline void Badge::clear_description() {
  _impl_.description_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Badge::description() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Badge.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Badge::set_description(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.Badge.description)
}
inline std::string* Badge::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Badge.description)
  return _s;
}
inline const std::string& Badge::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Badge::_internal_set_description(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Badge::_internal_mutable_description() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* Badge::release_description() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.Badge.description)
  if (!_internal_has_description()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.description_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Badge::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.Badge.description)
}

// optional string textInTitleSection = 5;
inline bool Badge::_internal_has_textintitlesection() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Badge::has_textintitlesection() const {
  return _internal_has_textintitlesection();
}
inline void Badge::clear_textintitlesection() {
  _impl_.textintitlesection_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& Badge::textintitlesection() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Badge.textInTitleSection)
  return _internal_textintitlesection();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Badge::set_textintitlesection(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.textintitlesection_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.Badge.textInTitleSection)
}
inline std::string* Badge::mutable_textintitlesection() {
  std::string* _s = _internal_mutable_textintitlesection();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Badge.textInTitleSection)
  return _s;
}
inline const std::string& Badge::_internal_textintitlesection() const {
  return _impl_.textintitlesection_.Get();
}
inline void Badge::_internal_set_textintitlesection(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.textintitlesection_.Set(value, GetArenaForAllocation());
}
inline std::string* Badge::_internal_mutable_textintitlesection() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.textintitlesection_.Mutable(GetArenaForAllocation());
}
inline std::string* Badge::release_textintitlesection() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.Badge.textInTitleSection)
  if (!_internal_has_textintitlesection()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.textintitlesection_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.textintitlesection_.IsDefault()) {
    _impl_.textintitlesection_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Badge::set_allocated_textintitlesection(std::string* textintitlesection) {
  if (textintitlesection != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.textintitlesection_.SetAllocated(textintitlesection, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.textintitlesection_.IsDefault()) {
    _impl_.textintitlesection_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.Badge.textInTitleSection)
}

// optional .playapi.proto.finsky.Image expandedBadgeImage = 6;
inline bool Badge::_internal_has_expandedbadgeimage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.expandedbadgeimage_ != nullptr);
  return value;
}
inline bool Badge::has_expandedbadgeimage() const {
  return _internal_has_expandedbadgeimage();
}
inline const ::playapi::proto::finsky::Image& Badge::_internal_expandedbadgeimage() const {
  const ::playapi::proto::finsky::Image* p = _impl_.expandedbadgeimage_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::Image&>(
      ::playapi::proto::finsky::_Image_default_instance_);
}
inline const ::playapi::proto::finsky::Image& Badge::expandedbadgeimage() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Badge.expandedBadgeImage)
  return _internal_expandedbadgeimage();
}
inline void Badge::unsafe_arena_set_allocated_expandedbadgeimage(
    ::playapi::proto::finsky::Image* expandedbadgeimage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expandedbadgeimage_);
  }
  _impl_.expandedbadgeimage_ = expandedbadgeimage;
  if (expandedbadgeimage) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.Badge.expandedBadgeImage)
}
inline ::playapi::proto::finsky::Image* Badge::release_expandedbadgeimage() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::playapi::proto::finsky::Image* temp = _impl_.expandedbadgeimage_;
  _impl_.expandedbadgeimage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::Image* Badge::unsafe_arena_release_expandedbadgeimage() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.Badge.expandedBadgeImage)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::playapi::proto::finsky::Image* temp = _impl_.expandedbadgeimage_;
  _impl_.expandedbadgeimage_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::Image* Badge::_internal_mutable_expandedbadgeimage() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.expandedbadgeimage_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::Image>(GetArenaForAllocation());
    _impl_.expandedbadgeimage_ = p;
  }
  return _impl_.expandedbadgeimage_;
}
inline ::playapi::proto::finsky::Image* Badge::mutable_expandedbadgeimage() {
  ::playapi::proto::finsky::Image* _msg = _internal_mutable_expandedbadgeimage();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Badge.expandedBadgeImage)
  return _msg;
}
inline void Badge::set_allocated_expandedbadgeimage(::playapi::proto::finsky::Image* expandedbadgeimage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expandedbadgeimage_);
  }
  if (expandedbadgeimage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(expandedbadgeimage));
    if (message_arena != submessage_arena) {
      expandedbadgeimage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expandedbadgeimage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.expandedbadgeimage_ = expandedbadgeimage;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.Badge.expandedBadgeImage)
}

// -------------------------------------------------------------------

// BadgeContainer

// optional string title = 1;
inline bool BadgeContainer::_internal_has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BadgeContainer::has_title() const {
  return _internal_has_title();
}
inline void BadgeContainer::clear_title() {
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BadgeContainer::title() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.BadgeContainer.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BadgeContainer::set_title(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.BadgeContainer.title)
}
inline std::string* BadgeContainer::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.BadgeContainer.title)
  return _s;
}
inline const std::string& BadgeContainer::_internal_title() const {
  return _impl_.title_.Get();
}
inline void BadgeContainer::_internal_set_title(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* BadgeContainer::_internal_mutable_title() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* BadgeContainer::release_title() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.BadgeContainer.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.title_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BadgeContainer::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.BadgeContainer.title)
}

// repeated .playapi.proto.finsky.Image image = 2;
inline int BadgeContainer::_internal_image_size() const {
  return _impl_.image_.size();
}
inline int BadgeContainer::image_size() const {
  return _internal_image_size();
}
inline ::playapi::proto::finsky::Image* BadgeContainer::mutable_image(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.BadgeContainer.image)
  return _impl_.image_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Image >*
BadgeContainer::mutable_image() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.document.BadgeContainer.image)
  return &_impl_.image_;
}
inline const ::playapi::proto::finsky::Image& BadgeContainer::_internal_image(int index) const {
  return _impl_.image_.Get(index);
}
inline const ::playapi::proto::finsky::Image& BadgeContainer::image(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.BadgeContainer.image)
  return _internal_image(index);
}
inline ::playapi::proto::finsky::Image* BadgeContainer::_internal_add_image() {
  return _impl_.image_.Add();
}
inline ::playapi::proto::finsky::Image* BadgeContainer::add_image() {
  ::playapi::proto::finsky::Image* _add = _internal_add_image();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.BadgeContainer.image)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Image >&
BadgeContainer::image() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.document.BadgeContainer.image)
  return _impl_.image_;
}

// repeated .playapi.proto.finsky.document.Badge badge = 3;
inline int BadgeContainer::_internal_badge_size() const {
  return _impl_.badge_.size();
}
inline int BadgeContainer::badge_size() const {
  return _internal_badge_size();
}
inline void BadgeContainer::clear_badge() {
  _impl_.badge_.Clear();
}
inline ::playapi::proto::finsky::document::Badge* BadgeContainer::mutable_badge(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.BadgeContainer.badge)
  return _impl_.badge_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::Badge >*
BadgeContainer::mutable_badge() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.document.BadgeContainer.badge)
  return &_impl_.badge_;
}
inline const ::playapi::proto::finsky::document::Badge& BadgeContainer::_internal_badge(int index) const {
  return _impl_.badge_.Get(index);
}
inline const ::playapi::proto::finsky::document::Badge& BadgeContainer::badge(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.BadgeContainer.badge)
  return _internal_badge(index);
}
inline ::playapi::proto::finsky::document::Badge* BadgeContainer::_internal_add_badge() {
  return _impl_.badge_.Add();
}
inline ::playapi::proto::finsky::document::Badge* BadgeContainer::add_badge() {
  ::playapi::proto::finsky::document::Badge* _add = _internal_add_badge();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.BadgeContainer.badge)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::Badge >&
BadgeContainer::badge() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.document.BadgeContainer.badge)
  return _impl_.badge_;
}

// -------------------------------------------------------------------

// PurchaseDetails

// optional int64 legalDocumentBrokerId = 1;
inline bool PurchaseDetails::_internal_has_legaldocumentbrokerid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PurchaseDetails::has_legaldocumentbrokerid() const {
  return _internal_has_legaldocumentbrokerid();
}
inline void PurchaseDetails::clear_legaldocumentbrokerid() {
  _impl_.legaldocumentbrokerid_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t PurchaseDetails::_internal_legaldocumentbrokerid() const {
  return _impl_.legaldocumentbrokerid_;
}
inline int64_t PurchaseDetails::legaldocumentbrokerid() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.PurchaseDetails.legalDocumentBrokerId)
  return _internal_legaldocumentbrokerid();
}
inline void PurchaseDetails::_internal_set_legaldocumentbrokerid(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.legaldocumentbrokerid_ = value;
}
inline void PurchaseDetails::set_legaldocumentbrokerid(int64_t value) {
  _internal_set_legaldocumentbrokerid(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.PurchaseDetails.legalDocumentBrokerId)
}

// optional bool showAgeConfirmationPrompt = 33;
inline bool PurchaseDetails::_internal_has_showageconfirmationprompt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PurchaseDetails::has_showageconfirmationprompt() const {
  return _internal_has_showageconfirmationprompt();
}
inline void PurchaseDetails::clear_showageconfirmationprompt() {
  _impl_.showageconfirmationprompt_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool PurchaseDetails::_internal_showageconfirmationprompt() const {
  return _impl_.showageconfirmationprompt_;
}
inline bool PurchaseDetails::showageconfirmationprompt() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.PurchaseDetails.showAgeConfirmationPrompt)
  return _internal_showageconfirmationprompt();
}
inline void PurchaseDetails::_internal_set_showageconfirmationprompt(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.showageconfirmationprompt_ = value;
}
inline void PurchaseDetails::set_showageconfirmationprompt(bool value) {
  _internal_set_showageconfirmationprompt(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.PurchaseDetails.showAgeConfirmationPrompt)
}

// optional bool purchaseAuthenticationRequired = 34;
inline bool PurchaseDetails::_internal_has_purchaseauthenticationrequired() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PurchaseDetails::has_purchaseauthenticationrequired() const {
  return _internal_has_purchaseauthenticationrequired();
}
inline void PurchaseDetails::clear_purchaseauthenticationrequired() {
  _impl_.purchaseauthenticationrequired_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool PurchaseDetails::_internal_purchaseauthenticationrequired() const {
  return _impl_.purchaseauthenticationrequired_;
}
inline bool PurchaseDetails::purchaseauthenticationrequired() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.PurchaseDetails.purchaseAuthenticationRequired)
  return _internal_purchaseauthenticationrequired();
}
inline void PurchaseDetails::_internal_set_purchaseauthenticationrequired(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.purchaseauthenticationrequired_ = value;
}
inline void PurchaseDetails::set_purchaseauthenticationrequired(bool value) {
  _internal_set_purchaseauthenticationrequired(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.PurchaseDetails.purchaseAuthenticationRequired)
}

// -------------------------------------------------------------------

// PurchaseHistoryDetails

// optional int64 purchaseTimestampMsec = 2;
inline bool PurchaseHistoryDetails::_internal_has_purchasetimestampmsec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool PurchaseHistoryDetails::has_purchasetimestampmsec() const {
  return _internal_has_purchasetimestampmsec();
}
inline void PurchaseHistoryDetails::clear_purchasetimestampmsec() {
  _impl_.purchasetimestampmsec_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int64_t PurchaseHistoryDetails::_internal_purchasetimestampmsec() const {
  return _impl_.purchasetimestampmsec_;
}
inline int64_t PurchaseHistoryDetails::purchasetimestampmsec() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.PurchaseHistoryDetails.purchaseTimestampMsec)
  return _internal_purchasetimestampmsec();
}
inline void PurchaseHistoryDetails::_internal_set_purchasetimestampmsec(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.purchasetimestampmsec_ = value;
}
inline void PurchaseHistoryDetails::set_purchasetimestampmsec(int64_t value) {
  _internal_set_purchasetimestampmsec(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.PurchaseHistoryDetails.purchaseTimestampMsec)
}

// optional string purchaseDetailsHtml = 3;
inline bool PurchaseHistoryDetails::_internal_has_purchasedetailshtml() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PurchaseHistoryDetails::has_purchasedetailshtml() const {
  return _internal_has_purchasedetailshtml();
}
inline void PurchaseHistoryDetails::clear_purchasedetailshtml() {
  _impl_.purchasedetailshtml_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PurchaseHistoryDetails::purchasedetailshtml() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.PurchaseHistoryDetails.purchaseDetailsHtml)
  return _internal_purchasedetailshtml();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PurchaseHistoryDetails::set_purchasedetailshtml(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.purchasedetailshtml_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.PurchaseHistoryDetails.purchaseDetailsHtml)
}
inline std::string* PurchaseHistoryDetails::mutable_purchasedetailshtml() {
  std::string* _s = _internal_mutable_purchasedetailshtml();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.PurchaseHistoryDetails.purchaseDetailsHtml)
  return _s;
}
inline const std::string& PurchaseHistoryDetails::_internal_purchasedetailshtml() const {
  return _impl_.purchasedetailshtml_.Get();
}
inline void PurchaseHistoryDetails::_internal_set_purchasedetailshtml(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.purchasedetailshtml_.Set(value, GetArenaForAllocation());
}
inline std::string* PurchaseHistoryDetails::_internal_mutable_purchasedetailshtml() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.purchasedetailshtml_.Mutable(GetArenaForAllocation());
}
inline std::string* PurchaseHistoryDetails::release_purchasedetailshtml() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.PurchaseHistoryDetails.purchaseDetailsHtml)
  if (!_internal_has_purchasedetailshtml()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.purchasedetailshtml_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.purchasedetailshtml_.IsDefault()) {
    _impl_.purchasedetailshtml_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PurchaseHistoryDetails::set_allocated_purchasedetailshtml(std::string* purchasedetailshtml) {
  if (purchasedetailshtml != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.purchasedetailshtml_.SetAllocated(purchasedetailshtml, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.purchasedetailshtml_.IsDefault()) {
    _impl_.purchasedetailshtml_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.PurchaseHistoryDetails.purchaseDetailsHtml)
}

// optional .playapi.proto.finsky.Offer offer = 5;
inline bool PurchaseHistoryDetails::_internal_has_offer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.offer_ != nullptr);
  return value;
}
inline bool PurchaseHistoryDetails::has_offer() const {
  return _internal_has_offer();
}
inline const ::playapi::proto::finsky::Offer& PurchaseHistoryDetails::_internal_offer() const {
  const ::playapi::proto::finsky::Offer* p = _impl_.offer_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::Offer&>(
      ::playapi::proto::finsky::_Offer_default_instance_);
}
inline const ::playapi::proto::finsky::Offer& PurchaseHistoryDetails::offer() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.PurchaseHistoryDetails.offer)
  return _internal_offer();
}
inline void PurchaseHistoryDetails::unsafe_arena_set_allocated_offer(
    ::playapi::proto::finsky::Offer* offer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.offer_);
  }
  _impl_.offer_ = offer;
  if (offer) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.PurchaseHistoryDetails.offer)
}
inline ::playapi::proto::finsky::Offer* PurchaseHistoryDetails::release_offer() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::playapi::proto::finsky::Offer* temp = _impl_.offer_;
  _impl_.offer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::Offer* PurchaseHistoryDetails::unsafe_arena_release_offer() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.PurchaseHistoryDetails.offer)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::playapi::proto::finsky::Offer* temp = _impl_.offer_;
  _impl_.offer_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::Offer* PurchaseHistoryDetails::_internal_mutable_offer() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.offer_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::Offer>(GetArenaForAllocation());
    _impl_.offer_ = p;
  }
  return _impl_.offer_;
}
inline ::playapi::proto::finsky::Offer* PurchaseHistoryDetails::mutable_offer() {
  ::playapi::proto::finsky::Offer* _msg = _internal_mutable_offer();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.PurchaseHistoryDetails.offer)
  return _msg;
}
inline void PurchaseHistoryDetails::set_allocated_offer(::playapi::proto::finsky::Offer* offer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.offer_);
  }
  if (offer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(offer));
    if (message_arena != submessage_arena) {
      offer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, offer, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.offer_ = offer;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.PurchaseHistoryDetails.offer)
}

// optional string purchaseStatus = 6;
inline bool PurchaseHistoryDetails::_internal_has_purchasestatus() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PurchaseHistoryDetails::has_purchasestatus() const {
  return _internal_has_purchasestatus();
}
inline void PurchaseHistoryDetails::clear_purchasestatus() {
  _impl_.purchasestatus_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PurchaseHistoryDetails::purchasestatus() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.PurchaseHistoryDetails.purchaseStatus)
  return _internal_purchasestatus();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PurchaseHistoryDetails::set_purchasestatus(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.purchasestatus_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.PurchaseHistoryDetails.purchaseStatus)
}
inline std::string* PurchaseHistoryDetails::mutable_purchasestatus() {
  std::string* _s = _internal_mutable_purchasestatus();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.PurchaseHistoryDetails.purchaseStatus)
  return _s;
}
inline const std::string& PurchaseHistoryDetails::_internal_purchasestatus() const {
  return _impl_.purchasestatus_.Get();
}
inline void PurchaseHistoryDetails::_internal_set_purchasestatus(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.purchasestatus_.Set(value, GetArenaForAllocation());
}
inline std::string* PurchaseHistoryDetails::_internal_mutable_purchasestatus() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.purchasestatus_.Mutable(GetArenaForAllocation());
}
inline std::string* PurchaseHistoryDetails::release_purchasestatus() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.PurchaseHistoryDetails.purchaseStatus)
  if (!_internal_has_purchasestatus()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.purchasestatus_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.purchasestatus_.IsDefault()) {
    _impl_.purchasestatus_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PurchaseHistoryDetails::set_allocated_purchasestatus(std::string* purchasestatus) {
  if (purchasestatus != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.purchasestatus_.SetAllocated(purchasestatus, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.purchasestatus_.IsDefault()) {
    _impl_.purchasestatus_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.PurchaseHistoryDetails.purchaseStatus)
}

// optional string titleBylineHtml = 7;
inline bool PurchaseHistoryDetails::_internal_has_titlebylinehtml() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PurchaseHistoryDetails::has_titlebylinehtml() const {
  return _internal_has_titlebylinehtml();
}
inline void PurchaseHistoryDetails::clear_titlebylinehtml() {
  _impl_.titlebylinehtml_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& PurchaseHistoryDetails::titlebylinehtml() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.PurchaseHistoryDetails.titleBylineHtml)
  return _internal_titlebylinehtml();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PurchaseHistoryDetails::set_titlebylinehtml(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.titlebylinehtml_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.PurchaseHistoryDetails.titleBylineHtml)
}
inline std::string* PurchaseHistoryDetails::mutable_titlebylinehtml() {
  std::string* _s = _internal_mutable_titlebylinehtml();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.PurchaseHistoryDetails.titleBylineHtml)
  return _s;
}
inline const std::string& PurchaseHistoryDetails::_internal_titlebylinehtml() const {
  return _impl_.titlebylinehtml_.Get();
}
inline void PurchaseHistoryDetails::_internal_set_titlebylinehtml(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.titlebylinehtml_.Set(value, GetArenaForAllocation());
}
inline std::string* PurchaseHistoryDetails::_internal_mutable_titlebylinehtml() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.titlebylinehtml_.Mutable(GetArenaForAllocation());
}
inline std::string* PurchaseHistoryDetails::release_titlebylinehtml() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.PurchaseHistoryDetails.titleBylineHtml)
  if (!_internal_has_titlebylinehtml()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.titlebylinehtml_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.titlebylinehtml_.IsDefault()) {
    _impl_.titlebylinehtml_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PurchaseHistoryDetails::set_allocated_titlebylinehtml(std::string* titlebylinehtml) {
  if (titlebylinehtml != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.titlebylinehtml_.SetAllocated(titlebylinehtml, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.titlebylinehtml_.IsDefault()) {
    _impl_.titlebylinehtml_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.PurchaseHistoryDetails.titleBylineHtml)
}

// optional bytes clientRefundContext = 8;
inline bool PurchaseHistoryDetails::_internal_has_clientrefundcontext() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PurchaseHistoryDetails::has_clientrefundcontext() const {
  return _internal_has_clientrefundcontext();
}
inline void PurchaseHistoryDetails::clear_clientrefundcontext() {
  _impl_.clientrefundcontext_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& PurchaseHistoryDetails::clientrefundcontext() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.PurchaseHistoryDetails.clientRefundContext)
  return _internal_clientrefundcontext();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PurchaseHistoryDetails::set_clientrefundcontext(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.clientrefundcontext_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.PurchaseHistoryDetails.clientRefundContext)
}
inline std::string* PurchaseHistoryDetails::mutable_clientrefundcontext() {
  std::string* _s = _internal_mutable_clientrefundcontext();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.PurchaseHistoryDetails.clientRefundContext)
  return _s;
}
inline const std::string& PurchaseHistoryDetails::_internal_clientrefundcontext() const {
  return _impl_.clientrefundcontext_.Get();
}
inline void PurchaseHistoryDetails::_internal_set_clientrefundcontext(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.clientrefundcontext_.Set(value, GetArenaForAllocation());
}
inline std::string* PurchaseHistoryDetails::_internal_mutable_clientrefundcontext() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.clientrefundcontext_.Mutable(GetArenaForAllocation());
}
inline std::string* PurchaseHistoryDetails::release_clientrefundcontext() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.PurchaseHistoryDetails.clientRefundContext)
  if (!_internal_has_clientrefundcontext()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.clientrefundcontext_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clientrefundcontext_.IsDefault()) {
    _impl_.clientrefundcontext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PurchaseHistoryDetails::set_allocated_clientrefundcontext(std::string* clientrefundcontext) {
  if (clientrefundcontext != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.clientrefundcontext_.SetAllocated(clientrefundcontext, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clientrefundcontext_.IsDefault()) {
    _impl_.clientrefundcontext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.PurchaseHistoryDetails.clientRefundContext)
}

// optional .playapi.proto.finsky.Image purchaseDetailsImage = 9;
inline bool PurchaseHistoryDetails::_internal_has_purchasedetailsimage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.purchasedetailsimage_ != nullptr);
  return value;
}
inline bool PurchaseHistoryDetails::has_purchasedetailsimage() const {
  return _internal_has_purchasedetailsimage();
}
inline const ::playapi::proto::finsky::Image& PurchaseHistoryDetails::_internal_purchasedetailsimage() const {
  const ::playapi::proto::finsky::Image* p = _impl_.purchasedetailsimage_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::Image&>(
      ::playapi::proto::finsky::_Image_default_instance_);
}
inline const ::playapi::proto::finsky::Image& PurchaseHistoryDetails::purchasedetailsimage() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.PurchaseHistoryDetails.purchaseDetailsImage)
  return _internal_purchasedetailsimage();
}
inline void PurchaseHistoryDetails::unsafe_arena_set_allocated_purchasedetailsimage(
    ::playapi::proto::finsky::Image* purchasedetailsimage) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.purchasedetailsimage_);
  }
  _impl_.purchasedetailsimage_ = purchasedetailsimage;
  if (purchasedetailsimage) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.PurchaseHistoryDetails.purchaseDetailsImage)
}
inline ::playapi::proto::finsky::Image* PurchaseHistoryDetails::release_purchasedetailsimage() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::playapi::proto::finsky::Image* temp = _impl_.purchasedetailsimage_;
  _impl_.purchasedetailsimage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::Image* PurchaseHistoryDetails::unsafe_arena_release_purchasedetailsimage() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.PurchaseHistoryDetails.purchaseDetailsImage)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::playapi::proto::finsky::Image* temp = _impl_.purchasedetailsimage_;
  _impl_.purchasedetailsimage_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::Image* PurchaseHistoryDetails::_internal_mutable_purchasedetailsimage() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.purchasedetailsimage_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::Image>(GetArenaForAllocation());
    _impl_.purchasedetailsimage_ = p;
  }
  return _impl_.purchasedetailsimage_;
}
inline ::playapi::proto::finsky::Image* PurchaseHistoryDetails::mutable_purchasedetailsimage() {
  ::playapi::proto::finsky::Image* _msg = _internal_mutable_purchasedetailsimage();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.PurchaseHistoryDetails.purchaseDetailsImage)
  return _msg;
}
inline void PurchaseHistoryDetails::set_allocated_purchasedetailsimage(::playapi::proto::finsky::Image* purchasedetailsimage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.purchasedetailsimage_);
  }
  if (purchasedetailsimage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(purchasedetailsimage));
    if (message_arena != submessage_arena) {
      purchasedetailsimage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, purchasedetailsimage, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.purchasedetailsimage_ = purchasedetailsimage;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.PurchaseHistoryDetails.purchaseDetailsImage)
}

// -------------------------------------------------------------------

// OBSOLETE_Reason

// optional string briefReason = 1;
inline bool OBSOLETE_Reason::_internal_has_briefreason() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OBSOLETE_Reason::has_briefreason() const {
  return _internal_has_briefreason();
}
inline void OBSOLETE_Reason::clear_briefreason() {
  _impl_.briefreason_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OBSOLETE_Reason::briefreason() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.OBSOLETE_Reason.briefReason)
  return _internal_briefreason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OBSOLETE_Reason::set_briefreason(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.briefreason_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.OBSOLETE_Reason.briefReason)
}
inline std::string* OBSOLETE_Reason::mutable_briefreason() {
  std::string* _s = _internal_mutable_briefreason();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.OBSOLETE_Reason.briefReason)
  return _s;
}
inline const std::string& OBSOLETE_Reason::_internal_briefreason() const {
  return _impl_.briefreason_.Get();
}
inline void OBSOLETE_Reason::_internal_set_briefreason(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.briefreason_.Set(value, GetArenaForAllocation());
}
inline std::string* OBSOLETE_Reason::_internal_mutable_briefreason() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.briefreason_.Mutable(GetArenaForAllocation());
}
inline std::string* OBSOLETE_Reason::release_briefreason() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.OBSOLETE_Reason.briefReason)
  if (!_internal_has_briefreason()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.briefreason_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.briefreason_.IsDefault()) {
    _impl_.briefreason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OBSOLETE_Reason::set_allocated_briefreason(std::string* briefreason) {
  if (briefreason != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.briefreason_.SetAllocated(briefreason, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.briefreason_.IsDefault()) {
    _impl_.briefreason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.OBSOLETE_Reason.briefReason)
}

// optional string OBSOLETEDetailedReason = 2;
inline bool OBSOLETE_Reason::_internal_has_obsoletedetailedreason() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool OBSOLETE_Reason::has_obsoletedetailedreason() const {
  return _internal_has_obsoletedetailedreason();
}
inline void OBSOLETE_Reason::clear_obsoletedetailedreason() {
  _impl_.obsoletedetailedreason_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& OBSOLETE_Reason::obsoletedetailedreason() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.OBSOLETE_Reason.OBSOLETEDetailedReason)
  return _internal_obsoletedetailedreason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OBSOLETE_Reason::set_obsoletedetailedreason(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.obsoletedetailedreason_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.OBSOLETE_Reason.OBSOLETEDetailedReason)
}
inline std::string* OBSOLETE_Reason::mutable_obsoletedetailedreason() {
  std::string* _s = _internal_mutable_obsoletedetailedreason();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.OBSOLETE_Reason.OBSOLETEDetailedReason)
  return _s;
}
inline const std::string& OBSOLETE_Reason::_internal_obsoletedetailedreason() const {
  return _impl_.obsoletedetailedreason_.Get();
}
inline void OBSOLETE_Reason::_internal_set_obsoletedetailedreason(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.obsoletedetailedreason_.Set(value, GetArenaForAllocation());
}
inline std::string* OBSOLETE_Reason::_internal_mutable_obsoletedetailedreason() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.obsoletedetailedreason_.Mutable(GetArenaForAllocation());
}
inline std::string* OBSOLETE_Reason::release_obsoletedetailedreason() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.OBSOLETE_Reason.OBSOLETEDetailedReason)
  if (!_internal_has_obsoletedetailedreason()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.obsoletedetailedreason_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.obsoletedetailedreason_.IsDefault()) {
    _impl_.obsoletedetailedreason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OBSOLETE_Reason::set_allocated_obsoletedetailedreason(std::string* obsoletedetailedreason) {
  if (obsoletedetailedreason != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.obsoletedetailedreason_.SetAllocated(obsoletedetailedreason, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.obsoletedetailedreason_.IsDefault()) {
    _impl_.obsoletedetailedreason_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.OBSOLETE_Reason.OBSOLETEDetailedReason)
}

// optional string uniqueId = 3;
inline bool OBSOLETE_Reason::_internal_has_uniqueid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool OBSOLETE_Reason::has_uniqueid() const {
  return _internal_has_uniqueid();
}
inline void OBSOLETE_Reason::clear_uniqueid() {
  _impl_.uniqueid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& OBSOLETE_Reason::uniqueid() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.OBSOLETE_Reason.uniqueId)
  return _internal_uniqueid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OBSOLETE_Reason::set_uniqueid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.uniqueid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.OBSOLETE_Reason.uniqueId)
}
inline std::string* OBSOLETE_Reason::mutable_uniqueid() {
  std::string* _s = _internal_mutable_uniqueid();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.OBSOLETE_Reason.uniqueId)
  return _s;
}
inline const std::string& OBSOLETE_Reason::_internal_uniqueid() const {
  return _impl_.uniqueid_.Get();
}
inline void OBSOLETE_Reason::_internal_set_uniqueid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.uniqueid_.Set(value, GetArenaForAllocation());
}
inline std::string* OBSOLETE_Reason::_internal_mutable_uniqueid() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.uniqueid_.Mutable(GetArenaForAllocation());
}
inline std::string* OBSOLETE_Reason::release_uniqueid() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.OBSOLETE_Reason.uniqueId)
  if (!_internal_has_uniqueid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.uniqueid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uniqueid_.IsDefault()) {
    _impl_.uniqueid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OBSOLETE_Reason::set_allocated_uniqueid(std::string* uniqueid) {
  if (uniqueid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.uniqueid_.SetAllocated(uniqueid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uniqueid_.IsDefault()) {
    _impl_.uniqueid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.OBSOLETE_Reason.uniqueId)
}

// -------------------------------------------------------------------

// VoucherInfo

// optional .playapi.proto.finsky.document.DocV2 doc = 1;
inline bool VoucherInfo::_internal_has_doc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.doc_ != nullptr);
  return value;
}
inline bool VoucherInfo::has_doc() const {
  return _internal_has_doc();
}
inline void VoucherInfo::clear_doc() {
  if (_impl_.doc_ != nullptr) _impl_.doc_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::playapi::proto::finsky::document::DocV2& VoucherInfo::_internal_doc() const {
  const ::playapi::proto::finsky::document::DocV2* p = _impl_.doc_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::DocV2&>(
      ::playapi::proto::finsky::document::_DocV2_default_instance_);
}
inline const ::playapi::proto::finsky::document::DocV2& VoucherInfo::doc() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.VoucherInfo.doc)
  return _internal_doc();
}
inline void VoucherInfo::unsafe_arena_set_allocated_doc(
    ::playapi::proto::finsky::document::DocV2* doc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.doc_);
  }
  _impl_.doc_ = doc;
  if (doc) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.VoucherInfo.doc)
}
inline ::playapi::proto::finsky::document::DocV2* VoucherInfo::release_doc() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::playapi::proto::finsky::document::DocV2* temp = _impl_.doc_;
  _impl_.doc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::DocV2* VoucherInfo::unsafe_arena_release_doc() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.VoucherInfo.doc)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::playapi::proto::finsky::document::DocV2* temp = _impl_.doc_;
  _impl_.doc_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::DocV2* VoucherInfo::_internal_mutable_doc() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.doc_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::DocV2>(GetArenaForAllocation());
    _impl_.doc_ = p;
  }
  return _impl_.doc_;
}
inline ::playapi::proto::finsky::document::DocV2* VoucherInfo::mutable_doc() {
  ::playapi::proto::finsky::document::DocV2* _msg = _internal_mutable_doc();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.VoucherInfo.doc)
  return _msg;
}
inline void VoucherInfo::set_allocated_doc(::playapi::proto::finsky::document::DocV2* doc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.doc_;
  }
  if (doc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(doc);
    if (message_arena != submessage_arena) {
      doc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, doc, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.doc_ = doc;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.VoucherInfo.doc)
}

// repeated .playapi.proto.finsky.Offer offer = 2;
inline int VoucherInfo::_internal_offer_size() const {
  return _impl_.offer_.size();
}
inline int VoucherInfo::offer_size() const {
  return _internal_offer_size();
}
inline ::playapi::proto::finsky::Offer* VoucherInfo::mutable_offer(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.VoucherInfo.offer)
  return _impl_.offer_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Offer >*
VoucherInfo::mutable_offer() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.document.VoucherInfo.offer)
  return &_impl_.offer_;
}
inline const ::playapi::proto::finsky::Offer& VoucherInfo::_internal_offer(int index) const {
  return _impl_.offer_.Get(index);
}
inline const ::playapi::proto::finsky::Offer& VoucherInfo::offer(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.VoucherInfo.offer)
  return _internal_offer(index);
}
inline ::playapi::proto::finsky::Offer* VoucherInfo::_internal_add_offer() {
  return _impl_.offer_.Add();
}
inline ::playapi::proto::finsky::Offer* VoucherInfo::add_offer() {
  ::playapi::proto::finsky::Offer* _add = _internal_add_offer();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.VoucherInfo.offer)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Offer >&
VoucherInfo::offer() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.document.VoucherInfo.offer)
  return _impl_.offer_;
}

// -------------------------------------------------------------------

// VideoAnnotations

// optional bool bundle = 1;
inline bool VideoAnnotations::_internal_has_bundle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool VideoAnnotations::has_bundle() const {
  return _internal_has_bundle();
}
inline void VideoAnnotations::clear_bundle() {
  _impl_.bundle_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool VideoAnnotations::_internal_bundle() const {
  return _impl_.bundle_;
}
inline bool VideoAnnotations::bundle() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.VideoAnnotations.bundle)
  return _internal_bundle();
}
inline void VideoAnnotations::_internal_set_bundle(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.bundle_ = value;
}
inline void VideoAnnotations::set_bundle(bool value) {
  _internal_set_bundle(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.VideoAnnotations.bundle)
}

// optional string bundleContentListUrl = 2;
inline bool VideoAnnotations::_internal_has_bundlecontentlisturl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VideoAnnotations::has_bundlecontentlisturl() const {
  return _internal_has_bundlecontentlisturl();
}
inline void VideoAnnotations::clear_bundlecontentlisturl() {
  _impl_.bundlecontentlisturl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VideoAnnotations::bundlecontentlisturl() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.VideoAnnotations.bundleContentListUrl)
  return _internal_bundlecontentlisturl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoAnnotations::set_bundlecontentlisturl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.bundlecontentlisturl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.VideoAnnotations.bundleContentListUrl)
}
inline std::string* VideoAnnotations::mutable_bundlecontentlisturl() {
  std::string* _s = _internal_mutable_bundlecontentlisturl();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.VideoAnnotations.bundleContentListUrl)
  return _s;
}
inline const std::string& VideoAnnotations::_internal_bundlecontentlisturl() const {
  return _impl_.bundlecontentlisturl_.Get();
}
inline void VideoAnnotations::_internal_set_bundlecontentlisturl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.bundlecontentlisturl_.Set(value, GetArenaForAllocation());
}
inline std::string* VideoAnnotations::_internal_mutable_bundlecontentlisturl() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.bundlecontentlisturl_.Mutable(GetArenaForAllocation());
}
inline std::string* VideoAnnotations::release_bundlecontentlisturl() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.VideoAnnotations.bundleContentListUrl)
  if (!_internal_has_bundlecontentlisturl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.bundlecontentlisturl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bundlecontentlisturl_.IsDefault()) {
    _impl_.bundlecontentlisturl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void VideoAnnotations::set_allocated_bundlecontentlisturl(std::string* bundlecontentlisturl) {
  if (bundlecontentlisturl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.bundlecontentlisturl_.SetAllocated(bundlecontentlisturl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bundlecontentlisturl_.IsDefault()) {
    _impl_.bundlecontentlisturl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.VideoAnnotations.bundleContentListUrl)
}

// optional string extrasContentListUrl = 3;
inline bool VideoAnnotations::_internal_has_extrascontentlisturl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VideoAnnotations::has_extrascontentlisturl() const {
  return _internal_has_extrascontentlisturl();
}
inline void VideoAnnotations::clear_extrascontentlisturl() {
  _impl_.extrascontentlisturl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& VideoAnnotations::extrascontentlisturl() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.VideoAnnotations.extrasContentListUrl)
  return _internal_extrascontentlisturl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoAnnotations::set_extrascontentlisturl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.extrascontentlisturl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.VideoAnnotations.extrasContentListUrl)
}
inline std::string* VideoAnnotations::mutable_extrascontentlisturl() {
  std::string* _s = _internal_mutable_extrascontentlisturl();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.VideoAnnotations.extrasContentListUrl)
  return _s;
}
inline const std::string& VideoAnnotations::_internal_extrascontentlisturl() const {
  return _impl_.extrascontentlisturl_.Get();
}
inline void VideoAnnotations::_internal_set_extrascontentlisturl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.extrascontentlisturl_.Set(value, GetArenaForAllocation());
}
inline std::string* VideoAnnotations::_internal_mutable_extrascontentlisturl() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.extrascontentlisturl_.Mutable(GetArenaForAllocation());
}
inline std::string* VideoAnnotations::release_extrascontentlisturl() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.VideoAnnotations.extrasContentListUrl)
  if (!_internal_has_extrascontentlisturl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.extrascontentlisturl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.extrascontentlisturl_.IsDefault()) {
    _impl_.extrascontentlisturl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void VideoAnnotations::set_allocated_extrascontentlisturl(std::string* extrascontentlisturl) {
  if (extrascontentlisturl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.extrascontentlisturl_.SetAllocated(extrascontentlisturl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.extrascontentlisturl_.IsDefault()) {
    _impl_.extrascontentlisturl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.VideoAnnotations.extrasContentListUrl)
}

// optional string alsoAvailableInListUrl = 4;
inline bool VideoAnnotations::_internal_has_alsoavailableinlisturl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool VideoAnnotations::has_alsoavailableinlisturl() const {
  return _internal_has_alsoavailableinlisturl();
}
inline void VideoAnnotations::clear_alsoavailableinlisturl() {
  _impl_.alsoavailableinlisturl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& VideoAnnotations::alsoavailableinlisturl() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.VideoAnnotations.alsoAvailableInListUrl)
  return _internal_alsoavailableinlisturl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoAnnotations::set_alsoavailableinlisturl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.alsoavailableinlisturl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.VideoAnnotations.alsoAvailableInListUrl)
}
inline std::string* VideoAnnotations::mutable_alsoavailableinlisturl() {
  std::string* _s = _internal_mutable_alsoavailableinlisturl();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.VideoAnnotations.alsoAvailableInListUrl)
  return _s;
}
inline const std::string& VideoAnnotations::_internal_alsoavailableinlisturl() const {
  return _impl_.alsoavailableinlisturl_.Get();
}
inline void VideoAnnotations::_internal_set_alsoavailableinlisturl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.alsoavailableinlisturl_.Set(value, GetArenaForAllocation());
}
inline std::string* VideoAnnotations::_internal_mutable_alsoavailableinlisturl() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.alsoavailableinlisturl_.Mutable(GetArenaForAllocation());
}
inline std::string* VideoAnnotations::release_alsoavailableinlisturl() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.VideoAnnotations.alsoAvailableInListUrl)
  if (!_internal_has_alsoavailableinlisturl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.alsoavailableinlisturl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.alsoavailableinlisturl_.IsDefault()) {
    _impl_.alsoavailableinlisturl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void VideoAnnotations::set_allocated_alsoavailableinlisturl(std::string* alsoavailableinlisturl) {
  if (alsoavailableinlisturl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.alsoavailableinlisturl_.SetAllocated(alsoavailableinlisturl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.alsoavailableinlisturl_.IsDefault()) {
    _impl_.alsoavailableinlisturl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.VideoAnnotations.alsoAvailableInListUrl)
}

// repeated .playapi.proto.finsky.Docid bundleDocid = 5;
inline int VideoAnnotations::_internal_bundledocid_size() const {
  return _impl_.bundledocid_.size();
}
inline int VideoAnnotations::bundledocid_size() const {
  return _internal_bundledocid_size();
}
inline ::playapi::proto::finsky::Docid* VideoAnnotations::mutable_bundledocid(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.VideoAnnotations.bundleDocid)
  return _impl_.bundledocid_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Docid >*
VideoAnnotations::mutable_bundledocid() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.document.VideoAnnotations.bundleDocid)
  return &_impl_.bundledocid_;
}
inline const ::playapi::proto::finsky::Docid& VideoAnnotations::_internal_bundledocid(int index) const {
  return _impl_.bundledocid_.Get(index);
}
inline const ::playapi::proto::finsky::Docid& VideoAnnotations::bundledocid(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.VideoAnnotations.bundleDocid)
  return _internal_bundledocid(index);
}
inline ::playapi::proto::finsky::Docid* VideoAnnotations::_internal_add_bundledocid() {
  return _impl_.bundledocid_.Add();
}
inline ::playapi::proto::finsky::Docid* VideoAnnotations::add_bundledocid() {
  ::playapi::proto::finsky::Docid* _add = _internal_add_bundledocid();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.VideoAnnotations.bundleDocid)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Docid >&
VideoAnnotations::bundledocid() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.document.VideoAnnotations.bundleDocid)
  return _impl_.bundledocid_;
}

// -------------------------------------------------------------------

// MySubscriptionDetails

// optional string subscriptionStatusHtml = 1;
inline bool MySubscriptionDetails::_internal_has_subscriptionstatushtml() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MySubscriptionDetails::has_subscriptionstatushtml() const {
  return _internal_has_subscriptionstatushtml();
}
inline void MySubscriptionDetails::clear_subscriptionstatushtml() {
  _impl_.subscriptionstatushtml_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MySubscriptionDetails::subscriptionstatushtml() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.MySubscriptionDetails.subscriptionStatusHtml)
  return _internal_subscriptionstatushtml();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MySubscriptionDetails::set_subscriptionstatushtml(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.subscriptionstatushtml_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.MySubscriptionDetails.subscriptionStatusHtml)
}
inline std::string* MySubscriptionDetails::mutable_subscriptionstatushtml() {
  std::string* _s = _internal_mutable_subscriptionstatushtml();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.MySubscriptionDetails.subscriptionStatusHtml)
  return _s;
}
inline const std::string& MySubscriptionDetails::_internal_subscriptionstatushtml() const {
  return _impl_.subscriptionstatushtml_.Get();
}
inline void MySubscriptionDetails::_internal_set_subscriptionstatushtml(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.subscriptionstatushtml_.Set(value, GetArenaForAllocation());
}
inline std::string* MySubscriptionDetails::_internal_mutable_subscriptionstatushtml() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.subscriptionstatushtml_.Mutable(GetArenaForAllocation());
}
inline std::string* MySubscriptionDetails::release_subscriptionstatushtml() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.MySubscriptionDetails.subscriptionStatusHtml)
  if (!_internal_has_subscriptionstatushtml()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.subscriptionstatushtml_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.subscriptionstatushtml_.IsDefault()) {
    _impl_.subscriptionstatushtml_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MySubscriptionDetails::set_allocated_subscriptionstatushtml(std::string* subscriptionstatushtml) {
  if (subscriptionstatushtml != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.subscriptionstatushtml_.SetAllocated(subscriptionstatushtml, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.subscriptionstatushtml_.IsDefault()) {
    _impl_.subscriptionstatushtml_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.MySubscriptionDetails.subscriptionStatusHtml)
}

// optional string title = 2;
inline bool MySubscriptionDetails::_internal_has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MySubscriptionDetails::has_title() const {
  return _internal_has_title();
}
inline void MySubscriptionDetails::clear_title() {
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MySubscriptionDetails::title() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.MySubscriptionDetails.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MySubscriptionDetails::set_title(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.MySubscriptionDetails.title)
}
inline std::string* MySubscriptionDetails::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.MySubscriptionDetails.title)
  return _s;
}
inline const std::string& MySubscriptionDetails::_internal_title() const {
  return _impl_.title_.Get();
}
inline void MySubscriptionDetails::_internal_set_title(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* MySubscriptionDetails::_internal_mutable_title() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* MySubscriptionDetails::release_title() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.MySubscriptionDetails.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.title_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MySubscriptionDetails::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.MySubscriptionDetails.title)
}

// optional string titleBylineHtml = 3;
inline bool MySubscriptionDetails::_internal_has_titlebylinehtml() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MySubscriptionDetails::has_titlebylinehtml() const {
  return _internal_has_titlebylinehtml();
}
inline void MySubscriptionDetails::clear_titlebylinehtml() {
  _impl_.titlebylinehtml_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& MySubscriptionDetails::titlebylinehtml() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.MySubscriptionDetails.titleBylineHtml)
  return _internal_titlebylinehtml();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MySubscriptionDetails::set_titlebylinehtml(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.titlebylinehtml_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.MySubscriptionDetails.titleBylineHtml)
}
inline std::string* MySubscriptionDetails::mutable_titlebylinehtml() {
  std::string* _s = _internal_mutable_titlebylinehtml();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.MySubscriptionDetails.titleBylineHtml)
  return _s;
}
inline const std::string& MySubscriptionDetails::_internal_titlebylinehtml() const {
  return _impl_.titlebylinehtml_.Get();
}
inline void MySubscriptionDetails::_internal_set_titlebylinehtml(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.titlebylinehtml_.Set(value, GetArenaForAllocation());
}
inline std::string* MySubscriptionDetails::_internal_mutable_titlebylinehtml() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.titlebylinehtml_.Mutable(GetArenaForAllocation());
}
inline std::string* MySubscriptionDetails::release_titlebylinehtml() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.MySubscriptionDetails.titleBylineHtml)
  if (!_internal_has_titlebylinehtml()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.titlebylinehtml_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.titlebylinehtml_.IsDefault()) {
    _impl_.titlebylinehtml_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MySubscriptionDetails::set_allocated_titlebylinehtml(std::string* titlebylinehtml) {
  if (titlebylinehtml != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.titlebylinehtml_.SetAllocated(titlebylinehtml, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.titlebylinehtml_.IsDefault()) {
    _impl_.titlebylinehtml_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.MySubscriptionDetails.titleBylineHtml)
}

// optional string formattedPrice = 4;
inline bool MySubscriptionDetails::_internal_has_formattedprice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MySubscriptionDetails::has_formattedprice() const {
  return _internal_has_formattedprice();
}
inline void MySubscriptionDetails::clear_formattedprice() {
  _impl_.formattedprice_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& MySubscriptionDetails::formattedprice() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.MySubscriptionDetails.formattedPrice)
  return _internal_formattedprice();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MySubscriptionDetails::set_formattedprice(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.formattedprice_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.MySubscriptionDetails.formattedPrice)
}
inline std::string* MySubscriptionDetails::mutable_formattedprice() {
  std::string* _s = _internal_mutable_formattedprice();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.MySubscriptionDetails.formattedPrice)
  return _s;
}
inline const std::string& MySubscriptionDetails::_internal_formattedprice() const {
  return _impl_.formattedprice_.Get();
}
inline void MySubscriptionDetails::_internal_set_formattedprice(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.formattedprice_.Set(value, GetArenaForAllocation());
}
inline std::string* MySubscriptionDetails::_internal_mutable_formattedprice() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.formattedprice_.Mutable(GetArenaForAllocation());
}
inline std::string* MySubscriptionDetails::release_formattedprice() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.MySubscriptionDetails.formattedPrice)
  if (!_internal_has_formattedprice()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.formattedprice_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.formattedprice_.IsDefault()) {
    _impl_.formattedprice_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MySubscriptionDetails::set_allocated_formattedprice(std::string* formattedprice) {
  if (formattedprice != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.formattedprice_.SetAllocated(formattedprice, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.formattedprice_.IsDefault()) {
    _impl_.formattedprice_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.MySubscriptionDetails.formattedPrice)
}

// optional string priceBylineHtml = 5;
inline bool MySubscriptionDetails::_internal_has_pricebylinehtml() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MySubscriptionDetails::has_pricebylinehtml() const {
  return _internal_has_pricebylinehtml();
}
inline void MySubscriptionDetails::clear_pricebylinehtml() {
  _impl_.pricebylinehtml_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& MySubscriptionDetails::pricebylinehtml() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.MySubscriptionDetails.priceBylineHtml)
  return _internal_pricebylinehtml();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MySubscriptionDetails::set_pricebylinehtml(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.pricebylinehtml_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.MySubscriptionDetails.priceBylineHtml)
}
inline std::string* MySubscriptionDetails::mutable_pricebylinehtml() {
  std::string* _s = _internal_mutable_pricebylinehtml();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.MySubscriptionDetails.priceBylineHtml)
  return _s;
}
inline const std::string& MySubscriptionDetails::_internal_pricebylinehtml() const {
  return _impl_.pricebylinehtml_.Get();
}
inline void MySubscriptionDetails::_internal_set_pricebylinehtml(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.pricebylinehtml_.Set(value, GetArenaForAllocation());
}
inline std::string* MySubscriptionDetails::_internal_mutable_pricebylinehtml() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.pricebylinehtml_.Mutable(GetArenaForAllocation());
}
inline std::string* MySubscriptionDetails::release_pricebylinehtml() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.MySubscriptionDetails.priceBylineHtml)
  if (!_internal_has_pricebylinehtml()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.pricebylinehtml_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pricebylinehtml_.IsDefault()) {
    _impl_.pricebylinehtml_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MySubscriptionDetails::set_allocated_pricebylinehtml(std::string* pricebylinehtml) {
  if (pricebylinehtml != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.pricebylinehtml_.SetAllocated(pricebylinehtml, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pricebylinehtml_.IsDefault()) {
    _impl_.pricebylinehtml_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.MySubscriptionDetails.priceBylineHtml)
}

// optional bool cancelSubscription = 6;
inline bool MySubscriptionDetails::_internal_has_cancelsubscription() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool MySubscriptionDetails::has_cancelsubscription() const {
  return _internal_has_cancelsubscription();
}
inline void MySubscriptionDetails::clear_cancelsubscription() {
  _impl_.cancelsubscription_ = false;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool MySubscriptionDetails::_internal_cancelsubscription() const {
  return _impl_.cancelsubscription_;
}
inline bool MySubscriptionDetails::cancelsubscription() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.MySubscriptionDetails.cancelSubscription)
  return _internal_cancelsubscription();
}
inline void MySubscriptionDetails::_internal_set_cancelsubscription(bool value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.cancelsubscription_ = value;
}
inline void MySubscriptionDetails::set_cancelsubscription(bool value) {
  _internal_set_cancelsubscription(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.MySubscriptionDetails.cancelSubscription)
}

// optional .playapi.proto.finsky.link.Link paymentDeclinedLearnMoreLink = 7;
inline bool MySubscriptionDetails::_internal_has_paymentdeclinedlearnmorelink() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.paymentdeclinedlearnmorelink_ != nullptr);
  return value;
}
inline bool MySubscriptionDetails::has_paymentdeclinedlearnmorelink() const {
  return _internal_has_paymentdeclinedlearnmorelink();
}
inline const ::playapi::proto::finsky::link::Link& MySubscriptionDetails::_internal_paymentdeclinedlearnmorelink() const {
  const ::playapi::proto::finsky::link::Link* p = _impl_.paymentdeclinedlearnmorelink_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::link::Link&>(
      ::playapi::proto::finsky::link::_Link_default_instance_);
}
inline const ::playapi::proto::finsky::link::Link& MySubscriptionDetails::paymentdeclinedlearnmorelink() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.MySubscriptionDetails.paymentDeclinedLearnMoreLink)
  return _internal_paymentdeclinedlearnmorelink();
}
inline void MySubscriptionDetails::unsafe_arena_set_allocated_paymentdeclinedlearnmorelink(
    ::playapi::proto::finsky::link::Link* paymentdeclinedlearnmorelink) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.paymentdeclinedlearnmorelink_);
  }
  _impl_.paymentdeclinedlearnmorelink_ = paymentdeclinedlearnmorelink;
  if (paymentdeclinedlearnmorelink) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.MySubscriptionDetails.paymentDeclinedLearnMoreLink)
}
inline ::playapi::proto::finsky::link::Link* MySubscriptionDetails::release_paymentdeclinedlearnmorelink() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::playapi::proto::finsky::link::Link* temp = _impl_.paymentdeclinedlearnmorelink_;
  _impl_.paymentdeclinedlearnmorelink_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::link::Link* MySubscriptionDetails::unsafe_arena_release_paymentdeclinedlearnmorelink() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.MySubscriptionDetails.paymentDeclinedLearnMoreLink)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::playapi::proto::finsky::link::Link* temp = _impl_.paymentdeclinedlearnmorelink_;
  _impl_.paymentdeclinedlearnmorelink_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::link::Link* MySubscriptionDetails::_internal_mutable_paymentdeclinedlearnmorelink() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.paymentdeclinedlearnmorelink_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::link::Link>(GetArenaForAllocation());
    _impl_.paymentdeclinedlearnmorelink_ = p;
  }
  return _impl_.paymentdeclinedlearnmorelink_;
}
inline ::playapi::proto::finsky::link::Link* MySubscriptionDetails::mutable_paymentdeclinedlearnmorelink() {
  ::playapi::proto::finsky::link::Link* _msg = _internal_mutable_paymentdeclinedlearnmorelink();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.MySubscriptionDetails.paymentDeclinedLearnMoreLink)
  return _msg;
}
inline void MySubscriptionDetails::set_allocated_paymentdeclinedlearnmorelink(::playapi::proto::finsky::link::Link* paymentdeclinedlearnmorelink) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.paymentdeclinedlearnmorelink_);
  }
  if (paymentdeclinedlearnmorelink) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(paymentdeclinedlearnmorelink));
    if (message_arena != submessage_arena) {
      paymentdeclinedlearnmorelink = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, paymentdeclinedlearnmorelink, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.paymentdeclinedlearnmorelink_ = paymentdeclinedlearnmorelink;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.MySubscriptionDetails.paymentDeclinedLearnMoreLink)
}

// optional bool inTrialPeriod = 8;
inline bool MySubscriptionDetails::_internal_has_intrialperiod() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool MySubscriptionDetails::has_intrialperiod() const {
  return _internal_has_intrialperiod();
}
inline void MySubscriptionDetails::clear_intrialperiod() {
  _impl_.intrialperiod_ = false;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline bool MySubscriptionDetails::_internal_intrialperiod() const {
  return _impl_.intrialperiod_;
}
inline bool MySubscriptionDetails::intrialperiod() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.MySubscriptionDetails.inTrialPeriod)
  return _internal_intrialperiod();
}
inline void MySubscriptionDetails::_internal_set_intrialperiod(bool value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.intrialperiod_ = value;
}
inline void MySubscriptionDetails::set_intrialperiod(bool value) {
  _internal_set_intrialperiod(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.MySubscriptionDetails.inTrialPeriod)
}

// optional .playapi.proto.finsky.Image titleBylineIcon = 9;
inline bool MySubscriptionDetails::_internal_has_titlebylineicon() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.titlebylineicon_ != nullptr);
  return value;
}
inline bool MySubscriptionDetails::has_titlebylineicon() const {
  return _internal_has_titlebylineicon();
}
inline const ::playapi::proto::finsky::Image& MySubscriptionDetails::_internal_titlebylineicon() const {
  const ::playapi::proto::finsky::Image* p = _impl_.titlebylineicon_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::Image&>(
      ::playapi::proto::finsky::_Image_default_instance_);
}
inline const ::playapi::proto::finsky::Image& MySubscriptionDetails::titlebylineicon() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.MySubscriptionDetails.titleBylineIcon)
  return _internal_titlebylineicon();
}
inline void MySubscriptionDetails::unsafe_arena_set_allocated_titlebylineicon(
    ::playapi::proto::finsky::Image* titlebylineicon) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.titlebylineicon_);
  }
  _impl_.titlebylineicon_ = titlebylineicon;
  if (titlebylineicon) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.MySubscriptionDetails.titleBylineIcon)
}
inline ::playapi::proto::finsky::Image* MySubscriptionDetails::release_titlebylineicon() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::playapi::proto::finsky::Image* temp = _impl_.titlebylineicon_;
  _impl_.titlebylineicon_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::Image* MySubscriptionDetails::unsafe_arena_release_titlebylineicon() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.MySubscriptionDetails.titleBylineIcon)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::playapi::proto::finsky::Image* temp = _impl_.titlebylineicon_;
  _impl_.titlebylineicon_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::Image* MySubscriptionDetails::_internal_mutable_titlebylineicon() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.titlebylineicon_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::Image>(GetArenaForAllocation());
    _impl_.titlebylineicon_ = p;
  }
  return _impl_.titlebylineicon_;
}
inline ::playapi::proto::finsky::Image* MySubscriptionDetails::mutable_titlebylineicon() {
  ::playapi::proto::finsky::Image* _msg = _internal_mutable_titlebylineicon();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.MySubscriptionDetails.titleBylineIcon)
  return _msg;
}
inline void MySubscriptionDetails::set_allocated_titlebylineicon(::playapi::proto::finsky::Image* titlebylineicon) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.titlebylineicon_);
  }
  if (titlebylineicon) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(titlebylineicon));
    if (message_arena != submessage_arena) {
      titlebylineicon = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, titlebylineicon, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.titlebylineicon_ = titlebylineicon;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.MySubscriptionDetails.titleBylineIcon)
}

// -------------------------------------------------------------------

// MyRewardDetails

// optional int64 expirationTimeMillis = 1;
inline bool MyRewardDetails::_internal_has_expirationtimemillis() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MyRewardDetails::has_expirationtimemillis() const {
  return _internal_has_expirationtimemillis();
}
inline void MyRewardDetails::clear_expirationtimemillis() {
  _impl_.expirationtimemillis_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int64_t MyRewardDetails::_internal_expirationtimemillis() const {
  return _impl_.expirationtimemillis_;
}
inline int64_t MyRewardDetails::expirationtimemillis() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.MyRewardDetails.expirationTimeMillis)
  return _internal_expirationtimemillis();
}
inline void MyRewardDetails::_internal_set_expirationtimemillis(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.expirationtimemillis_ = value;
}
inline void MyRewardDetails::set_expirationtimemillis(int64_t value) {
  _internal_set_expirationtimemillis(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.MyRewardDetails.expirationTimeMillis)
}

// optional string expirationDescription = 2;
inline bool MyRewardDetails::_internal_has_expirationdescription() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MyRewardDetails::has_expirationdescription() const {
  return _internal_has_expirationdescription();
}
inline void MyRewardDetails::clear_expirationdescription() {
  _impl_.expirationdescription_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MyRewardDetails::expirationdescription() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.MyRewardDetails.expirationDescription)
  return _internal_expirationdescription();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MyRewardDetails::set_expirationdescription(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.expirationdescription_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.MyRewardDetails.expirationDescription)
}
inline std::string* MyRewardDetails::mutable_expirationdescription() {
  std::string* _s = _internal_mutable_expirationdescription();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.MyRewardDetails.expirationDescription)
  return _s;
}
inline const std::string& MyRewardDetails::_internal_expirationdescription() const {
  return _impl_.expirationdescription_.Get();
}
inline void MyRewardDetails::_internal_set_expirationdescription(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.expirationdescription_.Set(value, GetArenaForAllocation());
}
inline std::string* MyRewardDetails::_internal_mutable_expirationdescription() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.expirationdescription_.Mutable(GetArenaForAllocation());
}
inline std::string* MyRewardDetails::release_expirationdescription() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.MyRewardDetails.expirationDescription)
  if (!_internal_has_expirationdescription()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.expirationdescription_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.expirationdescription_.IsDefault()) {
    _impl_.expirationdescription_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MyRewardDetails::set_allocated_expirationdescription(std::string* expirationdescription) {
  if (expirationdescription != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.expirationdescription_.SetAllocated(expirationdescription, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.expirationdescription_.IsDefault()) {
    _impl_.expirationdescription_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.MyRewardDetails.expirationDescription)
}

// optional string buttonLabel = 3;
inline bool MyRewardDetails::_internal_has_buttonlabel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MyRewardDetails::has_buttonlabel() const {
  return _internal_has_buttonlabel();
}
inline void MyRewardDetails::clear_buttonlabel() {
  _impl_.buttonlabel_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MyRewardDetails::buttonlabel() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.MyRewardDetails.buttonLabel)
  return _internal_buttonlabel();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MyRewardDetails::set_buttonlabel(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.buttonlabel_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.MyRewardDetails.buttonLabel)
}
inline std::string* MyRewardDetails::mutable_buttonlabel() {
  std::string* _s = _internal_mutable_buttonlabel();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.MyRewardDetails.buttonLabel)
  return _s;
}
inline const std::string& MyRewardDetails::_internal_buttonlabel() const {
  return _impl_.buttonlabel_.Get();
}
inline void MyRewardDetails::_internal_set_buttonlabel(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.buttonlabel_.Set(value, GetArenaForAllocation());
}
inline std::string* MyRewardDetails::_internal_mutable_buttonlabel() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.buttonlabel_.Mutable(GetArenaForAllocation());
}
inline std::string* MyRewardDetails::release_buttonlabel() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.MyRewardDetails.buttonLabel)
  if (!_internal_has_buttonlabel()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.buttonlabel_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.buttonlabel_.IsDefault()) {
    _impl_.buttonlabel_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MyRewardDetails::set_allocated_buttonlabel(std::string* buttonlabel) {
  if (buttonlabel != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.buttonlabel_.SetAllocated(buttonlabel, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.buttonlabel_.IsDefault()) {
    _impl_.buttonlabel_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.MyRewardDetails.buttonLabel)
}

// optional .playapi.proto.finsky.link.Link linkAction = 4;
inline bool MyRewardDetails::_internal_has_linkaction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.linkaction_ != nullptr);
  return value;
}
inline bool MyRewardDetails::has_linkaction() const {
  return _internal_has_linkaction();
}
inline const ::playapi::proto::finsky::link::Link& MyRewardDetails::_internal_linkaction() const {
  const ::playapi::proto::finsky::link::Link* p = _impl_.linkaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::link::Link&>(
      ::playapi::proto::finsky::link::_Link_default_instance_);
}
inline const ::playapi::proto::finsky::link::Link& MyRewardDetails::linkaction() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.MyRewardDetails.linkAction)
  return _internal_linkaction();
}
inline void MyRewardDetails::unsafe_arena_set_allocated_linkaction(
    ::playapi::proto::finsky::link::Link* linkaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.linkaction_);
  }
  _impl_.linkaction_ = linkaction;
  if (linkaction) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.MyRewardDetails.linkAction)
}
inline ::playapi::proto::finsky::link::Link* MyRewardDetails::release_linkaction() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::playapi::proto::finsky::link::Link* temp = _impl_.linkaction_;
  _impl_.linkaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::link::Link* MyRewardDetails::unsafe_arena_release_linkaction() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.MyRewardDetails.linkAction)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::playapi::proto::finsky::link::Link* temp = _impl_.linkaction_;
  _impl_.linkaction_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::link::Link* MyRewardDetails::_internal_mutable_linkaction() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.linkaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::link::Link>(GetArenaForAllocation());
    _impl_.linkaction_ = p;
  }
  return _impl_.linkaction_;
}
inline ::playapi::proto::finsky::link::Link* MyRewardDetails::mutable_linkaction() {
  ::playapi::proto::finsky::link::Link* _msg = _internal_mutable_linkaction();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.MyRewardDetails.linkAction)
  return _msg;
}
inline void MyRewardDetails::set_allocated_linkaction(::playapi::proto::finsky::link::Link* linkaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.linkaction_);
  }
  if (linkaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(linkaction));
    if (message_arena != submessage_arena) {
      linkaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linkaction, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.linkaction_ = linkaction;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.MyRewardDetails.linkAction)
}

// -------------------------------------------------------------------

// SelectedChild

// optional string docid = 1;
inline bool SelectedChild::_internal_has_docid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SelectedChild::has_docid() const {
  return _internal_has_docid();
}
inline void SelectedChild::clear_docid() {
  _impl_.docid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SelectedChild::docid() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.SelectedChild.docid)
  return _internal_docid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SelectedChild::set_docid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.docid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.SelectedChild.docid)
}
inline std::string* SelectedChild::mutable_docid() {
  std::string* _s = _internal_mutable_docid();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.SelectedChild.docid)
  return _s;
}
inline const std::string& SelectedChild::_internal_docid() const {
  return _impl_.docid_.Get();
}
inline void SelectedChild::_internal_set_docid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.docid_.Set(value, GetArenaForAllocation());
}
inline std::string* SelectedChild::_internal_mutable_docid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.docid_.Mutable(GetArenaForAllocation());
}
inline std::string* SelectedChild::release_docid() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.SelectedChild.docid)
  if (!_internal_has_docid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.docid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.docid_.IsDefault()) {
    _impl_.docid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SelectedChild::set_allocated_docid(std::string* docid) {
  if (docid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.docid_.SetAllocated(docid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.docid_.IsDefault()) {
    _impl_.docid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.SelectedChild.docid)
}

// optional .playapi.proto.finsky.document.SelectedChild selectedChild = 2;
inline bool SelectedChild::_internal_has_selectedchild() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.selectedchild_ != nullptr);
  return value;
}
inline bool SelectedChild::has_selectedchild() const {
  return _internal_has_selectedchild();
}
inline void SelectedChild::clear_selectedchild() {
  if (_impl_.selectedchild_ != nullptr) _impl_.selectedchild_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::playapi::proto::finsky::document::SelectedChild& SelectedChild::_internal_selectedchild() const {
  const ::playapi::proto::finsky::document::SelectedChild* p = _impl_.selectedchild_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::SelectedChild&>(
      ::playapi::proto::finsky::document::_SelectedChild_default_instance_);
}
inline const ::playapi::proto::finsky::document::SelectedChild& SelectedChild::selectedchild() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.SelectedChild.selectedChild)
  return _internal_selectedchild();
}
inline void SelectedChild::unsafe_arena_set_allocated_selectedchild(
    ::playapi::proto::finsky::document::SelectedChild* selectedchild) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.selectedchild_);
  }
  _impl_.selectedchild_ = selectedchild;
  if (selectedchild) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.SelectedChild.selectedChild)
}
inline ::playapi::proto::finsky::document::SelectedChild* SelectedChild::release_selectedchild() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::playapi::proto::finsky::document::SelectedChild* temp = _impl_.selectedchild_;
  _impl_.selectedchild_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::SelectedChild* SelectedChild::unsafe_arena_release_selectedchild() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.SelectedChild.selectedChild)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::playapi::proto::finsky::document::SelectedChild* temp = _impl_.selectedchild_;
  _impl_.selectedchild_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::SelectedChild* SelectedChild::_internal_mutable_selectedchild() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.selectedchild_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::SelectedChild>(GetArenaForAllocation());
    _impl_.selectedchild_ = p;
  }
  return _impl_.selectedchild_;
}
inline ::playapi::proto::finsky::document::SelectedChild* SelectedChild::mutable_selectedchild() {
  ::playapi::proto::finsky::document::SelectedChild* _msg = _internal_mutable_selectedchild();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.SelectedChild.selectedChild)
  return _msg;
}
inline void SelectedChild::set_allocated_selectedchild(::playapi::proto::finsky::document::SelectedChild* selectedchild) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.selectedchild_;
  }
  if (selectedchild) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(selectedchild);
    if (message_arena != submessage_arena) {
      selectedchild = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, selectedchild, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.selectedchild_ = selectedchild;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.SelectedChild.selectedChild)
}

// -------------------------------------------------------------------

// Snippet

// optional string snippetHtml = 1;
inline bool Snippet::_internal_has_snippethtml() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Snippet::has_snippethtml() const {
  return _internal_has_snippethtml();
}
inline void Snippet::clear_snippethtml() {
  _impl_.snippethtml_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Snippet::snippethtml() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Snippet.snippetHtml)
  return _internal_snippethtml();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Snippet::set_snippethtml(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.snippethtml_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.Snippet.snippetHtml)
}
inline std::string* Snippet::mutable_snippethtml() {
  std::string* _s = _internal_mutable_snippethtml();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Snippet.snippetHtml)
  return _s;
}
inline const std::string& Snippet::_internal_snippethtml() const {
  return _impl_.snippethtml_.Get();
}
inline void Snippet::_internal_set_snippethtml(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.snippethtml_.Set(value, GetArenaForAllocation());
}
inline std::string* Snippet::_internal_mutable_snippethtml() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.snippethtml_.Mutable(GetArenaForAllocation());
}
inline std::string* Snippet::release_snippethtml() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.Snippet.snippetHtml)
  if (!_internal_has_snippethtml()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.snippethtml_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.snippethtml_.IsDefault()) {
    _impl_.snippethtml_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Snippet::set_allocated_snippethtml(std::string* snippethtml) {
  if (snippethtml != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.snippethtml_.SetAllocated(snippethtml, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.snippethtml_.IsDefault()) {
    _impl_.snippethtml_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.Snippet.snippetHtml)
}

// -------------------------------------------------------------------

// ProductDetails

// optional string title = 1;
inline bool ProductDetails::_internal_has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ProductDetails::has_title() const {
  return _internal_has_title();
}
inline void ProductDetails::clear_title() {
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ProductDetails::title() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.ProductDetails.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProductDetails::set_title(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.ProductDetails.title)
}
inline std::string* ProductDetails::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.ProductDetails.title)
  return _s;
}
inline const std::string& ProductDetails::_internal_title() const {
  return _impl_.title_.Get();
}
inline void ProductDetails::_internal_set_title(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* ProductDetails::_internal_mutable_title() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* ProductDetails::release_title() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.ProductDetails.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.title_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ProductDetails::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.ProductDetails.title)
}

// repeated .playapi.proto.finsky.document.ProductDetailsSection section = 2;
inline int ProductDetails::_internal_section_size() const {
  return _impl_.section_.size();
}
inline int ProductDetails::section_size() const {
  return _internal_section_size();
}
inline void ProductDetails::clear_section() {
  _impl_.section_.Clear();
}
inline ::playapi::proto::finsky::document::ProductDetailsSection* ProductDetails::mutable_section(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.ProductDetails.section)
  return _impl_.section_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::ProductDetailsSection >*
ProductDetails::mutable_section() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.document.ProductDetails.section)
  return &_impl_.section_;
}
inline const ::playapi::proto::finsky::document::ProductDetailsSection& ProductDetails::_internal_section(int index) const {
  return _impl_.section_.Get(index);
}
inline const ::playapi::proto::finsky::document::ProductDetailsSection& ProductDetails::section(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.ProductDetails.section)
  return _internal_section(index);
}
inline ::playapi::proto::finsky::document::ProductDetailsSection* ProductDetails::_internal_add_section() {
  return _impl_.section_.Add();
}
inline ::playapi::proto::finsky::document::ProductDetailsSection* ProductDetails::add_section() {
  ::playapi::proto::finsky::document::ProductDetailsSection* _add = _internal_add_section();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.ProductDetails.section)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::ProductDetailsSection >&
ProductDetails::section() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.document.ProductDetails.section)
  return _impl_.section_;
}

// -------------------------------------------------------------------

// ProductDetailsSection

// optional string title = 1;
inline bool ProductDetailsSection::_internal_has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ProductDetailsSection::has_title() const {
  return _internal_has_title();
}
inline void ProductDetailsSection::clear_title() {
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ProductDetailsSection::title() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.ProductDetailsSection.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProductDetailsSection::set_title(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.ProductDetailsSection.title)
}
inline std::string* ProductDetailsSection::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.ProductDetailsSection.title)
  return _s;
}
inline const std::string& ProductDetailsSection::_internal_title() const {
  return _impl_.title_.Get();
}
inline void ProductDetailsSection::_internal_set_title(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* ProductDetailsSection::_internal_mutable_title() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* ProductDetailsSection::release_title() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.ProductDetailsSection.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.title_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ProductDetailsSection::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.ProductDetailsSection.title)
}

// repeated .playapi.proto.finsky.document.ProductDetailsDescription description = 3;
inline int ProductDetailsSection::_internal_description_size() const {
  return _impl_.description_.size();
}
inline int ProductDetailsSection::description_size() const {
  return _internal_description_size();
}
inline void ProductDetailsSection::clear_description() {
  _impl_.description_.Clear();
}
inline ::playapi::proto::finsky::document::ProductDetailsDescription* ProductDetailsSection::mutable_description(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.ProductDetailsSection.description)
  return _impl_.description_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::ProductDetailsDescription >*
ProductDetailsSection::mutable_description() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.document.ProductDetailsSection.description)
  return &_impl_.description_;
}
inline const ::playapi::proto::finsky::document::ProductDetailsDescription& ProductDetailsSection::_internal_description(int index) const {
  return _impl_.description_.Get(index);
}
inline const ::playapi::proto::finsky::document::ProductDetailsDescription& ProductDetailsSection::description(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.ProductDetailsSection.description)
  return _internal_description(index);
}
inline ::playapi::proto::finsky::document::ProductDetailsDescription* ProductDetailsSection::_internal_add_description() {
  return _impl_.description_.Add();
}
inline ::playapi::proto::finsky::document::ProductDetailsDescription* ProductDetailsSection::add_description() {
  ::playapi::proto::finsky::document::ProductDetailsDescription* _add = _internal_add_description();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.ProductDetailsSection.description)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::ProductDetailsDescription >&
ProductDetailsSection::description() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.document.ProductDetailsSection.description)
  return _impl_.description_;
}

// -------------------------------------------------------------------

// ProductDetailsDescription

// optional .playapi.proto.finsky.Image image = 1;
inline bool ProductDetailsDescription::_internal_has_image() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.image_ != nullptr);
  return value;
}
inline bool ProductDetailsDescription::has_image() const {
  return _internal_has_image();
}
inline const ::playapi::proto::finsky::Image& ProductDetailsDescription::_internal_image() const {
  const ::playapi::proto::finsky::Image* p = _impl_.image_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::Image&>(
      ::playapi::proto::finsky::_Image_default_instance_);
}
inline const ::playapi::proto::finsky::Image& ProductDetailsDescription::image() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.ProductDetailsDescription.image)
  return _internal_image();
}
inline void ProductDetailsDescription::unsafe_arena_set_allocated_image(
    ::playapi::proto::finsky::Image* image) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.image_);
  }
  _impl_.image_ = image;
  if (image) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.ProductDetailsDescription.image)
}
inline ::playapi::proto::finsky::Image* ProductDetailsDescription::release_image() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::playapi::proto::finsky::Image* temp = _impl_.image_;
  _impl_.image_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::Image* ProductDetailsDescription::unsafe_arena_release_image() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.ProductDetailsDescription.image)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::playapi::proto::finsky::Image* temp = _impl_.image_;
  _impl_.image_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::Image* ProductDetailsDescription::_internal_mutable_image() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.image_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::Image>(GetArenaForAllocation());
    _impl_.image_ = p;
  }
  return _impl_.image_;
}
inline ::playapi::proto::finsky::Image* ProductDetailsDescription::mutable_image() {
  ::playapi::proto::finsky::Image* _msg = _internal_mutable_image();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.ProductDetailsDescription.image)
  return _msg;
}
inline void ProductDetailsDescription::set_allocated_image(::playapi::proto::finsky::Image* image) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.image_);
  }
  if (image) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(image));
    if (message_arena != submessage_arena) {
      image = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, image, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.image_ = image;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.ProductDetailsDescription.image)
}

// optional string description = 2;
inline bool ProductDetailsDescription::_internal_has_description() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ProductDetailsDescription::has_description() const {
  return _internal_has_description();
}
inline void ProductDetailsDescription::clear_description() {
  _impl_.description_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ProductDetailsDescription::description() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.ProductDetailsDescription.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProductDetailsDescription::set_description(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.ProductDetailsDescription.description)
}
inline std::string* ProductDetailsDescription::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.ProductDetailsDescription.description)
  return _s;
}
inline const std::string& ProductDetailsDescription::_internal_description() const {
  return _impl_.description_.Get();
}
inline void ProductDetailsDescription::_internal_set_description(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* ProductDetailsDescription::_internal_mutable_description() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* ProductDetailsDescription::release_description() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.ProductDetailsDescription.description)
  if (!_internal_has_description()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.description_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ProductDetailsDescription::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.ProductDetailsDescription.description)
}

// -------------------------------------------------------------------

// PromotedDoc

// optional string title = 1;
inline bool PromotedDoc::_internal_has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PromotedDoc::has_title() const {
  return _internal_has_title();
}
inline void PromotedDoc::clear_title() {
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PromotedDoc::title() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.PromotedDoc.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PromotedDoc::set_title(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.PromotedDoc.title)
}
inline std::string* PromotedDoc::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.PromotedDoc.title)
  return _s;
}
inline const std::string& PromotedDoc::_internal_title() const {
  return _impl_.title_.Get();
}
inline void PromotedDoc::_internal_set_title(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* PromotedDoc::_internal_mutable_title() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* PromotedDoc::release_title() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.PromotedDoc.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.title_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PromotedDoc::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.PromotedDoc.title)
}

// optional string subtitle = 2;
inline bool PromotedDoc::_internal_has_subtitle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PromotedDoc::has_subtitle() const {
  return _internal_has_subtitle();
}
inline void PromotedDoc::clear_subtitle() {
  _impl_.subtitle_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PromotedDoc::subtitle() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.PromotedDoc.subtitle)
  return _internal_subtitle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PromotedDoc::set_subtitle(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.subtitle_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.PromotedDoc.subtitle)
}
inline std::string* PromotedDoc::mutable_subtitle() {
  std::string* _s = _internal_mutable_subtitle();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.PromotedDoc.subtitle)
  return _s;
}
inline const std::string& PromotedDoc::_internal_subtitle() const {
  return _impl_.subtitle_.Get();
}
inline void PromotedDoc::_internal_set_subtitle(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.subtitle_.Set(value, GetArenaForAllocation());
}
inline std::string* PromotedDoc::_internal_mutable_subtitle() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.subtitle_.Mutable(GetArenaForAllocation());
}
inline std::string* PromotedDoc::release_subtitle() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.PromotedDoc.subtitle)
  if (!_internal_has_subtitle()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.subtitle_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.subtitle_.IsDefault()) {
    _impl_.subtitle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PromotedDoc::set_allocated_subtitle(std::string* subtitle) {
  if (subtitle != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.subtitle_.SetAllocated(subtitle, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.subtitle_.IsDefault()) {
    _impl_.subtitle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.PromotedDoc.subtitle)
}

// repeated .playapi.proto.finsky.Image image = 3;
inline int PromotedDoc::_internal_image_size() const {
  return _impl_.image_.size();
}
inline int PromotedDoc::image_size() const {
  return _internal_image_size();
}
inline ::playapi::proto::finsky::Image* PromotedDoc::mutable_image(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.PromotedDoc.image)
  return _impl_.image_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Image >*
PromotedDoc::mutable_image() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.document.PromotedDoc.image)
  return &_impl_.image_;
}
inline const ::playapi::proto::finsky::Image& PromotedDoc::_internal_image(int index) const {
  return _impl_.image_.Get(index);
}
inline const ::playapi::proto::finsky::Image& PromotedDoc::image(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.PromotedDoc.image)
  return _internal_image(index);
}
inline ::playapi::proto::finsky::Image* PromotedDoc::_internal_add_image() {
  return _impl_.image_.Add();
}
inline ::playapi::proto::finsky::Image* PromotedDoc::add_image() {
  ::playapi::proto::finsky::Image* _add = _internal_add_image();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.PromotedDoc.image)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::Image >&
PromotedDoc::image() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.document.PromotedDoc.image)
  return _impl_.image_;
}

// optional string descriptionHtml = 4;
inline bool PromotedDoc::_internal_has_descriptionhtml() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PromotedDoc::has_descriptionhtml() const {
  return _internal_has_descriptionhtml();
}
inline void PromotedDoc::clear_descriptionhtml() {
  _impl_.descriptionhtml_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& PromotedDoc::descriptionhtml() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.PromotedDoc.descriptionHtml)
  return _internal_descriptionhtml();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PromotedDoc::set_descriptionhtml(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.descriptionhtml_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.PromotedDoc.descriptionHtml)
}
inline std::string* PromotedDoc::mutable_descriptionhtml() {
  std::string* _s = _internal_mutable_descriptionhtml();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.PromotedDoc.descriptionHtml)
  return _s;
}
inline const std::string& PromotedDoc::_internal_descriptionhtml() const {
  return _impl_.descriptionhtml_.Get();
}
inline void PromotedDoc::_internal_set_descriptionhtml(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.descriptionhtml_.Set(value, GetArenaForAllocation());
}
inline std::string* PromotedDoc::_internal_mutable_descriptionhtml() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.descriptionhtml_.Mutable(GetArenaForAllocation());
}
inline std::string* PromotedDoc::release_descriptionhtml() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.PromotedDoc.descriptionHtml)
  if (!_internal_has_descriptionhtml()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.descriptionhtml_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.descriptionhtml_.IsDefault()) {
    _impl_.descriptionhtml_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PromotedDoc::set_allocated_descriptionhtml(std::string* descriptionhtml) {
  if (descriptionhtml != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.descriptionhtml_.SetAllocated(descriptionhtml, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.descriptionhtml_.IsDefault()) {
    _impl_.descriptionhtml_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.PromotedDoc.descriptionHtml)
}

// optional string detailsUrl = 5;
inline bool PromotedDoc::_internal_has_detailsurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PromotedDoc::has_detailsurl() const {
  return _internal_has_detailsurl();
}
inline void PromotedDoc::clear_detailsurl() {
  _impl_.detailsurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& PromotedDoc::detailsurl() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.PromotedDoc.detailsUrl)
  return _internal_detailsurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PromotedDoc::set_detailsurl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.detailsurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.PromotedDoc.detailsUrl)
}
inline std::string* PromotedDoc::mutable_detailsurl() {
  std::string* _s = _internal_mutable_detailsurl();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.PromotedDoc.detailsUrl)
  return _s;
}
inline const std::string& PromotedDoc::_internal_detailsurl() const {
  return _impl_.detailsurl_.Get();
}
inline void PromotedDoc::_internal_set_detailsurl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.detailsurl_.Set(value, GetArenaForAllocation());
}
inline std::string* PromotedDoc::_internal_mutable_detailsurl() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.detailsurl_.Mutable(GetArenaForAllocation());
}
inline std::string* PromotedDoc::release_detailsurl() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.PromotedDoc.detailsUrl)
  if (!_internal_has_detailsurl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.detailsurl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.detailsurl_.IsDefault()) {
    _impl_.detailsurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PromotedDoc::set_allocated_detailsurl(std::string* detailsurl) {
  if (detailsurl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.detailsurl_.SetAllocated(detailsurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.detailsurl_.IsDefault()) {
    _impl_.detailsurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.PromotedDoc.detailsUrl)
}

// -------------------------------------------------------------------

// DocumentDetails

// optional .playapi.proto.finsky.document.AppDetails appDetails = 1;
inline bool DocumentDetails::_internal_has_appdetails() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.appdetails_ != nullptr);
  return value;
}
inline bool DocumentDetails::has_appdetails() const {
  return _internal_has_appdetails();
}
inline void DocumentDetails::clear_appdetails() {
  if (_impl_.appdetails_ != nullptr) _impl_.appdetails_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::playapi::proto::finsky::document::AppDetails& DocumentDetails::_internal_appdetails() const {
  const ::playapi::proto::finsky::document::AppDetails* p = _impl_.appdetails_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::AppDetails&>(
      ::playapi::proto::finsky::document::_AppDetails_default_instance_);
}
inline const ::playapi::proto::finsky::document::AppDetails& DocumentDetails::appdetails() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.DocumentDetails.appDetails)
  return _internal_appdetails();
}
inline void DocumentDetails::unsafe_arena_set_allocated_appdetails(
    ::playapi::proto::finsky::document::AppDetails* appdetails) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.appdetails_);
  }
  _impl_.appdetails_ = appdetails;
  if (appdetails) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.DocumentDetails.appDetails)
}
inline ::playapi::proto::finsky::document::AppDetails* DocumentDetails::release_appdetails() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::playapi::proto::finsky::document::AppDetails* temp = _impl_.appdetails_;
  _impl_.appdetails_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::AppDetails* DocumentDetails::unsafe_arena_release_appdetails() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.DocumentDetails.appDetails)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::playapi::proto::finsky::document::AppDetails* temp = _impl_.appdetails_;
  _impl_.appdetails_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::AppDetails* DocumentDetails::_internal_mutable_appdetails() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.appdetails_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::AppDetails>(GetArenaForAllocation());
    _impl_.appdetails_ = p;
  }
  return _impl_.appdetails_;
}
inline ::playapi::proto::finsky::document::AppDetails* DocumentDetails::mutable_appdetails() {
  ::playapi::proto::finsky::document::AppDetails* _msg = _internal_mutable_appdetails();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.DocumentDetails.appDetails)
  return _msg;
}
inline void DocumentDetails::set_allocated_appdetails(::playapi::proto::finsky::document::AppDetails* appdetails) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.appdetails_;
  }
  if (appdetails) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(appdetails);
    if (message_arena != submessage_arena) {
      appdetails = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, appdetails, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.appdetails_ = appdetails;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.DocumentDetails.appDetails)
}

// optional .playapi.proto.finsky.document.AlbumDetails albumDetails = 2;
inline bool DocumentDetails::_internal_has_albumdetails() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.albumdetails_ != nullptr);
  return value;
}
inline bool DocumentDetails::has_albumdetails() const {
  return _internal_has_albumdetails();
}
inline void DocumentDetails::clear_albumdetails() {
  if (_impl_.albumdetails_ != nullptr) _impl_.albumdetails_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::playapi::proto::finsky::document::AlbumDetails& DocumentDetails::_internal_albumdetails() const {
  const ::playapi::proto::finsky::document::AlbumDetails* p = _impl_.albumdetails_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::AlbumDetails&>(
      ::playapi::proto::finsky::document::_AlbumDetails_default_instance_);
}
inline const ::playapi::proto::finsky::document::AlbumDetails& DocumentDetails::albumdetails() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.DocumentDetails.albumDetails)
  return _internal_albumdetails();
}
inline void DocumentDetails::unsafe_arena_set_allocated_albumdetails(
    ::playapi::proto::finsky::document::AlbumDetails* albumdetails) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.albumdetails_);
  }
  _impl_.albumdetails_ = albumdetails;
  if (albumdetails) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.DocumentDetails.albumDetails)
}
inline ::playapi::proto::finsky::document::AlbumDetails* DocumentDetails::release_albumdetails() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::playapi::proto::finsky::document::AlbumDetails* temp = _impl_.albumdetails_;
  _impl_.albumdetails_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::AlbumDetails* DocumentDetails::unsafe_arena_release_albumdetails() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.DocumentDetails.albumDetails)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::playapi::proto::finsky::document::AlbumDetails* temp = _impl_.albumdetails_;
  _impl_.albumdetails_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::AlbumDetails* DocumentDetails::_internal_mutable_albumdetails() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.albumdetails_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::AlbumDetails>(GetArenaForAllocation());
    _impl_.albumdetails_ = p;
  }
  return _impl_.albumdetails_;
}
inline ::playapi::proto::finsky::document::AlbumDetails* DocumentDetails::mutable_albumdetails() {
  ::playapi::proto::finsky::document::AlbumDetails* _msg = _internal_mutable_albumdetails();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.DocumentDetails.albumDetails)
  return _msg;
}
inline void DocumentDetails::set_allocated_albumdetails(::playapi::proto::finsky::document::AlbumDetails* albumdetails) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.albumdetails_;
  }
  if (albumdetails) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(albumdetails);
    if (message_arena != submessage_arena) {
      albumdetails = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, albumdetails, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.albumdetails_ = albumdetails;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.DocumentDetails.albumDetails)
}

// optional .playapi.proto.finsky.document.ArtistDetails artistDetails = 3;
inline bool DocumentDetails::_internal_has_artistdetails() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.artistdetails_ != nullptr);
  return value;
}
inline bool DocumentDetails::has_artistdetails() const {
  return _internal_has_artistdetails();
}
inline void DocumentDetails::clear_artistdetails() {
  if (_impl_.artistdetails_ != nullptr) _impl_.artistdetails_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::playapi::proto::finsky::document::ArtistDetails& DocumentDetails::_internal_artistdetails() const {
  const ::playapi::proto::finsky::document::ArtistDetails* p = _impl_.artistdetails_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::ArtistDetails&>(
      ::playapi::proto::finsky::document::_ArtistDetails_default_instance_);
}
inline const ::playapi::proto::finsky::document::ArtistDetails& DocumentDetails::artistdetails() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.DocumentDetails.artistDetails)
  return _internal_artistdetails();
}
inline void DocumentDetails::unsafe_arena_set_allocated_artistdetails(
    ::playapi::proto::finsky::document::ArtistDetails* artistdetails) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.artistdetails_);
  }
  _impl_.artistdetails_ = artistdetails;
  if (artistdetails) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.DocumentDetails.artistDetails)
}
inline ::playapi::proto::finsky::document::ArtistDetails* DocumentDetails::release_artistdetails() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::playapi::proto::finsky::document::ArtistDetails* temp = _impl_.artistdetails_;
  _impl_.artistdetails_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::ArtistDetails* DocumentDetails::unsafe_arena_release_artistdetails() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.DocumentDetails.artistDetails)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::playapi::proto::finsky::document::ArtistDetails* temp = _impl_.artistdetails_;
  _impl_.artistdetails_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::ArtistDetails* DocumentDetails::_internal_mutable_artistdetails() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.artistdetails_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::ArtistDetails>(GetArenaForAllocation());
    _impl_.artistdetails_ = p;
  }
  return _impl_.artistdetails_;
}
inline ::playapi::proto::finsky::document::ArtistDetails* DocumentDetails::mutable_artistdetails() {
  ::playapi::proto::finsky::document::ArtistDetails* _msg = _internal_mutable_artistdetails();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.DocumentDetails.artistDetails)
  return _msg;
}
inline void DocumentDetails::set_allocated_artistdetails(::playapi::proto::finsky::document::ArtistDetails* artistdetails) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.artistdetails_;
  }
  if (artistdetails) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(artistdetails);
    if (message_arena != submessage_arena) {
      artistdetails = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, artistdetails, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.artistdetails_ = artistdetails;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.DocumentDetails.artistDetails)
}

// optional .playapi.proto.finsky.document.SongDetails songDetails = 4;
inline bool DocumentDetails::_internal_has_songdetails() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.songdetails_ != nullptr);
  return value;
}
inline bool DocumentDetails::has_songdetails() const {
  return _internal_has_songdetails();
}
inline void DocumentDetails::clear_songdetails() {
  if (_impl_.songdetails_ != nullptr) _impl_.songdetails_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::playapi::proto::finsky::document::SongDetails& DocumentDetails::_internal_songdetails() const {
  const ::playapi::proto::finsky::document::SongDetails* p = _impl_.songdetails_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::SongDetails&>(
      ::playapi::proto::finsky::document::_SongDetails_default_instance_);
}
inline const ::playapi::proto::finsky::document::SongDetails& DocumentDetails::songdetails() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.DocumentDetails.songDetails)
  return _internal_songdetails();
}
inline void DocumentDetails::unsafe_arena_set_allocated_songdetails(
    ::playapi::proto::finsky::document::SongDetails* songdetails) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.songdetails_);
  }
  _impl_.songdetails_ = songdetails;
  if (songdetails) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.DocumentDetails.songDetails)
}
inline ::playapi::proto::finsky::document::SongDetails* DocumentDetails::release_songdetails() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::playapi::proto::finsky::document::SongDetails* temp = _impl_.songdetails_;
  _impl_.songdetails_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::SongDetails* DocumentDetails::unsafe_arena_release_songdetails() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.DocumentDetails.songDetails)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::playapi::proto::finsky::document::SongDetails* temp = _impl_.songdetails_;
  _impl_.songdetails_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::SongDetails* DocumentDetails::_internal_mutable_songdetails() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.songdetails_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::SongDetails>(GetArenaForAllocation());
    _impl_.songdetails_ = p;
  }
  return _impl_.songdetails_;
}
inline ::playapi::proto::finsky::document::SongDetails* DocumentDetails::mutable_songdetails() {
  ::playapi::proto::finsky::document::SongDetails* _msg = _internal_mutable_songdetails();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.DocumentDetails.songDetails)
  return _msg;
}
inline void DocumentDetails::set_allocated_songdetails(::playapi::proto::finsky::document::SongDetails* songdetails) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.songdetails_;
  }
  if (songdetails) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(songdetails);
    if (message_arena != submessage_arena) {
      songdetails = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, songdetails, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.songdetails_ = songdetails;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.DocumentDetails.songDetails)
}

// optional .playapi.proto.finsky.document.BookDetails bookDetails = 5;
inline bool DocumentDetails::_internal_has_bookdetails() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.bookdetails_ != nullptr);
  return value;
}
inline bool DocumentDetails::has_bookdetails() const {
  return _internal_has_bookdetails();
}
inline void DocumentDetails::clear_bookdetails() {
  if (_impl_.bookdetails_ != nullptr) _impl_.bookdetails_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::playapi::proto::finsky::document::BookDetails& DocumentDetails::_internal_bookdetails() const {
  const ::playapi::proto::finsky::document::BookDetails* p = _impl_.bookdetails_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::BookDetails&>(
      ::playapi::proto::finsky::document::_BookDetails_default_instance_);
}
inline const ::playapi::proto::finsky::document::BookDetails& DocumentDetails::bookdetails() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.DocumentDetails.bookDetails)
  return _internal_bookdetails();
}
inline void DocumentDetails::unsafe_arena_set_allocated_bookdetails(
    ::playapi::proto::finsky::document::BookDetails* bookdetails) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bookdetails_);
  }
  _impl_.bookdetails_ = bookdetails;
  if (bookdetails) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.DocumentDetails.bookDetails)
}
inline ::playapi::proto::finsky::document::BookDetails* DocumentDetails::release_bookdetails() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::playapi::proto::finsky::document::BookDetails* temp = _impl_.bookdetails_;
  _impl_.bookdetails_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::BookDetails* DocumentDetails::unsafe_arena_release_bookdetails() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.DocumentDetails.bookDetails)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::playapi::proto::finsky::document::BookDetails* temp = _impl_.bookdetails_;
  _impl_.bookdetails_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::BookDetails* DocumentDetails::_internal_mutable_bookdetails() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.bookdetails_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::BookDetails>(GetArenaForAllocation());
    _impl_.bookdetails_ = p;
  }
  return _impl_.bookdetails_;
}
inline ::playapi::proto::finsky::document::BookDetails* DocumentDetails::mutable_bookdetails() {
  ::playapi::proto::finsky::document::BookDetails* _msg = _internal_mutable_bookdetails();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.DocumentDetails.bookDetails)
  return _msg;
}
inline void DocumentDetails::set_allocated_bookdetails(::playapi::proto::finsky::document::BookDetails* bookdetails) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.bookdetails_;
  }
  if (bookdetails) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bookdetails);
    if (message_arena != submessage_arena) {
      bookdetails = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bookdetails, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.bookdetails_ = bookdetails;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.DocumentDetails.bookDetails)
}

// optional .playapi.proto.finsky.document.VideoDetails videoDetails = 6;
inline bool DocumentDetails::_internal_has_videodetails() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.videodetails_ != nullptr);
  return value;
}
inline bool DocumentDetails::has_videodetails() const {
  return _internal_has_videodetails();
}
inline void DocumentDetails::clear_videodetails() {
  if (_impl_.videodetails_ != nullptr) _impl_.videodetails_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::playapi::proto::finsky::document::VideoDetails& DocumentDetails::_internal_videodetails() const {
  const ::playapi::proto::finsky::document::VideoDetails* p = _impl_.videodetails_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::VideoDetails&>(
      ::playapi::proto::finsky::document::_VideoDetails_default_instance_);
}
inline const ::playapi::proto::finsky::document::VideoDetails& DocumentDetails::videodetails() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.DocumentDetails.videoDetails)
  return _internal_videodetails();
}
inline void DocumentDetails::unsafe_arena_set_allocated_videodetails(
    ::playapi::proto::finsky::document::VideoDetails* videodetails) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.videodetails_);
  }
  _impl_.videodetails_ = videodetails;
  if (videodetails) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.DocumentDetails.videoDetails)
}
inline ::playapi::proto::finsky::document::VideoDetails* DocumentDetails::release_videodetails() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::playapi::proto::finsky::document::VideoDetails* temp = _impl_.videodetails_;
  _impl_.videodetails_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::VideoDetails* DocumentDetails::unsafe_arena_release_videodetails() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.DocumentDetails.videoDetails)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::playapi::proto::finsky::document::VideoDetails* temp = _impl_.videodetails_;
  _impl_.videodetails_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::VideoDetails* DocumentDetails::_internal_mutable_videodetails() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.videodetails_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::VideoDetails>(GetArenaForAllocation());
    _impl_.videodetails_ = p;
  }
  return _impl_.videodetails_;
}
inline ::playapi::proto::finsky::document::VideoDetails* DocumentDetails::mutable_videodetails() {
  ::playapi::proto::finsky::document::VideoDetails* _msg = _internal_mutable_videodetails();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.DocumentDetails.videoDetails)
  return _msg;
}
inline void DocumentDetails::set_allocated_videodetails(::playapi::proto::finsky::document::VideoDetails* videodetails) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.videodetails_;
  }
  if (videodetails) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(videodetails);
    if (message_arena != submessage_arena) {
      videodetails = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, videodetails, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.videodetails_ = videodetails;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.DocumentDetails.videoDetails)
}

// optional .playapi.proto.finsky.document.SubscriptionDetails subscriptionDetails = 7;
inline bool DocumentDetails::_internal_has_subscriptiondetails() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.subscriptiondetails_ != nullptr);
  return value;
}
inline bool DocumentDetails::has_subscriptiondetails() const {
  return _internal_has_subscriptiondetails();
}
inline void DocumentDetails::clear_subscriptiondetails() {
  if (_impl_.subscriptiondetails_ != nullptr) _impl_.subscriptiondetails_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::playapi::proto::finsky::document::SubscriptionDetails& DocumentDetails::_internal_subscriptiondetails() const {
  const ::playapi::proto::finsky::document::SubscriptionDetails* p = _impl_.subscriptiondetails_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::SubscriptionDetails&>(
      ::playapi::proto::finsky::document::_SubscriptionDetails_default_instance_);
}
inline const ::playapi::proto::finsky::document::SubscriptionDetails& DocumentDetails::subscriptiondetails() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.DocumentDetails.subscriptionDetails)
  return _internal_subscriptiondetails();
}
inline void DocumentDetails::unsafe_arena_set_allocated_subscriptiondetails(
    ::playapi::proto::finsky::document::SubscriptionDetails* subscriptiondetails) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.subscriptiondetails_);
  }
  _impl_.subscriptiondetails_ = subscriptiondetails;
  if (subscriptiondetails) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.DocumentDetails.subscriptionDetails)
}
inline ::playapi::proto::finsky::document::SubscriptionDetails* DocumentDetails::release_subscriptiondetails() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::playapi::proto::finsky::document::SubscriptionDetails* temp = _impl_.subscriptiondetails_;
  _impl_.subscriptiondetails_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::SubscriptionDetails* DocumentDetails::unsafe_arena_release_subscriptiondetails() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.DocumentDetails.subscriptionDetails)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::playapi::proto::finsky::document::SubscriptionDetails* temp = _impl_.subscriptiondetails_;
  _impl_.subscriptiondetails_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::SubscriptionDetails* DocumentDetails::_internal_mutable_subscriptiondetails() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.subscriptiondetails_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::SubscriptionDetails>(GetArenaForAllocation());
    _impl_.subscriptiondetails_ = p;
  }
  return _impl_.subscriptiondetails_;
}
inline ::playapi::proto::finsky::document::SubscriptionDetails* DocumentDetails::mutable_subscriptiondetails() {
  ::playapi::proto::finsky::document::SubscriptionDetails* _msg = _internal_mutable_subscriptiondetails();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.DocumentDetails.subscriptionDetails)
  return _msg;
}
inline void DocumentDetails::set_allocated_subscriptiondetails(::playapi::proto::finsky::document::SubscriptionDetails* subscriptiondetails) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.subscriptiondetails_;
  }
  if (subscriptiondetails) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(subscriptiondetails);
    if (message_arena != submessage_arena) {
      subscriptiondetails = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subscriptiondetails, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.subscriptiondetails_ = subscriptiondetails;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.DocumentDetails.subscriptionDetails)
}

// optional .playapi.proto.finsky.document.MagazineDetails magazineDetails = 8;
inline bool DocumentDetails::_internal_has_magazinedetails() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.magazinedetails_ != nullptr);
  return value;
}
inline bool DocumentDetails::has_magazinedetails() const {
  return _internal_has_magazinedetails();
}
inline void DocumentDetails::clear_magazinedetails() {
  if (_impl_.magazinedetails_ != nullptr) _impl_.magazinedetails_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::playapi::proto::finsky::document::MagazineDetails& DocumentDetails::_internal_magazinedetails() const {
  const ::playapi::proto::finsky::document::MagazineDetails* p = _impl_.magazinedetails_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::MagazineDetails&>(
      ::playapi::proto::finsky::document::_MagazineDetails_default_instance_);
}
inline const ::playapi::proto::finsky::document::MagazineDetails& DocumentDetails::magazinedetails() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.DocumentDetails.magazineDetails)
  return _internal_magazinedetails();
}
inline void DocumentDetails::unsafe_arena_set_allocated_magazinedetails(
    ::playapi::proto::finsky::document::MagazineDetails* magazinedetails) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.magazinedetails_);
  }
  _impl_.magazinedetails_ = magazinedetails;
  if (magazinedetails) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.DocumentDetails.magazineDetails)
}
inline ::playapi::proto::finsky::document::MagazineDetails* DocumentDetails::release_magazinedetails() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::playapi::proto::finsky::document::MagazineDetails* temp = _impl_.magazinedetails_;
  _impl_.magazinedetails_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::MagazineDetails* DocumentDetails::unsafe_arena_release_magazinedetails() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.DocumentDetails.magazineDetails)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::playapi::proto::finsky::document::MagazineDetails* temp = _impl_.magazinedetails_;
  _impl_.magazinedetails_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::MagazineDetails* DocumentDetails::_internal_mutable_magazinedetails() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.magazinedetails_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::MagazineDetails>(GetArenaForAllocation());
    _impl_.magazinedetails_ = p;
  }
  return _impl_.magazinedetails_;
}
inline ::playapi::proto::finsky::document::MagazineDetails* DocumentDetails::mutable_magazinedetails() {
  ::playapi::proto::finsky::document::MagazineDetails* _msg = _internal_mutable_magazinedetails();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.DocumentDetails.magazineDetails)
  return _msg;
}
inline void DocumentDetails::set_allocated_magazinedetails(::playapi::proto::finsky::document::MagazineDetails* magazinedetails) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.magazinedetails_;
  }
  if (magazinedetails) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(magazinedetails);
    if (message_arena != submessage_arena) {
      magazinedetails = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, magazinedetails, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.magazinedetails_ = magazinedetails;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.DocumentDetails.magazineDetails)
}

// optional .playapi.proto.finsky.document.TvShowDetails tvShowDetails = 9;
inline bool DocumentDetails::_internal_has_tvshowdetails() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tvshowdetails_ != nullptr);
  return value;
}
inline bool DocumentDetails::has_tvshowdetails() const {
  return _internal_has_tvshowdetails();
}
inline void DocumentDetails::clear_tvshowdetails() {
  if (_impl_.tvshowdetails_ != nullptr) _impl_.tvshowdetails_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::playapi::proto::finsky::document::TvShowDetails& DocumentDetails::_internal_tvshowdetails() const {
  const ::playapi::proto::finsky::document::TvShowDetails* p = _impl_.tvshowdetails_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::TvShowDetails&>(
      ::playapi::proto::finsky::document::_TvShowDetails_default_instance_);
}
inline const ::playapi::proto::finsky::document::TvShowDetails& DocumentDetails::tvshowdetails() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.DocumentDetails.tvShowDetails)
  return _internal_tvshowdetails();
}
inline void DocumentDetails::unsafe_arena_set_allocated_tvshowdetails(
    ::playapi::proto::finsky::document::TvShowDetails* tvshowdetails) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tvshowdetails_);
  }
  _impl_.tvshowdetails_ = tvshowdetails;
  if (tvshowdetails) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.DocumentDetails.tvShowDetails)
}
inline ::playapi::proto::finsky::document::TvShowDetails* DocumentDetails::release_tvshowdetails() {
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::playapi::proto::finsky::document::TvShowDetails* temp = _impl_.tvshowdetails_;
  _impl_.tvshowdetails_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::TvShowDetails* DocumentDetails::unsafe_arena_release_tvshowdetails() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.DocumentDetails.tvShowDetails)
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::playapi::proto::finsky::document::TvShowDetails* temp = _impl_.tvshowdetails_;
  _impl_.tvshowdetails_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::TvShowDetails* DocumentDetails::_internal_mutable_tvshowdetails() {
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.tvshowdetails_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::TvShowDetails>(GetArenaForAllocation());
    _impl_.tvshowdetails_ = p;
  }
  return _impl_.tvshowdetails_;
}
inline ::playapi::proto::finsky::document::TvShowDetails* DocumentDetails::mutable_tvshowdetails() {
  ::playapi::proto::finsky::document::TvShowDetails* _msg = _internal_mutable_tvshowdetails();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.DocumentDetails.tvShowDetails)
  return _msg;
}
inline void DocumentDetails::set_allocated_tvshowdetails(::playapi::proto::finsky::document::TvShowDetails* tvshowdetails) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tvshowdetails_;
  }
  if (tvshowdetails) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tvshowdetails);
    if (message_arena != submessage_arena) {
      tvshowdetails = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tvshowdetails, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.tvshowdetails_ = tvshowdetails;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.DocumentDetails.tvShowDetails)
}

// optional .playapi.proto.finsky.document.TvSeasonDetails tvSeasonDetails = 10;
inline bool DocumentDetails::_internal_has_tvseasondetails() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tvseasondetails_ != nullptr);
  return value;
}
inline bool DocumentDetails::has_tvseasondetails() const {
  return _internal_has_tvseasondetails();
}
inline void DocumentDetails::clear_tvseasondetails() {
  if (_impl_.tvseasondetails_ != nullptr) _impl_.tvseasondetails_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const ::playapi::proto::finsky::document::TvSeasonDetails& DocumentDetails::_internal_tvseasondetails() const {
  const ::playapi::proto::finsky::document::TvSeasonDetails* p = _impl_.tvseasondetails_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::TvSeasonDetails&>(
      ::playapi::proto::finsky::document::_TvSeasonDetails_default_instance_);
}
inline const ::playapi::proto::finsky::document::TvSeasonDetails& DocumentDetails::tvseasondetails() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.DocumentDetails.tvSeasonDetails)
  return _internal_tvseasondetails();
}
inline void DocumentDetails::unsafe_arena_set_allocated_tvseasondetails(
    ::playapi::proto::finsky::document::TvSeasonDetails* tvseasondetails) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tvseasondetails_);
  }
  _impl_.tvseasondetails_ = tvseasondetails;
  if (tvseasondetails) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.DocumentDetails.tvSeasonDetails)
}
inline ::playapi::proto::finsky::document::TvSeasonDetails* DocumentDetails::release_tvseasondetails() {
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::playapi::proto::finsky::document::TvSeasonDetails* temp = _impl_.tvseasondetails_;
  _impl_.tvseasondetails_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::TvSeasonDetails* DocumentDetails::unsafe_arena_release_tvseasondetails() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.DocumentDetails.tvSeasonDetails)
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::playapi::proto::finsky::document::TvSeasonDetails* temp = _impl_.tvseasondetails_;
  _impl_.tvseasondetails_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::TvSeasonDetails* DocumentDetails::_internal_mutable_tvseasondetails() {
  _impl_._has_bits_[0] |= 0x00000200u;
  if (_impl_.tvseasondetails_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::TvSeasonDetails>(GetArenaForAllocation());
    _impl_.tvseasondetails_ = p;
  }
  return _impl_.tvseasondetails_;
}
inline ::playapi::proto::finsky::document::TvSeasonDetails* DocumentDetails::mutable_tvseasondetails() {
  ::playapi::proto::finsky::document::TvSeasonDetails* _msg = _internal_mutable_tvseasondetails();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.DocumentDetails.tvSeasonDetails)
  return _msg;
}
inline void DocumentDetails::set_allocated_tvseasondetails(::playapi::proto::finsky::document::TvSeasonDetails* tvseasondetails) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tvseasondetails_;
  }
  if (tvseasondetails) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tvseasondetails);
    if (message_arena != submessage_arena) {
      tvseasondetails = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tvseasondetails, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.tvseasondetails_ = tvseasondetails;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.DocumentDetails.tvSeasonDetails)
}

// optional .playapi.proto.finsky.document.TvEpisodeDetails tvEpisodeDetails = 11;
inline bool DocumentDetails::_internal_has_tvepisodedetails() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tvepisodedetails_ != nullptr);
  return value;
}
inline bool DocumentDetails::has_tvepisodedetails() const {
  return _internal_has_tvepisodedetails();
}
inline void DocumentDetails::clear_tvepisodedetails() {
  if (_impl_.tvepisodedetails_ != nullptr) _impl_.tvepisodedetails_->Clear();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const ::playapi::proto::finsky::document::TvEpisodeDetails& DocumentDetails::_internal_tvepisodedetails() const {
  const ::playapi::proto::finsky::document::TvEpisodeDetails* p = _impl_.tvepisodedetails_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::TvEpisodeDetails&>(
      ::playapi::proto::finsky::document::_TvEpisodeDetails_default_instance_);
}
inline const ::playapi::proto::finsky::document::TvEpisodeDetails& DocumentDetails::tvepisodedetails() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.DocumentDetails.tvEpisodeDetails)
  return _internal_tvepisodedetails();
}
inline void DocumentDetails::unsafe_arena_set_allocated_tvepisodedetails(
    ::playapi::proto::finsky::document::TvEpisodeDetails* tvepisodedetails) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tvepisodedetails_);
  }
  _impl_.tvepisodedetails_ = tvepisodedetails;
  if (tvepisodedetails) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.DocumentDetails.tvEpisodeDetails)
}
inline ::playapi::proto::finsky::document::TvEpisodeDetails* DocumentDetails::release_tvepisodedetails() {
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::playapi::proto::finsky::document::TvEpisodeDetails* temp = _impl_.tvepisodedetails_;
  _impl_.tvepisodedetails_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::TvEpisodeDetails* DocumentDetails::unsafe_arena_release_tvepisodedetails() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.DocumentDetails.tvEpisodeDetails)
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::playapi::proto::finsky::document::TvEpisodeDetails* temp = _impl_.tvepisodedetails_;
  _impl_.tvepisodedetails_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::TvEpisodeDetails* DocumentDetails::_internal_mutable_tvepisodedetails() {
  _impl_._has_bits_[0] |= 0x00000400u;
  if (_impl_.tvepisodedetails_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::TvEpisodeDetails>(GetArenaForAllocation());
    _impl_.tvepisodedetails_ = p;
  }
  return _impl_.tvepisodedetails_;
}
inline ::playapi::proto::finsky::document::TvEpisodeDetails* DocumentDetails::mutable_tvepisodedetails() {
  ::playapi::proto::finsky::document::TvEpisodeDetails* _msg = _internal_mutable_tvepisodedetails();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.DocumentDetails.tvEpisodeDetails)
  return _msg;
}
inline void DocumentDetails::set_allocated_tvepisodedetails(::playapi::proto::finsky::document::TvEpisodeDetails* tvepisodedetails) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tvepisodedetails_;
  }
  if (tvepisodedetails) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tvepisodedetails);
    if (message_arena != submessage_arena) {
      tvepisodedetails = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tvepisodedetails, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.tvepisodedetails_ = tvepisodedetails;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.DocumentDetails.tvEpisodeDetails)
}

// optional .playapi.proto.finsky.document.PersonDetails personDetails = 12;
inline bool DocumentDetails::_internal_has_persondetails() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.persondetails_ != nullptr);
  return value;
}
inline bool DocumentDetails::has_persondetails() const {
  return _internal_has_persondetails();
}
inline void DocumentDetails::clear_persondetails() {
  if (_impl_.persondetails_ != nullptr) _impl_.persondetails_->Clear();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline const ::playapi::proto::finsky::document::PersonDetails& DocumentDetails::_internal_persondetails() const {
  const ::playapi::proto::finsky::document::PersonDetails* p = _impl_.persondetails_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::PersonDetails&>(
      ::playapi::proto::finsky::document::_PersonDetails_default_instance_);
}
inline const ::playapi::proto::finsky::document::PersonDetails& DocumentDetails::persondetails() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.DocumentDetails.personDetails)
  return _internal_persondetails();
}
inline void DocumentDetails::unsafe_arena_set_allocated_persondetails(
    ::playapi::proto::finsky::document::PersonDetails* persondetails) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.persondetails_);
  }
  _impl_.persondetails_ = persondetails;
  if (persondetails) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.DocumentDetails.personDetails)
}
inline ::playapi::proto::finsky::document::PersonDetails* DocumentDetails::release_persondetails() {
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::playapi::proto::finsky::document::PersonDetails* temp = _impl_.persondetails_;
  _impl_.persondetails_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::PersonDetails* DocumentDetails::unsafe_arena_release_persondetails() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.DocumentDetails.personDetails)
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::playapi::proto::finsky::document::PersonDetails* temp = _impl_.persondetails_;
  _impl_.persondetails_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::PersonDetails* DocumentDetails::_internal_mutable_persondetails() {
  _impl_._has_bits_[0] |= 0x00000800u;
  if (_impl_.persondetails_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::PersonDetails>(GetArenaForAllocation());
    _impl_.persondetails_ = p;
  }
  return _impl_.persondetails_;
}
inline ::playapi::proto::finsky::document::PersonDetails* DocumentDetails::mutable_persondetails() {
  ::playapi::proto::finsky::document::PersonDetails* _msg = _internal_mutable_persondetails();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.DocumentDetails.personDetails)
  return _msg;
}
inline void DocumentDetails::set_allocated_persondetails(::playapi::proto::finsky::document::PersonDetails* persondetails) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.persondetails_;
  }
  if (persondetails) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(persondetails);
    if (message_arena != submessage_arena) {
      persondetails = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, persondetails, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  _impl_.persondetails_ = persondetails;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.DocumentDetails.personDetails)
}

// optional .playapi.proto.finsky.document.TalentDetails talentDetails = 13;
inline bool DocumentDetails::_internal_has_talentdetails() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.talentdetails_ != nullptr);
  return value;
}
inline bool DocumentDetails::has_talentdetails() const {
  return _internal_has_talentdetails();
}
inline void DocumentDetails::clear_talentdetails() {
  if (_impl_.talentdetails_ != nullptr) _impl_.talentdetails_->Clear();
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline const ::playapi::proto::finsky::document::TalentDetails& DocumentDetails::_internal_talentdetails() const {
  const ::playapi::proto::finsky::document::TalentDetails* p = _impl_.talentdetails_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::TalentDetails&>(
      ::playapi::proto::finsky::document::_TalentDetails_default_instance_);
}
inline const ::playapi::proto::finsky::document::TalentDetails& DocumentDetails::talentdetails() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.DocumentDetails.talentDetails)
  return _internal_talentdetails();
}
inline void DocumentDetails::unsafe_arena_set_allocated_talentdetails(
    ::playapi::proto::finsky::document::TalentDetails* talentdetails) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.talentdetails_);
  }
  _impl_.talentdetails_ = talentdetails;
  if (talentdetails) {
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.DocumentDetails.talentDetails)
}
inline ::playapi::proto::finsky::document::TalentDetails* DocumentDetails::release_talentdetails() {
  _impl_._has_bits_[0] &= ~0x00001000u;
  ::playapi::proto::finsky::document::TalentDetails* temp = _impl_.talentdetails_;
  _impl_.talentdetails_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::TalentDetails* DocumentDetails::unsafe_arena_release_talentdetails() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.DocumentDetails.talentDetails)
  _impl_._has_bits_[0] &= ~0x00001000u;
  ::playapi::proto::finsky::document::TalentDetails* temp = _impl_.talentdetails_;
  _impl_.talentdetails_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::TalentDetails* DocumentDetails::_internal_mutable_talentdetails() {
  _impl_._has_bits_[0] |= 0x00001000u;
  if (_impl_.talentdetails_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::TalentDetails>(GetArenaForAllocation());
    _impl_.talentdetails_ = p;
  }
  return _impl_.talentdetails_;
}
inline ::playapi::proto::finsky::document::TalentDetails* DocumentDetails::mutable_talentdetails() {
  ::playapi::proto::finsky::document::TalentDetails* _msg = _internal_mutable_talentdetails();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.DocumentDetails.talentDetails)
  return _msg;
}
inline void DocumentDetails::set_allocated_talentdetails(::playapi::proto::finsky::document::TalentDetails* talentdetails) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.talentdetails_;
  }
  if (talentdetails) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(talentdetails);
    if (message_arena != submessage_arena) {
      talentdetails = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, talentdetails, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  _impl_.talentdetails_ = talentdetails;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.DocumentDetails.talentDetails)
}

// optional .playapi.proto.finsky.document.DeveloperDetails developerDetails = 14;
inline bool DocumentDetails::_internal_has_developerdetails() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.developerdetails_ != nullptr);
  return value;
}
inline bool DocumentDetails::has_developerdetails() const {
  return _internal_has_developerdetails();
}
inline void DocumentDetails::clear_developerdetails() {
  if (_impl_.developerdetails_ != nullptr) _impl_.developerdetails_->Clear();
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline const ::playapi::proto::finsky::document::DeveloperDetails& DocumentDetails::_internal_developerdetails() const {
  const ::playapi::proto::finsky::document::DeveloperDetails* p = _impl_.developerdetails_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::DeveloperDetails&>(
      ::playapi::proto::finsky::document::_DeveloperDetails_default_instance_);
}
inline const ::playapi::proto::finsky::document::DeveloperDetails& DocumentDetails::developerdetails() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.DocumentDetails.developerDetails)
  return _internal_developerdetails();
}
inline void DocumentDetails::unsafe_arena_set_allocated_developerdetails(
    ::playapi::proto::finsky::document::DeveloperDetails* developerdetails) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.developerdetails_);
  }
  _impl_.developerdetails_ = developerdetails;
  if (developerdetails) {
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.DocumentDetails.developerDetails)
}
inline ::playapi::proto::finsky::document::DeveloperDetails* DocumentDetails::release_developerdetails() {
  _impl_._has_bits_[0] &= ~0x00002000u;
  ::playapi::proto::finsky::document::DeveloperDetails* temp = _impl_.developerdetails_;
  _impl_.developerdetails_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::DeveloperDetails* DocumentDetails::unsafe_arena_release_developerdetails() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.DocumentDetails.developerDetails)
  _impl_._has_bits_[0] &= ~0x00002000u;
  ::playapi::proto::finsky::document::DeveloperDetails* temp = _impl_.developerdetails_;
  _impl_.developerdetails_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::DeveloperDetails* DocumentDetails::_internal_mutable_developerdetails() {
  _impl_._has_bits_[0] |= 0x00002000u;
  if (_impl_.developerdetails_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::DeveloperDetails>(GetArenaForAllocation());
    _impl_.developerdetails_ = p;
  }
  return _impl_.developerdetails_;
}
inline ::playapi::proto::finsky::document::DeveloperDetails* DocumentDetails::mutable_developerdetails() {
  ::playapi::proto::finsky::document::DeveloperDetails* _msg = _internal_mutable_developerdetails();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.DocumentDetails.developerDetails)
  return _msg;
}
inline void DocumentDetails::set_allocated_developerdetails(::playapi::proto::finsky::document::DeveloperDetails* developerdetails) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.developerdetails_;
  }
  if (developerdetails) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(developerdetails);
    if (message_arena != submessage_arena) {
      developerdetails = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, developerdetails, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  _impl_.developerdetails_ = developerdetails;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.DocumentDetails.developerDetails)
}

// optional .playapi.proto.finsky.document.BookSeriesDetails bookSeriesDetails = 15;
inline bool DocumentDetails::_internal_has_bookseriesdetails() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.bookseriesdetails_ != nullptr);
  return value;
}
inline bool DocumentDetails::has_bookseriesdetails() const {
  return _internal_has_bookseriesdetails();
}
inline void DocumentDetails::clear_bookseriesdetails() {
  if (_impl_.bookseriesdetails_ != nullptr) _impl_.bookseriesdetails_->Clear();
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline const ::playapi::proto::finsky::document::BookSeriesDetails& DocumentDetails::_internal_bookseriesdetails() const {
  const ::playapi::proto::finsky::document::BookSeriesDetails* p = _impl_.bookseriesdetails_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::BookSeriesDetails&>(
      ::playapi::proto::finsky::document::_BookSeriesDetails_default_instance_);
}
inline const ::playapi::proto::finsky::document::BookSeriesDetails& DocumentDetails::bookseriesdetails() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.DocumentDetails.bookSeriesDetails)
  return _internal_bookseriesdetails();
}
inline void DocumentDetails::unsafe_arena_set_allocated_bookseriesdetails(
    ::playapi::proto::finsky::document::BookSeriesDetails* bookseriesdetails) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bookseriesdetails_);
  }
  _impl_.bookseriesdetails_ = bookseriesdetails;
  if (bookseriesdetails) {
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.DocumentDetails.bookSeriesDetails)
}
inline ::playapi::proto::finsky::document::BookSeriesDetails* DocumentDetails::release_bookseriesdetails() {
  _impl_._has_bits_[0] &= ~0x00004000u;
  ::playapi::proto::finsky::document::BookSeriesDetails* temp = _impl_.bookseriesdetails_;
  _impl_.bookseriesdetails_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::BookSeriesDetails* DocumentDetails::unsafe_arena_release_bookseriesdetails() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.DocumentDetails.bookSeriesDetails)
  _impl_._has_bits_[0] &= ~0x00004000u;
  ::playapi::proto::finsky::document::BookSeriesDetails* temp = _impl_.bookseriesdetails_;
  _impl_.bookseriesdetails_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::BookSeriesDetails* DocumentDetails::_internal_mutable_bookseriesdetails() {
  _impl_._has_bits_[0] |= 0x00004000u;
  if (_impl_.bookseriesdetails_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::BookSeriesDetails>(GetArenaForAllocation());
    _impl_.bookseriesdetails_ = p;
  }
  return _impl_.bookseriesdetails_;
}
inline ::playapi::proto::finsky::document::BookSeriesDetails* DocumentDetails::mutable_bookseriesdetails() {
  ::playapi::proto::finsky::document::BookSeriesDetails* _msg = _internal_mutable_bookseriesdetails();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.DocumentDetails.bookSeriesDetails)
  return _msg;
}
inline void DocumentDetails::set_allocated_bookseriesdetails(::playapi::proto::finsky::document::BookSeriesDetails* bookseriesdetails) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.bookseriesdetails_;
  }
  if (bookseriesdetails) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bookseriesdetails);
    if (message_arena != submessage_arena) {
      bookseriesdetails = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bookseriesdetails, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }
  _impl_.bookseriesdetails_ = bookseriesdetails;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.DocumentDetails.bookSeriesDetails)
}

// -------------------------------------------------------------------

// AppDetails

// optional string developerName = 1;
inline bool AppDetails::_internal_has_developername() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AppDetails::has_developername() const {
  return _internal_has_developername();
}
inline void AppDetails::clear_developername() {
  _impl_.developername_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AppDetails::developername() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.AppDetails.developerName)
  return _internal_developername();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppDetails::set_developername(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.developername_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.AppDetails.developerName)
}
inline std::string* AppDetails::mutable_developername() {
  std::string* _s = _internal_mutable_developername();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.AppDetails.developerName)
  return _s;
}
inline const std::string& AppDetails::_internal_developername() const {
  return _impl_.developername_.Get();
}
inline void AppDetails::_internal_set_developername(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.developername_.Set(value, GetArenaForAllocation());
}
inline std::string* AppDetails::_internal_mutable_developername() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.developername_.Mutable(GetArenaForAllocation());
}
inline std::string* AppDetails::release_developername() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.AppDetails.developerName)
  if (!_internal_has_developername()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.developername_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.developername_.IsDefault()) {
    _impl_.developername_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AppDetails::set_allocated_developername(std::string* developername) {
  if (developername != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.developername_.SetAllocated(developername, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.developername_.IsDefault()) {
    _impl_.developername_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.AppDetails.developerName)
}

// optional int32 majorVersionNumber = 2;
inline bool AppDetails::_internal_has_majorversionnumber() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool AppDetails::has_majorversionnumber() const {
  return _internal_has_majorversionnumber();
}
inline void AppDetails::clear_majorversionnumber() {
  _impl_.majorversionnumber_ = 0;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline int32_t AppDetails::_internal_majorversionnumber() const {
  return _impl_.majorversionnumber_;
}
inline int32_t AppDetails::majorversionnumber() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.AppDetails.majorVersionNumber)
  return _internal_majorversionnumber();
}
inline void AppDetails::_internal_set_majorversionnumber(int32_t value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.majorversionnumber_ = value;
}
inline void AppDetails::set_majorversionnumber(int32_t value) {
  _internal_set_majorversionnumber(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.AppDetails.majorVersionNumber)
}

// optional int32 versionCode = 3;
inline bool AppDetails::_internal_has_versioncode() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool AppDetails::has_versioncode() const {
  return _internal_has_versioncode();
}
inline void AppDetails::clear_versioncode() {
  _impl_.versioncode_ = 0;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline int32_t AppDetails::_internal_versioncode() const {
  return _impl_.versioncode_;
}
inline int32_t AppDetails::versioncode() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.AppDetails.versionCode)
  return _internal_versioncode();
}
inline void AppDetails::_internal_set_versioncode(int32_t value) {
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.versioncode_ = value;
}
inline void AppDetails::set_versioncode(int32_t value) {
  _internal_set_versioncode(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.AppDetails.versionCode)
}

// optional string versionString = 4;
inline bool AppDetails::_internal_has_versionstring() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AppDetails::has_versionstring() const {
  return _internal_has_versionstring();
}
inline void AppDetails::clear_versionstring() {
  _impl_.versionstring_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AppDetails::versionstring() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.AppDetails.versionString)
  return _internal_versionstring();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppDetails::set_versionstring(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.versionstring_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.AppDetails.versionString)
}
inline std::string* AppDetails::mutable_versionstring() {
  std::string* _s = _internal_mutable_versionstring();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.AppDetails.versionString)
  return _s;
}
inline const std::string& AppDetails::_internal_versionstring() const {
  return _impl_.versionstring_.Get();
}
inline void AppDetails::_internal_set_versionstring(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.versionstring_.Set(value, GetArenaForAllocation());
}
inline std::string* AppDetails::_internal_mutable_versionstring() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.versionstring_.Mutable(GetArenaForAllocation());
}
inline std::string* AppDetails::release_versionstring() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.AppDetails.versionString)
  if (!_internal_has_versionstring()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.versionstring_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.versionstring_.IsDefault()) {
    _impl_.versionstring_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AppDetails::set_allocated_versionstring(std::string* versionstring) {
  if (versionstring != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.versionstring_.SetAllocated(versionstring, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.versionstring_.IsDefault()) {
    _impl_.versionstring_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.AppDetails.versionString)
}

// optional string title = 5;
inline bool AppDetails::_internal_has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AppDetails::has_title() const {
  return _internal_has_title();
}
inline void AppDetails::clear_title() {
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& AppDetails::title() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.AppDetails.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppDetails::set_title(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.AppDetails.title)
}
inline std::string* AppDetails::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.AppDetails.title)
  return _s;
}
inline const std::string& AppDetails::_internal_title() const {
  return _impl_.title_.Get();
}
inline void AppDetails::_internal_set_title(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* AppDetails::_internal_mutable_title() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* AppDetails::release_title() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.AppDetails.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.title_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AppDetails::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.AppDetails.title)
}

// repeated string appCategory = 7;
inline int AppDetails::_internal_appcategory_size() const {
  return _impl_.appcategory_.size();
}
inline int AppDetails::appcategory_size() const {
  return _internal_appcategory_size();
}
inline void AppDetails::clear_appcategory() {
  _impl_.appcategory_.Clear();
}
inline std::string* AppDetails::add_appcategory() {
  std::string* _s = _internal_add_appcategory();
  // @@protoc_insertion_point(field_add_mutable:playapi.proto.finsky.document.AppDetails.appCategory)
  return _s;
}
inline const std::string& AppDetails::_internal_appcategory(int index) const {
  return _impl_.appcategory_.Get(index);
}
inline const std::string& AppDetails::appcategory(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.AppDetails.appCategory)
  return _internal_appcategory(index);
}
inline std::string* AppDetails::mutable_appcategory(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.AppDetails.appCategory)
  return _impl_.appcategory_.Mutable(index);
}
inline void AppDetails::set_appcategory(int index, const std::string& value) {
  _impl_.appcategory_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.AppDetails.appCategory)
}
inline void AppDetails::set_appcategory(int index, std::string&& value) {
  _impl_.appcategory_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.AppDetails.appCategory)
}
inline void AppDetails::set_appcategory(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.appcategory_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:playapi.proto.finsky.document.AppDetails.appCategory)
}
inline void AppDetails::set_appcategory(int index, const char* value, size_t size) {
  _impl_.appcategory_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:playapi.proto.finsky.document.AppDetails.appCategory)
}
inline std::string* AppDetails::_internal_add_appcategory() {
  return _impl_.appcategory_.Add();
}
inline void AppDetails::add_appcategory(const std::string& value) {
  _impl_.appcategory_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.AppDetails.appCategory)
}
inline void AppDetails::add_appcategory(std::string&& value) {
  _impl_.appcategory_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.AppDetails.appCategory)
}
inline void AppDetails::add_appcategory(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.appcategory_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:playapi.proto.finsky.document.AppDetails.appCategory)
}
inline void AppDetails::add_appcategory(const char* value, size_t size) {
  _impl_.appcategory_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:playapi.proto.finsky.document.AppDetails.appCategory)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AppDetails::appcategory() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.document.AppDetails.appCategory)
  return _impl_.appcategory_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AppDetails::mutable_appcategory() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.document.AppDetails.appCategory)
  return &_impl_.appcategory_;
}

// optional int32 contentRating = 8;
inline bool AppDetails::_internal_has_contentrating() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool AppDetails::has_contentrating() const {
  return _internal_has_contentrating();
}
inline void AppDetails::clear_contentrating() {
  _impl_.contentrating_ = 0;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline int32_t AppDetails::_internal_contentrating() const {
  return _impl_.contentrating_;
}
inline int32_t AppDetails::contentrating() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.AppDetails.contentRating)
  return _internal_contentrating();
}
inline void AppDetails::_internal_set_contentrating(int32_t value) {
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.contentrating_ = value;
}
inline void AppDetails::set_contentrating(int32_t value) {
  _internal_set_contentrating(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.AppDetails.contentRating)
}

// optional int64 installationSize = 9;
inline bool AppDetails::_internal_has_installationsize() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool AppDetails::has_installationsize() const {
  return _internal_has_installationsize();
}
inline void AppDetails::clear_installationsize() {
  _impl_.installationsize_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline int64_t AppDetails::_internal_installationsize() const {
  return _impl_.installationsize_;
}
inline int64_t AppDetails::installationsize() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.AppDetails.installationSize)
  return _internal_installationsize();
}
inline void AppDetails::_internal_set_installationsize(int64_t value) {
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.installationsize_ = value;
}
inline void AppDetails::set_installationsize(int64_t value) {
  _internal_set_installationsize(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.AppDetails.installationSize)
}

// repeated string permission = 10;
inline int AppDetails::_internal_permission_size() const {
  return _impl_.permission_.size();
}
inline int AppDetails::permission_size() const {
  return _internal_permission_size();
}
inline void AppDetails::clear_permission() {
  _impl_.permission_.Clear();
}
inline std::string* AppDetails::add_permission() {
  std::string* _s = _internal_add_permission();
  // @@protoc_insertion_point(field_add_mutable:playapi.proto.finsky.document.AppDetails.permission)
  return _s;
}
inline const std::string& AppDetails::_internal_permission(int index) const {
  return _impl_.permission_.Get(index);
}
inline const std::string& AppDetails::permission(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.AppDetails.permission)
  return _internal_permission(index);
}
inline std::string* AppDetails::mutable_permission(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.AppDetails.permission)
  return _impl_.permission_.Mutable(index);
}
inline void AppDetails::set_permission(int index, const std::string& value) {
  _impl_.permission_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.AppDetails.permission)
}
inline void AppDetails::set_permission(int index, std::string&& value) {
  _impl_.permission_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.AppDetails.permission)
}
inline void AppDetails::set_permission(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.permission_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:playapi.proto.finsky.document.AppDetails.permission)
}
inline void AppDetails::set_permission(int index, const char* value, size_t size) {
  _impl_.permission_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:playapi.proto.finsky.document.AppDetails.permission)
}
inline std::string* AppDetails::_internal_add_permission() {
  return _impl_.permission_.Add();
}
inline void AppDetails::add_permission(const std::string& value) {
  _impl_.permission_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.AppDetails.permission)
}
inline void AppDetails::add_permission(std::string&& value) {
  _impl_.permission_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.AppDetails.permission)
}
inline void AppDetails::add_permission(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.permission_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:playapi.proto.finsky.document.AppDetails.permission)
}
inline void AppDetails::add_permission(const char* value, size_t size) {
  _impl_.permission_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:playapi.proto.finsky.document.AppDetails.permission)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AppDetails::permission() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.document.AppDetails.permission)
  return _impl_.permission_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AppDetails::mutable_permission() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.document.AppDetails.permission)
  return &_impl_.permission_;
}

// optional string developerEmail = 11;
inline bool AppDetails::_internal_has_developeremail() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool AppDetails::has_developeremail() const {
  return _internal_has_developeremail();
}
inline void AppDetails::clear_developeremail() {
  _impl_.developeremail_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& AppDetails::developeremail() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.AppDetails.developerEmail)
  return _internal_developeremail();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppDetails::set_developeremail(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.developeremail_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.AppDetails.developerEmail)
}
inline std::string* AppDetails::mutable_developeremail() {
  std::string* _s = _internal_mutable_developeremail();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.AppDetails.developerEmail)
  return _s;
}
inline const std::string& AppDetails::_internal_developeremail() const {
  return _impl_.developeremail_.Get();
}
inline void AppDetails::_internal_set_developeremail(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.developeremail_.Set(value, GetArenaForAllocation());
}
inline std::string* AppDetails::_internal_mutable_developeremail() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.developeremail_.Mutable(GetArenaForAllocation());
}
inline std::string* AppDetails::release_developeremail() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.AppDetails.developerEmail)
  if (!_internal_has_developeremail()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.developeremail_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.developeremail_.IsDefault()) {
    _impl_.developeremail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AppDetails::set_allocated_developeremail(std::string* developeremail) {
  if (developeremail != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.developeremail_.SetAllocated(developeremail, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.developeremail_.IsDefault()) {
    _impl_.developeremail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.AppDetails.developerEmail)
}

// optional string developerWebsite = 12;
inline bool AppDetails::_internal_has_developerwebsite() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool AppDetails::has_developerwebsite() const {
  return _internal_has_developerwebsite();
}
inline void AppDetails::clear_developerwebsite() {
  _impl_.developerwebsite_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& AppDetails::developerwebsite() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.AppDetails.developerWebsite)
  return _internal_developerwebsite();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppDetails::set_developerwebsite(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.developerwebsite_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.AppDetails.developerWebsite)
}
inline std::string* AppDetails::mutable_developerwebsite() {
  std::string* _s = _internal_mutable_developerwebsite();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.AppDetails.developerWebsite)
  return _s;
}
inline const std::string& AppDetails::_internal_developerwebsite() const {
  return _impl_.developerwebsite_.Get();
}
inline void AppDetails::_internal_set_developerwebsite(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.developerwebsite_.Set(value, GetArenaForAllocation());
}
inline std::string* AppDetails::_internal_mutable_developerwebsite() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.developerwebsite_.Mutable(GetArenaForAllocation());
}
inline std::string* AppDetails::release_developerwebsite() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.AppDetails.developerWebsite)
  if (!_internal_has_developerwebsite()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.developerwebsite_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.developerwebsite_.IsDefault()) {
    _impl_.developerwebsite_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AppDetails::set_allocated_developerwebsite(std::string* developerwebsite) {
  if (developerwebsite != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.developerwebsite_.SetAllocated(developerwebsite, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.developerwebsite_.IsDefault()) {
    _impl_.developerwebsite_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.AppDetails.developerWebsite)
}

// optional string numDownloads = 13;
inline bool AppDetails::_internal_has_numdownloads() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool AppDetails::has_numdownloads() const {
  return _internal_has_numdownloads();
}
inline void AppDetails::clear_numdownloads() {
  _impl_.numdownloads_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& AppDetails::numdownloads() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.AppDetails.numDownloads)
  return _internal_numdownloads();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppDetails::set_numdownloads(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.numdownloads_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.AppDetails.numDownloads)
}
inline std::string* AppDetails::mutable_numdownloads() {
  std::string* _s = _internal_mutable_numdownloads();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.AppDetails.numDownloads)
  return _s;
}
inline const std::string& AppDetails::_internal_numdownloads() const {
  return _impl_.numdownloads_.Get();
}
inline void AppDetails::_internal_set_numdownloads(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.numdownloads_.Set(value, GetArenaForAllocation());
}
inline std::string* AppDetails::_internal_mutable_numdownloads() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.numdownloads_.Mutable(GetArenaForAllocation());
}
inline std::string* AppDetails::release_numdownloads() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.AppDetails.numDownloads)
  if (!_internal_has_numdownloads()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.numdownloads_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.numdownloads_.IsDefault()) {
    _impl_.numdownloads_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AppDetails::set_allocated_numdownloads(std::string* numdownloads) {
  if (numdownloads != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.numdownloads_.SetAllocated(numdownloads, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.numdownloads_.IsDefault()) {
    _impl_.numdownloads_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.AppDetails.numDownloads)
}

// optional string packageName = 14;
inline bool AppDetails::_internal_has_packagename() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool AppDetails::has_packagename() const {
  return _internal_has_packagename();
}
inline void AppDetails::clear_packagename() {
  _impl_.packagename_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& AppDetails::packagename() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.AppDetails.packageName)
  return _internal_packagename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppDetails::set_packagename(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000040u;
 _impl_.packagename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.AppDetails.packageName)
}
inline std::string* AppDetails::mutable_packagename() {
  std::string* _s = _internal_mutable_packagename();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.AppDetails.packageName)
  return _s;
}
inline const std::string& AppDetails::_internal_packagename() const {
  return _impl_.packagename_.Get();
}
inline void AppDetails::_internal_set_packagename(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.packagename_.Set(value, GetArenaForAllocation());
}
inline std::string* AppDetails::_internal_mutable_packagename() {
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.packagename_.Mutable(GetArenaForAllocation());
}
inline std::string* AppDetails::release_packagename() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.AppDetails.packageName)
  if (!_internal_has_packagename()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* p = _impl_.packagename_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.packagename_.IsDefault()) {
    _impl_.packagename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AppDetails::set_allocated_packagename(std::string* packagename) {
  if (packagename != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.packagename_.SetAllocated(packagename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.packagename_.IsDefault()) {
    _impl_.packagename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.AppDetails.packageName)
}

// optional string recentChangesHtml = 15;
inline bool AppDetails::_internal_has_recentchangeshtml() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool AppDetails::has_recentchangeshtml() const {
  return _internal_has_recentchangeshtml();
}
inline void AppDetails::clear_recentchangeshtml() {
  _impl_.recentchangeshtml_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& AppDetails::recentchangeshtml() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.AppDetails.recentChangesHtml)
  return _internal_recentchangeshtml();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppDetails::set_recentchangeshtml(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000080u;
 _impl_.recentchangeshtml_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.AppDetails.recentChangesHtml)
}
inline std::string* AppDetails::mutable_recentchangeshtml() {
  std::string* _s = _internal_mutable_recentchangeshtml();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.AppDetails.recentChangesHtml)
  return _s;
}
inline const std::string& AppDetails::_internal_recentchangeshtml() const {
  return _impl_.recentchangeshtml_.Get();
}
inline void AppDetails::_internal_set_recentchangeshtml(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.recentchangeshtml_.Set(value, GetArenaForAllocation());
}
inline std::string* AppDetails::_internal_mutable_recentchangeshtml() {
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.recentchangeshtml_.Mutable(GetArenaForAllocation());
}
inline std::string* AppDetails::release_recentchangeshtml() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.AppDetails.recentChangesHtml)
  if (!_internal_has_recentchangeshtml()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* p = _impl_.recentchangeshtml_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.recentchangeshtml_.IsDefault()) {
    _impl_.recentchangeshtml_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AppDetails::set_allocated_recentchangeshtml(std::string* recentchangeshtml) {
  if (recentchangeshtml != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.recentchangeshtml_.SetAllocated(recentchangeshtml, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.recentchangeshtml_.IsDefault()) {
    _impl_.recentchangeshtml_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.AppDetails.recentChangesHtml)
}

// optional string uploadDate = 16;
inline bool AppDetails::_internal_has_uploaddate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool AppDetails::has_uploaddate() const {
  return _internal_has_uploaddate();
}
inline void AppDetails::clear_uploaddate() {
  _impl_.uploaddate_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const std::string& AppDetails::uploaddate() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.AppDetails.uploadDate)
  return _internal_uploaddate();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppDetails::set_uploaddate(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000100u;
 _impl_.uploaddate_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.AppDetails.uploadDate)
}
inline std::string* AppDetails::mutable_uploaddate() {
  std::string* _s = _internal_mutable_uploaddate();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.AppDetails.uploadDate)
  return _s;
}
inline const std::string& AppDetails::_internal_uploaddate() const {
  return _impl_.uploaddate_.Get();
}
inline void AppDetails::_internal_set_uploaddate(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.uploaddate_.Set(value, GetArenaForAllocation());
}
inline std::string* AppDetails::_internal_mutable_uploaddate() {
  _impl_._has_bits_[0] |= 0x00000100u;
  return _impl_.uploaddate_.Mutable(GetArenaForAllocation());
}
inline std::string* AppDetails::release_uploaddate() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.AppDetails.uploadDate)
  if (!_internal_has_uploaddate()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000100u;
  auto* p = _impl_.uploaddate_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uploaddate_.IsDefault()) {
    _impl_.uploaddate_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AppDetails::set_allocated_uploaddate(std::string* uploaddate) {
  if (uploaddate != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.uploaddate_.SetAllocated(uploaddate, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uploaddate_.IsDefault()) {
    _impl_.uploaddate_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.AppDetails.uploadDate)
}

// repeated .playapi.proto.finsky.download.FileMetadata file = 17;
inline int AppDetails::_internal_file_size() const {
  return _impl_.file_.size();
}
inline int AppDetails::file_size() const {
  return _internal_file_size();
}
inline ::playapi::proto::finsky::download::FileMetadata* AppDetails::mutable_file(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.AppDetails.file)
  return _impl_.file_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::download::FileMetadata >*
AppDetails::mutable_file() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.document.AppDetails.file)
  return &_impl_.file_;
}
inline const ::playapi::proto::finsky::download::FileMetadata& AppDetails::_internal_file(int index) const {
  return _impl_.file_.Get(index);
}
inline const ::playapi::proto::finsky::download::FileMetadata& AppDetails::file(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.AppDetails.file)
  return _internal_file(index);
}
inline ::playapi::proto::finsky::download::FileMetadata* AppDetails::_internal_add_file() {
  return _impl_.file_.Add();
}
inline ::playapi::proto::finsky::download::FileMetadata* AppDetails::add_file() {
  ::playapi::proto::finsky::download::FileMetadata* _add = _internal_add_file();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.AppDetails.file)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::download::FileMetadata >&
AppDetails::file() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.document.AppDetails.file)
  return _impl_.file_;
}

// optional string appType = 18;
inline bool AppDetails::_internal_has_apptype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool AppDetails::has_apptype() const {
  return _internal_has_apptype();
}
inline void AppDetails::clear_apptype() {
  _impl_.apptype_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const std::string& AppDetails::apptype() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.AppDetails.appType)
  return _internal_apptype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppDetails::set_apptype(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000200u;
 _impl_.apptype_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.AppDetails.appType)
}
inline std::string* AppDetails::mutable_apptype() {
  std::string* _s = _internal_mutable_apptype();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.AppDetails.appType)
  return _s;
}
inline const std::string& AppDetails::_internal_apptype() const {
  return _impl_.apptype_.Get();
}
inline void AppDetails::_internal_set_apptype(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.apptype_.Set(value, GetArenaForAllocation());
}
inline std::string* AppDetails::_internal_mutable_apptype() {
  _impl_._has_bits_[0] |= 0x00000200u;
  return _impl_.apptype_.Mutable(GetArenaForAllocation());
}
inline std::string* AppDetails::release_apptype() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.AppDetails.appType)
  if (!_internal_has_apptype()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000200u;
  auto* p = _impl_.apptype_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.apptype_.IsDefault()) {
    _impl_.apptype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AppDetails::set_allocated_apptype(std::string* apptype) {
  if (apptype != nullptr) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.apptype_.SetAllocated(apptype, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.apptype_.IsDefault()) {
    _impl_.apptype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.AppDetails.appType)
}

// repeated string certificateHash = 19;
inline int AppDetails::_internal_certificatehash_size() const {
  return _impl_.certificatehash_.size();
}
inline int AppDetails::certificatehash_size() const {
  return _internal_certificatehash_size();
}
inline void AppDetails::clear_certificatehash() {
  _impl_.certificatehash_.Clear();
}
inline std::string* AppDetails::add_certificatehash() {
  std::string* _s = _internal_add_certificatehash();
  // @@protoc_insertion_point(field_add_mutable:playapi.proto.finsky.document.AppDetails.certificateHash)
  return _s;
}
inline const std::string& AppDetails::_internal_certificatehash(int index) const {
  return _impl_.certificatehash_.Get(index);
}
inline const std::string& AppDetails::certificatehash(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.AppDetails.certificateHash)
  return _internal_certificatehash(index);
}
inline std::string* AppDetails::mutable_certificatehash(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.AppDetails.certificateHash)
  return _impl_.certificatehash_.Mutable(index);
}
inline void AppDetails::set_certificatehash(int index, const std::string& value) {
  _impl_.certificatehash_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.AppDetails.certificateHash)
}
inline void AppDetails::set_certificatehash(int index, std::string&& value) {
  _impl_.certificatehash_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.AppDetails.certificateHash)
}
inline void AppDetails::set_certificatehash(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.certificatehash_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:playapi.proto.finsky.document.AppDetails.certificateHash)
}
inline void AppDetails::set_certificatehash(int index, const char* value, size_t size) {
  _impl_.certificatehash_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:playapi.proto.finsky.document.AppDetails.certificateHash)
}
inline std::string* AppDetails::_internal_add_certificatehash() {
  return _impl_.certificatehash_.Add();
}
inline void AppDetails::add_certificatehash(const std::string& value) {
  _impl_.certificatehash_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.AppDetails.certificateHash)
}
inline void AppDetails::add_certificatehash(std::string&& value) {
  _impl_.certificatehash_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.AppDetails.certificateHash)
}
inline void AppDetails::add_certificatehash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.certificatehash_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:playapi.proto.finsky.document.AppDetails.certificateHash)
}
inline void AppDetails::add_certificatehash(const char* value, size_t size) {
  _impl_.certificatehash_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:playapi.proto.finsky.document.AppDetails.certificateHash)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AppDetails::certificatehash() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.document.AppDetails.certificateHash)
  return _impl_.certificatehash_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AppDetails::mutable_certificatehash() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.document.AppDetails.certificateHash)
  return &_impl_.certificatehash_;
}

// optional bool variesByAccount = 21;
inline bool AppDetails::_internal_has_variesbyaccount() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool AppDetails::has_variesbyaccount() const {
  return _internal_has_variesbyaccount();
}
inline void AppDetails::clear_variesbyaccount() {
  _impl_.variesbyaccount_ = false;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline bool AppDetails::_internal_variesbyaccount() const {
  return _impl_.variesbyaccount_;
}
inline bool AppDetails::variesbyaccount() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.AppDetails.variesByAccount)
  return _internal_variesbyaccount();
}
inline void AppDetails::_internal_set_variesbyaccount(bool value) {
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.variesbyaccount_ = value;
}
inline void AppDetails::set_variesbyaccount(bool value) {
  _internal_set_variesbyaccount(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.AppDetails.variesByAccount)
}

// repeated .playapi.proto.finsky.CertificateSet certificateSet = 22;
inline int AppDetails::_internal_certificateset_size() const {
  return _impl_.certificateset_.size();
}
inline int AppDetails::certificateset_size() const {
  return _internal_certificateset_size();
}
inline ::playapi::proto::finsky::CertificateSet* AppDetails::mutable_certificateset(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.AppDetails.certificateSet)
  return _impl_.certificateset_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::CertificateSet >*
AppDetails::mutable_certificateset() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.document.AppDetails.certificateSet)
  return &_impl_.certificateset_;
}
inline const ::playapi::proto::finsky::CertificateSet& AppDetails::_internal_certificateset(int index) const {
  return _impl_.certificateset_.Get(index);
}
inline const ::playapi::proto::finsky::CertificateSet& AppDetails::certificateset(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.AppDetails.certificateSet)
  return _internal_certificateset(index);
}
inline ::playapi::proto::finsky::CertificateSet* AppDetails::_internal_add_certificateset() {
  return _impl_.certificateset_.Add();
}
inline ::playapi::proto::finsky::CertificateSet* AppDetails::add_certificateset() {
  ::playapi::proto::finsky::CertificateSet* _add = _internal_add_certificateset();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.AppDetails.certificateSet)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::CertificateSet >&
AppDetails::certificateset() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.document.AppDetails.certificateSet)
  return _impl_.certificateset_;
}

// repeated string autoAcquireFreeAppIfHigherVersionAvailableTag = 23;
inline int AppDetails::_internal_autoacquirefreeappifhigherversionavailabletag_size() const {
  return _impl_.autoacquirefreeappifhigherversionavailabletag_.size();
}
inline int AppDetails::autoacquirefreeappifhigherversionavailabletag_size() const {
  return _internal_autoacquirefreeappifhigherversionavailabletag_size();
}
inline void AppDetails::clear_autoacquirefreeappifhigherversionavailabletag() {
  _impl_.autoacquirefreeappifhigherversionavailabletag_.Clear();
}
inline std::string* AppDetails::add_autoacquirefreeappifhigherversionavailabletag() {
  std::string* _s = _internal_add_autoacquirefreeappifhigherversionavailabletag();
  // @@protoc_insertion_point(field_add_mutable:playapi.proto.finsky.document.AppDetails.autoAcquireFreeAppIfHigherVersionAvailableTag)
  return _s;
}
inline const std::string& AppDetails::_internal_autoacquirefreeappifhigherversionavailabletag(int index) const {
  return _impl_.autoacquirefreeappifhigherversionavailabletag_.Get(index);
}
inline const std::string& AppDetails::autoacquirefreeappifhigherversionavailabletag(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.AppDetails.autoAcquireFreeAppIfHigherVersionAvailableTag)
  return _internal_autoacquirefreeappifhigherversionavailabletag(index);
}
inline std::string* AppDetails::mutable_autoacquirefreeappifhigherversionavailabletag(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.AppDetails.autoAcquireFreeAppIfHigherVersionAvailableTag)
  return _impl_.autoacquirefreeappifhigherversionavailabletag_.Mutable(index);
}
inline void AppDetails::set_autoacquirefreeappifhigherversionavailabletag(int index, const std::string& value) {
  _impl_.autoacquirefreeappifhigherversionavailabletag_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.AppDetails.autoAcquireFreeAppIfHigherVersionAvailableTag)
}
inline void AppDetails::set_autoacquirefreeappifhigherversionavailabletag(int index, std::string&& value) {
  _impl_.autoacquirefreeappifhigherversionavailabletag_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.AppDetails.autoAcquireFreeAppIfHigherVersionAvailableTag)
}
inline void AppDetails::set_autoacquirefreeappifhigherversionavailabletag(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.autoacquirefreeappifhigherversionavailabletag_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:playapi.proto.finsky.document.AppDetails.autoAcquireFreeAppIfHigherVersionAvailableTag)
}
inline void AppDetails::set_autoacquirefreeappifhigherversionavailabletag(int index, const char* value, size_t size) {
  _impl_.autoacquirefreeappifhigherversionavailabletag_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:playapi.proto.finsky.document.AppDetails.autoAcquireFreeAppIfHigherVersionAvailableTag)
}
inline std::string* AppDetails::_internal_add_autoacquirefreeappifhigherversionavailabletag() {
  return _impl_.autoacquirefreeappifhigherversionavailabletag_.Add();
}
inline void AppDetails::add_autoacquirefreeappifhigherversionavailabletag(const std::string& value) {
  _impl_.autoacquirefreeappifhigherversionavailabletag_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.AppDetails.autoAcquireFreeAppIfHigherVersionAvailableTag)
}
inline void AppDetails::add_autoacquirefreeappifhigherversionavailabletag(std::string&& value) {
  _impl_.autoacquirefreeappifhigherversionavailabletag_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.AppDetails.autoAcquireFreeAppIfHigherVersionAvailableTag)
}
inline void AppDetails::add_autoacquirefreeappifhigherversionavailabletag(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.autoacquirefreeappifhigherversionavailabletag_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:playapi.proto.finsky.document.AppDetails.autoAcquireFreeAppIfHigherVersionAvailableTag)
}
inline void AppDetails::add_autoacquirefreeappifhigherversionavailabletag(const char* value, size_t size) {
  _impl_.autoacquirefreeappifhigherversionavailabletag_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:playapi.proto.finsky.document.AppDetails.autoAcquireFreeAppIfHigherVersionAvailableTag)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AppDetails::autoacquirefreeappifhigherversionavailabletag() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.document.AppDetails.autoAcquireFreeAppIfHigherVersionAvailableTag)
  return _impl_.autoacquirefreeappifhigherversionavailabletag_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AppDetails::mutable_autoacquirefreeappifhigherversionavailabletag() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.document.AppDetails.autoAcquireFreeAppIfHigherVersionAvailableTag)
  return &_impl_.autoacquirefreeappifhigherversionavailabletag_;
}

// optional bool declaresIab = 24;
inline bool AppDetails::_internal_has_declaresiab() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool AppDetails::has_declaresiab() const {
  return _internal_has_declaresiab();
}
inline void AppDetails::clear_declaresiab() {
  _impl_.declaresiab_ = false;
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline bool AppDetails::_internal_declaresiab() const {
  return _impl_.declaresiab_;
}
inline bool AppDetails::declaresiab() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.AppDetails.declaresIab)
  return _internal_declaresiab();
}
inline void AppDetails::_internal_set_declaresiab(bool value) {
  _impl_._has_bits_[0] |= 0x00080000u;
  _impl_.declaresiab_ = value;
}
inline void AppDetails::set_declaresiab(bool value) {
  _internal_set_declaresiab(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.AppDetails.declaresIab)
}

// repeated string splitId = 25;
inline int AppDetails::_internal_splitid_size() const {
  return _impl_.splitid_.size();
}
inline int AppDetails::splitid_size() const {
  return _internal_splitid_size();
}
inline void AppDetails::clear_splitid() {
  _impl_.splitid_.Clear();
}
inline std::string* AppDetails::add_splitid() {
  std::string* _s = _internal_add_splitid();
  // @@protoc_insertion_point(field_add_mutable:playapi.proto.finsky.document.AppDetails.splitId)
  return _s;
}
inline const std::string& AppDetails::_internal_splitid(int index) const {
  return _impl_.splitid_.Get(index);
}
inline const std::string& AppDetails::splitid(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.AppDetails.splitId)
  return _internal_splitid(index);
}
inline std::string* AppDetails::mutable_splitid(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.AppDetails.splitId)
  return _impl_.splitid_.Mutable(index);
}
inline void AppDetails::set_splitid(int index, const std::string& value) {
  _impl_.splitid_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.AppDetails.splitId)
}
inline void AppDetails::set_splitid(int index, std::string&& value) {
  _impl_.splitid_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.AppDetails.splitId)
}
inline void AppDetails::set_splitid(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.splitid_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:playapi.proto.finsky.document.AppDetails.splitId)
}
inline void AppDetails::set_splitid(int index, const char* value, size_t size) {
  _impl_.splitid_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:playapi.proto.finsky.document.AppDetails.splitId)
}
inline std::string* AppDetails::_internal_add_splitid() {
  return _impl_.splitid_.Add();
}
inline void AppDetails::add_splitid(const std::string& value) {
  _impl_.splitid_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.AppDetails.splitId)
}
inline void AppDetails::add_splitid(std::string&& value) {
  _impl_.splitid_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.AppDetails.splitId)
}
inline void AppDetails::add_splitid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.splitid_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:playapi.proto.finsky.document.AppDetails.splitId)
}
inline void AppDetails::add_splitid(const char* value, size_t size) {
  _impl_.splitid_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:playapi.proto.finsky.document.AppDetails.splitId)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AppDetails::splitid() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.document.AppDetails.splitId)
  return _impl_.splitid_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AppDetails::mutable_splitid() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.document.AppDetails.splitId)
  return &_impl_.splitid_;
}

// optional bool gamepadRequired = 26;
inline bool AppDetails::_internal_has_gamepadrequired() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool AppDetails::has_gamepadrequired() const {
  return _internal_has_gamepadrequired();
}
inline void AppDetails::clear_gamepadrequired() {
  _impl_.gamepadrequired_ = false;
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline bool AppDetails::_internal_gamepadrequired() const {
  return _impl_.gamepadrequired_;
}
inline bool AppDetails::gamepadrequired() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.AppDetails.gamepadRequired)
  return _internal_gamepadrequired();
}
inline void AppDetails::_internal_set_gamepadrequired(bool value) {
  _impl_._has_bits_[0] |= 0x00100000u;
  _impl_.gamepadrequired_ = value;
}
inline void AppDetails::set_gamepadrequired(bool value) {
  _internal_set_gamepadrequired(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.AppDetails.gamepadRequired)
}

// optional bool externallyHosted = 27;
inline bool AppDetails::_internal_has_externallyhosted() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool AppDetails::has_externallyhosted() const {
  return _internal_has_externallyhosted();
}
inline void AppDetails::clear_externallyhosted() {
  _impl_.externallyhosted_ = false;
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline bool AppDetails::_internal_externallyhosted() const {
  return _impl_.externallyhosted_;
}
inline bool AppDetails::externallyhosted() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.AppDetails.externallyHosted)
  return _internal_externallyhosted();
}
inline void AppDetails::_internal_set_externallyhosted(bool value) {
  _impl_._has_bits_[0] |= 0x00200000u;
  _impl_.externallyhosted_ = value;
}
inline void AppDetails::set_externallyhosted(bool value) {
  _internal_set_externallyhosted(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.AppDetails.externallyHosted)
}

// optional bool everExternallyHosted = 28;
inline bool AppDetails::_internal_has_everexternallyhosted() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool AppDetails::has_everexternallyhosted() const {
  return _internal_has_everexternallyhosted();
}
inline void AppDetails::clear_everexternallyhosted() {
  _impl_.everexternallyhosted_ = false;
  _impl_._has_bits_[0] &= ~0x00400000u;
}
inline bool AppDetails::_internal_everexternallyhosted() const {
  return _impl_.everexternallyhosted_;
}
inline bool AppDetails::everexternallyhosted() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.AppDetails.everExternallyHosted)
  return _internal_everexternallyhosted();
}
inline void AppDetails::_internal_set_everexternallyhosted(bool value) {
  _impl_._has_bits_[0] |= 0x00400000u;
  _impl_.everexternallyhosted_ = value;
}
inline void AppDetails::set_everexternallyhosted(bool value) {
  _internal_set_everexternallyhosted(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.AppDetails.everExternallyHosted)
}

// optional string installNotes = 30;
inline bool AppDetails::_internal_has_installnotes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool AppDetails::has_installnotes() const {
  return _internal_has_installnotes();
}
inline void AppDetails::clear_installnotes() {
  _impl_.installnotes_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const std::string& AppDetails::installnotes() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.AppDetails.installNotes)
  return _internal_installnotes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppDetails::set_installnotes(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000400u;
 _impl_.installnotes_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.AppDetails.installNotes)
}
inline std::string* AppDetails::mutable_installnotes() {
  std::string* _s = _internal_mutable_installnotes();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.AppDetails.installNotes)
  return _s;
}
inline const std::string& AppDetails::_internal_installnotes() const {
  return _impl_.installnotes_.Get();
}
inline void AppDetails::_internal_set_installnotes(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.installnotes_.Set(value, GetArenaForAllocation());
}
inline std::string* AppDetails::_internal_mutable_installnotes() {
  _impl_._has_bits_[0] |= 0x00000400u;
  return _impl_.installnotes_.Mutable(GetArenaForAllocation());
}
inline std::string* AppDetails::release_installnotes() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.AppDetails.installNotes)
  if (!_internal_has_installnotes()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000400u;
  auto* p = _impl_.installnotes_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.installnotes_.IsDefault()) {
    _impl_.installnotes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AppDetails::set_allocated_installnotes(std::string* installnotes) {
  if (installnotes != nullptr) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.installnotes_.SetAllocated(installnotes, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.installnotes_.IsDefault()) {
    _impl_.installnotes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.AppDetails.installNotes)
}

// optional int32 installLocation = 31;
inline bool AppDetails::_internal_has_installlocation() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool AppDetails::has_installlocation() const {
  return _internal_has_installlocation();
}
inline void AppDetails::clear_installlocation() {
  _impl_.installlocation_ = 0;
  _impl_._has_bits_[0] &= ~0x00800000u;
}
inline int32_t AppDetails::_internal_installlocation() const {
  return _impl_.installlocation_;
}
inline int32_t AppDetails::installlocation() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.AppDetails.installLocation)
  return _internal_installlocation();
}
inline void AppDetails::_internal_set_installlocation(int32_t value) {
  _impl_._has_bits_[0] |= 0x00800000u;
  _impl_.installlocation_ = value;
}
inline void AppDetails::set_installlocation(int32_t value) {
  _internal_set_installlocation(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.AppDetails.installLocation)
}

// optional int32 targetSdkVersion = 32;
inline bool AppDetails::_internal_has_targetsdkversion() const {
  bool value = (_impl_._has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool AppDetails::has_targetsdkversion() const {
  return _internal_has_targetsdkversion();
}
inline void AppDetails::clear_targetsdkversion() {
  _impl_.targetsdkversion_ = 0;
  _impl_._has_bits_[0] &= ~0x01000000u;
}
inline int32_t AppDetails::_internal_targetsdkversion() const {
  return _impl_.targetsdkversion_;
}
inline int32_t AppDetails::targetsdkversion() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.AppDetails.targetSdkVersion)
  return _internal_targetsdkversion();
}
inline void AppDetails::_internal_set_targetsdkversion(int32_t value) {
  _impl_._has_bits_[0] |= 0x01000000u;
  _impl_.targetsdkversion_ = value;
}
inline void AppDetails::set_targetsdkversion(int32_t value) {
  _internal_set_targetsdkversion(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.AppDetails.targetSdkVersion)
}

// optional string preregistrationPromoCode = 33;
inline bool AppDetails::_internal_has_preregistrationpromocode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool AppDetails::has_preregistrationpromocode() const {
  return _internal_has_preregistrationpromocode();
}
inline void AppDetails::clear_preregistrationpromocode() {
  _impl_.preregistrationpromocode_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline const std::string& AppDetails::preregistrationpromocode() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.AppDetails.preregistrationPromoCode)
  return _internal_preregistrationpromocode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppDetails::set_preregistrationpromocode(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000800u;
 _impl_.preregistrationpromocode_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.AppDetails.preregistrationPromoCode)
}
inline std::string* AppDetails::mutable_preregistrationpromocode() {
  std::string* _s = _internal_mutable_preregistrationpromocode();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.AppDetails.preregistrationPromoCode)
  return _s;
}
inline const std::string& AppDetails::_internal_preregistrationpromocode() const {
  return _impl_.preregistrationpromocode_.Get();
}
inline void AppDetails::_internal_set_preregistrationpromocode(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.preregistrationpromocode_.Set(value, GetArenaForAllocation());
}
inline std::string* AppDetails::_internal_mutable_preregistrationpromocode() {
  _impl_._has_bits_[0] |= 0x00000800u;
  return _impl_.preregistrationpromocode_.Mutable(GetArenaForAllocation());
}
inline std::string* AppDetails::release_preregistrationpromocode() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.AppDetails.preregistrationPromoCode)
  if (!_internal_has_preregistrationpromocode()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000800u;
  auto* p = _impl_.preregistrationpromocode_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.preregistrationpromocode_.IsDefault()) {
    _impl_.preregistrationpromocode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AppDetails::set_allocated_preregistrationpromocode(std::string* preregistrationpromocode) {
  if (preregistrationpromocode != nullptr) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  _impl_.preregistrationpromocode_.SetAllocated(preregistrationpromocode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.preregistrationpromocode_.IsDefault()) {
    _impl_.preregistrationpromocode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.AppDetails.preregistrationPromoCode)
}

// optional .playapi.proto.finsky.download.InstallDetails installDetails = 34;
inline bool AppDetails::_internal_has_installdetails() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.installdetails_ != nullptr);
  return value;
}
inline bool AppDetails::has_installdetails() const {
  return _internal_has_installdetails();
}
inline const ::playapi::proto::finsky::download::InstallDetails& AppDetails::_internal_installdetails() const {
  const ::playapi::proto::finsky::download::InstallDetails* p = _impl_.installdetails_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::download::InstallDetails&>(
      ::playapi::proto::finsky::download::_InstallDetails_default_instance_);
}
inline const ::playapi::proto::finsky::download::InstallDetails& AppDetails::installdetails() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.AppDetails.installDetails)
  return _internal_installdetails();
}
inline void AppDetails::unsafe_arena_set_allocated_installdetails(
    ::playapi::proto::finsky::download::InstallDetails* installdetails) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.installdetails_);
  }
  _impl_.installdetails_ = installdetails;
  if (installdetails) {
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.AppDetails.installDetails)
}
inline ::playapi::proto::finsky::download::InstallDetails* AppDetails::release_installdetails() {
  _impl_._has_bits_[0] &= ~0x00001000u;
  ::playapi::proto::finsky::download::InstallDetails* temp = _impl_.installdetails_;
  _impl_.installdetails_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::download::InstallDetails* AppDetails::unsafe_arena_release_installdetails() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.AppDetails.installDetails)
  _impl_._has_bits_[0] &= ~0x00001000u;
  ::playapi::proto::finsky::download::InstallDetails* temp = _impl_.installdetails_;
  _impl_.installdetails_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::download::InstallDetails* AppDetails::_internal_mutable_installdetails() {
  _impl_._has_bits_[0] |= 0x00001000u;
  if (_impl_.installdetails_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::download::InstallDetails>(GetArenaForAllocation());
    _impl_.installdetails_ = p;
  }
  return _impl_.installdetails_;
}
inline ::playapi::proto::finsky::download::InstallDetails* AppDetails::mutable_installdetails() {
  ::playapi::proto::finsky::download::InstallDetails* _msg = _internal_mutable_installdetails();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.AppDetails.installDetails)
  return _msg;
}
inline void AppDetails::set_allocated_installdetails(::playapi::proto::finsky::download::InstallDetails* installdetails) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.installdetails_);
  }
  if (installdetails) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(installdetails));
    if (message_arena != submessage_arena) {
      installdetails = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, installdetails, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  _impl_.installdetails_ = installdetails;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.AppDetails.installDetails)
}

// optional .playapi.proto.finsky.document.TestingProgramInfo testingProgramInfo = 35;
inline bool AppDetails::_internal_has_testingprograminfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.testingprograminfo_ != nullptr);
  return value;
}
inline bool AppDetails::has_testingprograminfo() const {
  return _internal_has_testingprograminfo();
}
inline void AppDetails::clear_testingprograminfo() {
  if (_impl_.testingprograminfo_ != nullptr) _impl_.testingprograminfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline const ::playapi::proto::finsky::document::TestingProgramInfo& AppDetails::_internal_testingprograminfo() const {
  const ::playapi::proto::finsky::document::TestingProgramInfo* p = _impl_.testingprograminfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::TestingProgramInfo&>(
      ::playapi::proto::finsky::document::_TestingProgramInfo_default_instance_);
}
inline const ::playapi::proto::finsky::document::TestingProgramInfo& AppDetails::testingprograminfo() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.AppDetails.testingProgramInfo)
  return _internal_testingprograminfo();
}
inline void AppDetails::unsafe_arena_set_allocated_testingprograminfo(
    ::playapi::proto::finsky::document::TestingProgramInfo* testingprograminfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.testingprograminfo_);
  }
  _impl_.testingprograminfo_ = testingprograminfo;
  if (testingprograminfo) {
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.AppDetails.testingProgramInfo)
}
inline ::playapi::proto::finsky::document::TestingProgramInfo* AppDetails::release_testingprograminfo() {
  _impl_._has_bits_[0] &= ~0x00002000u;
  ::playapi::proto::finsky::document::TestingProgramInfo* temp = _impl_.testingprograminfo_;
  _impl_.testingprograminfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::TestingProgramInfo* AppDetails::unsafe_arena_release_testingprograminfo() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.AppDetails.testingProgramInfo)
  _impl_._has_bits_[0] &= ~0x00002000u;
  ::playapi::proto::finsky::document::TestingProgramInfo* temp = _impl_.testingprograminfo_;
  _impl_.testingprograminfo_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::TestingProgramInfo* AppDetails::_internal_mutable_testingprograminfo() {
  _impl_._has_bits_[0] |= 0x00002000u;
  if (_impl_.testingprograminfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::TestingProgramInfo>(GetArenaForAllocation());
    _impl_.testingprograminfo_ = p;
  }
  return _impl_.testingprograminfo_;
}
inline ::playapi::proto::finsky::document::TestingProgramInfo* AppDetails::mutable_testingprograminfo() {
  ::playapi::proto::finsky::document::TestingProgramInfo* _msg = _internal_mutable_testingprograminfo();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.AppDetails.testingProgramInfo)
  return _msg;
}
inline void AppDetails::set_allocated_testingprograminfo(::playapi::proto::finsky::document::TestingProgramInfo* testingprograminfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.testingprograminfo_;
  }
  if (testingprograminfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(testingprograminfo);
    if (message_arena != submessage_arena) {
      testingprograminfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, testingprograminfo, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  _impl_.testingprograminfo_ = testingprograminfo;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.AppDetails.testingProgramInfo)
}

// -------------------------------------------------------------------

// TestingProgramInfo

// optional bool subscribed = 2;
inline bool TestingProgramInfo::_internal_has_subscribed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TestingProgramInfo::has_subscribed() const {
  return _internal_has_subscribed();
}
inline void TestingProgramInfo::clear_subscribed() {
  _impl_.subscribed_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool TestingProgramInfo::_internal_subscribed() const {
  return _impl_.subscribed_;
}
inline bool TestingProgramInfo::subscribed() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.TestingProgramInfo.subscribed)
  return _internal_subscribed();
}
inline void TestingProgramInfo::_internal_set_subscribed(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.subscribed_ = value;
}
inline void TestingProgramInfo::set_subscribed(bool value) {
  _internal_set_subscribed(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.TestingProgramInfo.subscribed)
}

// optional bool subscribed1 = 3;
inline bool TestingProgramInfo::_internal_has_subscribed1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TestingProgramInfo::has_subscribed1() const {
  return _internal_has_subscribed1();
}
inline void TestingProgramInfo::clear_subscribed1() {
  _impl_.subscribed1_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool TestingProgramInfo::_internal_subscribed1() const {
  return _impl_.subscribed1_;
}
inline bool TestingProgramInfo::subscribed1() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.TestingProgramInfo.subscribed1)
  return _internal_subscribed1();
}
inline void TestingProgramInfo::_internal_set_subscribed1(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.subscribed1_ = value;
}
inline void TestingProgramInfo::set_subscribed1(bool value) {
  _internal_set_subscribed1(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.TestingProgramInfo.subscribed1)
}

// -------------------------------------------------------------------

// AlbumDetails

// optional string name = 1;
inline bool AlbumDetails::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AlbumDetails::has_name() const {
  return _internal_has_name();
}
inline void AlbumDetails::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AlbumDetails::name() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.AlbumDetails.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AlbumDetails::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.AlbumDetails.name)
}
inline std::string* AlbumDetails::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.AlbumDetails.name)
  return _s;
}
inline const std::string& AlbumDetails::_internal_name() const {
  return _impl_.name_.Get();
}
inline void AlbumDetails::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* AlbumDetails::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* AlbumDetails::release_name() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.AlbumDetails.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AlbumDetails::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.AlbumDetails.name)
}

// optional .playapi.proto.finsky.document.MusicDetails details = 2;
inline bool AlbumDetails::_internal_has_details() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.details_ != nullptr);
  return value;
}
inline bool AlbumDetails::has_details() const {
  return _internal_has_details();
}
inline void AlbumDetails::clear_details() {
  if (_impl_.details_ != nullptr) _impl_.details_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::playapi::proto::finsky::document::MusicDetails& AlbumDetails::_internal_details() const {
  const ::playapi::proto::finsky::document::MusicDetails* p = _impl_.details_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::MusicDetails&>(
      ::playapi::proto::finsky::document::_MusicDetails_default_instance_);
}
inline const ::playapi::proto::finsky::document::MusicDetails& AlbumDetails::details() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.AlbumDetails.details)
  return _internal_details();
}
inline void AlbumDetails::unsafe_arena_set_allocated_details(
    ::playapi::proto::finsky::document::MusicDetails* details) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.details_);
  }
  _impl_.details_ = details;
  if (details) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.AlbumDetails.details)
}
inline ::playapi::proto::finsky::document::MusicDetails* AlbumDetails::release_details() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::playapi::proto::finsky::document::MusicDetails* temp = _impl_.details_;
  _impl_.details_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::MusicDetails* AlbumDetails::unsafe_arena_release_details() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.AlbumDetails.details)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::playapi::proto::finsky::document::MusicDetails* temp = _impl_.details_;
  _impl_.details_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::MusicDetails* AlbumDetails::_internal_mutable_details() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.details_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::MusicDetails>(GetArenaForAllocation());
    _impl_.details_ = p;
  }
  return _impl_.details_;
}
inline ::playapi::proto::finsky::document::MusicDetails* AlbumDetails::mutable_details() {
  ::playapi::proto::finsky::document::MusicDetails* _msg = _internal_mutable_details();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.AlbumDetails.details)
  return _msg;
}
inline void AlbumDetails::set_allocated_details(::playapi::proto::finsky::document::MusicDetails* details) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.details_;
  }
  if (details) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(details);
    if (message_arena != submessage_arena) {
      details = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, details, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.details_ = details;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.AlbumDetails.details)
}

// optional .playapi.proto.finsky.document.ArtistDetails displayArtist = 3;
inline bool AlbumDetails::_internal_has_displayartist() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.displayartist_ != nullptr);
  return value;
}
inline bool AlbumDetails::has_displayartist() const {
  return _internal_has_displayartist();
}
inline void AlbumDetails::clear_displayartist() {
  if (_impl_.displayartist_ != nullptr) _impl_.displayartist_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::playapi::proto::finsky::document::ArtistDetails& AlbumDetails::_internal_displayartist() const {
  const ::playapi::proto::finsky::document::ArtistDetails* p = _impl_.displayartist_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::ArtistDetails&>(
      ::playapi::proto::finsky::document::_ArtistDetails_default_instance_);
}
inline const ::playapi::proto::finsky::document::ArtistDetails& AlbumDetails::displayartist() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.AlbumDetails.displayArtist)
  return _internal_displayartist();
}
inline void AlbumDetails::unsafe_arena_set_allocated_displayartist(
    ::playapi::proto::finsky::document::ArtistDetails* displayartist) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.displayartist_);
  }
  _impl_.displayartist_ = displayartist;
  if (displayartist) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.AlbumDetails.displayArtist)
}
inline ::playapi::proto::finsky::document::ArtistDetails* AlbumDetails::release_displayartist() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::playapi::proto::finsky::document::ArtistDetails* temp = _impl_.displayartist_;
  _impl_.displayartist_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::ArtistDetails* AlbumDetails::unsafe_arena_release_displayartist() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.AlbumDetails.displayArtist)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::playapi::proto::finsky::document::ArtistDetails* temp = _impl_.displayartist_;
  _impl_.displayartist_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::ArtistDetails* AlbumDetails::_internal_mutable_displayartist() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.displayartist_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::ArtistDetails>(GetArenaForAllocation());
    _impl_.displayartist_ = p;
  }
  return _impl_.displayartist_;
}
inline ::playapi::proto::finsky::document::ArtistDetails* AlbumDetails::mutable_displayartist() {
  ::playapi::proto::finsky::document::ArtistDetails* _msg = _internal_mutable_displayartist();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.AlbumDetails.displayArtist)
  return _msg;
}
inline void AlbumDetails::set_allocated_displayartist(::playapi::proto::finsky::document::ArtistDetails* displayartist) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.displayartist_;
  }
  if (displayartist) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(displayartist);
    if (message_arena != submessage_arena) {
      displayartist = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, displayartist, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.displayartist_ = displayartist;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.AlbumDetails.displayArtist)
}

// -------------------------------------------------------------------

// MusicDetails

// optional int32 censoring = 1;
inline bool MusicDetails::_internal_has_censoring() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MusicDetails::has_censoring() const {
  return _internal_has_censoring();
}
inline void MusicDetails::clear_censoring() {
  _impl_.censoring_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t MusicDetails::_internal_censoring() const {
  return _impl_.censoring_;
}
inline int32_t MusicDetails::censoring() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.MusicDetails.censoring)
  return _internal_censoring();
}
inline void MusicDetails::_internal_set_censoring(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.censoring_ = value;
}
inline void MusicDetails::set_censoring(int32_t value) {
  _internal_set_censoring(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.MusicDetails.censoring)
}

// optional int32 durationSec = 2;
inline bool MusicDetails::_internal_has_durationsec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MusicDetails::has_durationsec() const {
  return _internal_has_durationsec();
}
inline void MusicDetails::clear_durationsec() {
  _impl_.durationsec_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t MusicDetails::_internal_durationsec() const {
  return _impl_.durationsec_;
}
inline int32_t MusicDetails::durationsec() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.MusicDetails.durationSec)
  return _internal_durationsec();
}
inline void MusicDetails::_internal_set_durationsec(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.durationsec_ = value;
}
inline void MusicDetails::set_durationsec(int32_t value) {
  _internal_set_durationsec(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.MusicDetails.durationSec)
}

// optional string originalReleaseDate = 3;
inline bool MusicDetails::_internal_has_originalreleasedate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MusicDetails::has_originalreleasedate() const {
  return _internal_has_originalreleasedate();
}
inline void MusicDetails::clear_originalreleasedate() {
  _impl_.originalreleasedate_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MusicDetails::originalreleasedate() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.MusicDetails.originalReleaseDate)
  return _internal_originalreleasedate();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MusicDetails::set_originalreleasedate(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.originalreleasedate_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.MusicDetails.originalReleaseDate)
}
inline std::string* MusicDetails::mutable_originalreleasedate() {
  std::string* _s = _internal_mutable_originalreleasedate();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.MusicDetails.originalReleaseDate)
  return _s;
}
inline const std::string& MusicDetails::_internal_originalreleasedate() const {
  return _impl_.originalreleasedate_.Get();
}
inline void MusicDetails::_internal_set_originalreleasedate(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.originalreleasedate_.Set(value, GetArenaForAllocation());
}
inline std::string* MusicDetails::_internal_mutable_originalreleasedate() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.originalreleasedate_.Mutable(GetArenaForAllocation());
}
inline std::string* MusicDetails::release_originalreleasedate() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.MusicDetails.originalReleaseDate)
  if (!_internal_has_originalreleasedate()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.originalreleasedate_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.originalreleasedate_.IsDefault()) {
    _impl_.originalreleasedate_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MusicDetails::set_allocated_originalreleasedate(std::string* originalreleasedate) {
  if (originalreleasedate != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.originalreleasedate_.SetAllocated(originalreleasedate, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.originalreleasedate_.IsDefault()) {
    _impl_.originalreleasedate_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.MusicDetails.originalReleaseDate)
}

// optional string label = 4;
inline bool MusicDetails::_internal_has_label() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MusicDetails::has_label() const {
  return _internal_has_label();
}
inline void MusicDetails::clear_label() {
  _impl_.label_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MusicDetails::label() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.MusicDetails.label)
  return _internal_label();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MusicDetails::set_label(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.label_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.MusicDetails.label)
}
inline std::string* MusicDetails::mutable_label() {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.MusicDetails.label)
  return _s;
}
inline const std::string& MusicDetails::_internal_label() const {
  return _impl_.label_.Get();
}
inline void MusicDetails::_internal_set_label(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.label_.Set(value, GetArenaForAllocation());
}
inline std::string* MusicDetails::_internal_mutable_label() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.label_.Mutable(GetArenaForAllocation());
}
inline std::string* MusicDetails::release_label() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.MusicDetails.label)
  if (!_internal_has_label()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.label_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.label_.IsDefault()) {
    _impl_.label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MusicDetails::set_allocated_label(std::string* label) {
  if (label != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.label_.SetAllocated(label, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.label_.IsDefault()) {
    _impl_.label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.MusicDetails.label)
}

// repeated .playapi.proto.finsky.document.ArtistDetails artist = 5;
inline int MusicDetails::_internal_artist_size() const {
  return _impl_.artist_.size();
}
inline int MusicDetails::artist_size() const {
  return _internal_artist_size();
}
inline void MusicDetails::clear_artist() {
  _impl_.artist_.Clear();
}
inline ::playapi::proto::finsky::document::ArtistDetails* MusicDetails::mutable_artist(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.MusicDetails.artist)
  return _impl_.artist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::ArtistDetails >*
MusicDetails::mutable_artist() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.document.MusicDetails.artist)
  return &_impl_.artist_;
}
inline const ::playapi::proto::finsky::document::ArtistDetails& MusicDetails::_internal_artist(int index) const {
  return _impl_.artist_.Get(index);
}
inline const ::playapi::proto::finsky::document::ArtistDetails& MusicDetails::artist(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.MusicDetails.artist)
  return _internal_artist(index);
}
inline ::playapi::proto::finsky::document::ArtistDetails* MusicDetails::_internal_add_artist() {
  return _impl_.artist_.Add();
}
inline ::playapi::proto::finsky::document::ArtistDetails* MusicDetails::add_artist() {
  ::playapi::proto::finsky::document::ArtistDetails* _add = _internal_add_artist();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.MusicDetails.artist)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::ArtistDetails >&
MusicDetails::artist() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.document.MusicDetails.artist)
  return _impl_.artist_;
}

// repeated string genre = 6;
inline int MusicDetails::_internal_genre_size() const {
  return _impl_.genre_.size();
}
inline int MusicDetails::genre_size() const {
  return _internal_genre_size();
}
inline void MusicDetails::clear_genre() {
  _impl_.genre_.Clear();
}
inline std::string* MusicDetails::add_genre() {
  std::string* _s = _internal_add_genre();
  // @@protoc_insertion_point(field_add_mutable:playapi.proto.finsky.document.MusicDetails.genre)
  return _s;
}
inline const std::string& MusicDetails::_internal_genre(int index) const {
  return _impl_.genre_.Get(index);
}
inline const std::string& MusicDetails::genre(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.MusicDetails.genre)
  return _internal_genre(index);
}
inline std::string* MusicDetails::mutable_genre(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.MusicDetails.genre)
  return _impl_.genre_.Mutable(index);
}
inline void MusicDetails::set_genre(int index, const std::string& value) {
  _impl_.genre_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.MusicDetails.genre)
}
inline void MusicDetails::set_genre(int index, std::string&& value) {
  _impl_.genre_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.MusicDetails.genre)
}
inline void MusicDetails::set_genre(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.genre_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:playapi.proto.finsky.document.MusicDetails.genre)
}
inline void MusicDetails::set_genre(int index, const char* value, size_t size) {
  _impl_.genre_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:playapi.proto.finsky.document.MusicDetails.genre)
}
inline std::string* MusicDetails::_internal_add_genre() {
  return _impl_.genre_.Add();
}
inline void MusicDetails::add_genre(const std::string& value) {
  _impl_.genre_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.MusicDetails.genre)
}
inline void MusicDetails::add_genre(std::string&& value) {
  _impl_.genre_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.MusicDetails.genre)
}
inline void MusicDetails::add_genre(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.genre_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:playapi.proto.finsky.document.MusicDetails.genre)
}
inline void MusicDetails::add_genre(const char* value, size_t size) {
  _impl_.genre_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:playapi.proto.finsky.document.MusicDetails.genre)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MusicDetails::genre() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.document.MusicDetails.genre)
  return _impl_.genre_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MusicDetails::mutable_genre() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.document.MusicDetails.genre)
  return &_impl_.genre_;
}

// optional string releaseDate = 7;
inline bool MusicDetails::_internal_has_releasedate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MusicDetails::has_releasedate() const {
  return _internal_has_releasedate();
}
inline void MusicDetails::clear_releasedate() {
  _impl_.releasedate_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& MusicDetails::releasedate() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.MusicDetails.releaseDate)
  return _internal_releasedate();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MusicDetails::set_releasedate(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.releasedate_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.MusicDetails.releaseDate)
}
inline std::string* MusicDetails::mutable_releasedate() {
  std::string* _s = _internal_mutable_releasedate();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.MusicDetails.releaseDate)
  return _s;
}
inline const std::string& MusicDetails::_internal_releasedate() const {
  return _impl_.releasedate_.Get();
}
inline void MusicDetails::_internal_set_releasedate(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.releasedate_.Set(value, GetArenaForAllocation());
}
inline std::string* MusicDetails::_internal_mutable_releasedate() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.releasedate_.Mutable(GetArenaForAllocation());
}
inline std::string* MusicDetails::release_releasedate() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.MusicDetails.releaseDate)
  if (!_internal_has_releasedate()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.releasedate_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.releasedate_.IsDefault()) {
    _impl_.releasedate_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MusicDetails::set_allocated_releasedate(std::string* releasedate) {
  if (releasedate != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.releasedate_.SetAllocated(releasedate, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.releasedate_.IsDefault()) {
    _impl_.releasedate_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.MusicDetails.releaseDate)
}

// repeated int32 releaseType = 8;
inline int MusicDetails::_internal_releasetype_size() const {
  return _impl_.releasetype_.size();
}
inline int MusicDetails::releasetype_size() const {
  return _internal_releasetype_size();
}
inline void MusicDetails::clear_releasetype() {
  _impl_.releasetype_.Clear();
}
inline int32_t MusicDetails::_internal_releasetype(int index) const {
  return _impl_.releasetype_.Get(index);
}
inline int32_t MusicDetails::releasetype(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.MusicDetails.releaseType)
  return _internal_releasetype(index);
}
inline void MusicDetails::set_releasetype(int index, int32_t value) {
  _impl_.releasetype_.Set(index, value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.MusicDetails.releaseType)
}
inline void MusicDetails::_internal_add_releasetype(int32_t value) {
  _impl_.releasetype_.Add(value);
}
inline void MusicDetails::add_releasetype(int32_t value) {
  _internal_add_releasetype(value);
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.MusicDetails.releaseType)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
MusicDetails::_internal_releasetype() const {
  return _impl_.releasetype_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
MusicDetails::releasetype() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.document.MusicDetails.releaseType)
  return _internal_releasetype();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
MusicDetails::_internal_mutable_releasetype() {
  return &_impl_.releasetype_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
MusicDetails::mutable_releasetype() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.document.MusicDetails.releaseType)
  return _internal_mutable_releasetype();
}

// -------------------------------------------------------------------

// ArtistDetails

// optional string detailsUrl = 1;
inline bool ArtistDetails::_internal_has_detailsurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ArtistDetails::has_detailsurl() const {
  return _internal_has_detailsurl();
}
inline void ArtistDetails::clear_detailsurl() {
  _impl_.detailsurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ArtistDetails::detailsurl() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.ArtistDetails.detailsUrl)
  return _internal_detailsurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ArtistDetails::set_detailsurl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.detailsurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.ArtistDetails.detailsUrl)
}
inline std::string* ArtistDetails::mutable_detailsurl() {
  std::string* _s = _internal_mutable_detailsurl();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.ArtistDetails.detailsUrl)
  return _s;
}
inline const std::string& ArtistDetails::_internal_detailsurl() const {
  return _impl_.detailsurl_.Get();
}
inline void ArtistDetails::_internal_set_detailsurl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.detailsurl_.Set(value, GetArenaForAllocation());
}
inline std::string* ArtistDetails::_internal_mutable_detailsurl() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.detailsurl_.Mutable(GetArenaForAllocation());
}
inline std::string* ArtistDetails::release_detailsurl() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.ArtistDetails.detailsUrl)
  if (!_internal_has_detailsurl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.detailsurl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.detailsurl_.IsDefault()) {
    _impl_.detailsurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ArtistDetails::set_allocated_detailsurl(std::string* detailsurl) {
  if (detailsurl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.detailsurl_.SetAllocated(detailsurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.detailsurl_.IsDefault()) {
    _impl_.detailsurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.ArtistDetails.detailsUrl)
}

// optional string name = 2;
inline bool ArtistDetails::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ArtistDetails::has_name() const {
  return _internal_has_name();
}
inline void ArtistDetails::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ArtistDetails::name() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.ArtistDetails.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ArtistDetails::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.ArtistDetails.name)
}
inline std::string* ArtistDetails::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.ArtistDetails.name)
  return _s;
}
inline const std::string& ArtistDetails::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ArtistDetails::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ArtistDetails::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ArtistDetails::release_name() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.ArtistDetails.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ArtistDetails::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.ArtistDetails.name)
}

// optional .playapi.proto.finsky.document.ArtistExternalLinks externalLinks = 3;
inline bool ArtistDetails::_internal_has_externallinks() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.externallinks_ != nullptr);
  return value;
}
inline bool ArtistDetails::has_externallinks() const {
  return _internal_has_externallinks();
}
inline void ArtistDetails::clear_externallinks() {
  if (_impl_.externallinks_ != nullptr) _impl_.externallinks_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::playapi::proto::finsky::document::ArtistExternalLinks& ArtistDetails::_internal_externallinks() const {
  const ::playapi::proto::finsky::document::ArtistExternalLinks* p = _impl_.externallinks_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::ArtistExternalLinks&>(
      ::playapi::proto::finsky::document::_ArtistExternalLinks_default_instance_);
}
inline const ::playapi::proto::finsky::document::ArtistExternalLinks& ArtistDetails::externallinks() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.ArtistDetails.externalLinks)
  return _internal_externallinks();
}
inline void ArtistDetails::unsafe_arena_set_allocated_externallinks(
    ::playapi::proto::finsky::document::ArtistExternalLinks* externallinks) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.externallinks_);
  }
  _impl_.externallinks_ = externallinks;
  if (externallinks) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.ArtistDetails.externalLinks)
}
inline ::playapi::proto::finsky::document::ArtistExternalLinks* ArtistDetails::release_externallinks() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::playapi::proto::finsky::document::ArtistExternalLinks* temp = _impl_.externallinks_;
  _impl_.externallinks_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::ArtistExternalLinks* ArtistDetails::unsafe_arena_release_externallinks() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.ArtistDetails.externalLinks)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::playapi::proto::finsky::document::ArtistExternalLinks* temp = _impl_.externallinks_;
  _impl_.externallinks_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::ArtistExternalLinks* ArtistDetails::_internal_mutable_externallinks() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.externallinks_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::ArtistExternalLinks>(GetArenaForAllocation());
    _impl_.externallinks_ = p;
  }
  return _impl_.externallinks_;
}
inline ::playapi::proto::finsky::document::ArtistExternalLinks* ArtistDetails::mutable_externallinks() {
  ::playapi::proto::finsky::document::ArtistExternalLinks* _msg = _internal_mutable_externallinks();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.ArtistDetails.externalLinks)
  return _msg;
}
inline void ArtistDetails::set_allocated_externallinks(::playapi::proto::finsky::document::ArtistExternalLinks* externallinks) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.externallinks_;
  }
  if (externallinks) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(externallinks);
    if (message_arena != submessage_arena) {
      externallinks = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, externallinks, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.externallinks_ = externallinks;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.ArtistDetails.externalLinks)
}

// -------------------------------------------------------------------

// ArtistExternalLinks

// repeated string websiteUrl = 1;
inline int ArtistExternalLinks::_internal_websiteurl_size() const {
  return _impl_.websiteurl_.size();
}
inline int ArtistExternalLinks::websiteurl_size() const {
  return _internal_websiteurl_size();
}
inline void ArtistExternalLinks::clear_websiteurl() {
  _impl_.websiteurl_.Clear();
}
inline std::string* ArtistExternalLinks::add_websiteurl() {
  std::string* _s = _internal_add_websiteurl();
  // @@protoc_insertion_point(field_add_mutable:playapi.proto.finsky.document.ArtistExternalLinks.websiteUrl)
  return _s;
}
inline const std::string& ArtistExternalLinks::_internal_websiteurl(int index) const {
  return _impl_.websiteurl_.Get(index);
}
inline const std::string& ArtistExternalLinks::websiteurl(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.ArtistExternalLinks.websiteUrl)
  return _internal_websiteurl(index);
}
inline std::string* ArtistExternalLinks::mutable_websiteurl(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.ArtistExternalLinks.websiteUrl)
  return _impl_.websiteurl_.Mutable(index);
}
inline void ArtistExternalLinks::set_websiteurl(int index, const std::string& value) {
  _impl_.websiteurl_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.ArtistExternalLinks.websiteUrl)
}
inline void ArtistExternalLinks::set_websiteurl(int index, std::string&& value) {
  _impl_.websiteurl_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.ArtistExternalLinks.websiteUrl)
}
inline void ArtistExternalLinks::set_websiteurl(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.websiteurl_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:playapi.proto.finsky.document.ArtistExternalLinks.websiteUrl)
}
inline void ArtistExternalLinks::set_websiteurl(int index, const char* value, size_t size) {
  _impl_.websiteurl_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:playapi.proto.finsky.document.ArtistExternalLinks.websiteUrl)
}
inline std::string* ArtistExternalLinks::_internal_add_websiteurl() {
  return _impl_.websiteurl_.Add();
}
inline void ArtistExternalLinks::add_websiteurl(const std::string& value) {
  _impl_.websiteurl_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.ArtistExternalLinks.websiteUrl)
}
inline void ArtistExternalLinks::add_websiteurl(std::string&& value) {
  _impl_.websiteurl_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.ArtistExternalLinks.websiteUrl)
}
inline void ArtistExternalLinks::add_websiteurl(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.websiteurl_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:playapi.proto.finsky.document.ArtistExternalLinks.websiteUrl)
}
inline void ArtistExternalLinks::add_websiteurl(const char* value, size_t size) {
  _impl_.websiteurl_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:playapi.proto.finsky.document.ArtistExternalLinks.websiteUrl)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ArtistExternalLinks::websiteurl() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.document.ArtistExternalLinks.websiteUrl)
  return _impl_.websiteurl_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ArtistExternalLinks::mutable_websiteurl() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.document.ArtistExternalLinks.websiteUrl)
  return &_impl_.websiteurl_;
}

// optional string googlePlusProfileUrl = 2;
inline bool ArtistExternalLinks::_internal_has_googleplusprofileurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ArtistExternalLinks::has_googleplusprofileurl() const {
  return _internal_has_googleplusprofileurl();
}
inline void ArtistExternalLinks::clear_googleplusprofileurl() {
  _impl_.googleplusprofileurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ArtistExternalLinks::googleplusprofileurl() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.ArtistExternalLinks.googlePlusProfileUrl)
  return _internal_googleplusprofileurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ArtistExternalLinks::set_googleplusprofileurl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.googleplusprofileurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.ArtistExternalLinks.googlePlusProfileUrl)
}
inline std::string* ArtistExternalLinks::mutable_googleplusprofileurl() {
  std::string* _s = _internal_mutable_googleplusprofileurl();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.ArtistExternalLinks.googlePlusProfileUrl)
  return _s;
}
inline const std::string& ArtistExternalLinks::_internal_googleplusprofileurl() const {
  return _impl_.googleplusprofileurl_.Get();
}
inline void ArtistExternalLinks::_internal_set_googleplusprofileurl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.googleplusprofileurl_.Set(value, GetArenaForAllocation());
}
inline std::string* ArtistExternalLinks::_internal_mutable_googleplusprofileurl() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.googleplusprofileurl_.Mutable(GetArenaForAllocation());
}
inline std::string* ArtistExternalLinks::release_googleplusprofileurl() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.ArtistExternalLinks.googlePlusProfileUrl)
  if (!_internal_has_googleplusprofileurl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.googleplusprofileurl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.googleplusprofileurl_.IsDefault()) {
    _impl_.googleplusprofileurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ArtistExternalLinks::set_allocated_googleplusprofileurl(std::string* googleplusprofileurl) {
  if (googleplusprofileurl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.googleplusprofileurl_.SetAllocated(googleplusprofileurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.googleplusprofileurl_.IsDefault()) {
    _impl_.googleplusprofileurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.ArtistExternalLinks.googlePlusProfileUrl)
}

// optional string youtubeChannelUrl = 3;
inline bool ArtistExternalLinks::_internal_has_youtubechannelurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ArtistExternalLinks::has_youtubechannelurl() const {
  return _internal_has_youtubechannelurl();
}
inline void ArtistExternalLinks::clear_youtubechannelurl() {
  _impl_.youtubechannelurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ArtistExternalLinks::youtubechannelurl() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.ArtistExternalLinks.youtubeChannelUrl)
  return _internal_youtubechannelurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ArtistExternalLinks::set_youtubechannelurl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.youtubechannelurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.ArtistExternalLinks.youtubeChannelUrl)
}
inline std::string* ArtistExternalLinks::mutable_youtubechannelurl() {
  std::string* _s = _internal_mutable_youtubechannelurl();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.ArtistExternalLinks.youtubeChannelUrl)
  return _s;
}
inline const std::string& ArtistExternalLinks::_internal_youtubechannelurl() const {
  return _impl_.youtubechannelurl_.Get();
}
inline void ArtistExternalLinks::_internal_set_youtubechannelurl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.youtubechannelurl_.Set(value, GetArenaForAllocation());
}
inline std::string* ArtistExternalLinks::_internal_mutable_youtubechannelurl() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.youtubechannelurl_.Mutable(GetArenaForAllocation());
}
inline std::string* ArtistExternalLinks::release_youtubechannelurl() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.ArtistExternalLinks.youtubeChannelUrl)
  if (!_internal_has_youtubechannelurl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.youtubechannelurl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.youtubechannelurl_.IsDefault()) {
    _impl_.youtubechannelurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ArtistExternalLinks::set_allocated_youtubechannelurl(std::string* youtubechannelurl) {
  if (youtubechannelurl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.youtubechannelurl_.SetAllocated(youtubechannelurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.youtubechannelurl_.IsDefault()) {
    _impl_.youtubechannelurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.ArtistExternalLinks.youtubeChannelUrl)
}

// -------------------------------------------------------------------

// SongDetails

// optional string name = 1;
inline bool SongDetails::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SongDetails::has_name() const {
  return _internal_has_name();
}
inline void SongDetails::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SongDetails::name() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.SongDetails.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SongDetails::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.SongDetails.name)
}
inline std::string* SongDetails::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.SongDetails.name)
  return _s;
}
inline const std::string& SongDetails::_internal_name() const {
  return _impl_.name_.Get();
}
inline void SongDetails::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* SongDetails::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* SongDetails::release_name() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.SongDetails.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SongDetails::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.SongDetails.name)
}

// optional .playapi.proto.finsky.document.MusicDetails details = 2;
inline bool SongDetails::_internal_has_details() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.details_ != nullptr);
  return value;
}
inline bool SongDetails::has_details() const {
  return _internal_has_details();
}
inline void SongDetails::clear_details() {
  if (_impl_.details_ != nullptr) _impl_.details_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::playapi::proto::finsky::document::MusicDetails& SongDetails::_internal_details() const {
  const ::playapi::proto::finsky::document::MusicDetails* p = _impl_.details_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::MusicDetails&>(
      ::playapi::proto::finsky::document::_MusicDetails_default_instance_);
}
inline const ::playapi::proto::finsky::document::MusicDetails& SongDetails::details() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.SongDetails.details)
  return _internal_details();
}
inline void SongDetails::unsafe_arena_set_allocated_details(
    ::playapi::proto::finsky::document::MusicDetails* details) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.details_);
  }
  _impl_.details_ = details;
  if (details) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.SongDetails.details)
}
inline ::playapi::proto::finsky::document::MusicDetails* SongDetails::release_details() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::playapi::proto::finsky::document::MusicDetails* temp = _impl_.details_;
  _impl_.details_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::MusicDetails* SongDetails::unsafe_arena_release_details() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.SongDetails.details)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::playapi::proto::finsky::document::MusicDetails* temp = _impl_.details_;
  _impl_.details_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::MusicDetails* SongDetails::_internal_mutable_details() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.details_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::MusicDetails>(GetArenaForAllocation());
    _impl_.details_ = p;
  }
  return _impl_.details_;
}
inline ::playapi::proto::finsky::document::MusicDetails* SongDetails::mutable_details() {
  ::playapi::proto::finsky::document::MusicDetails* _msg = _internal_mutable_details();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.SongDetails.details)
  return _msg;
}
inline void SongDetails::set_allocated_details(::playapi::proto::finsky::document::MusicDetails* details) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.details_;
  }
  if (details) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(details);
    if (message_arena != submessage_arena) {
      details = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, details, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.details_ = details;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.SongDetails.details)
}

// optional string albumName = 3;
inline bool SongDetails::_internal_has_albumname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SongDetails::has_albumname() const {
  return _internal_has_albumname();
}
inline void SongDetails::clear_albumname() {
  _impl_.albumname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SongDetails::albumname() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.SongDetails.albumName)
  return _internal_albumname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SongDetails::set_albumname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.albumname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.SongDetails.albumName)
}
inline std::string* SongDetails::mutable_albumname() {
  std::string* _s = _internal_mutable_albumname();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.SongDetails.albumName)
  return _s;
}
inline const std::string& SongDetails::_internal_albumname() const {
  return _impl_.albumname_.Get();
}
inline void SongDetails::_internal_set_albumname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.albumname_.Set(value, GetArenaForAllocation());
}
inline std::string* SongDetails::_internal_mutable_albumname() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.albumname_.Mutable(GetArenaForAllocation());
}
inline std::string* SongDetails::release_albumname() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.SongDetails.albumName)
  if (!_internal_has_albumname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.albumname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.albumname_.IsDefault()) {
    _impl_.albumname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SongDetails::set_allocated_albumname(std::string* albumname) {
  if (albumname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.albumname_.SetAllocated(albumname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.albumname_.IsDefault()) {
    _impl_.albumname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.SongDetails.albumName)
}

// optional int32 trackNumber = 4;
inline bool SongDetails::_internal_has_tracknumber() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool SongDetails::has_tracknumber() const {
  return _internal_has_tracknumber();
}
inline void SongDetails::clear_tracknumber() {
  _impl_.tracknumber_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int32_t SongDetails::_internal_tracknumber() const {
  return _impl_.tracknumber_;
}
inline int32_t SongDetails::tracknumber() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.SongDetails.trackNumber)
  return _internal_tracknumber();
}
inline void SongDetails::_internal_set_tracknumber(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.tracknumber_ = value;
}
inline void SongDetails::set_tracknumber(int32_t value) {
  _internal_set_tracknumber(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.SongDetails.trackNumber)
}

// optional string previewUrl = 5;
inline bool SongDetails::_internal_has_previewurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SongDetails::has_previewurl() const {
  return _internal_has_previewurl();
}
inline void SongDetails::clear_previewurl() {
  _impl_.previewurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& SongDetails::previewurl() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.SongDetails.previewUrl)
  return _internal_previewurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SongDetails::set_previewurl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.previewurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.SongDetails.previewUrl)
}
inline std::string* SongDetails::mutable_previewurl() {
  std::string* _s = _internal_mutable_previewurl();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.SongDetails.previewUrl)
  return _s;
}
inline const std::string& SongDetails::_internal_previewurl() const {
  return _impl_.previewurl_.Get();
}
inline void SongDetails::_internal_set_previewurl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.previewurl_.Set(value, GetArenaForAllocation());
}
inline std::string* SongDetails::_internal_mutable_previewurl() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.previewurl_.Mutable(GetArenaForAllocation());
}
inline std::string* SongDetails::release_previewurl() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.SongDetails.previewUrl)
  if (!_internal_has_previewurl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.previewurl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.previewurl_.IsDefault()) {
    _impl_.previewurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SongDetails::set_allocated_previewurl(std::string* previewurl) {
  if (previewurl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.previewurl_.SetAllocated(previewurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.previewurl_.IsDefault()) {
    _impl_.previewurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.SongDetails.previewUrl)
}

// optional .playapi.proto.finsky.document.ArtistDetails displayArtist = 6;
inline bool SongDetails::_internal_has_displayartist() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.displayartist_ != nullptr);
  return value;
}
inline bool SongDetails::has_displayartist() const {
  return _internal_has_displayartist();
}
inline void SongDetails::clear_displayartist() {
  if (_impl_.displayartist_ != nullptr) _impl_.displayartist_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::playapi::proto::finsky::document::ArtistDetails& SongDetails::_internal_displayartist() const {
  const ::playapi::proto::finsky::document::ArtistDetails* p = _impl_.displayartist_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::ArtistDetails&>(
      ::playapi::proto::finsky::document::_ArtistDetails_default_instance_);
}
inline const ::playapi::proto::finsky::document::ArtistDetails& SongDetails::displayartist() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.SongDetails.displayArtist)
  return _internal_displayartist();
}
inline void SongDetails::unsafe_arena_set_allocated_displayartist(
    ::playapi::proto::finsky::document::ArtistDetails* displayartist) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.displayartist_);
  }
  _impl_.displayartist_ = displayartist;
  if (displayartist) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.SongDetails.displayArtist)
}
inline ::playapi::proto::finsky::document::ArtistDetails* SongDetails::release_displayartist() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::playapi::proto::finsky::document::ArtistDetails* temp = _impl_.displayartist_;
  _impl_.displayartist_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::ArtistDetails* SongDetails::unsafe_arena_release_displayartist() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.SongDetails.displayArtist)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::playapi::proto::finsky::document::ArtistDetails* temp = _impl_.displayartist_;
  _impl_.displayartist_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::ArtistDetails* SongDetails::_internal_mutable_displayartist() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.displayartist_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::ArtistDetails>(GetArenaForAllocation());
    _impl_.displayartist_ = p;
  }
  return _impl_.displayartist_;
}
inline ::playapi::proto::finsky::document::ArtistDetails* SongDetails::mutable_displayartist() {
  ::playapi::proto::finsky::document::ArtistDetails* _msg = _internal_mutable_displayartist();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.SongDetails.displayArtist)
  return _msg;
}
inline void SongDetails::set_allocated_displayartist(::playapi::proto::finsky::document::ArtistDetails* displayartist) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.displayartist_;
  }
  if (displayartist) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(displayartist);
    if (message_arena != submessage_arena) {
      displayartist = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, displayartist, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.displayartist_ = displayartist;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.SongDetails.displayArtist)
}

// optional .playapi.proto.finsky.document.Badge badge = 7;
inline bool SongDetails::_internal_has_badge() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.badge_ != nullptr);
  return value;
}
inline bool SongDetails::has_badge() const {
  return _internal_has_badge();
}
inline void SongDetails::clear_badge() {
  if (_impl_.badge_ != nullptr) _impl_.badge_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::playapi::proto::finsky::document::Badge& SongDetails::_internal_badge() const {
  const ::playapi::proto::finsky::document::Badge* p = _impl_.badge_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::Badge&>(
      ::playapi::proto::finsky::document::_Badge_default_instance_);
}
inline const ::playapi::proto::finsky::document::Badge& SongDetails::badge() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.SongDetails.badge)
  return _internal_badge();
}
inline void SongDetails::unsafe_arena_set_allocated_badge(
    ::playapi::proto::finsky::document::Badge* badge) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.badge_);
  }
  _impl_.badge_ = badge;
  if (badge) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.SongDetails.badge)
}
inline ::playapi::proto::finsky::document::Badge* SongDetails::release_badge() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::playapi::proto::finsky::document::Badge* temp = _impl_.badge_;
  _impl_.badge_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::Badge* SongDetails::unsafe_arena_release_badge() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.SongDetails.badge)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::playapi::proto::finsky::document::Badge* temp = _impl_.badge_;
  _impl_.badge_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::Badge* SongDetails::_internal_mutable_badge() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.badge_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::Badge>(GetArenaForAllocation());
    _impl_.badge_ = p;
  }
  return _impl_.badge_;
}
inline ::playapi::proto::finsky::document::Badge* SongDetails::mutable_badge() {
  ::playapi::proto::finsky::document::Badge* _msg = _internal_mutable_badge();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.SongDetails.badge)
  return _msg;
}
inline void SongDetails::set_allocated_badge(::playapi::proto::finsky::document::Badge* badge) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.badge_;
  }
  if (badge) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(badge);
    if (message_arena != submessage_arena) {
      badge = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, badge, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.badge_ = badge;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.SongDetails.badge)
}

// -------------------------------------------------------------------

// BookDetails

// optional string publisher = 4;
inline bool BookDetails::_internal_has_publisher() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BookDetails::has_publisher() const {
  return _internal_has_publisher();
}
inline void BookDetails::clear_publisher() {
  _impl_.publisher_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BookDetails::publisher() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.BookDetails.publisher)
  return _internal_publisher();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BookDetails::set_publisher(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.publisher_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.BookDetails.publisher)
}
inline std::string* BookDetails::mutable_publisher() {
  std::string* _s = _internal_mutable_publisher();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.BookDetails.publisher)
  return _s;
}
inline const std::string& BookDetails::_internal_publisher() const {
  return _impl_.publisher_.Get();
}
inline void BookDetails::_internal_set_publisher(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.publisher_.Set(value, GetArenaForAllocation());
}
inline std::string* BookDetails::_internal_mutable_publisher() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.publisher_.Mutable(GetArenaForAllocation());
}
inline std::string* BookDetails::release_publisher() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.BookDetails.publisher)
  if (!_internal_has_publisher()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.publisher_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.publisher_.IsDefault()) {
    _impl_.publisher_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BookDetails::set_allocated_publisher(std::string* publisher) {
  if (publisher != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.publisher_.SetAllocated(publisher, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.publisher_.IsDefault()) {
    _impl_.publisher_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.BookDetails.publisher)
}

// optional string publicationDate = 5;
inline bool BookDetails::_internal_has_publicationdate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BookDetails::has_publicationdate() const {
  return _internal_has_publicationdate();
}
inline void BookDetails::clear_publicationdate() {
  _impl_.publicationdate_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BookDetails::publicationdate() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.BookDetails.publicationDate)
  return _internal_publicationdate();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BookDetails::set_publicationdate(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.publicationdate_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.BookDetails.publicationDate)
}
inline std::string* BookDetails::mutable_publicationdate() {
  std::string* _s = _internal_mutable_publicationdate();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.BookDetails.publicationDate)
  return _s;
}
inline const std::string& BookDetails::_internal_publicationdate() const {
  return _impl_.publicationdate_.Get();
}
inline void BookDetails::_internal_set_publicationdate(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.publicationdate_.Set(value, GetArenaForAllocation());
}
inline std::string* BookDetails::_internal_mutable_publicationdate() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.publicationdate_.Mutable(GetArenaForAllocation());
}
inline std::string* BookDetails::release_publicationdate() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.BookDetails.publicationDate)
  if (!_internal_has_publicationdate()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.publicationdate_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.publicationdate_.IsDefault()) {
    _impl_.publicationdate_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BookDetails::set_allocated_publicationdate(std::string* publicationdate) {
  if (publicationdate != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.publicationdate_.SetAllocated(publicationdate, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.publicationdate_.IsDefault()) {
    _impl_.publicationdate_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.BookDetails.publicationDate)
}

// optional string isbn = 6;
inline bool BookDetails::_internal_has_isbn() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BookDetails::has_isbn() const {
  return _internal_has_isbn();
}
inline void BookDetails::clear_isbn() {
  _impl_.isbn_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& BookDetails::isbn() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.BookDetails.isbn)
  return _internal_isbn();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BookDetails::set_isbn(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.isbn_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.BookDetails.isbn)
}
inline std::string* BookDetails::mutable_isbn() {
  std::string* _s = _internal_mutable_isbn();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.BookDetails.isbn)
  return _s;
}
inline const std::string& BookDetails::_internal_isbn() const {
  return _impl_.isbn_.Get();
}
inline void BookDetails::_internal_set_isbn(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.isbn_.Set(value, GetArenaForAllocation());
}
inline std::string* BookDetails::_internal_mutable_isbn() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.isbn_.Mutable(GetArenaForAllocation());
}
inline std::string* BookDetails::release_isbn() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.BookDetails.isbn)
  if (!_internal_has_isbn()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.isbn_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.isbn_.IsDefault()) {
    _impl_.isbn_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BookDetails::set_allocated_isbn(std::string* isbn) {
  if (isbn != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.isbn_.SetAllocated(isbn, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.isbn_.IsDefault()) {
    _impl_.isbn_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.BookDetails.isbn)
}

// optional int32 numberOfPages = 7;
inline bool BookDetails::_internal_has_numberofpages() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool BookDetails::has_numberofpages() const {
  return _internal_has_numberofpages();
}
inline void BookDetails::clear_numberofpages() {
  _impl_.numberofpages_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline int32_t BookDetails::_internal_numberofpages() const {
  return _impl_.numberofpages_;
}
inline int32_t BookDetails::numberofpages() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.BookDetails.numberOfPages)
  return _internal_numberofpages();
}
inline void BookDetails::_internal_set_numberofpages(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.numberofpages_ = value;
}
inline void BookDetails::set_numberofpages(int32_t value) {
  _internal_set_numberofpages(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.BookDetails.numberOfPages)
}

// optional string aboutTheAuthor = 17;
inline bool BookDetails::_internal_has_abouttheauthor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool BookDetails::has_abouttheauthor() const {
  return _internal_has_abouttheauthor();
}
inline void BookDetails::clear_abouttheauthor() {
  _impl_.abouttheauthor_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& BookDetails::abouttheauthor() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.BookDetails.aboutTheAuthor)
  return _internal_abouttheauthor();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BookDetails::set_abouttheauthor(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.abouttheauthor_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.BookDetails.aboutTheAuthor)
}
inline std::string* BookDetails::mutable_abouttheauthor() {
  std::string* _s = _internal_mutable_abouttheauthor();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.BookDetails.aboutTheAuthor)
  return _s;
}
inline const std::string& BookDetails::_internal_abouttheauthor() const {
  return _impl_.abouttheauthor_.Get();
}
inline void BookDetails::_internal_set_abouttheauthor(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.abouttheauthor_.Set(value, GetArenaForAllocation());
}
inline std::string* BookDetails::_internal_mutable_abouttheauthor() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.abouttheauthor_.Mutable(GetArenaForAllocation());
}
inline std::string* BookDetails::release_abouttheauthor() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.BookDetails.aboutTheAuthor)
  if (!_internal_has_abouttheauthor()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.abouttheauthor_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.abouttheauthor_.IsDefault()) {
    _impl_.abouttheauthor_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BookDetails::set_allocated_abouttheauthor(std::string* abouttheauthor) {
  if (abouttheauthor != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.abouttheauthor_.SetAllocated(abouttheauthor, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.abouttheauthor_.IsDefault()) {
    _impl_.abouttheauthor_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.BookDetails.aboutTheAuthor)
}

// optional int32 bookType = 27;
inline bool BookDetails::_internal_has_booktype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool BookDetails::has_booktype() const {
  return _internal_has_booktype();
}
inline void BookDetails::clear_booktype() {
  _impl_.booktype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline int32_t BookDetails::_internal_booktype() const {
  return _impl_.booktype_;
}
inline int32_t BookDetails::booktype() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.BookDetails.bookType)
  return _internal_booktype();
}
inline void BookDetails::_internal_set_booktype(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.booktype_ = value;
}
inline void BookDetails::set_booktype(int32_t value) {
  _internal_set_booktype(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.BookDetails.bookType)
}

// optional string seriesLine = 28;
inline bool BookDetails::_internal_has_seriesline() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool BookDetails::has_seriesline() const {
  return _internal_has_seriesline();
}
inline void BookDetails::clear_seriesline() {
  _impl_.seriesline_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& BookDetails::seriesline() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.BookDetails.seriesLine)
  return _internal_seriesline();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BookDetails::set_seriesline(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.seriesline_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.BookDetails.seriesLine)
}
inline std::string* BookDetails::mutable_seriesline() {
  std::string* _s = _internal_mutable_seriesline();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.BookDetails.seriesLine)
  return _s;
}
inline const std::string& BookDetails::_internal_seriesline() const {
  return _impl_.seriesline_.Get();
}
inline void BookDetails::_internal_set_seriesline(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.seriesline_.Set(value, GetArenaForAllocation());
}
inline std::string* BookDetails::_internal_mutable_seriesline() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.seriesline_.Mutable(GetArenaForAllocation());
}
inline std::string* BookDetails::release_seriesline() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.BookDetails.seriesLine)
  if (!_internal_has_seriesline()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.seriesline_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.seriesline_.IsDefault()) {
    _impl_.seriesline_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BookDetails::set_allocated_seriesline(std::string* seriesline) {
  if (seriesline != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.seriesline_.SetAllocated(seriesline, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.seriesline_.IsDefault()) {
    _impl_.seriesline_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.BookDetails.seriesLine)
}

// optional string conciseTitle = 29;
inline bool BookDetails::_internal_has_concisetitle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool BookDetails::has_concisetitle() const {
  return _internal_has_concisetitle();
}
inline void BookDetails::clear_concisetitle() {
  _impl_.concisetitle_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& BookDetails::concisetitle() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.BookDetails.conciseTitle)
  return _internal_concisetitle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BookDetails::set_concisetitle(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.concisetitle_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.BookDetails.conciseTitle)
}
inline std::string* BookDetails::mutable_concisetitle() {
  std::string* _s = _internal_mutable_concisetitle();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.BookDetails.conciseTitle)
  return _s;
}
inline const std::string& BookDetails::_internal_concisetitle() const {
  return _impl_.concisetitle_.Get();
}
inline void BookDetails::_internal_set_concisetitle(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.concisetitle_.Set(value, GetArenaForAllocation());
}
inline std::string* BookDetails::_internal_mutable_concisetitle() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.concisetitle_.Mutable(GetArenaForAllocation());
}
inline std::string* BookDetails::release_concisetitle() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.BookDetails.conciseTitle)
  if (!_internal_has_concisetitle()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.concisetitle_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.concisetitle_.IsDefault()) {
    _impl_.concisetitle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BookDetails::set_allocated_concisetitle(std::string* concisetitle) {
  if (concisetitle != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.concisetitle_.SetAllocated(concisetitle, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.concisetitle_.IsDefault()) {
    _impl_.concisetitle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.BookDetails.conciseTitle)
}

// optional string shortTitle = 30;
inline bool BookDetails::_internal_has_shorttitle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool BookDetails::has_shorttitle() const {
  return _internal_has_shorttitle();
}
inline void BookDetails::clear_shorttitle() {
  _impl_.shorttitle_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& BookDetails::shorttitle() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.BookDetails.shortTitle)
  return _internal_shorttitle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BookDetails::set_shorttitle(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000040u;
 _impl_.shorttitle_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.BookDetails.shortTitle)
}
inline std::string* BookDetails::mutable_shorttitle() {
  std::string* _s = _internal_mutable_shorttitle();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.BookDetails.shortTitle)
  return _s;
}
inline const std::string& BookDetails::_internal_shorttitle() const {
  return _impl_.shorttitle_.Get();
}
inline void BookDetails::_internal_set_shorttitle(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.shorttitle_.Set(value, GetArenaForAllocation());
}
inline std::string* BookDetails::_internal_mutable_shorttitle() {
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.shorttitle_.Mutable(GetArenaForAllocation());
}
inline std::string* BookDetails::release_shorttitle() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.BookDetails.shortTitle)
  if (!_internal_has_shorttitle()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* p = _impl_.shorttitle_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.shorttitle_.IsDefault()) {
    _impl_.shorttitle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BookDetails::set_allocated_shorttitle(std::string* shorttitle) {
  if (shorttitle != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.shorttitle_.SetAllocated(shorttitle, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.shorttitle_.IsDefault()) {
    _impl_.shorttitle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.BookDetails.shortTitle)
}

// optional string seriesTitle = 31;
inline bool BookDetails::_internal_has_seriestitle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool BookDetails::has_seriestitle() const {
  return _internal_has_seriestitle();
}
inline void BookDetails::clear_seriestitle() {
  _impl_.seriestitle_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& BookDetails::seriestitle() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.BookDetails.seriesTitle)
  return _internal_seriestitle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BookDetails::set_seriestitle(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000080u;
 _impl_.seriestitle_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.BookDetails.seriesTitle)
}
inline std::string* BookDetails::mutable_seriestitle() {
  std::string* _s = _internal_mutable_seriestitle();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.BookDetails.seriesTitle)
  return _s;
}
inline const std::string& BookDetails::_internal_seriestitle() const {
  return _impl_.seriestitle_.Get();
}
inline void BookDetails::_internal_set_seriestitle(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.seriestitle_.Set(value, GetArenaForAllocation());
}
inline std::string* BookDetails::_internal_mutable_seriestitle() {
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.seriestitle_.Mutable(GetArenaForAllocation());
}
inline std::string* BookDetails::release_seriestitle() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.BookDetails.seriesTitle)
  if (!_internal_has_seriestitle()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* p = _impl_.seriestitle_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.seriestitle_.IsDefault()) {
    _impl_.seriestitle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BookDetails::set_allocated_seriestitle(std::string* seriestitle) {
  if (seriestitle != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.seriestitle_.SetAllocated(seriestitle, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.seriestitle_.IsDefault()) {
    _impl_.seriestitle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.BookDetails.seriesTitle)
}

// -------------------------------------------------------------------

// VideoDetails

// repeated .playapi.proto.finsky.document.VideoCredit credit = 1;
inline int VideoDetails::_internal_credit_size() const {
  return _impl_.credit_.size();
}
inline int VideoDetails::credit_size() const {
  return _internal_credit_size();
}
inline void VideoDetails::clear_credit() {
  _impl_.credit_.Clear();
}
inline ::playapi::proto::finsky::document::VideoCredit* VideoDetails::mutable_credit(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.VideoDetails.credit)
  return _impl_.credit_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::VideoCredit >*
VideoDetails::mutable_credit() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.document.VideoDetails.credit)
  return &_impl_.credit_;
}
inline const ::playapi::proto::finsky::document::VideoCredit& VideoDetails::_internal_credit(int index) const {
  return _impl_.credit_.Get(index);
}
inline const ::playapi::proto::finsky::document::VideoCredit& VideoDetails::credit(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.VideoDetails.credit)
  return _internal_credit(index);
}
inline ::playapi::proto::finsky::document::VideoCredit* VideoDetails::_internal_add_credit() {
  return _impl_.credit_.Add();
}
inline ::playapi::proto::finsky::document::VideoCredit* VideoDetails::add_credit() {
  ::playapi::proto::finsky::document::VideoCredit* _add = _internal_add_credit();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.VideoDetails.credit)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::VideoCredit >&
VideoDetails::credit() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.document.VideoDetails.credit)
  return _impl_.credit_;
}

// optional string duration = 2;
inline bool VideoDetails::_internal_has_duration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VideoDetails::has_duration() const {
  return _internal_has_duration();
}
inline void VideoDetails::clear_duration() {
  _impl_.duration_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VideoDetails::duration() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.VideoDetails.duration)
  return _internal_duration();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoDetails::set_duration(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.duration_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.VideoDetails.duration)
}
inline std::string* VideoDetails::mutable_duration() {
  std::string* _s = _internal_mutable_duration();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.VideoDetails.duration)
  return _s;
}
inline const std::string& VideoDetails::_internal_duration() const {
  return _impl_.duration_.Get();
}
inline void VideoDetails::_internal_set_duration(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.duration_.Set(value, GetArenaForAllocation());
}
inline std::string* VideoDetails::_internal_mutable_duration() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.duration_.Mutable(GetArenaForAllocation());
}
inline std::string* VideoDetails::release_duration() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.VideoDetails.duration)
  if (!_internal_has_duration()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.duration_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.duration_.IsDefault()) {
    _impl_.duration_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void VideoDetails::set_allocated_duration(std::string* duration) {
  if (duration != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.duration_.SetAllocated(duration, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.duration_.IsDefault()) {
    _impl_.duration_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.VideoDetails.duration)
}

// optional string releaseDate = 3;
inline bool VideoDetails::_internal_has_releasedate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VideoDetails::has_releasedate() const {
  return _internal_has_releasedate();
}
inline void VideoDetails::clear_releasedate() {
  _impl_.releasedate_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& VideoDetails::releasedate() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.VideoDetails.releaseDate)
  return _internal_releasedate();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoDetails::set_releasedate(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.releasedate_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.VideoDetails.releaseDate)
}
inline std::string* VideoDetails::mutable_releasedate() {
  std::string* _s = _internal_mutable_releasedate();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.VideoDetails.releaseDate)
  return _s;
}
inline const std::string& VideoDetails::_internal_releasedate() const {
  return _impl_.releasedate_.Get();
}
inline void VideoDetails::_internal_set_releasedate(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.releasedate_.Set(value, GetArenaForAllocation());
}
inline std::string* VideoDetails::_internal_mutable_releasedate() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.releasedate_.Mutable(GetArenaForAllocation());
}
inline std::string* VideoDetails::release_releasedate() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.VideoDetails.releaseDate)
  if (!_internal_has_releasedate()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.releasedate_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.releasedate_.IsDefault()) {
    _impl_.releasedate_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void VideoDetails::set_allocated_releasedate(std::string* releasedate) {
  if (releasedate != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.releasedate_.SetAllocated(releasedate, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.releasedate_.IsDefault()) {
    _impl_.releasedate_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.VideoDetails.releaseDate)
}

// optional string contentRating = 4;
inline bool VideoDetails::_internal_has_contentrating() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool VideoDetails::has_contentrating() const {
  return _internal_has_contentrating();
}
inline void VideoDetails::clear_contentrating() {
  _impl_.contentrating_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& VideoDetails::contentrating() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.VideoDetails.contentRating)
  return _internal_contentrating();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoDetails::set_contentrating(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.contentrating_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.VideoDetails.contentRating)
}
inline std::string* VideoDetails::mutable_contentrating() {
  std::string* _s = _internal_mutable_contentrating();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.VideoDetails.contentRating)
  return _s;
}
inline const std::string& VideoDetails::_internal_contentrating() const {
  return _impl_.contentrating_.Get();
}
inline void VideoDetails::_internal_set_contentrating(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.contentrating_.Set(value, GetArenaForAllocation());
}
inline std::string* VideoDetails::_internal_mutable_contentrating() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.contentrating_.Mutable(GetArenaForAllocation());
}
inline std::string* VideoDetails::release_contentrating() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.VideoDetails.contentRating)
  if (!_internal_has_contentrating()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.contentrating_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contentrating_.IsDefault()) {
    _impl_.contentrating_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void VideoDetails::set_allocated_contentrating(std::string* contentrating) {
  if (contentrating != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.contentrating_.SetAllocated(contentrating, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contentrating_.IsDefault()) {
    _impl_.contentrating_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.VideoDetails.contentRating)
}

// optional int64 likes = 5;
inline bool VideoDetails::_internal_has_likes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool VideoDetails::has_likes() const {
  return _internal_has_likes();
}
inline void VideoDetails::clear_likes() {
  _impl_.likes_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int64_t VideoDetails::_internal_likes() const {
  return _impl_.likes_;
}
inline int64_t VideoDetails::likes() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.VideoDetails.likes)
  return _internal_likes();
}
inline void VideoDetails::_internal_set_likes(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.likes_ = value;
}
inline void VideoDetails::set_likes(int64_t value) {
  _internal_set_likes(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.VideoDetails.likes)
}

// optional int64 dislikes = 6;
inline bool VideoDetails::_internal_has_dislikes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool VideoDetails::has_dislikes() const {
  return _internal_has_dislikes();
}
inline void VideoDetails::clear_dislikes() {
  _impl_.dislikes_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int64_t VideoDetails::_internal_dislikes() const {
  return _impl_.dislikes_;
}
inline int64_t VideoDetails::dislikes() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.VideoDetails.dislikes)
  return _internal_dislikes();
}
inline void VideoDetails::_internal_set_dislikes(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.dislikes_ = value;
}
inline void VideoDetails::set_dislikes(int64_t value) {
  _internal_set_dislikes(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.VideoDetails.dislikes)
}

// repeated string genre = 7;
inline int VideoDetails::_internal_genre_size() const {
  return _impl_.genre_.size();
}
inline int VideoDetails::genre_size() const {
  return _internal_genre_size();
}
inline void VideoDetails::clear_genre() {
  _impl_.genre_.Clear();
}
inline std::string* VideoDetails::add_genre() {
  std::string* _s = _internal_add_genre();
  // @@protoc_insertion_point(field_add_mutable:playapi.proto.finsky.document.VideoDetails.genre)
  return _s;
}
inline const std::string& VideoDetails::_internal_genre(int index) const {
  return _impl_.genre_.Get(index);
}
inline const std::string& VideoDetails::genre(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.VideoDetails.genre)
  return _internal_genre(index);
}
inline std::string* VideoDetails::mutable_genre(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.VideoDetails.genre)
  return _impl_.genre_.Mutable(index);
}
inline void VideoDetails::set_genre(int index, const std::string& value) {
  _impl_.genre_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.VideoDetails.genre)
}
inline void VideoDetails::set_genre(int index, std::string&& value) {
  _impl_.genre_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.VideoDetails.genre)
}
inline void VideoDetails::set_genre(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.genre_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:playapi.proto.finsky.document.VideoDetails.genre)
}
inline void VideoDetails::set_genre(int index, const char* value, size_t size) {
  _impl_.genre_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:playapi.proto.finsky.document.VideoDetails.genre)
}
inline std::string* VideoDetails::_internal_add_genre() {
  return _impl_.genre_.Add();
}
inline void VideoDetails::add_genre(const std::string& value) {
  _impl_.genre_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.VideoDetails.genre)
}
inline void VideoDetails::add_genre(std::string&& value) {
  _impl_.genre_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.VideoDetails.genre)
}
inline void VideoDetails::add_genre(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.genre_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:playapi.proto.finsky.document.VideoDetails.genre)
}
inline void VideoDetails::add_genre(const char* value, size_t size) {
  _impl_.genre_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:playapi.proto.finsky.document.VideoDetails.genre)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
VideoDetails::genre() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.document.VideoDetails.genre)
  return _impl_.genre_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
VideoDetails::mutable_genre() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.document.VideoDetails.genre)
  return &_impl_.genre_;
}

// repeated .playapi.proto.finsky.document.Trailer trailer = 8;
inline int VideoDetails::_internal_trailer_size() const {
  return _impl_.trailer_.size();
}
inline int VideoDetails::trailer_size() const {
  return _internal_trailer_size();
}
inline void VideoDetails::clear_trailer() {
  _impl_.trailer_.Clear();
}
inline ::playapi::proto::finsky::document::Trailer* VideoDetails::mutable_trailer(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.VideoDetails.trailer)
  return _impl_.trailer_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::Trailer >*
VideoDetails::mutable_trailer() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.document.VideoDetails.trailer)
  return &_impl_.trailer_;
}
inline const ::playapi::proto::finsky::document::Trailer& VideoDetails::_internal_trailer(int index) const {
  return _impl_.trailer_.Get(index);
}
inline const ::playapi::proto::finsky::document::Trailer& VideoDetails::trailer(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.VideoDetails.trailer)
  return _internal_trailer(index);
}
inline ::playapi::proto::finsky::document::Trailer* VideoDetails::_internal_add_trailer() {
  return _impl_.trailer_.Add();
}
inline ::playapi::proto::finsky::document::Trailer* VideoDetails::add_trailer() {
  ::playapi::proto::finsky::document::Trailer* _add = _internal_add_trailer();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.VideoDetails.trailer)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::Trailer >&
VideoDetails::trailer() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.document.VideoDetails.trailer)
  return _impl_.trailer_;
}

// repeated .playapi.proto.finsky.document.VideoRentalTerm rentalTerm = 9;
inline int VideoDetails::_internal_rentalterm_size() const {
  return _impl_.rentalterm_.size();
}
inline int VideoDetails::rentalterm_size() const {
  return _internal_rentalterm_size();
}
inline void VideoDetails::clear_rentalterm() {
  _impl_.rentalterm_.Clear();
}
inline ::playapi::proto::finsky::document::VideoRentalTerm* VideoDetails::mutable_rentalterm(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.VideoDetails.rentalTerm)
  return _impl_.rentalterm_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::VideoRentalTerm >*
VideoDetails::mutable_rentalterm() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.document.VideoDetails.rentalTerm)
  return &_impl_.rentalterm_;
}
inline const ::playapi::proto::finsky::document::VideoRentalTerm& VideoDetails::_internal_rentalterm(int index) const {
  return _impl_.rentalterm_.Get(index);
}
inline const ::playapi::proto::finsky::document::VideoRentalTerm& VideoDetails::rentalterm(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.VideoDetails.rentalTerm)
  return _internal_rentalterm(index);
}
inline ::playapi::proto::finsky::document::VideoRentalTerm* VideoDetails::_internal_add_rentalterm() {
  return _impl_.rentalterm_.Add();
}
inline ::playapi::proto::finsky::document::VideoRentalTerm* VideoDetails::add_rentalterm() {
  ::playapi::proto::finsky::document::VideoRentalTerm* _add = _internal_add_rentalterm();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.VideoDetails.rentalTerm)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::VideoRentalTerm >&
VideoDetails::rentalterm() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.document.VideoDetails.rentalTerm)
  return _impl_.rentalterm_;
}

// repeated string audioLanguage = 10;
inline int VideoDetails::_internal_audiolanguage_size() const {
  return _impl_.audiolanguage_.size();
}
inline int VideoDetails::audiolanguage_size() const {
  return _internal_audiolanguage_size();
}
inline void VideoDetails::clear_audiolanguage() {
  _impl_.audiolanguage_.Clear();
}
inline std::string* VideoDetails::add_audiolanguage() {
  std::string* _s = _internal_add_audiolanguage();
  // @@protoc_insertion_point(field_add_mutable:playapi.proto.finsky.document.VideoDetails.audioLanguage)
  return _s;
}
inline const std::string& VideoDetails::_internal_audiolanguage(int index) const {
  return _impl_.audiolanguage_.Get(index);
}
inline const std::string& VideoDetails::audiolanguage(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.VideoDetails.audioLanguage)
  return _internal_audiolanguage(index);
}
inline std::string* VideoDetails::mutable_audiolanguage(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.VideoDetails.audioLanguage)
  return _impl_.audiolanguage_.Mutable(index);
}
inline void VideoDetails::set_audiolanguage(int index, const std::string& value) {
  _impl_.audiolanguage_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.VideoDetails.audioLanguage)
}
inline void VideoDetails::set_audiolanguage(int index, std::string&& value) {
  _impl_.audiolanguage_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.VideoDetails.audioLanguage)
}
inline void VideoDetails::set_audiolanguage(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.audiolanguage_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:playapi.proto.finsky.document.VideoDetails.audioLanguage)
}
inline void VideoDetails::set_audiolanguage(int index, const char* value, size_t size) {
  _impl_.audiolanguage_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:playapi.proto.finsky.document.VideoDetails.audioLanguage)
}
inline std::string* VideoDetails::_internal_add_audiolanguage() {
  return _impl_.audiolanguage_.Add();
}
inline void VideoDetails::add_audiolanguage(const std::string& value) {
  _impl_.audiolanguage_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.VideoDetails.audioLanguage)
}
inline void VideoDetails::add_audiolanguage(std::string&& value) {
  _impl_.audiolanguage_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.VideoDetails.audioLanguage)
}
inline void VideoDetails::add_audiolanguage(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.audiolanguage_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:playapi.proto.finsky.document.VideoDetails.audioLanguage)
}
inline void VideoDetails::add_audiolanguage(const char* value, size_t size) {
  _impl_.audiolanguage_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:playapi.proto.finsky.document.VideoDetails.audioLanguage)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
VideoDetails::audiolanguage() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.document.VideoDetails.audioLanguage)
  return _impl_.audiolanguage_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
VideoDetails::mutable_audiolanguage() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.document.VideoDetails.audioLanguage)
  return &_impl_.audiolanguage_;
}

// repeated string captionLanguage = 11;
inline int VideoDetails::_internal_captionlanguage_size() const {
  return _impl_.captionlanguage_.size();
}
inline int VideoDetails::captionlanguage_size() const {
  return _internal_captionlanguage_size();
}
inline void VideoDetails::clear_captionlanguage() {
  _impl_.captionlanguage_.Clear();
}
inline std::string* VideoDetails::add_captionlanguage() {
  std::string* _s = _internal_add_captionlanguage();
  // @@protoc_insertion_point(field_add_mutable:playapi.proto.finsky.document.VideoDetails.captionLanguage)
  return _s;
}
inline const std::string& VideoDetails::_internal_captionlanguage(int index) const {
  return _impl_.captionlanguage_.Get(index);
}
inline const std::string& VideoDetails::captionlanguage(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.VideoDetails.captionLanguage)
  return _internal_captionlanguage(index);
}
inline std::string* VideoDetails::mutable_captionlanguage(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.VideoDetails.captionLanguage)
  return _impl_.captionlanguage_.Mutable(index);
}
inline void VideoDetails::set_captionlanguage(int index, const std::string& value) {
  _impl_.captionlanguage_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.VideoDetails.captionLanguage)
}
inline void VideoDetails::set_captionlanguage(int index, std::string&& value) {
  _impl_.captionlanguage_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.VideoDetails.captionLanguage)
}
inline void VideoDetails::set_captionlanguage(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.captionlanguage_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:playapi.proto.finsky.document.VideoDetails.captionLanguage)
}
inline void VideoDetails::set_captionlanguage(int index, const char* value, size_t size) {
  _impl_.captionlanguage_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:playapi.proto.finsky.document.VideoDetails.captionLanguage)
}
inline std::string* VideoDetails::_internal_add_captionlanguage() {
  return _impl_.captionlanguage_.Add();
}
inline void VideoDetails::add_captionlanguage(const std::string& value) {
  _impl_.captionlanguage_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.VideoDetails.captionLanguage)
}
inline void VideoDetails::add_captionlanguage(std::string&& value) {
  _impl_.captionlanguage_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.VideoDetails.captionLanguage)
}
inline void VideoDetails::add_captionlanguage(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.captionlanguage_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:playapi.proto.finsky.document.VideoDetails.captionLanguage)
}
inline void VideoDetails::add_captionlanguage(const char* value, size_t size) {
  _impl_.captionlanguage_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:playapi.proto.finsky.document.VideoDetails.captionLanguage)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
VideoDetails::captionlanguage() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.document.VideoDetails.captionLanguage)
  return _impl_.captionlanguage_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
VideoDetails::mutable_captionlanguage() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.document.VideoDetails.captionLanguage)
  return &_impl_.captionlanguage_;
}

// -------------------------------------------------------------------

// VideoCredit

// optional int32 creditType = 1;
inline bool VideoCredit::_internal_has_credittype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VideoCredit::has_credittype() const {
  return _internal_has_credittype();
}
inline void VideoCredit::clear_credittype() {
  _impl_.credittype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t VideoCredit::_internal_credittype() const {
  return _impl_.credittype_;
}
inline int32_t VideoCredit::credittype() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.VideoCredit.creditType)
  return _internal_credittype();
}
inline void VideoCredit::_internal_set_credittype(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.credittype_ = value;
}
inline void VideoCredit::set_credittype(int32_t value) {
  _internal_set_credittype(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.VideoCredit.creditType)
}

// optional string credit = 2;
inline bool VideoCredit::_internal_has_credit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VideoCredit::has_credit() const {
  return _internal_has_credit();
}
inline void VideoCredit::clear_credit() {
  _impl_.credit_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VideoCredit::credit() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.VideoCredit.credit)
  return _internal_credit();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoCredit::set_credit(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.credit_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.VideoCredit.credit)
}
inline std::string* VideoCredit::mutable_credit() {
  std::string* _s = _internal_mutable_credit();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.VideoCredit.credit)
  return _s;
}
inline const std::string& VideoCredit::_internal_credit() const {
  return _impl_.credit_.Get();
}
inline void VideoCredit::_internal_set_credit(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.credit_.Set(value, GetArenaForAllocation());
}
inline std::string* VideoCredit::_internal_mutable_credit() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.credit_.Mutable(GetArenaForAllocation());
}
inline std::string* VideoCredit::release_credit() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.VideoCredit.credit)
  if (!_internal_has_credit()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.credit_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.credit_.IsDefault()) {
    _impl_.credit_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void VideoCredit::set_allocated_credit(std::string* credit) {
  if (credit != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.credit_.SetAllocated(credit, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.credit_.IsDefault()) {
    _impl_.credit_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.VideoCredit.credit)
}

// repeated string name = 3;
inline int VideoCredit::_internal_name_size() const {
  return _impl_.name_.size();
}
inline int VideoCredit::name_size() const {
  return _internal_name_size();
}
inline void VideoCredit::clear_name() {
  _impl_.name_.Clear();
}
inline std::string* VideoCredit::add_name() {
  std::string* _s = _internal_add_name();
  // @@protoc_insertion_point(field_add_mutable:playapi.proto.finsky.document.VideoCredit.name)
  return _s;
}
inline const std::string& VideoCredit::_internal_name(int index) const {
  return _impl_.name_.Get(index);
}
inline const std::string& VideoCredit::name(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.VideoCredit.name)
  return _internal_name(index);
}
inline std::string* VideoCredit::mutable_name(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.VideoCredit.name)
  return _impl_.name_.Mutable(index);
}
inline void VideoCredit::set_name(int index, const std::string& value) {
  _impl_.name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.VideoCredit.name)
}
inline void VideoCredit::set_name(int index, std::string&& value) {
  _impl_.name_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.VideoCredit.name)
}
inline void VideoCredit::set_name(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:playapi.proto.finsky.document.VideoCredit.name)
}
inline void VideoCredit::set_name(int index, const char* value, size_t size) {
  _impl_.name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:playapi.proto.finsky.document.VideoCredit.name)
}
inline std::string* VideoCredit::_internal_add_name() {
  return _impl_.name_.Add();
}
inline void VideoCredit::add_name(const std::string& value) {
  _impl_.name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.VideoCredit.name)
}
inline void VideoCredit::add_name(std::string&& value) {
  _impl_.name_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.VideoCredit.name)
}
inline void VideoCredit::add_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:playapi.proto.finsky.document.VideoCredit.name)
}
inline void VideoCredit::add_name(const char* value, size_t size) {
  _impl_.name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:playapi.proto.finsky.document.VideoCredit.name)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
VideoCredit::name() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.document.VideoCredit.name)
  return _impl_.name_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
VideoCredit::mutable_name() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.document.VideoCredit.name)
  return &_impl_.name_;
}

// -------------------------------------------------------------------

// Trailer

// optional string trailerId = 1;
inline bool Trailer::_internal_has_trailerid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Trailer::has_trailerid() const {
  return _internal_has_trailerid();
}
inline void Trailer::clear_trailerid() {
  _impl_.trailerid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Trailer::trailerid() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Trailer.trailerId)
  return _internal_trailerid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Trailer::set_trailerid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.trailerid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.Trailer.trailerId)
}
inline std::string* Trailer::mutable_trailerid() {
  std::string* _s = _internal_mutable_trailerid();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Trailer.trailerId)
  return _s;
}
inline const std::string& Trailer::_internal_trailerid() const {
  return _impl_.trailerid_.Get();
}
inline void Trailer::_internal_set_trailerid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.trailerid_.Set(value, GetArenaForAllocation());
}
inline std::string* Trailer::_internal_mutable_trailerid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.trailerid_.Mutable(GetArenaForAllocation());
}
inline std::string* Trailer::release_trailerid() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.Trailer.trailerId)
  if (!_internal_has_trailerid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.trailerid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.trailerid_.IsDefault()) {
    _impl_.trailerid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Trailer::set_allocated_trailerid(std::string* trailerid) {
  if (trailerid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.trailerid_.SetAllocated(trailerid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.trailerid_.IsDefault()) {
    _impl_.trailerid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.Trailer.trailerId)
}

// optional string title = 2;
inline bool Trailer::_internal_has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Trailer::has_title() const {
  return _internal_has_title();
}
inline void Trailer::clear_title() {
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Trailer::title() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Trailer.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Trailer::set_title(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.Trailer.title)
}
inline std::string* Trailer::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Trailer.title)
  return _s;
}
inline const std::string& Trailer::_internal_title() const {
  return _impl_.title_.Get();
}
inline void Trailer::_internal_set_title(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* Trailer::_internal_mutable_title() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* Trailer::release_title() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.Trailer.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.title_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Trailer::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.Trailer.title)
}

// optional string thumbnailUrl = 3;
inline bool Trailer::_internal_has_thumbnailurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Trailer::has_thumbnailurl() const {
  return _internal_has_thumbnailurl();
}
inline void Trailer::clear_thumbnailurl() {
  _impl_.thumbnailurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Trailer::thumbnailurl() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Trailer.thumbnailUrl)
  return _internal_thumbnailurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Trailer::set_thumbnailurl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.thumbnailurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.Trailer.thumbnailUrl)
}
inline std::string* Trailer::mutable_thumbnailurl() {
  std::string* _s = _internal_mutable_thumbnailurl();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Trailer.thumbnailUrl)
  return _s;
}
inline const std::string& Trailer::_internal_thumbnailurl() const {
  return _impl_.thumbnailurl_.Get();
}
inline void Trailer::_internal_set_thumbnailurl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.thumbnailurl_.Set(value, GetArenaForAllocation());
}
inline std::string* Trailer::_internal_mutable_thumbnailurl() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.thumbnailurl_.Mutable(GetArenaForAllocation());
}
inline std::string* Trailer::release_thumbnailurl() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.Trailer.thumbnailUrl)
  if (!_internal_has_thumbnailurl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.thumbnailurl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thumbnailurl_.IsDefault()) {
    _impl_.thumbnailurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Trailer::set_allocated_thumbnailurl(std::string* thumbnailurl) {
  if (thumbnailurl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.thumbnailurl_.SetAllocated(thumbnailurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.thumbnailurl_.IsDefault()) {
    _impl_.thumbnailurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.Trailer.thumbnailUrl)
}

// optional string watchUrl = 4;
inline bool Trailer::_internal_has_watchurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Trailer::has_watchurl() const {
  return _internal_has_watchurl();
}
inline void Trailer::clear_watchurl() {
  _impl_.watchurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& Trailer::watchurl() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Trailer.watchUrl)
  return _internal_watchurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Trailer::set_watchurl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.watchurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.Trailer.watchUrl)
}
inline std::string* Trailer::mutable_watchurl() {
  std::string* _s = _internal_mutable_watchurl();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Trailer.watchUrl)
  return _s;
}
inline const std::string& Trailer::_internal_watchurl() const {
  return _impl_.watchurl_.Get();
}
inline void Trailer::_internal_set_watchurl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.watchurl_.Set(value, GetArenaForAllocation());
}
inline std::string* Trailer::_internal_mutable_watchurl() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.watchurl_.Mutable(GetArenaForAllocation());
}
inline std::string* Trailer::release_watchurl() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.Trailer.watchUrl)
  if (!_internal_has_watchurl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.watchurl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.watchurl_.IsDefault()) {
    _impl_.watchurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Trailer::set_allocated_watchurl(std::string* watchurl) {
  if (watchurl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.watchurl_.SetAllocated(watchurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.watchurl_.IsDefault()) {
    _impl_.watchurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.Trailer.watchUrl)
}

// optional string duration = 5;
inline bool Trailer::_internal_has_duration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Trailer::has_duration() const {
  return _internal_has_duration();
}
inline void Trailer::clear_duration() {
  _impl_.duration_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& Trailer::duration() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Trailer.duration)
  return _internal_duration();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Trailer::set_duration(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.duration_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.Trailer.duration)
}
inline std::string* Trailer::mutable_duration() {
  std::string* _s = _internal_mutable_duration();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Trailer.duration)
  return _s;
}
inline const std::string& Trailer::_internal_duration() const {
  return _impl_.duration_.Get();
}
inline void Trailer::_internal_set_duration(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.duration_.Set(value, GetArenaForAllocation());
}
inline std::string* Trailer::_internal_mutable_duration() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.duration_.Mutable(GetArenaForAllocation());
}
inline std::string* Trailer::release_duration() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.Trailer.duration)
  if (!_internal_has_duration()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.duration_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.duration_.IsDefault()) {
    _impl_.duration_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Trailer::set_allocated_duration(std::string* duration) {
  if (duration != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.duration_.SetAllocated(duration, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.duration_.IsDefault()) {
    _impl_.duration_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.Trailer.duration)
}

// -------------------------------------------------------------------

// VideoRentalTerm_Term

// optional string header = 5;
inline bool VideoRentalTerm_Term::_internal_has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VideoRentalTerm_Term::has_header() const {
  return _internal_has_header();
}
inline void VideoRentalTerm_Term::clear_header() {
  _impl_.header_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VideoRentalTerm_Term::header() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.VideoRentalTerm.Term.header)
  return _internal_header();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoRentalTerm_Term::set_header(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.header_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.VideoRentalTerm.Term.header)
}
inline std::string* VideoRentalTerm_Term::mutable_header() {
  std::string* _s = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.VideoRentalTerm.Term.header)
  return _s;
}
inline const std::string& VideoRentalTerm_Term::_internal_header() const {
  return _impl_.header_.Get();
}
inline void VideoRentalTerm_Term::_internal_set_header(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.header_.Set(value, GetArenaForAllocation());
}
inline std::string* VideoRentalTerm_Term::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.header_.Mutable(GetArenaForAllocation());
}
inline std::string* VideoRentalTerm_Term::release_header() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.VideoRentalTerm.Term.header)
  if (!_internal_has_header()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.header_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.header_.IsDefault()) {
    _impl_.header_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void VideoRentalTerm_Term::set_allocated_header(std::string* header) {
  if (header != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.header_.SetAllocated(header, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.header_.IsDefault()) {
    _impl_.header_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.VideoRentalTerm.Term.header)
}

// optional string body = 6;
inline bool VideoRentalTerm_Term::_internal_has_body() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VideoRentalTerm_Term::has_body() const {
  return _internal_has_body();
}
inline void VideoRentalTerm_Term::clear_body() {
  _impl_.body_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& VideoRentalTerm_Term::body() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.VideoRentalTerm.Term.body)
  return _internal_body();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoRentalTerm_Term::set_body(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.body_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.VideoRentalTerm.Term.body)
}
inline std::string* VideoRentalTerm_Term::mutable_body() {
  std::string* _s = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.VideoRentalTerm.Term.body)
  return _s;
}
inline const std::string& VideoRentalTerm_Term::_internal_body() const {
  return _impl_.body_.Get();
}
inline void VideoRentalTerm_Term::_internal_set_body(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.body_.Set(value, GetArenaForAllocation());
}
inline std::string* VideoRentalTerm_Term::_internal_mutable_body() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.body_.Mutable(GetArenaForAllocation());
}
inline std::string* VideoRentalTerm_Term::release_body() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.VideoRentalTerm.Term.body)
  if (!_internal_has_body()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.body_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.body_.IsDefault()) {
    _impl_.body_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void VideoRentalTerm_Term::set_allocated_body(std::string* body) {
  if (body != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.body_.SetAllocated(body, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.body_.IsDefault()) {
    _impl_.body_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.VideoRentalTerm.Term.body)
}

// -------------------------------------------------------------------

// VideoRentalTerm

// optional int32 offerType = 1;
inline bool VideoRentalTerm::_internal_has_offertype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool VideoRentalTerm::has_offertype() const {
  return _internal_has_offertype();
}
inline void VideoRentalTerm::clear_offertype() {
  _impl_.offertype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t VideoRentalTerm::_internal_offertype() const {
  return _impl_.offertype_;
}
inline int32_t VideoRentalTerm::offertype() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.VideoRentalTerm.offerType)
  return _internal_offertype();
}
inline void VideoRentalTerm::_internal_set_offertype(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.offertype_ = value;
}
inline void VideoRentalTerm::set_offertype(int32_t value) {
  _internal_set_offertype(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.VideoRentalTerm.offerType)
}

// optional string offerAbbreviation = 2;
inline bool VideoRentalTerm::_internal_has_offerabbreviation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VideoRentalTerm::has_offerabbreviation() const {
  return _internal_has_offerabbreviation();
}
inline void VideoRentalTerm::clear_offerabbreviation() {
  _impl_.offerabbreviation_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VideoRentalTerm::offerabbreviation() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.VideoRentalTerm.offerAbbreviation)
  return _internal_offerabbreviation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoRentalTerm::set_offerabbreviation(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.offerabbreviation_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.VideoRentalTerm.offerAbbreviation)
}
inline std::string* VideoRentalTerm::mutable_offerabbreviation() {
  std::string* _s = _internal_mutable_offerabbreviation();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.VideoRentalTerm.offerAbbreviation)
  return _s;
}
inline const std::string& VideoRentalTerm::_internal_offerabbreviation() const {
  return _impl_.offerabbreviation_.Get();
}
inline void VideoRentalTerm::_internal_set_offerabbreviation(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.offerabbreviation_.Set(value, GetArenaForAllocation());
}
inline std::string* VideoRentalTerm::_internal_mutable_offerabbreviation() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.offerabbreviation_.Mutable(GetArenaForAllocation());
}
inline std::string* VideoRentalTerm::release_offerabbreviation() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.VideoRentalTerm.offerAbbreviation)
  if (!_internal_has_offerabbreviation()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.offerabbreviation_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.offerabbreviation_.IsDefault()) {
    _impl_.offerabbreviation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void VideoRentalTerm::set_allocated_offerabbreviation(std::string* offerabbreviation) {
  if (offerabbreviation != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.offerabbreviation_.SetAllocated(offerabbreviation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.offerabbreviation_.IsDefault()) {
    _impl_.offerabbreviation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.VideoRentalTerm.offerAbbreviation)
}

// optional string rentalHeader = 3;
inline bool VideoRentalTerm::_internal_has_rentalheader() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VideoRentalTerm::has_rentalheader() const {
  return _internal_has_rentalheader();
}
inline void VideoRentalTerm::clear_rentalheader() {
  _impl_.rentalheader_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& VideoRentalTerm::rentalheader() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.VideoRentalTerm.rentalHeader)
  return _internal_rentalheader();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoRentalTerm::set_rentalheader(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.rentalheader_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.VideoRentalTerm.rentalHeader)
}
inline std::string* VideoRentalTerm::mutable_rentalheader() {
  std::string* _s = _internal_mutable_rentalheader();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.VideoRentalTerm.rentalHeader)
  return _s;
}
inline const std::string& VideoRentalTerm::_internal_rentalheader() const {
  return _impl_.rentalheader_.Get();
}
inline void VideoRentalTerm::_internal_set_rentalheader(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.rentalheader_.Set(value, GetArenaForAllocation());
}
inline std::string* VideoRentalTerm::_internal_mutable_rentalheader() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.rentalheader_.Mutable(GetArenaForAllocation());
}
inline std::string* VideoRentalTerm::release_rentalheader() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.VideoRentalTerm.rentalHeader)
  if (!_internal_has_rentalheader()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.rentalheader_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rentalheader_.IsDefault()) {
    _impl_.rentalheader_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void VideoRentalTerm::set_allocated_rentalheader(std::string* rentalheader) {
  if (rentalheader != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.rentalheader_.SetAllocated(rentalheader, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rentalheader_.IsDefault()) {
    _impl_.rentalheader_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.VideoRentalTerm.rentalHeader)
}

// repeated group Term = 4 { ... };
inline int VideoRentalTerm::_internal_term_size() const {
  return _impl_.term_.size();
}
inline int VideoRentalTerm::term_size() const {
  return _internal_term_size();
}
inline void VideoRentalTerm::clear_term() {
  _impl_.term_.Clear();
}
inline ::playapi::proto::finsky::document::VideoRentalTerm_Term* VideoRentalTerm::mutable_term(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.VideoRentalTerm.term)
  return _impl_.term_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::VideoRentalTerm_Term >*
VideoRentalTerm::mutable_term() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.document.VideoRentalTerm.term)
  return &_impl_.term_;
}
inline const ::playapi::proto::finsky::document::VideoRentalTerm_Term& VideoRentalTerm::_internal_term(int index) const {
  return _impl_.term_.Get(index);
}
inline const ::playapi::proto::finsky::document::VideoRentalTerm_Term& VideoRentalTerm::term(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.VideoRentalTerm.term)
  return _internal_term(index);
}
inline ::playapi::proto::finsky::document::VideoRentalTerm_Term* VideoRentalTerm::_internal_add_term() {
  return _impl_.term_.Add();
}
inline ::playapi::proto::finsky::document::VideoRentalTerm_Term* VideoRentalTerm::add_term() {
  ::playapi::proto::finsky::document::VideoRentalTerm_Term* _add = _internal_add_term();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.VideoRentalTerm.term)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::VideoRentalTerm_Term >&
VideoRentalTerm::term() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.document.VideoRentalTerm.term)
  return _impl_.term_;
}

// -------------------------------------------------------------------

// SubscriptionDetails

// optional int32 subscriptionPeriod = 1;
inline bool SubscriptionDetails::_internal_has_subscriptionperiod() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SubscriptionDetails::has_subscriptionperiod() const {
  return _internal_has_subscriptionperiod();
}
inline void SubscriptionDetails::clear_subscriptionperiod() {
  _impl_.subscriptionperiod_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t SubscriptionDetails::_internal_subscriptionperiod() const {
  return _impl_.subscriptionperiod_;
}
inline int32_t SubscriptionDetails::subscriptionperiod() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.SubscriptionDetails.subscriptionPeriod)
  return _internal_subscriptionperiod();
}
inline void SubscriptionDetails::_internal_set_subscriptionperiod(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.subscriptionperiod_ = value;
}
inline void SubscriptionDetails::set_subscriptionperiod(int32_t value) {
  _internal_set_subscriptionperiod(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.SubscriptionDetails.subscriptionPeriod)
}

// -------------------------------------------------------------------

// MagazineDetails

// optional string parentDetailsUrl = 1;
inline bool MagazineDetails::_internal_has_parentdetailsurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MagazineDetails::has_parentdetailsurl() const {
  return _internal_has_parentdetailsurl();
}
inline void MagazineDetails::clear_parentdetailsurl() {
  _impl_.parentdetailsurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MagazineDetails::parentdetailsurl() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.MagazineDetails.parentDetailsUrl)
  return _internal_parentdetailsurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MagazineDetails::set_parentdetailsurl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.parentdetailsurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.MagazineDetails.parentDetailsUrl)
}
inline std::string* MagazineDetails::mutable_parentdetailsurl() {
  std::string* _s = _internal_mutable_parentdetailsurl();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.MagazineDetails.parentDetailsUrl)
  return _s;
}
inline const std::string& MagazineDetails::_internal_parentdetailsurl() const {
  return _impl_.parentdetailsurl_.Get();
}
inline void MagazineDetails::_internal_set_parentdetailsurl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.parentdetailsurl_.Set(value, GetArenaForAllocation());
}
inline std::string* MagazineDetails::_internal_mutable_parentdetailsurl() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.parentdetailsurl_.Mutable(GetArenaForAllocation());
}
inline std::string* MagazineDetails::release_parentdetailsurl() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.MagazineDetails.parentDetailsUrl)
  if (!_internal_has_parentdetailsurl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.parentdetailsurl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parentdetailsurl_.IsDefault()) {
    _impl_.parentdetailsurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MagazineDetails::set_allocated_parentdetailsurl(std::string* parentdetailsurl) {
  if (parentdetailsurl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.parentdetailsurl_.SetAllocated(parentdetailsurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parentdetailsurl_.IsDefault()) {
    _impl_.parentdetailsurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.MagazineDetails.parentDetailsUrl)
}

// optional string deviceAvailabilityDescriptionHtml = 2;
inline bool MagazineDetails::_internal_has_deviceavailabilitydescriptionhtml() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MagazineDetails::has_deviceavailabilitydescriptionhtml() const {
  return _internal_has_deviceavailabilitydescriptionhtml();
}
inline void MagazineDetails::clear_deviceavailabilitydescriptionhtml() {
  _impl_.deviceavailabilitydescriptionhtml_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MagazineDetails::deviceavailabilitydescriptionhtml() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.MagazineDetails.deviceAvailabilityDescriptionHtml)
  return _internal_deviceavailabilitydescriptionhtml();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MagazineDetails::set_deviceavailabilitydescriptionhtml(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.deviceavailabilitydescriptionhtml_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.MagazineDetails.deviceAvailabilityDescriptionHtml)
}
inline std::string* MagazineDetails::mutable_deviceavailabilitydescriptionhtml() {
  std::string* _s = _internal_mutable_deviceavailabilitydescriptionhtml();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.MagazineDetails.deviceAvailabilityDescriptionHtml)
  return _s;
}
inline const std::string& MagazineDetails::_internal_deviceavailabilitydescriptionhtml() const {
  return _impl_.deviceavailabilitydescriptionhtml_.Get();
}
inline void MagazineDetails::_internal_set_deviceavailabilitydescriptionhtml(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.deviceavailabilitydescriptionhtml_.Set(value, GetArenaForAllocation());
}
inline std::string* MagazineDetails::_internal_mutable_deviceavailabilitydescriptionhtml() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.deviceavailabilitydescriptionhtml_.Mutable(GetArenaForAllocation());
}
inline std::string* MagazineDetails::release_deviceavailabilitydescriptionhtml() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.MagazineDetails.deviceAvailabilityDescriptionHtml)
  if (!_internal_has_deviceavailabilitydescriptionhtml()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.deviceavailabilitydescriptionhtml_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.deviceavailabilitydescriptionhtml_.IsDefault()) {
    _impl_.deviceavailabilitydescriptionhtml_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MagazineDetails::set_allocated_deviceavailabilitydescriptionhtml(std::string* deviceavailabilitydescriptionhtml) {
  if (deviceavailabilitydescriptionhtml != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.deviceavailabilitydescriptionhtml_.SetAllocated(deviceavailabilitydescriptionhtml, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.deviceavailabilitydescriptionhtml_.IsDefault()) {
    _impl_.deviceavailabilitydescriptionhtml_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.MagazineDetails.deviceAvailabilityDescriptionHtml)
}

// optional string psvDescription = 3;
inline bool MagazineDetails::_internal_has_psvdescription() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MagazineDetails::has_psvdescription() const {
  return _internal_has_psvdescription();
}
inline void MagazineDetails::clear_psvdescription() {
  _impl_.psvdescription_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& MagazineDetails::psvdescription() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.MagazineDetails.psvDescription)
  return _internal_psvdescription();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MagazineDetails::set_psvdescription(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.psvdescription_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.MagazineDetails.psvDescription)
}
inline std::string* MagazineDetails::mutable_psvdescription() {
  std::string* _s = _internal_mutable_psvdescription();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.MagazineDetails.psvDescription)
  return _s;
}
inline const std::string& MagazineDetails::_internal_psvdescription() const {
  return _impl_.psvdescription_.Get();
}
inline void MagazineDetails::_internal_set_psvdescription(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.psvdescription_.Set(value, GetArenaForAllocation());
}
inline std::string* MagazineDetails::_internal_mutable_psvdescription() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.psvdescription_.Mutable(GetArenaForAllocation());
}
inline std::string* MagazineDetails::release_psvdescription() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.MagazineDetails.psvDescription)
  if (!_internal_has_psvdescription()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.psvdescription_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.psvdescription_.IsDefault()) {
    _impl_.psvdescription_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MagazineDetails::set_allocated_psvdescription(std::string* psvdescription) {
  if (psvdescription != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.psvdescription_.SetAllocated(psvdescription, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.psvdescription_.IsDefault()) {
    _impl_.psvdescription_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.MagazineDetails.psvDescription)
}

// optional string deliveryFrequencyDescription = 4;
inline bool MagazineDetails::_internal_has_deliveryfrequencydescription() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MagazineDetails::has_deliveryfrequencydescription() const {
  return _internal_has_deliveryfrequencydescription();
}
inline void MagazineDetails::clear_deliveryfrequencydescription() {
  _impl_.deliveryfrequencydescription_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& MagazineDetails::deliveryfrequencydescription() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.MagazineDetails.deliveryFrequencyDescription)
  return _internal_deliveryfrequencydescription();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MagazineDetails::set_deliveryfrequencydescription(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.deliveryfrequencydescription_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.MagazineDetails.deliveryFrequencyDescription)
}
inline std::string* MagazineDetails::mutable_deliveryfrequencydescription() {
  std::string* _s = _internal_mutable_deliveryfrequencydescription();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.MagazineDetails.deliveryFrequencyDescription)
  return _s;
}
inline const std::string& MagazineDetails::_internal_deliveryfrequencydescription() const {
  return _impl_.deliveryfrequencydescription_.Get();
}
inline void MagazineDetails::_internal_set_deliveryfrequencydescription(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.deliveryfrequencydescription_.Set(value, GetArenaForAllocation());
}
inline std::string* MagazineDetails::_internal_mutable_deliveryfrequencydescription() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.deliveryfrequencydescription_.Mutable(GetArenaForAllocation());
}
inline std::string* MagazineDetails::release_deliveryfrequencydescription() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.MagazineDetails.deliveryFrequencyDescription)
  if (!_internal_has_deliveryfrequencydescription()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.deliveryfrequencydescription_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.deliveryfrequencydescription_.IsDefault()) {
    _impl_.deliveryfrequencydescription_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MagazineDetails::set_allocated_deliveryfrequencydescription(std::string* deliveryfrequencydescription) {
  if (deliveryfrequencydescription != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.deliveryfrequencydescription_.SetAllocated(deliveryfrequencydescription, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.deliveryfrequencydescription_.IsDefault()) {
    _impl_.deliveryfrequencydescription_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.MagazineDetails.deliveryFrequencyDescription)
}

// -------------------------------------------------------------------

// TvShowDetails

// optional int32 seasonCount = 1;
inline bool TvShowDetails::_internal_has_seasoncount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TvShowDetails::has_seasoncount() const {
  return _internal_has_seasoncount();
}
inline void TvShowDetails::clear_seasoncount() {
  _impl_.seasoncount_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t TvShowDetails::_internal_seasoncount() const {
  return _impl_.seasoncount_;
}
inline int32_t TvShowDetails::seasoncount() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.TvShowDetails.seasonCount)
  return _internal_seasoncount();
}
inline void TvShowDetails::_internal_set_seasoncount(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.seasoncount_ = value;
}
inline void TvShowDetails::set_seasoncount(int32_t value) {
  _internal_set_seasoncount(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.TvShowDetails.seasonCount)
}

// optional int32 startYear = 2;
inline bool TvShowDetails::_internal_has_startyear() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TvShowDetails::has_startyear() const {
  return _internal_has_startyear();
}
inline void TvShowDetails::clear_startyear() {
  _impl_.startyear_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t TvShowDetails::_internal_startyear() const {
  return _impl_.startyear_;
}
inline int32_t TvShowDetails::startyear() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.TvShowDetails.startYear)
  return _internal_startyear();
}
inline void TvShowDetails::_internal_set_startyear(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.startyear_ = value;
}
inline void TvShowDetails::set_startyear(int32_t value) {
  _internal_set_startyear(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.TvShowDetails.startYear)
}

// optional int32 endYear = 3;
inline bool TvShowDetails::_internal_has_endyear() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TvShowDetails::has_endyear() const {
  return _internal_has_endyear();
}
inline void TvShowDetails::clear_endyear() {
  _impl_.endyear_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t TvShowDetails::_internal_endyear() const {
  return _impl_.endyear_;
}
inline int32_t TvShowDetails::endyear() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.TvShowDetails.endYear)
  return _internal_endyear();
}
inline void TvShowDetails::_internal_set_endyear(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.endyear_ = value;
}
inline void TvShowDetails::set_endyear(int32_t value) {
  _internal_set_endyear(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.TvShowDetails.endYear)
}

// optional string broadcaster = 4;
inline bool TvShowDetails::_internal_has_broadcaster() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TvShowDetails::has_broadcaster() const {
  return _internal_has_broadcaster();
}
inline void TvShowDetails::clear_broadcaster() {
  _impl_.broadcaster_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TvShowDetails::broadcaster() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.TvShowDetails.broadcaster)
  return _internal_broadcaster();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TvShowDetails::set_broadcaster(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.broadcaster_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.TvShowDetails.broadcaster)
}
inline std::string* TvShowDetails::mutable_broadcaster() {
  std::string* _s = _internal_mutable_broadcaster();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.TvShowDetails.broadcaster)
  return _s;
}
inline const std::string& TvShowDetails::_internal_broadcaster() const {
  return _impl_.broadcaster_.Get();
}
inline void TvShowDetails::_internal_set_broadcaster(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.broadcaster_.Set(value, GetArenaForAllocation());
}
inline std::string* TvShowDetails::_internal_mutable_broadcaster() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.broadcaster_.Mutable(GetArenaForAllocation());
}
inline std::string* TvShowDetails::release_broadcaster() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.TvShowDetails.broadcaster)
  if (!_internal_has_broadcaster()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.broadcaster_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.broadcaster_.IsDefault()) {
    _impl_.broadcaster_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TvShowDetails::set_allocated_broadcaster(std::string* broadcaster) {
  if (broadcaster != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.broadcaster_.SetAllocated(broadcaster, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.broadcaster_.IsDefault()) {
    _impl_.broadcaster_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.TvShowDetails.broadcaster)
}

// -------------------------------------------------------------------

// TvSeasonDetails

// optional string parentDetailsUrl = 1;
inline bool TvSeasonDetails::_internal_has_parentdetailsurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TvSeasonDetails::has_parentdetailsurl() const {
  return _internal_has_parentdetailsurl();
}
inline void TvSeasonDetails::clear_parentdetailsurl() {
  _impl_.parentdetailsurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TvSeasonDetails::parentdetailsurl() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.TvSeasonDetails.parentDetailsUrl)
  return _internal_parentdetailsurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TvSeasonDetails::set_parentdetailsurl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.parentdetailsurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.TvSeasonDetails.parentDetailsUrl)
}
inline std::string* TvSeasonDetails::mutable_parentdetailsurl() {
  std::string* _s = _internal_mutable_parentdetailsurl();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.TvSeasonDetails.parentDetailsUrl)
  return _s;
}
inline const std::string& TvSeasonDetails::_internal_parentdetailsurl() const {
  return _impl_.parentdetailsurl_.Get();
}
inline void TvSeasonDetails::_internal_set_parentdetailsurl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.parentdetailsurl_.Set(value, GetArenaForAllocation());
}
inline std::string* TvSeasonDetails::_internal_mutable_parentdetailsurl() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.parentdetailsurl_.Mutable(GetArenaForAllocation());
}
inline std::string* TvSeasonDetails::release_parentdetailsurl() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.TvSeasonDetails.parentDetailsUrl)
  if (!_internal_has_parentdetailsurl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.parentdetailsurl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parentdetailsurl_.IsDefault()) {
    _impl_.parentdetailsurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TvSeasonDetails::set_allocated_parentdetailsurl(std::string* parentdetailsurl) {
  if (parentdetailsurl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.parentdetailsurl_.SetAllocated(parentdetailsurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parentdetailsurl_.IsDefault()) {
    _impl_.parentdetailsurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.TvSeasonDetails.parentDetailsUrl)
}

// optional int32 seasonIndex = 2;
inline bool TvSeasonDetails::_internal_has_seasonindex() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TvSeasonDetails::has_seasonindex() const {
  return _internal_has_seasonindex();
}
inline void TvSeasonDetails::clear_seasonindex() {
  _impl_.seasonindex_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t TvSeasonDetails::_internal_seasonindex() const {
  return _impl_.seasonindex_;
}
inline int32_t TvSeasonDetails::seasonindex() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.TvSeasonDetails.seasonIndex)
  return _internal_seasonindex();
}
inline void TvSeasonDetails::_internal_set_seasonindex(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.seasonindex_ = value;
}
inline void TvSeasonDetails::set_seasonindex(int32_t value) {
  _internal_set_seasonindex(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.TvSeasonDetails.seasonIndex)
}

// optional string releaseDate = 3;
inline bool TvSeasonDetails::_internal_has_releasedate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TvSeasonDetails::has_releasedate() const {
  return _internal_has_releasedate();
}
inline void TvSeasonDetails::clear_releasedate() {
  _impl_.releasedate_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TvSeasonDetails::releasedate() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.TvSeasonDetails.releaseDate)
  return _internal_releasedate();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TvSeasonDetails::set_releasedate(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.releasedate_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.TvSeasonDetails.releaseDate)
}
inline std::string* TvSeasonDetails::mutable_releasedate() {
  std::string* _s = _internal_mutable_releasedate();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.TvSeasonDetails.releaseDate)
  return _s;
}
inline const std::string& TvSeasonDetails::_internal_releasedate() const {
  return _impl_.releasedate_.Get();
}
inline void TvSeasonDetails::_internal_set_releasedate(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.releasedate_.Set(value, GetArenaForAllocation());
}
inline std::string* TvSeasonDetails::_internal_mutable_releasedate() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.releasedate_.Mutable(GetArenaForAllocation());
}
inline std::string* TvSeasonDetails::release_releasedate() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.TvSeasonDetails.releaseDate)
  if (!_internal_has_releasedate()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.releasedate_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.releasedate_.IsDefault()) {
    _impl_.releasedate_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TvSeasonDetails::set_allocated_releasedate(std::string* releasedate) {
  if (releasedate != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.releasedate_.SetAllocated(releasedate, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.releasedate_.IsDefault()) {
    _impl_.releasedate_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.TvSeasonDetails.releaseDate)
}

// optional string broadcaster = 4;
inline bool TvSeasonDetails::_internal_has_broadcaster() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TvSeasonDetails::has_broadcaster() const {
  return _internal_has_broadcaster();
}
inline void TvSeasonDetails::clear_broadcaster() {
  _impl_.broadcaster_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TvSeasonDetails::broadcaster() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.TvSeasonDetails.broadcaster)
  return _internal_broadcaster();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TvSeasonDetails::set_broadcaster(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.broadcaster_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.TvSeasonDetails.broadcaster)
}
inline std::string* TvSeasonDetails::mutable_broadcaster() {
  std::string* _s = _internal_mutable_broadcaster();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.TvSeasonDetails.broadcaster)
  return _s;
}
inline const std::string& TvSeasonDetails::_internal_broadcaster() const {
  return _impl_.broadcaster_.Get();
}
inline void TvSeasonDetails::_internal_set_broadcaster(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.broadcaster_.Set(value, GetArenaForAllocation());
}
inline std::string* TvSeasonDetails::_internal_mutable_broadcaster() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.broadcaster_.Mutable(GetArenaForAllocation());
}
inline std::string* TvSeasonDetails::release_broadcaster() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.TvSeasonDetails.broadcaster)
  if (!_internal_has_broadcaster()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.broadcaster_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.broadcaster_.IsDefault()) {
    _impl_.broadcaster_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TvSeasonDetails::set_allocated_broadcaster(std::string* broadcaster) {
  if (broadcaster != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.broadcaster_.SetAllocated(broadcaster, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.broadcaster_.IsDefault()) {
    _impl_.broadcaster_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.TvSeasonDetails.broadcaster)
}

// optional int32 episodeCount = 5;
inline bool TvSeasonDetails::_internal_has_episodecount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TvSeasonDetails::has_episodecount() const {
  return _internal_has_episodecount();
}
inline void TvSeasonDetails::clear_episodecount() {
  _impl_.episodecount_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t TvSeasonDetails::_internal_episodecount() const {
  return _impl_.episodecount_;
}
inline int32_t TvSeasonDetails::episodecount() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.TvSeasonDetails.episodeCount)
  return _internal_episodecount();
}
inline void TvSeasonDetails::_internal_set_episodecount(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.episodecount_ = value;
}
inline void TvSeasonDetails::set_episodecount(int32_t value) {
  _internal_set_episodecount(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.TvSeasonDetails.episodeCount)
}

// optional int32 expectedEpisodeCount = 6;
inline bool TvSeasonDetails::_internal_has_expectedepisodecount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TvSeasonDetails::has_expectedepisodecount() const {
  return _internal_has_expectedepisodecount();
}
inline void TvSeasonDetails::clear_expectedepisodecount() {
  _impl_.expectedepisodecount_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int32_t TvSeasonDetails::_internal_expectedepisodecount() const {
  return _impl_.expectedepisodecount_;
}
inline int32_t TvSeasonDetails::expectedepisodecount() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.TvSeasonDetails.expectedEpisodeCount)
  return _internal_expectedepisodecount();
}
inline void TvSeasonDetails::_internal_set_expectedepisodecount(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.expectedepisodecount_ = value;
}
inline void TvSeasonDetails::set_expectedepisodecount(int32_t value) {
  _internal_set_expectedepisodecount(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.TvSeasonDetails.expectedEpisodeCount)
}

// optional bool inProgress = 7;
inline bool TvSeasonDetails::_internal_has_inprogress() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool TvSeasonDetails::has_inprogress() const {
  return _internal_has_inprogress();
}
inline void TvSeasonDetails::clear_inprogress() {
  _impl_.inprogress_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool TvSeasonDetails::_internal_inprogress() const {
  return _impl_.inprogress_;
}
inline bool TvSeasonDetails::inprogress() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.TvSeasonDetails.inProgress)
  return _internal_inprogress();
}
inline void TvSeasonDetails::_internal_set_inprogress(bool value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.inprogress_ = value;
}
inline void TvSeasonDetails::set_inprogress(bool value) {
  _internal_set_inprogress(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.TvSeasonDetails.inProgress)
}

// -------------------------------------------------------------------

// TvEpisodeDetails

// optional string parentDetailsUrl = 1;
inline bool TvEpisodeDetails::_internal_has_parentdetailsurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TvEpisodeDetails::has_parentdetailsurl() const {
  return _internal_has_parentdetailsurl();
}
inline void TvEpisodeDetails::clear_parentdetailsurl() {
  _impl_.parentdetailsurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TvEpisodeDetails::parentdetailsurl() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.TvEpisodeDetails.parentDetailsUrl)
  return _internal_parentdetailsurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TvEpisodeDetails::set_parentdetailsurl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.parentdetailsurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.TvEpisodeDetails.parentDetailsUrl)
}
inline std::string* TvEpisodeDetails::mutable_parentdetailsurl() {
  std::string* _s = _internal_mutable_parentdetailsurl();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.TvEpisodeDetails.parentDetailsUrl)
  return _s;
}
inline const std::string& TvEpisodeDetails::_internal_parentdetailsurl() const {
  return _impl_.parentdetailsurl_.Get();
}
inline void TvEpisodeDetails::_internal_set_parentdetailsurl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.parentdetailsurl_.Set(value, GetArenaForAllocation());
}
inline std::string* TvEpisodeDetails::_internal_mutable_parentdetailsurl() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.parentdetailsurl_.Mutable(GetArenaForAllocation());
}
inline std::string* TvEpisodeDetails::release_parentdetailsurl() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.TvEpisodeDetails.parentDetailsUrl)
  if (!_internal_has_parentdetailsurl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.parentdetailsurl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parentdetailsurl_.IsDefault()) {
    _impl_.parentdetailsurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TvEpisodeDetails::set_allocated_parentdetailsurl(std::string* parentdetailsurl) {
  if (parentdetailsurl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.parentdetailsurl_.SetAllocated(parentdetailsurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parentdetailsurl_.IsDefault()) {
    _impl_.parentdetailsurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.TvEpisodeDetails.parentDetailsUrl)
}

// optional int32 episodeIndex = 2;
inline bool TvEpisodeDetails::_internal_has_episodeindex() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TvEpisodeDetails::has_episodeindex() const {
  return _internal_has_episodeindex();
}
inline void TvEpisodeDetails::clear_episodeindex() {
  _impl_.episodeindex_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t TvEpisodeDetails::_internal_episodeindex() const {
  return _impl_.episodeindex_;
}
inline int32_t TvEpisodeDetails::episodeindex() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.TvEpisodeDetails.episodeIndex)
  return _internal_episodeindex();
}
inline void TvEpisodeDetails::_internal_set_episodeindex(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.episodeindex_ = value;
}
inline void TvEpisodeDetails::set_episodeindex(int32_t value) {
  _internal_set_episodeindex(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.TvEpisodeDetails.episodeIndex)
}

// optional string releaseDate = 3;
inline bool TvEpisodeDetails::_internal_has_releasedate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TvEpisodeDetails::has_releasedate() const {
  return _internal_has_releasedate();
}
inline void TvEpisodeDetails::clear_releasedate() {
  _impl_.releasedate_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TvEpisodeDetails::releasedate() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.TvEpisodeDetails.releaseDate)
  return _internal_releasedate();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TvEpisodeDetails::set_releasedate(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.releasedate_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.TvEpisodeDetails.releaseDate)
}
inline std::string* TvEpisodeDetails::mutable_releasedate() {
  std::string* _s = _internal_mutable_releasedate();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.TvEpisodeDetails.releaseDate)
  return _s;
}
inline const std::string& TvEpisodeDetails::_internal_releasedate() const {
  return _impl_.releasedate_.Get();
}
inline void TvEpisodeDetails::_internal_set_releasedate(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.releasedate_.Set(value, GetArenaForAllocation());
}
inline std::string* TvEpisodeDetails::_internal_mutable_releasedate() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.releasedate_.Mutable(GetArenaForAllocation());
}
inline std::string* TvEpisodeDetails::release_releasedate() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.TvEpisodeDetails.releaseDate)
  if (!_internal_has_releasedate()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.releasedate_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.releasedate_.IsDefault()) {
    _impl_.releasedate_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TvEpisodeDetails::set_allocated_releasedate(std::string* releasedate) {
  if (releasedate != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.releasedate_.SetAllocated(releasedate, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.releasedate_.IsDefault()) {
    _impl_.releasedate_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.TvEpisodeDetails.releaseDate)
}

// -------------------------------------------------------------------

// PersonDetails

// optional bool personIsRequester = 1;
inline bool PersonDetails::_internal_has_personisrequester() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PersonDetails::has_personisrequester() const {
  return _internal_has_personisrequester();
}
inline void PersonDetails::clear_personisrequester() {
  _impl_.personisrequester_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool PersonDetails::_internal_personisrequester() const {
  return _impl_.personisrequester_;
}
inline bool PersonDetails::personisrequester() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.PersonDetails.personIsRequester)
  return _internal_personisrequester();
}
inline void PersonDetails::_internal_set_personisrequester(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.personisrequester_ = value;
}
inline void PersonDetails::set_personisrequester(bool value) {
  _internal_set_personisrequester(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.PersonDetails.personIsRequester)
}

// optional bool isGplusUser = 2;
inline bool PersonDetails::_internal_has_isgplususer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PersonDetails::has_isgplususer() const {
  return _internal_has_isgplususer();
}
inline void PersonDetails::clear_isgplususer() {
  _impl_.isgplususer_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool PersonDetails::_internal_isgplususer() const {
  return _impl_.isgplususer_;
}
inline bool PersonDetails::isgplususer() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.PersonDetails.isGplusUser)
  return _internal_isgplususer();
}
inline void PersonDetails::_internal_set_isgplususer(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.isgplususer_ = value;
}
inline void PersonDetails::set_isgplususer(bool value) {
  _internal_set_isgplususer(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.PersonDetails.isGplusUser)
}

// -------------------------------------------------------------------

// TalentDetails

// optional .playapi.proto.finsky.document.TalentExternalLinks externalLinks = 1;
inline bool TalentDetails::_internal_has_externallinks() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.externallinks_ != nullptr);
  return value;
}
inline bool TalentDetails::has_externallinks() const {
  return _internal_has_externallinks();
}
inline void TalentDetails::clear_externallinks() {
  if (_impl_.externallinks_ != nullptr) _impl_.externallinks_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::playapi::proto::finsky::document::TalentExternalLinks& TalentDetails::_internal_externallinks() const {
  const ::playapi::proto::finsky::document::TalentExternalLinks* p = _impl_.externallinks_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::TalentExternalLinks&>(
      ::playapi::proto::finsky::document::_TalentExternalLinks_default_instance_);
}
inline const ::playapi::proto::finsky::document::TalentExternalLinks& TalentDetails::externallinks() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.TalentDetails.externalLinks)
  return _internal_externallinks();
}
inline void TalentDetails::unsafe_arena_set_allocated_externallinks(
    ::playapi::proto::finsky::document::TalentExternalLinks* externallinks) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.externallinks_);
  }
  _impl_.externallinks_ = externallinks;
  if (externallinks) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.TalentDetails.externalLinks)
}
inline ::playapi::proto::finsky::document::TalentExternalLinks* TalentDetails::release_externallinks() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::playapi::proto::finsky::document::TalentExternalLinks* temp = _impl_.externallinks_;
  _impl_.externallinks_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::TalentExternalLinks* TalentDetails::unsafe_arena_release_externallinks() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.TalentDetails.externalLinks)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::playapi::proto::finsky::document::TalentExternalLinks* temp = _impl_.externallinks_;
  _impl_.externallinks_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::TalentExternalLinks* TalentDetails::_internal_mutable_externallinks() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.externallinks_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::TalentExternalLinks>(GetArenaForAllocation());
    _impl_.externallinks_ = p;
  }
  return _impl_.externallinks_;
}
inline ::playapi::proto::finsky::document::TalentExternalLinks* TalentDetails::mutable_externallinks() {
  ::playapi::proto::finsky::document::TalentExternalLinks* _msg = _internal_mutable_externallinks();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.TalentDetails.externalLinks)
  return _msg;
}
inline void TalentDetails::set_allocated_externallinks(::playapi::proto::finsky::document::TalentExternalLinks* externallinks) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.externallinks_;
  }
  if (externallinks) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(externallinks);
    if (message_arena != submessage_arena) {
      externallinks = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, externallinks, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.externallinks_ = externallinks;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.TalentDetails.externalLinks)
}

// optional int32 primaryRoleId = 2;
inline bool TalentDetails::_internal_has_primaryroleid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TalentDetails::has_primaryroleid() const {
  return _internal_has_primaryroleid();
}
inline void TalentDetails::clear_primaryroleid() {
  _impl_.primaryroleid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t TalentDetails::_internal_primaryroleid() const {
  return _impl_.primaryroleid_;
}
inline int32_t TalentDetails::primaryroleid() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.TalentDetails.primaryRoleId)
  return _internal_primaryroleid();
}
inline void TalentDetails::_internal_set_primaryroleid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.primaryroleid_ = value;
}
inline void TalentDetails::set_primaryroleid(int32_t value) {
  _internal_set_primaryroleid(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.TalentDetails.primaryRoleId)
}

// -------------------------------------------------------------------

// TalentExternalLinks

// repeated .playapi.proto.finsky.link.Link websiteUrl = 1;
inline int TalentExternalLinks::_internal_websiteurl_size() const {
  return _impl_.websiteurl_.size();
}
inline int TalentExternalLinks::websiteurl_size() const {
  return _internal_websiteurl_size();
}
inline ::playapi::proto::finsky::link::Link* TalentExternalLinks::mutable_websiteurl(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.TalentExternalLinks.websiteUrl)
  return _impl_.websiteurl_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::link::Link >*
TalentExternalLinks::mutable_websiteurl() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.document.TalentExternalLinks.websiteUrl)
  return &_impl_.websiteurl_;
}
inline const ::playapi::proto::finsky::link::Link& TalentExternalLinks::_internal_websiteurl(int index) const {
  return _impl_.websiteurl_.Get(index);
}
inline const ::playapi::proto::finsky::link::Link& TalentExternalLinks::websiteurl(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.TalentExternalLinks.websiteUrl)
  return _internal_websiteurl(index);
}
inline ::playapi::proto::finsky::link::Link* TalentExternalLinks::_internal_add_websiteurl() {
  return _impl_.websiteurl_.Add();
}
inline ::playapi::proto::finsky::link::Link* TalentExternalLinks::add_websiteurl() {
  ::playapi::proto::finsky::link::Link* _add = _internal_add_websiteurl();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.TalentExternalLinks.websiteUrl)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::link::Link >&
TalentExternalLinks::websiteurl() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.document.TalentExternalLinks.websiteUrl)
  return _impl_.websiteurl_;
}

// optional .playapi.proto.finsky.link.Link googlePlusProfileUrl = 2;
inline bool TalentExternalLinks::_internal_has_googleplusprofileurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.googleplusprofileurl_ != nullptr);
  return value;
}
inline bool TalentExternalLinks::has_googleplusprofileurl() const {
  return _internal_has_googleplusprofileurl();
}
inline const ::playapi::proto::finsky::link::Link& TalentExternalLinks::_internal_googleplusprofileurl() const {
  const ::playapi::proto::finsky::link::Link* p = _impl_.googleplusprofileurl_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::link::Link&>(
      ::playapi::proto::finsky::link::_Link_default_instance_);
}
inline const ::playapi::proto::finsky::link::Link& TalentExternalLinks::googleplusprofileurl() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.TalentExternalLinks.googlePlusProfileUrl)
  return _internal_googleplusprofileurl();
}
inline void TalentExternalLinks::unsafe_arena_set_allocated_googleplusprofileurl(
    ::playapi::proto::finsky::link::Link* googleplusprofileurl) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.googleplusprofileurl_);
  }
  _impl_.googleplusprofileurl_ = googleplusprofileurl;
  if (googleplusprofileurl) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.TalentExternalLinks.googlePlusProfileUrl)
}
inline ::playapi::proto::finsky::link::Link* TalentExternalLinks::release_googleplusprofileurl() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::playapi::proto::finsky::link::Link* temp = _impl_.googleplusprofileurl_;
  _impl_.googleplusprofileurl_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::link::Link* TalentExternalLinks::unsafe_arena_release_googleplusprofileurl() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.TalentExternalLinks.googlePlusProfileUrl)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::playapi::proto::finsky::link::Link* temp = _impl_.googleplusprofileurl_;
  _impl_.googleplusprofileurl_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::link::Link* TalentExternalLinks::_internal_mutable_googleplusprofileurl() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.googleplusprofileurl_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::link::Link>(GetArenaForAllocation());
    _impl_.googleplusprofileurl_ = p;
  }
  return _impl_.googleplusprofileurl_;
}
inline ::playapi::proto::finsky::link::Link* TalentExternalLinks::mutable_googleplusprofileurl() {
  ::playapi::proto::finsky::link::Link* _msg = _internal_mutable_googleplusprofileurl();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.TalentExternalLinks.googlePlusProfileUrl)
  return _msg;
}
inline void TalentExternalLinks::set_allocated_googleplusprofileurl(::playapi::proto::finsky::link::Link* googleplusprofileurl) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.googleplusprofileurl_);
  }
  if (googleplusprofileurl) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(googleplusprofileurl));
    if (message_arena != submessage_arena) {
      googleplusprofileurl = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, googleplusprofileurl, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.googleplusprofileurl_ = googleplusprofileurl;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.TalentExternalLinks.googlePlusProfileUrl)
}

// optional .playapi.proto.finsky.link.Link youtubeChannelUrl = 3;
inline bool TalentExternalLinks::_internal_has_youtubechannelurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.youtubechannelurl_ != nullptr);
  return value;
}
inline bool TalentExternalLinks::has_youtubechannelurl() const {
  return _internal_has_youtubechannelurl();
}
inline const ::playapi::proto::finsky::link::Link& TalentExternalLinks::_internal_youtubechannelurl() const {
  const ::playapi::proto::finsky::link::Link* p = _impl_.youtubechannelurl_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::link::Link&>(
      ::playapi::proto::finsky::link::_Link_default_instance_);
}
inline const ::playapi::proto::finsky::link::Link& TalentExternalLinks::youtubechannelurl() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.TalentExternalLinks.youtubeChannelUrl)
  return _internal_youtubechannelurl();
}
inline void TalentExternalLinks::unsafe_arena_set_allocated_youtubechannelurl(
    ::playapi::proto::finsky::link::Link* youtubechannelurl) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.youtubechannelurl_);
  }
  _impl_.youtubechannelurl_ = youtubechannelurl;
  if (youtubechannelurl) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.TalentExternalLinks.youtubeChannelUrl)
}
inline ::playapi::proto::finsky::link::Link* TalentExternalLinks::release_youtubechannelurl() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::playapi::proto::finsky::link::Link* temp = _impl_.youtubechannelurl_;
  _impl_.youtubechannelurl_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::link::Link* TalentExternalLinks::unsafe_arena_release_youtubechannelurl() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.TalentExternalLinks.youtubeChannelUrl)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::playapi::proto::finsky::link::Link* temp = _impl_.youtubechannelurl_;
  _impl_.youtubechannelurl_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::link::Link* TalentExternalLinks::_internal_mutable_youtubechannelurl() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.youtubechannelurl_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::link::Link>(GetArenaForAllocation());
    _impl_.youtubechannelurl_ = p;
  }
  return _impl_.youtubechannelurl_;
}
inline ::playapi::proto::finsky::link::Link* TalentExternalLinks::mutable_youtubechannelurl() {
  ::playapi::proto::finsky::link::Link* _msg = _internal_mutable_youtubechannelurl();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.TalentExternalLinks.youtubeChannelUrl)
  return _msg;
}
inline void TalentExternalLinks::set_allocated_youtubechannelurl(::playapi::proto::finsky::link::Link* youtubechannelurl) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.youtubechannelurl_);
  }
  if (youtubechannelurl) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(youtubechannelurl));
    if (message_arena != submessage_arena) {
      youtubechannelurl = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, youtubechannelurl, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.youtubechannelurl_ = youtubechannelurl;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.TalentExternalLinks.youtubeChannelUrl)
}

// -------------------------------------------------------------------

// DeveloperDetails

// optional string websiteUrl = 1;
inline bool DeveloperDetails::_internal_has_websiteurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeveloperDetails::has_websiteurl() const {
  return _internal_has_websiteurl();
}
inline void DeveloperDetails::clear_websiteurl() {
  _impl_.websiteurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeveloperDetails::websiteurl() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.DeveloperDetails.websiteUrl)
  return _internal_websiteurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeveloperDetails::set_websiteurl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.websiteurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.DeveloperDetails.websiteUrl)
}
inline std::string* DeveloperDetails::mutable_websiteurl() {
  std::string* _s = _internal_mutable_websiteurl();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.DeveloperDetails.websiteUrl)
  return _s;
}
inline const std::string& DeveloperDetails::_internal_websiteurl() const {
  return _impl_.websiteurl_.Get();
}
inline void DeveloperDetails::_internal_set_websiteurl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.websiteurl_.Set(value, GetArenaForAllocation());
}
inline std::string* DeveloperDetails::_internal_mutable_websiteurl() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.websiteurl_.Mutable(GetArenaForAllocation());
}
inline std::string* DeveloperDetails::release_websiteurl() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.DeveloperDetails.websiteUrl)
  if (!_internal_has_websiteurl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.websiteurl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.websiteurl_.IsDefault()) {
    _impl_.websiteurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeveloperDetails::set_allocated_websiteurl(std::string* websiteurl) {
  if (websiteurl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.websiteurl_.SetAllocated(websiteurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.websiteurl_.IsDefault()) {
    _impl_.websiteurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.DeveloperDetails.websiteUrl)
}

// -------------------------------------------------------------------

// BookSeriesDetails

// optional string publisher = 1;
inline bool BookSeriesDetails::_internal_has_publisher() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BookSeriesDetails::has_publisher() const {
  return _internal_has_publisher();
}
inline void BookSeriesDetails::clear_publisher() {
  _impl_.publisher_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BookSeriesDetails::publisher() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.BookSeriesDetails.publisher)
  return _internal_publisher();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BookSeriesDetails::set_publisher(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.publisher_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.BookSeriesDetails.publisher)
}
inline std::string* BookSeriesDetails::mutable_publisher() {
  std::string* _s = _internal_mutable_publisher();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.BookSeriesDetails.publisher)
  return _s;
}
inline const std::string& BookSeriesDetails::_internal_publisher() const {
  return _impl_.publisher_.Get();
}
inline void BookSeriesDetails::_internal_set_publisher(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.publisher_.Set(value, GetArenaForAllocation());
}
inline std::string* BookSeriesDetails::_internal_mutable_publisher() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.publisher_.Mutable(GetArenaForAllocation());
}
inline std::string* BookSeriesDetails::release_publisher() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.BookSeriesDetails.publisher)
  if (!_internal_has_publisher()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.publisher_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.publisher_.IsDefault()) {
    _impl_.publisher_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BookSeriesDetails::set_allocated_publisher(std::string* publisher) {
  if (publisher != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.publisher_.SetAllocated(publisher, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.publisher_.IsDefault()) {
    _impl_.publisher_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.BookSeriesDetails.publisher)
}

// optional string seriesComposition = 2;
inline bool BookSeriesDetails::_internal_has_seriescomposition() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BookSeriesDetails::has_seriescomposition() const {
  return _internal_has_seriescomposition();
}
inline void BookSeriesDetails::clear_seriescomposition() {
  _impl_.seriescomposition_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BookSeriesDetails::seriescomposition() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.BookSeriesDetails.seriesComposition)
  return _internal_seriescomposition();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BookSeriesDetails::set_seriescomposition(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.seriescomposition_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.BookSeriesDetails.seriesComposition)
}
inline std::string* BookSeriesDetails::mutable_seriescomposition() {
  std::string* _s = _internal_mutable_seriescomposition();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.BookSeriesDetails.seriesComposition)
  return _s;
}
inline const std::string& BookSeriesDetails::_internal_seriescomposition() const {
  return _impl_.seriescomposition_.Get();
}
inline void BookSeriesDetails::_internal_set_seriescomposition(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.seriescomposition_.Set(value, GetArenaForAllocation());
}
inline std::string* BookSeriesDetails::_internal_mutable_seriescomposition() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.seriescomposition_.Mutable(GetArenaForAllocation());
}
inline std::string* BookSeriesDetails::release_seriescomposition() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.BookSeriesDetails.seriesComposition)
  if (!_internal_has_seriescomposition()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.seriescomposition_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.seriescomposition_.IsDefault()) {
    _impl_.seriescomposition_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BookSeriesDetails::set_allocated_seriescomposition(std::string* seriescomposition) {
  if (seriescomposition != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.seriescomposition_.SetAllocated(seriescomposition, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.seriescomposition_.IsDefault()) {
    _impl_.seriescomposition_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.BookSeriesDetails.seriesComposition)
}

// optional string seriesCardComposition = 3;
inline bool BookSeriesDetails::_internal_has_seriescardcomposition() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BookSeriesDetails::has_seriescardcomposition() const {
  return _internal_has_seriescardcomposition();
}
inline void BookSeriesDetails::clear_seriescardcomposition() {
  _impl_.seriescardcomposition_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& BookSeriesDetails::seriescardcomposition() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.BookSeriesDetails.seriesCardComposition)
  return _internal_seriescardcomposition();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BookSeriesDetails::set_seriescardcomposition(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.seriescardcomposition_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.BookSeriesDetails.seriesCardComposition)
}
inline std::string* BookSeriesDetails::mutable_seriescardcomposition() {
  std::string* _s = _internal_mutable_seriescardcomposition();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.BookSeriesDetails.seriesCardComposition)
  return _s;
}
inline const std::string& BookSeriesDetails::_internal_seriescardcomposition() const {
  return _impl_.seriescardcomposition_.Get();
}
inline void BookSeriesDetails::_internal_set_seriescardcomposition(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.seriescardcomposition_.Set(value, GetArenaForAllocation());
}
inline std::string* BookSeriesDetails::_internal_mutable_seriescardcomposition() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.seriescardcomposition_.Mutable(GetArenaForAllocation());
}
inline std::string* BookSeriesDetails::release_seriescardcomposition() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.BookSeriesDetails.seriesCardComposition)
  if (!_internal_has_seriescardcomposition()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.seriescardcomposition_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.seriescardcomposition_.IsDefault()) {
    _impl_.seriescardcomposition_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BookSeriesDetails::set_allocated_seriescardcomposition(std::string* seriescardcomposition) {
  if (seriescardcomposition != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.seriescardcomposition_.SetAllocated(seriescardcomposition, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.seriescardcomposition_.IsDefault()) {
    _impl_.seriescardcomposition_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.BookSeriesDetails.seriesCardComposition)
}

// -------------------------------------------------------------------

// AggregateRating

// optional int32 type = 1;
inline bool AggregateRating::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AggregateRating::has_type() const {
  return _internal_has_type();
}
inline void AggregateRating::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t AggregateRating::_internal_type() const {
  return _impl_.type_;
}
inline int32_t AggregateRating::type() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.AggregateRating.type)
  return _internal_type();
}
inline void AggregateRating::_internal_set_type(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.type_ = value;
}
inline void AggregateRating::set_type(int32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.AggregateRating.type)
}

// optional float starRating = 2;
inline bool AggregateRating::_internal_has_starrating() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AggregateRating::has_starrating() const {
  return _internal_has_starrating();
}
inline void AggregateRating::clear_starrating() {
  _impl_.starrating_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float AggregateRating::_internal_starrating() const {
  return _impl_.starrating_;
}
inline float AggregateRating::starrating() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.AggregateRating.starRating)
  return _internal_starrating();
}
inline void AggregateRating::_internal_set_starrating(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.starrating_ = value;
}
inline void AggregateRating::set_starrating(float value) {
  _internal_set_starrating(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.AggregateRating.starRating)
}

// optional int64 ratingsCount = 3;
inline bool AggregateRating::_internal_has_ratingscount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AggregateRating::has_ratingscount() const {
  return _internal_has_ratingscount();
}
inline void AggregateRating::clear_ratingscount() {
  _impl_.ratingscount_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t AggregateRating::_internal_ratingscount() const {
  return _impl_.ratingscount_;
}
inline int64_t AggregateRating::ratingscount() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.AggregateRating.ratingsCount)
  return _internal_ratingscount();
}
inline void AggregateRating::_internal_set_ratingscount(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.ratingscount_ = value;
}
inline void AggregateRating::set_ratingscount(int64_t value) {
  _internal_set_ratingscount(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.AggregateRating.ratingsCount)
}

// optional int64 oneStarRatings = 4;
inline bool AggregateRating::_internal_has_onestarratings() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool AggregateRating::has_onestarratings() const {
  return _internal_has_onestarratings();
}
inline void AggregateRating::clear_onestarratings() {
  _impl_.onestarratings_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int64_t AggregateRating::_internal_onestarratings() const {
  return _impl_.onestarratings_;
}
inline int64_t AggregateRating::onestarratings() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.AggregateRating.oneStarRatings)
  return _internal_onestarratings();
}
inline void AggregateRating::_internal_set_onestarratings(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.onestarratings_ = value;
}
inline void AggregateRating::set_onestarratings(int64_t value) {
  _internal_set_onestarratings(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.AggregateRating.oneStarRatings)
}

// optional int64 twoStarRatings = 5;
inline bool AggregateRating::_internal_has_twostarratings() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool AggregateRating::has_twostarratings() const {
  return _internal_has_twostarratings();
}
inline void AggregateRating::clear_twostarratings() {
  _impl_.twostarratings_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int64_t AggregateRating::_internal_twostarratings() const {
  return _impl_.twostarratings_;
}
inline int64_t AggregateRating::twostarratings() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.AggregateRating.twoStarRatings)
  return _internal_twostarratings();
}
inline void AggregateRating::_internal_set_twostarratings(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.twostarratings_ = value;
}
inline void AggregateRating::set_twostarratings(int64_t value) {
  _internal_set_twostarratings(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.AggregateRating.twoStarRatings)
}

// optional int64 threeStarRatings = 6;
inline bool AggregateRating::_internal_has_threestarratings() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool AggregateRating::has_threestarratings() const {
  return _internal_has_threestarratings();
}
inline void AggregateRating::clear_threestarratings() {
  _impl_.threestarratings_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int64_t AggregateRating::_internal_threestarratings() const {
  return _impl_.threestarratings_;
}
inline int64_t AggregateRating::threestarratings() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.AggregateRating.threeStarRatings)
  return _internal_threestarratings();
}
inline void AggregateRating::_internal_set_threestarratings(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.threestarratings_ = value;
}
inline void AggregateRating::set_threestarratings(int64_t value) {
  _internal_set_threestarratings(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.AggregateRating.threeStarRatings)
}

// optional int64 fourStarRatings = 7;
inline bool AggregateRating::_internal_has_fourstarratings() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool AggregateRating::has_fourstarratings() const {
  return _internal_has_fourstarratings();
}
inline void AggregateRating::clear_fourstarratings() {
  _impl_.fourstarratings_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int64_t AggregateRating::_internal_fourstarratings() const {
  return _impl_.fourstarratings_;
}
inline int64_t AggregateRating::fourstarratings() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.AggregateRating.fourStarRatings)
  return _internal_fourstarratings();
}
inline void AggregateRating::_internal_set_fourstarratings(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.fourstarratings_ = value;
}
inline void AggregateRating::set_fourstarratings(int64_t value) {
  _internal_set_fourstarratings(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.AggregateRating.fourStarRatings)
}

// optional int64 fiveStarRatings = 8;
inline bool AggregateRating::_internal_has_fivestarratings() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool AggregateRating::has_fivestarratings() const {
  return _internal_has_fivestarratings();
}
inline void AggregateRating::clear_fivestarratings() {
  _impl_.fivestarratings_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline int64_t AggregateRating::_internal_fivestarratings() const {
  return _impl_.fivestarratings_;
}
inline int64_t AggregateRating::fivestarratings() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.AggregateRating.fiveStarRatings)
  return _internal_fivestarratings();
}
inline void AggregateRating::_internal_set_fivestarratings(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.fivestarratings_ = value;
}
inline void AggregateRating::set_fivestarratings(int64_t value) {
  _internal_set_fivestarratings(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.AggregateRating.fiveStarRatings)
}

// optional int64 thumbsUpCount = 9;
inline bool AggregateRating::_internal_has_thumbsupcount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool AggregateRating::has_thumbsupcount() const {
  return _internal_has_thumbsupcount();
}
inline void AggregateRating::clear_thumbsupcount() {
  _impl_.thumbsupcount_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline int64_t AggregateRating::_internal_thumbsupcount() const {
  return _impl_.thumbsupcount_;
}
inline int64_t AggregateRating::thumbsupcount() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.AggregateRating.thumbsUpCount)
  return _internal_thumbsupcount();
}
inline void AggregateRating::_internal_set_thumbsupcount(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.thumbsupcount_ = value;
}
inline void AggregateRating::set_thumbsupcount(int64_t value) {
  _internal_set_thumbsupcount(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.AggregateRating.thumbsUpCount)
}

// optional int64 thumbsDownCount = 10;
inline bool AggregateRating::_internal_has_thumbsdowncount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool AggregateRating::has_thumbsdowncount() const {
  return _internal_has_thumbsdowncount();
}
inline void AggregateRating::clear_thumbsdowncount() {
  _impl_.thumbsdowncount_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline int64_t AggregateRating::_internal_thumbsdowncount() const {
  return _impl_.thumbsdowncount_;
}
inline int64_t AggregateRating::thumbsdowncount() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.AggregateRating.thumbsDownCount)
  return _internal_thumbsdowncount();
}
inline void AggregateRating::_internal_set_thumbsdowncount(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.thumbsdowncount_ = value;
}
inline void AggregateRating::set_thumbsdowncount(int64_t value) {
  _internal_set_thumbsdowncount(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.AggregateRating.thumbsDownCount)
}

// optional int64 commentCount = 11;
inline bool AggregateRating::_internal_has_commentcount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool AggregateRating::has_commentcount() const {
  return _internal_has_commentcount();
}
inline void AggregateRating::clear_commentcount() {
  _impl_.commentcount_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline int64_t AggregateRating::_internal_commentcount() const {
  return _impl_.commentcount_;
}
inline int64_t AggregateRating::commentcount() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.AggregateRating.commentCount)
  return _internal_commentcount();
}
inline void AggregateRating::_internal_set_commentcount(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.commentcount_ = value;
}
inline void AggregateRating::set_commentcount(int64_t value) {
  _internal_set_commentcount(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.AggregateRating.commentCount)
}

// optional double bayesianMeanRating = 12;
inline bool AggregateRating::_internal_has_bayesianmeanrating() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool AggregateRating::has_bayesianmeanrating() const {
  return _internal_has_bayesianmeanrating();
}
inline void AggregateRating::clear_bayesianmeanrating() {
  _impl_.bayesianmeanrating_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline double AggregateRating::_internal_bayesianmeanrating() const {
  return _impl_.bayesianmeanrating_;
}
inline double AggregateRating::bayesianmeanrating() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.AggregateRating.bayesianMeanRating)
  return _internal_bayesianmeanrating();
}
inline void AggregateRating::_internal_set_bayesianmeanrating(double value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.bayesianmeanrating_ = value;
}
inline void AggregateRating::set_bayesianmeanrating(double value) {
  _internal_set_bayesianmeanrating(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.AggregateRating.bayesianMeanRating)
}

// repeated .playapi.proto.finsky.document.AggregateRatingTip tip = 13;
inline int AggregateRating::_internal_tip_size() const {
  return _impl_.tip_.size();
}
inline int AggregateRating::tip_size() const {
  return _internal_tip_size();
}
inline void AggregateRating::clear_tip() {
  _impl_.tip_.Clear();
}
inline ::playapi::proto::finsky::document::AggregateRatingTip* AggregateRating::mutable_tip(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.AggregateRating.tip)
  return _impl_.tip_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::AggregateRatingTip >*
AggregateRating::mutable_tip() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.document.AggregateRating.tip)
  return &_impl_.tip_;
}
inline const ::playapi::proto::finsky::document::AggregateRatingTip& AggregateRating::_internal_tip(int index) const {
  return _impl_.tip_.Get(index);
}
inline const ::playapi::proto::finsky::document::AggregateRatingTip& AggregateRating::tip(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.AggregateRating.tip)
  return _internal_tip(index);
}
inline ::playapi::proto::finsky::document::AggregateRatingTip* AggregateRating::_internal_add_tip() {
  return _impl_.tip_.Add();
}
inline ::playapi::proto::finsky::document::AggregateRatingTip* AggregateRating::add_tip() {
  ::playapi::proto::finsky::document::AggregateRatingTip* _add = _internal_add_tip();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.AggregateRating.tip)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::AggregateRatingTip >&
AggregateRating::tip() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.document.AggregateRating.tip)
  return _impl_.tip_;
}

// -------------------------------------------------------------------

// AggregateRatingTip

// optional string tipId = 1;
inline bool AggregateRatingTip::_internal_has_tipid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AggregateRatingTip::has_tipid() const {
  return _internal_has_tipid();
}
inline void AggregateRatingTip::clear_tipid() {
  _impl_.tipid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AggregateRatingTip::tipid() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.AggregateRatingTip.tipId)
  return _internal_tipid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AggregateRatingTip::set_tipid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.tipid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.AggregateRatingTip.tipId)
}
inline std::string* AggregateRatingTip::mutable_tipid() {
  std::string* _s = _internal_mutable_tipid();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.AggregateRatingTip.tipId)
  return _s;
}
inline const std::string& AggregateRatingTip::_internal_tipid() const {
  return _impl_.tipid_.Get();
}
inline void AggregateRatingTip::_internal_set_tipid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.tipid_.Set(value, GetArenaForAllocation());
}
inline std::string* AggregateRatingTip::_internal_mutable_tipid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.tipid_.Mutable(GetArenaForAllocation());
}
inline std::string* AggregateRatingTip::release_tipid() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.AggregateRatingTip.tipId)
  if (!_internal_has_tipid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.tipid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tipid_.IsDefault()) {
    _impl_.tipid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AggregateRatingTip::set_allocated_tipid(std::string* tipid) {
  if (tipid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.tipid_.SetAllocated(tipid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tipid_.IsDefault()) {
    _impl_.tipid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.AggregateRatingTip.tipId)
}

// optional string text = 2;
inline bool AggregateRatingTip::_internal_has_text() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AggregateRatingTip::has_text() const {
  return _internal_has_text();
}
inline void AggregateRatingTip::clear_text() {
  _impl_.text_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AggregateRatingTip::text() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.AggregateRatingTip.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AggregateRatingTip::set_text(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.AggregateRatingTip.text)
}
inline std::string* AggregateRatingTip::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.AggregateRatingTip.text)
  return _s;
}
inline const std::string& AggregateRatingTip::_internal_text() const {
  return _impl_.text_.Get();
}
inline void AggregateRatingTip::_internal_set_text(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* AggregateRatingTip::_internal_mutable_text() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* AggregateRatingTip::release_text() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.AggregateRatingTip.text)
  if (!_internal_has_text()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AggregateRatingTip::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.AggregateRatingTip.text)
}

// optional int32 polarity = 3;
inline bool AggregateRatingTip::_internal_has_polarity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool AggregateRatingTip::has_polarity() const {
  return _internal_has_polarity();
}
inline void AggregateRatingTip::clear_polarity() {
  _impl_.polarity_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t AggregateRatingTip::_internal_polarity() const {
  return _impl_.polarity_;
}
inline int32_t AggregateRatingTip::polarity() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.AggregateRatingTip.polarity)
  return _internal_polarity();
}
inline void AggregateRatingTip::_internal_set_polarity(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.polarity_ = value;
}
inline void AggregateRatingTip::set_polarity(int32_t value) {
  _internal_set_polarity(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.AggregateRatingTip.polarity)
}

// optional int64 reviewCount = 4;
inline bool AggregateRatingTip::_internal_has_reviewcount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool AggregateRatingTip::has_reviewcount() const {
  return _internal_has_reviewcount();
}
inline void AggregateRatingTip::clear_reviewcount() {
  _impl_.reviewcount_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int64_t AggregateRatingTip::_internal_reviewcount() const {
  return _impl_.reviewcount_;
}
inline int64_t AggregateRatingTip::reviewcount() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.AggregateRatingTip.reviewCount)
  return _internal_reviewcount();
}
inline void AggregateRatingTip::_internal_set_reviewcount(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.reviewcount_ = value;
}
inline void AggregateRatingTip::set_reviewcount(int64_t value) {
  _internal_set_reviewcount(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.AggregateRatingTip.reviewCount)
}

// optional string language = 5;
inline bool AggregateRatingTip::_internal_has_language() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AggregateRatingTip::has_language() const {
  return _internal_has_language();
}
inline void AggregateRatingTip::clear_language() {
  _impl_.language_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& AggregateRatingTip::language() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.AggregateRatingTip.language)
  return _internal_language();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AggregateRatingTip::set_language(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.language_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.AggregateRatingTip.language)
}
inline std::string* AggregateRatingTip::mutable_language() {
  std::string* _s = _internal_mutable_language();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.AggregateRatingTip.language)
  return _s;
}
inline const std::string& AggregateRatingTip::_internal_language() const {
  return _impl_.language_.Get();
}
inline void AggregateRatingTip::_internal_set_language(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.language_.Set(value, GetArenaForAllocation());
}
inline std::string* AggregateRatingTip::_internal_mutable_language() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.language_.Mutable(GetArenaForAllocation());
}
inline std::string* AggregateRatingTip::release_language() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.AggregateRatingTip.language)
  if (!_internal_has_language()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.language_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.language_.IsDefault()) {
    _impl_.language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AggregateRatingTip::set_allocated_language(std::string* language) {
  if (language != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.language_.SetAllocated(language, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.language_.IsDefault()) {
    _impl_.language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.AggregateRatingTip.language)
}

// repeated string snippetReviewId = 6;
inline int AggregateRatingTip::_internal_snippetreviewid_size() const {
  return _impl_.snippetreviewid_.size();
}
inline int AggregateRatingTip::snippetreviewid_size() const {
  return _internal_snippetreviewid_size();
}
inline void AggregateRatingTip::clear_snippetreviewid() {
  _impl_.snippetreviewid_.Clear();
}
inline std::string* AggregateRatingTip::add_snippetreviewid() {
  std::string* _s = _internal_add_snippetreviewid();
  // @@protoc_insertion_point(field_add_mutable:playapi.proto.finsky.document.AggregateRatingTip.snippetReviewId)
  return _s;
}
inline const std::string& AggregateRatingTip::_internal_snippetreviewid(int index) const {
  return _impl_.snippetreviewid_.Get(index);
}
inline const std::string& AggregateRatingTip::snippetreviewid(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.AggregateRatingTip.snippetReviewId)
  return _internal_snippetreviewid(index);
}
inline std::string* AggregateRatingTip::mutable_snippetreviewid(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.AggregateRatingTip.snippetReviewId)
  return _impl_.snippetreviewid_.Mutable(index);
}
inline void AggregateRatingTip::set_snippetreviewid(int index, const std::string& value) {
  _impl_.snippetreviewid_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.AggregateRatingTip.snippetReviewId)
}
inline void AggregateRatingTip::set_snippetreviewid(int index, std::string&& value) {
  _impl_.snippetreviewid_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.AggregateRatingTip.snippetReviewId)
}
inline void AggregateRatingTip::set_snippetreviewid(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.snippetreviewid_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:playapi.proto.finsky.document.AggregateRatingTip.snippetReviewId)
}
inline void AggregateRatingTip::set_snippetreviewid(int index, const char* value, size_t size) {
  _impl_.snippetreviewid_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:playapi.proto.finsky.document.AggregateRatingTip.snippetReviewId)
}
inline std::string* AggregateRatingTip::_internal_add_snippetreviewid() {
  return _impl_.snippetreviewid_.Add();
}
inline void AggregateRatingTip::add_snippetreviewid(const std::string& value) {
  _impl_.snippetreviewid_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.AggregateRatingTip.snippetReviewId)
}
inline void AggregateRatingTip::add_snippetreviewid(std::string&& value) {
  _impl_.snippetreviewid_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.document.AggregateRatingTip.snippetReviewId)
}
inline void AggregateRatingTip::add_snippetreviewid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.snippetreviewid_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:playapi.proto.finsky.document.AggregateRatingTip.snippetReviewId)
}
inline void AggregateRatingTip::add_snippetreviewid(const char* value, size_t size) {
  _impl_.snippetreviewid_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:playapi.proto.finsky.document.AggregateRatingTip.snippetReviewId)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AggregateRatingTip::snippetreviewid() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.document.AggregateRatingTip.snippetReviewId)
  return _impl_.snippetreviewid_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AggregateRatingTip::mutable_snippetreviewid() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.document.AggregateRatingTip.snippetReviewId)
  return &_impl_.snippetreviewid_;
}

// -------------------------------------------------------------------

// Review

// optional string authorName = 1;
inline bool Review::_internal_has_authorname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Review::has_authorname() const {
  return _internal_has_authorname();
}
inline void Review::clear_authorname() {
  _impl_.authorname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Review::authorname() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Review.authorName)
  return _internal_authorname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Review::set_authorname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.authorname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.Review.authorName)
}
inline std::string* Review::mutable_authorname() {
  std::string* _s = _internal_mutable_authorname();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Review.authorName)
  return _s;
}
inline const std::string& Review::_internal_authorname() const {
  return _impl_.authorname_.Get();
}
inline void Review::_internal_set_authorname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.authorname_.Set(value, GetArenaForAllocation());
}
inline std::string* Review::_internal_mutable_authorname() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.authorname_.Mutable(GetArenaForAllocation());
}
inline std::string* Review::release_authorname() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.Review.authorName)
  if (!_internal_has_authorname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.authorname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.authorname_.IsDefault()) {
    _impl_.authorname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Review::set_allocated_authorname(std::string* authorname) {
  if (authorname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.authorname_.SetAllocated(authorname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.authorname_.IsDefault()) {
    _impl_.authorname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.Review.authorName)
}

// optional string url = 2;
inline bool Review::_internal_has_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Review::has_url() const {
  return _internal_has_url();
}
inline void Review::clear_url() {
  _impl_.url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Review::url() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Review.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Review::set_url(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.Review.url)
}
inline std::string* Review::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Review.url)
  return _s;
}
inline const std::string& Review::_internal_url() const {
  return _impl_.url_.Get();
}
inline void Review::_internal_set_url(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* Review::_internal_mutable_url() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* Review::release_url() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.Review.url)
  if (!_internal_has_url()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Review::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.Review.url)
}

// optional string source = 3;
inline bool Review::_internal_has_source() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Review::has_source() const {
  return _internal_has_source();
}
inline void Review::clear_source() {
  _impl_.source_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Review::source() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Review.source)
  return _internal_source();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Review::set_source(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.source_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.Review.source)
}
inline std::string* Review::mutable_source() {
  std::string* _s = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Review.source)
  return _s;
}
inline const std::string& Review::_internal_source() const {
  return _impl_.source_.Get();
}
inline void Review::_internal_set_source(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.source_.Set(value, GetArenaForAllocation());
}
inline std::string* Review::_internal_mutable_source() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.source_.Mutable(GetArenaForAllocation());
}
inline std::string* Review::release_source() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.Review.source)
  if (!_internal_has_source()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.source_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.source_.IsDefault()) {
    _impl_.source_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Review::set_allocated_source(std::string* source) {
  if (source != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.source_.SetAllocated(source, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.source_.IsDefault()) {
    _impl_.source_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.Review.source)
}

// optional string documentVersion = 4;
inline bool Review::_internal_has_documentversion() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Review::has_documentversion() const {
  return _internal_has_documentversion();
}
inline void Review::clear_documentversion() {
  _impl_.documentversion_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& Review::documentversion() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Review.documentVersion)
  return _internal_documentversion();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Review::set_documentversion(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.documentversion_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.Review.documentVersion)
}
inline std::string* Review::mutable_documentversion() {
  std::string* _s = _internal_mutable_documentversion();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Review.documentVersion)
  return _s;
}
inline const std::string& Review::_internal_documentversion() const {
  return _impl_.documentversion_.Get();
}
inline void Review::_internal_set_documentversion(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.documentversion_.Set(value, GetArenaForAllocation());
}
inline std::string* Review::_internal_mutable_documentversion() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.documentversion_.Mutable(GetArenaForAllocation());
}
inline std::string* Review::release_documentversion() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.Review.documentVersion)
  if (!_internal_has_documentversion()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.documentversion_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.documentversion_.IsDefault()) {
    _impl_.documentversion_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Review::set_allocated_documentversion(std::string* documentversion) {
  if (documentversion != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.documentversion_.SetAllocated(documentversion, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.documentversion_.IsDefault()) {
    _impl_.documentversion_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.Review.documentVersion)
}

// optional int64 timestampMsec = 5;
inline bool Review::_internal_has_timestampmsec() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool Review::has_timestampmsec() const {
  return _internal_has_timestampmsec();
}
inline void Review::clear_timestampmsec() {
  _impl_.timestampmsec_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline int64_t Review::_internal_timestampmsec() const {
  return _impl_.timestampmsec_;
}
inline int64_t Review::timestampmsec() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Review.timestampMsec)
  return _internal_timestampmsec();
}
inline void Review::_internal_set_timestampmsec(int64_t value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.timestampmsec_ = value;
}
inline void Review::set_timestampmsec(int64_t value) {
  _internal_set_timestampmsec(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.Review.timestampMsec)
}

// optional int32 starRating = 6;
inline bool Review::_internal_has_starrating() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool Review::has_starrating() const {
  return _internal_has_starrating();
}
inline void Review::clear_starrating() {
  _impl_.starrating_ = 0;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline int32_t Review::_internal_starrating() const {
  return _impl_.starrating_;
}
inline int32_t Review::starrating() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Review.starRating)
  return _internal_starrating();
}
inline void Review::_internal_set_starrating(int32_t value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.starrating_ = value;
}
inline void Review::set_starrating(int32_t value) {
  _internal_set_starrating(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.Review.starRating)
}

// optional string title = 7;
inline bool Review::_internal_has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Review::has_title() const {
  return _internal_has_title();
}
inline void Review::clear_title() {
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& Review::title() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Review.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Review::set_title(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.Review.title)
}
inline std::string* Review::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Review.title)
  return _s;
}
inline const std::string& Review::_internal_title() const {
  return _impl_.title_.Get();
}
inline void Review::_internal_set_title(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* Review::_internal_mutable_title() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* Review::release_title() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.Review.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.title_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Review::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.Review.title)
}

// optional string comment = 8;
inline bool Review::_internal_has_comment() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Review::has_comment() const {
  return _internal_has_comment();
}
inline void Review::clear_comment() {
  _impl_.comment_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& Review::comment() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Review.comment)
  return _internal_comment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Review::set_comment(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.comment_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.Review.comment)
}
inline std::string* Review::mutable_comment() {
  std::string* _s = _internal_mutable_comment();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Review.comment)
  return _s;
}
inline const std::string& Review::_internal_comment() const {
  return _impl_.comment_.Get();
}
inline void Review::_internal_set_comment(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.comment_.Set(value, GetArenaForAllocation());
}
inline std::string* Review::_internal_mutable_comment() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.comment_.Mutable(GetArenaForAllocation());
}
inline std::string* Review::release_comment() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.Review.comment)
  if (!_internal_has_comment()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.comment_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comment_.IsDefault()) {
    _impl_.comment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Review::set_allocated_comment(std::string* comment) {
  if (comment != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.comment_.SetAllocated(comment, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comment_.IsDefault()) {
    _impl_.comment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.Review.comment)
}

// optional string commentId = 9;
inline bool Review::_internal_has_commentid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Review::has_commentid() const {
  return _internal_has_commentid();
}
inline void Review::clear_commentid() {
  _impl_.commentid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& Review::commentid() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Review.commentId)
  return _internal_commentid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Review::set_commentid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000040u;
 _impl_.commentid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.Review.commentId)
}
inline std::string* Review::mutable_commentid() {
  std::string* _s = _internal_mutable_commentid();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Review.commentId)
  return _s;
}
inline const std::string& Review::_internal_commentid() const {
  return _impl_.commentid_.Get();
}
inline void Review::_internal_set_commentid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.commentid_.Set(value, GetArenaForAllocation());
}
inline std::string* Review::_internal_mutable_commentid() {
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.commentid_.Mutable(GetArenaForAllocation());
}
inline std::string* Review::release_commentid() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.Review.commentId)
  if (!_internal_has_commentid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* p = _impl_.commentid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.commentid_.IsDefault()) {
    _impl_.commentid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Review::set_allocated_commentid(std::string* commentid) {
  if (commentid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.commentid_.SetAllocated(commentid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.commentid_.IsDefault()) {
    _impl_.commentid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.Review.commentId)
}

// optional string deviceName = 19;
inline bool Review::_internal_has_devicename() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Review::has_devicename() const {
  return _internal_has_devicename();
}
inline void Review::clear_devicename() {
  _impl_.devicename_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& Review::devicename() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Review.deviceName)
  return _internal_devicename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Review::set_devicename(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000080u;
 _impl_.devicename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.Review.deviceName)
}
inline std::string* Review::mutable_devicename() {
  std::string* _s = _internal_mutable_devicename();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Review.deviceName)
  return _s;
}
inline const std::string& Review::_internal_devicename() const {
  return _impl_.devicename_.Get();
}
inline void Review::_internal_set_devicename(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.devicename_.Set(value, GetArenaForAllocation());
}
inline std::string* Review::_internal_mutable_devicename() {
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.devicename_.Mutable(GetArenaForAllocation());
}
inline std::string* Review::release_devicename() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.Review.deviceName)
  if (!_internal_has_devicename()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* p = _impl_.devicename_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.devicename_.IsDefault()) {
    _impl_.devicename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Review::set_allocated_devicename(std::string* devicename) {
  if (devicename != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.devicename_.SetAllocated(devicename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.devicename_.IsDefault()) {
    _impl_.devicename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.Review.deviceName)
}

// optional string replyText = 29;
inline bool Review::_internal_has_replytext() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Review::has_replytext() const {
  return _internal_has_replytext();
}
inline void Review::clear_replytext() {
  _impl_.replytext_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const std::string& Review::replytext() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Review.replyText)
  return _internal_replytext();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Review::set_replytext(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000100u;
 _impl_.replytext_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.Review.replyText)
}
inline std::string* Review::mutable_replytext() {
  std::string* _s = _internal_mutable_replytext();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Review.replyText)
  return _s;
}
inline const std::string& Review::_internal_replytext() const {
  return _impl_.replytext_.Get();
}
inline void Review::_internal_set_replytext(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.replytext_.Set(value, GetArenaForAllocation());
}
inline std::string* Review::_internal_mutable_replytext() {
  _impl_._has_bits_[0] |= 0x00000100u;
  return _impl_.replytext_.Mutable(GetArenaForAllocation());
}
inline std::string* Review::release_replytext() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.Review.replyText)
  if (!_internal_has_replytext()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000100u;
  auto* p = _impl_.replytext_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.replytext_.IsDefault()) {
    _impl_.replytext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Review::set_allocated_replytext(std::string* replytext) {
  if (replytext != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.replytext_.SetAllocated(replytext, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.replytext_.IsDefault()) {
    _impl_.replytext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.Review.replyText)
}

// optional int64 replyTimestampMsec = 30;
inline bool Review::_internal_has_replytimestampmsec() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool Review::has_replytimestampmsec() const {
  return _internal_has_replytimestampmsec();
}
inline void Review::clear_replytimestampmsec() {
  _impl_.replytimestampmsec_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline int64_t Review::_internal_replytimestampmsec() const {
  return _impl_.replytimestampmsec_;
}
inline int64_t Review::replytimestampmsec() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Review.replyTimestampMsec)
  return _internal_replytimestampmsec();
}
inline void Review::_internal_set_replytimestampmsec(int64_t value) {
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.replytimestampmsec_ = value;
}
inline void Review::set_replytimestampmsec(int64_t value) {
  _internal_set_replytimestampmsec(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.Review.replyTimestampMsec)
}

// optional .playapi.proto.finsky.document.OBSOLETE_PlusProfile OBSOLETEPlusProfile = 31;
inline bool Review::_internal_has_obsoleteplusprofile() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.obsoleteplusprofile_ != nullptr);
  return value;
}
inline bool Review::has_obsoleteplusprofile() const {
  return _internal_has_obsoleteplusprofile();
}
inline void Review::clear_obsoleteplusprofile() {
  if (_impl_.obsoleteplusprofile_ != nullptr) _impl_.obsoleteplusprofile_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const ::playapi::proto::finsky::document::OBSOLETE_PlusProfile& Review::_internal_obsoleteplusprofile() const {
  const ::playapi::proto::finsky::document::OBSOLETE_PlusProfile* p = _impl_.obsoleteplusprofile_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::OBSOLETE_PlusProfile&>(
      ::playapi::proto::finsky::document::_OBSOLETE_PlusProfile_default_instance_);
}
inline const ::playapi::proto::finsky::document::OBSOLETE_PlusProfile& Review::obsoleteplusprofile() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Review.OBSOLETEPlusProfile)
  return _internal_obsoleteplusprofile();
}
inline void Review::unsafe_arena_set_allocated_obsoleteplusprofile(
    ::playapi::proto::finsky::document::OBSOLETE_PlusProfile* obsoleteplusprofile) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.obsoleteplusprofile_);
  }
  _impl_.obsoleteplusprofile_ = obsoleteplusprofile;
  if (obsoleteplusprofile) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.Review.OBSOLETEPlusProfile)
}
inline ::playapi::proto::finsky::document::OBSOLETE_PlusProfile* Review::release_obsoleteplusprofile() {
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::playapi::proto::finsky::document::OBSOLETE_PlusProfile* temp = _impl_.obsoleteplusprofile_;
  _impl_.obsoleteplusprofile_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::OBSOLETE_PlusProfile* Review::unsafe_arena_release_obsoleteplusprofile() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.Review.OBSOLETEPlusProfile)
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::playapi::proto::finsky::document::OBSOLETE_PlusProfile* temp = _impl_.obsoleteplusprofile_;
  _impl_.obsoleteplusprofile_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::OBSOLETE_PlusProfile* Review::_internal_mutable_obsoleteplusprofile() {
  _impl_._has_bits_[0] |= 0x00000200u;
  if (_impl_.obsoleteplusprofile_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::OBSOLETE_PlusProfile>(GetArenaForAllocation());
    _impl_.obsoleteplusprofile_ = p;
  }
  return _impl_.obsoleteplusprofile_;
}
inline ::playapi::proto::finsky::document::OBSOLETE_PlusProfile* Review::mutable_obsoleteplusprofile() {
  ::playapi::proto::finsky::document::OBSOLETE_PlusProfile* _msg = _internal_mutable_obsoleteplusprofile();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Review.OBSOLETEPlusProfile)
  return _msg;
}
inline void Review::set_allocated_obsoleteplusprofile(::playapi::proto::finsky::document::OBSOLETE_PlusProfile* obsoleteplusprofile) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.obsoleteplusprofile_;
  }
  if (obsoleteplusprofile) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(obsoleteplusprofile);
    if (message_arena != submessage_arena) {
      obsoleteplusprofile = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, obsoleteplusprofile, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.obsoleteplusprofile_ = obsoleteplusprofile;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.Review.OBSOLETEPlusProfile)
}

// optional .playapi.proto.finsky.document.DocV2 author = 33;
inline bool Review::_internal_has_author() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.author_ != nullptr);
  return value;
}
inline bool Review::has_author() const {
  return _internal_has_author();
}
inline void Review::clear_author() {
  if (_impl_.author_ != nullptr) _impl_.author_->Clear();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const ::playapi::proto::finsky::document::DocV2& Review::_internal_author() const {
  const ::playapi::proto::finsky::document::DocV2* p = _impl_.author_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::DocV2&>(
      ::playapi::proto::finsky::document::_DocV2_default_instance_);
}
inline const ::playapi::proto::finsky::document::DocV2& Review::author() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Review.author)
  return _internal_author();
}
inline void Review::unsafe_arena_set_allocated_author(
    ::playapi::proto::finsky::document::DocV2* author) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.author_);
  }
  _impl_.author_ = author;
  if (author) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.Review.author)
}
inline ::playapi::proto::finsky::document::DocV2* Review::release_author() {
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::playapi::proto::finsky::document::DocV2* temp = _impl_.author_;
  _impl_.author_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::DocV2* Review::unsafe_arena_release_author() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.Review.author)
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::playapi::proto::finsky::document::DocV2* temp = _impl_.author_;
  _impl_.author_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::DocV2* Review::_internal_mutable_author() {
  _impl_._has_bits_[0] |= 0x00000400u;
  if (_impl_.author_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::DocV2>(GetArenaForAllocation());
    _impl_.author_ = p;
  }
  return _impl_.author_;
}
inline ::playapi::proto::finsky::document::DocV2* Review::mutable_author() {
  ::playapi::proto::finsky::document::DocV2* _msg = _internal_mutable_author();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Review.author)
  return _msg;
}
inline void Review::set_allocated_author(::playapi::proto::finsky::document::DocV2* author) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.author_;
  }
  if (author) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(author);
    if (message_arena != submessage_arena) {
      author = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, author, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.author_ = author;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.Review.author)
}

// optional .playapi.proto.finsky.Image sentiment = 34;
inline bool Review::_internal_has_sentiment() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sentiment_ != nullptr);
  return value;
}
inline bool Review::has_sentiment() const {
  return _internal_has_sentiment();
}
inline const ::playapi::proto::finsky::Image& Review::_internal_sentiment() const {
  const ::playapi::proto::finsky::Image* p = _impl_.sentiment_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::Image&>(
      ::playapi::proto::finsky::_Image_default_instance_);
}
inline const ::playapi::proto::finsky::Image& Review::sentiment() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Review.sentiment)
  return _internal_sentiment();
}
inline void Review::unsafe_arena_set_allocated_sentiment(
    ::playapi::proto::finsky::Image* sentiment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sentiment_);
  }
  _impl_.sentiment_ = sentiment;
  if (sentiment) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.document.Review.sentiment)
}
inline ::playapi::proto::finsky::Image* Review::release_sentiment() {
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::playapi::proto::finsky::Image* temp = _impl_.sentiment_;
  _impl_.sentiment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::Image* Review::unsafe_arena_release_sentiment() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.Review.sentiment)
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::playapi::proto::finsky::Image* temp = _impl_.sentiment_;
  _impl_.sentiment_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::Image* Review::_internal_mutable_sentiment() {
  _impl_._has_bits_[0] |= 0x00000800u;
  if (_impl_.sentiment_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::Image>(GetArenaForAllocation());
    _impl_.sentiment_ = p;
  }
  return _impl_.sentiment_;
}
inline ::playapi::proto::finsky::Image* Review::mutable_sentiment() {
  ::playapi::proto::finsky::Image* _msg = _internal_mutable_sentiment();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.Review.sentiment)
  return _msg;
}
inline void Review::set_allocated_sentiment(::playapi::proto::finsky::Image* sentiment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sentiment_);
  }
  if (sentiment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sentiment));
    if (message_arena != submessage_arena) {
      sentiment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sentiment, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  _impl_.sentiment_ = sentiment;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.Review.sentiment)
}

// optional int32 helpfulCount = 35;
inline bool Review::_internal_has_helpfulcount() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool Review::has_helpfulcount() const {
  return _internal_has_helpfulcount();
}
inline void Review::clear_helpfulcount() {
  _impl_.helpfulcount_ = 0;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline int32_t Review::_internal_helpfulcount() const {
  return _impl_.helpfulcount_;
}
inline int32_t Review::helpfulcount() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Review.helpfulCount)
  return _internal_helpfulcount();
}
inline void Review::_internal_set_helpfulcount(int32_t value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.helpfulcount_ = value;
}
inline void Review::set_helpfulcount(int32_t value) {
  _internal_set_helpfulcount(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.Review.helpfulCount)
}

// optional int64 thumbsUpCount = 38;
inline bool Review::_internal_has_thumbsupcount() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool Review::has_thumbsupcount() const {
  return _internal_has_thumbsupcount();
}
inline void Review::clear_thumbsupcount() {
  _impl_.thumbsupcount_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline int64_t Review::_internal_thumbsupcount() const {
  return _impl_.thumbsupcount_;
}
inline int64_t Review::thumbsupcount() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.Review.thumbsUpCount)
  return _internal_thumbsupcount();
}
inline void Review::_internal_set_thumbsupcount(int64_t value) {
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.thumbsupcount_ = value;
}
inline void Review::set_thumbsupcount(int64_t value) {
  _internal_set_thumbsupcount(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.Review.thumbsUpCount)
}

// -------------------------------------------------------------------

// ReviewTip

// optional string tipUrl = 1;
inline bool ReviewTip::_internal_has_tipurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReviewTip::has_tipurl() const {
  return _internal_has_tipurl();
}
inline void ReviewTip::clear_tipurl() {
  _impl_.tipurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ReviewTip::tipurl() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.ReviewTip.tipUrl)
  return _internal_tipurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReviewTip::set_tipurl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.tipurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.ReviewTip.tipUrl)
}
inline std::string* ReviewTip::mutable_tipurl() {
  std::string* _s = _internal_mutable_tipurl();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.ReviewTip.tipUrl)
  return _s;
}
inline const std::string& ReviewTip::_internal_tipurl() const {
  return _impl_.tipurl_.Get();
}
inline void ReviewTip::_internal_set_tipurl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.tipurl_.Set(value, GetArenaForAllocation());
}
inline std::string* ReviewTip::_internal_mutable_tipurl() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.tipurl_.Mutable(GetArenaForAllocation());
}
inline std::string* ReviewTip::release_tipurl() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.ReviewTip.tipUrl)
  if (!_internal_has_tipurl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.tipurl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tipurl_.IsDefault()) {
    _impl_.tipurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ReviewTip::set_allocated_tipurl(std::string* tipurl) {
  if (tipurl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.tipurl_.SetAllocated(tipurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tipurl_.IsDefault()) {
    _impl_.tipurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.ReviewTip.tipUrl)
}

// optional string text = 2;
inline bool ReviewTip::_internal_has_text() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ReviewTip::has_text() const {
  return _internal_has_text();
}
inline void ReviewTip::clear_text() {
  _impl_.text_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ReviewTip::text() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.ReviewTip.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReviewTip::set_text(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.ReviewTip.text)
}
inline std::string* ReviewTip::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.document.ReviewTip.text)
  return _s;
}
inline const std::string& ReviewTip::_internal_text() const {
  return _impl_.text_.Get();
}
inline void ReviewTip::_internal_set_text(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* ReviewTip::_internal_mutable_text() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* ReviewTip::release_text() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.document.ReviewTip.text)
  if (!_internal_has_text()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ReviewTip::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.document.ReviewTip.text)
}

// optional int32 polarity = 3;
inline bool ReviewTip::_internal_has_polarity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ReviewTip::has_polarity() const {
  return _internal_has_polarity();
}
inline void ReviewTip::clear_polarity() {
  _impl_.polarity_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t ReviewTip::_internal_polarity() const {
  return _impl_.polarity_;
}
inline int32_t ReviewTip::polarity() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.ReviewTip.polarity)
  return _internal_polarity();
}
inline void ReviewTip::_internal_set_polarity(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.polarity_ = value;
}
inline void ReviewTip::set_polarity(int32_t value) {
  _internal_set_polarity(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.ReviewTip.polarity)
}

// optional int64 reviewCount = 4;
inline bool ReviewTip::_internal_has_reviewcount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ReviewTip::has_reviewcount() const {
  return _internal_has_reviewcount();
}
inline void ReviewTip::clear_reviewcount() {
  _impl_.reviewcount_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t ReviewTip::_internal_reviewcount() const {
  return _impl_.reviewcount_;
}
inline int64_t ReviewTip::reviewcount() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.document.ReviewTip.reviewCount)
  return _internal_reviewcount();
}
inline void ReviewTip::_internal_set_reviewcount(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.reviewcount_ = value;
}
inline void ReviewTip::set_reviewcount(int64_t value) {
  _internal_set_reviewcount(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.document.ReviewTip.reviewCount)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace document
}  // namespace finsky
}  // namespace proto
}  // namespace playapi

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_play_5fdocument_2eproto
