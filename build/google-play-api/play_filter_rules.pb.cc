// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: play_filter_rules.proto

#include "play_filter_rules.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace playapi {
namespace proto {
namespace finsky {
namespace filter_rules {
PROTOBUF_CONSTEXPR Availability_PerDeviceAvailabilityRestriction::Availability_PerDeviceAvailabilityRestriction(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.filterinfo_)*/nullptr
  , /*decltype(_impl_.androidid_)*/uint64_t{0u}
  , /*decltype(_impl_.channelid_)*/int64_t{0}
  , /*decltype(_impl_.devicerestriction_)*/0
  , /*decltype(_impl_.availableifowned_)*/false} {}
struct Availability_PerDeviceAvailabilityRestrictionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Availability_PerDeviceAvailabilityRestrictionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Availability_PerDeviceAvailabilityRestrictionDefaultTypeInternal() {}
  union {
    Availability_PerDeviceAvailabilityRestriction _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Availability_PerDeviceAvailabilityRestrictionDefaultTypeInternal _Availability_PerDeviceAvailabilityRestriction_default_instance_;
PROTOBUF_CONSTEXPR Availability::Availability(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.perdeviceavailabilityrestriction_)*/{}
  , /*decltype(_impl_.install_)*/{}
  , /*decltype(_impl_.availabilityproblem_)*/{}
  , /*decltype(_impl_.rule_)*/nullptr
  , /*decltype(_impl_.filterinfo_)*/nullptr
  , /*decltype(_impl_.ownershipinfo_)*/nullptr
  , /*decltype(_impl_.restriction_)*/0
  , /*decltype(_impl_.offertype_)*/0
  , /*decltype(_impl_.availableifowned_)*/false
  , /*decltype(_impl_.hidden_)*/false} {}
struct AvailabilityDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AvailabilityDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AvailabilityDefaultTypeInternal() {}
  union {
    Availability _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AvailabilityDefaultTypeInternal _Availability_default_instance_;
PROTOBUF_CONSTEXPR AvailabilityProblem::AvailabilityProblem(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.missingvalue_)*/{}
  , /*decltype(_impl_.problemtype_)*/0} {}
struct AvailabilityProblemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AvailabilityProblemDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AvailabilityProblemDefaultTypeInternal() {}
  union {
    AvailabilityProblem _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AvailabilityProblemDefaultTypeInternal _AvailabilityProblem_default_instance_;
PROTOBUF_CONSTEXPR FilterEvaluationInfo::FilterEvaluationInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ruleevaluation_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FilterEvaluationInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FilterEvaluationInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FilterEvaluationInfoDefaultTypeInternal() {}
  union {
    FilterEvaluationInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FilterEvaluationInfoDefaultTypeInternal _FilterEvaluationInfo_default_instance_;
PROTOBUF_CONSTEXPR Rule::Rule(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.stringarg_)*/{}
  , /*decltype(_impl_.longarg_)*/{}
  , /*decltype(_impl_.doublearg_)*/{}
  , /*decltype(_impl_.subrule_)*/{}
  , /*decltype(_impl_.stringarghash_)*/{}
  , /*decltype(_impl_.comment_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.operator__)*/0
  , /*decltype(_impl_.key_)*/0
  , /*decltype(_impl_.negate_)*/false
  , /*decltype(_impl_.includemissingvalues_)*/false
  , /*decltype(_impl_.responsecode_)*/0
  , /*decltype(_impl_.availabilityproblemtype_)*/0} {}
struct RuleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RuleDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RuleDefaultTypeInternal() {}
  union {
    Rule _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RuleDefaultTypeInternal _Rule_default_instance_;
PROTOBUF_CONSTEXPR RuleEvaluation::RuleEvaluation(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.actualstringvalue_)*/{}
  , /*decltype(_impl_.actuallongvalue_)*/{}
  , /*decltype(_impl_.actualboolvalue_)*/{}
  , /*decltype(_impl_.actualdoublevalue_)*/{}
  , /*decltype(_impl_.rule_)*/nullptr} {}
struct RuleEvaluationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RuleEvaluationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RuleEvaluationDefaultTypeInternal() {}
  union {
    RuleEvaluation _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RuleEvaluationDefaultTypeInternal _RuleEvaluation_default_instance_;
}  // namespace filter_rules
}  // namespace finsky
}  // namespace proto
}  // namespace playapi
static ::_pb::Metadata file_level_metadata_play_5ffilter_5frules_2eproto[6];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_play_5ffilter_5frules_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_play_5ffilter_5frules_2eproto = nullptr;

const uint32_t TableStruct_play_5ffilter_5frules_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::filter_rules::Availability_PerDeviceAvailabilityRestriction, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::filter_rules::Availability_PerDeviceAvailabilityRestriction, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::filter_rules::Availability_PerDeviceAvailabilityRestriction, _impl_.androidid_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::filter_rules::Availability_PerDeviceAvailabilityRestriction, _impl_.devicerestriction_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::filter_rules::Availability_PerDeviceAvailabilityRestriction, _impl_.channelid_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::filter_rules::Availability_PerDeviceAvailabilityRestriction, _impl_.filterinfo_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::filter_rules::Availability_PerDeviceAvailabilityRestriction, _impl_.availableifowned_),
  1,
  3,
  2,
  0,
  4,
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::filter_rules::Availability, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::filter_rules::Availability, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::filter_rules::Availability, _impl_.restriction_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::filter_rules::Availability, _impl_.offertype_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::filter_rules::Availability, _impl_.rule_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::filter_rules::Availability, _impl_.perdeviceavailabilityrestriction_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::filter_rules::Availability, _impl_.availableifowned_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::filter_rules::Availability, _impl_.install_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::filter_rules::Availability, _impl_.filterinfo_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::filter_rules::Availability, _impl_.ownershipinfo_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::filter_rules::Availability, _impl_.availabilityproblem_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::filter_rules::Availability, _impl_.hidden_),
  3,
  4,
  0,
  ~0u,
  5,
  ~0u,
  1,
  2,
  ~0u,
  6,
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::filter_rules::AvailabilityProblem, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::filter_rules::AvailabilityProblem, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::filter_rules::AvailabilityProblem, _impl_.problemtype_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::filter_rules::AvailabilityProblem, _impl_.missingvalue_),
  0,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::filter_rules::FilterEvaluationInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::filter_rules::FilterEvaluationInfo, _impl_.ruleevaluation_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::filter_rules::Rule, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::filter_rules::Rule, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::filter_rules::Rule, _impl_.negate_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::filter_rules::Rule, _impl_.operator__),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::filter_rules::Rule, _impl_.key_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::filter_rules::Rule, _impl_.stringarg_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::filter_rules::Rule, _impl_.longarg_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::filter_rules::Rule, _impl_.doublearg_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::filter_rules::Rule, _impl_.subrule_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::filter_rules::Rule, _impl_.responsecode_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::filter_rules::Rule, _impl_.comment_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::filter_rules::Rule, _impl_.stringarghash_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::filter_rules::Rule, _impl_.availabilityproblemtype_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::filter_rules::Rule, _impl_.includemissingvalues_),
  3,
  1,
  2,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  5,
  0,
  ~0u,
  6,
  4,
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::filter_rules::RuleEvaluation, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::filter_rules::RuleEvaluation, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::filter_rules::RuleEvaluation, _impl_.rule_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::filter_rules::RuleEvaluation, _impl_.actualstringvalue_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::filter_rules::RuleEvaluation, _impl_.actuallongvalue_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::filter_rules::RuleEvaluation, _impl_.actualboolvalue_),
  PROTOBUF_FIELD_OFFSET(::playapi::proto::finsky::filter_rules::RuleEvaluation, _impl_.actualdoublevalue_),
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 11, -1, sizeof(::playapi::proto::finsky::filter_rules::Availability_PerDeviceAvailabilityRestriction)},
  { 16, 32, -1, sizeof(::playapi::proto::finsky::filter_rules::Availability)},
  { 42, 50, -1, sizeof(::playapi::proto::finsky::filter_rules::AvailabilityProblem)},
  { 52, -1, -1, sizeof(::playapi::proto::finsky::filter_rules::FilterEvaluationInfo)},
  { 59, 77, -1, sizeof(::playapi::proto::finsky::filter_rules::Rule)},
  { 89, 100, -1, sizeof(::playapi::proto::finsky::filter_rules::RuleEvaluation)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::playapi::proto::finsky::filter_rules::_Availability_PerDeviceAvailabilityRestriction_default_instance_._instance,
  &::playapi::proto::finsky::filter_rules::_Availability_default_instance_._instance,
  &::playapi::proto::finsky::filter_rules::_AvailabilityProblem_default_instance_._instance,
  &::playapi::proto::finsky::filter_rules::_FilterEvaluationInfo_default_instance_._instance,
  &::playapi::proto::finsky::filter_rules::_Rule_default_instance_._instance,
  &::playapi::proto::finsky::filter_rules::_RuleEvaluation_default_instance_._instance,
};

const char descriptor_table_protodef_play_5ffilter_5frules_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\027play_filter_rules.proto\022!playapi.proto"
  ".finsky.filter_rules\032\021play_common.proto\032"
  "\023play_download.proto\"\367\005\n\014Availability\022\023\n"
  "\013restriction\030\005 \001(\005\022\021\n\tofferType\030\006 \001(\005\0225\n"
  "\004rule\030\007 \001(\0132\'.playapi.proto.finsky.filte"
  "r_rules.Rule\022z\n perdeviceavailabilityres"
  "triction\030\t \003(\n2P.playapi.proto.finsky.fi"
  "lter_rules.Availability.PerDeviceAvailab"
  "ilityRestriction\022\030\n\020availableIfOwned\030\r \001"
  "(\010\0227\n\007install\030\016 \003(\0132&.playapi.proto.fins"
  "ky.download.Install\022K\n\nfilterInfo\030\020 \001(\0132"
  "7.playapi.proto.finsky.filter_rules.Filt"
  "erEvaluationInfo\022:\n\rownershipInfo\030\021 \001(\0132"
  "#.playapi.proto.finsky.OwnershipInfo\022S\n\023"
  "availabilityProblem\030\022 \003(\01326.playapi.prot"
  "o.finsky.filter_rules.AvailabilityProble"
  "m\022\016\n\006hidden\030\025 \001(\010\032\312\001\n PerDeviceAvailabil"
  "ityRestriction\022\021\n\tandroidId\030\n \001(\006\022\031\n\021dev"
  "iceRestriction\030\013 \001(\005\022\021\n\tchannelId\030\014 \001(\003\022"
  "K\n\nfilterInfo\030\017 \001(\01327.playapi.proto.fins"
  "ky.filter_rules.FilterEvaluationInfo\022\030\n\020"
  "availableIfOwned\030\026 \001(\010\"@\n\023AvailabilityPr"
  "oblem\022\023\n\013problemType\030\001 \001(\005\022\024\n\014missingVal"
  "ue\030\002 \003(\t\"a\n\024FilterEvaluationInfo\022I\n\016rule"
  "Evaluation\030\001 \003(\01321.playapi.proto.finsky."
  "filter_rules.RuleEvaluation\"\243\002\n\004Rule\022\016\n\006"
  "negate\030\001 \001(\010\022\020\n\010operator\030\002 \001(\005\022\013\n\003key\030\003 "
  "\001(\005\022\021\n\tstringArg\030\004 \003(\t\022\017\n\007longArg\030\005 \003(\003\022"
  "\021\n\tdoubleArg\030\006 \003(\001\0228\n\007subrule\030\007 \003(\0132\'.pl"
  "ayapi.proto.finsky.filter_rules.Rule\022\024\n\014"
  "responseCode\030\010 \001(\005\022\017\n\007comment\030\t \001(\t\022\025\n\rs"
  "tringArgHash\030\n \003(\006\022\037\n\027availabilityProble"
  "mType\030\014 \001(\005\022\034\n\024includeMissingValues\030\r \001("
  "\010\"\257\001\n\016RuleEvaluation\0225\n\004rule\030\001 \001(\0132\'.pla"
  "yapi.proto.finsky.filter_rules.Rule\022\031\n\021a"
  "ctualStringValue\030\002 \003(\t\022\027\n\017actualLongValu"
  "e\030\003 \003(\003\022\027\n\017actualBoolValue\030\004 \003(\010\022\031\n\021actu"
  "alDoubleValue\030\005 \003(\001"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_play_5ffilter_5frules_2eproto_deps[2] = {
  &::descriptor_table_play_5fcommon_2eproto,
  &::descriptor_table_play_5fdownload_2eproto,
};
static ::_pbi::once_flag descriptor_table_play_5ffilter_5frules_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_play_5ffilter_5frules_2eproto = {
    false, false, 1499, descriptor_table_protodef_play_5ffilter_5frules_2eproto,
    "play_filter_rules.proto",
    &descriptor_table_play_5ffilter_5frules_2eproto_once, descriptor_table_play_5ffilter_5frules_2eproto_deps, 2, 6,
    schemas, file_default_instances, TableStruct_play_5ffilter_5frules_2eproto::offsets,
    file_level_metadata_play_5ffilter_5frules_2eproto, file_level_enum_descriptors_play_5ffilter_5frules_2eproto,
    file_level_service_descriptors_play_5ffilter_5frules_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_play_5ffilter_5frules_2eproto_getter() {
  return &descriptor_table_play_5ffilter_5frules_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_play_5ffilter_5frules_2eproto(&descriptor_table_play_5ffilter_5frules_2eproto);
namespace playapi {
namespace proto {
namespace finsky {
namespace filter_rules {

// ===================================================================

class Availability_PerDeviceAvailabilityRestriction::_Internal {
 public:
  using HasBits = decltype(std::declval<Availability_PerDeviceAvailabilityRestriction>()._impl_._has_bits_);
  static void set_has_androidid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_devicerestriction(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_channelid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::playapi::proto::finsky::filter_rules::FilterEvaluationInfo& filterinfo(const Availability_PerDeviceAvailabilityRestriction* msg);
  static void set_has_filterinfo(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_availableifowned(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::playapi::proto::finsky::filter_rules::FilterEvaluationInfo&
Availability_PerDeviceAvailabilityRestriction::_Internal::filterinfo(const Availability_PerDeviceAvailabilityRestriction* msg) {
  return *msg->_impl_.filterinfo_;
}
Availability_PerDeviceAvailabilityRestriction::Availability_PerDeviceAvailabilityRestriction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:playapi.proto.finsky.filter_rules.Availability.PerDeviceAvailabilityRestriction)
}
Availability_PerDeviceAvailabilityRestriction::Availability_PerDeviceAvailabilityRestriction(const Availability_PerDeviceAvailabilityRestriction& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Availability_PerDeviceAvailabilityRestriction* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.filterinfo_){nullptr}
    , decltype(_impl_.androidid_){}
    , decltype(_impl_.channelid_){}
    , decltype(_impl_.devicerestriction_){}
    , decltype(_impl_.availableifowned_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_filterinfo()) {
    _this->_impl_.filterinfo_ = new ::playapi::proto::finsky::filter_rules::FilterEvaluationInfo(*from._impl_.filterinfo_);
  }
  ::memcpy(&_impl_.androidid_, &from._impl_.androidid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.availableifowned_) -
    reinterpret_cast<char*>(&_impl_.androidid_)) + sizeof(_impl_.availableifowned_));
  // @@protoc_insertion_point(copy_constructor:playapi.proto.finsky.filter_rules.Availability.PerDeviceAvailabilityRestriction)
}

inline void Availability_PerDeviceAvailabilityRestriction::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.filterinfo_){nullptr}
    , decltype(_impl_.androidid_){uint64_t{0u}}
    , decltype(_impl_.channelid_){int64_t{0}}
    , decltype(_impl_.devicerestriction_){0}
    , decltype(_impl_.availableifowned_){false}
  };
}

Availability_PerDeviceAvailabilityRestriction::~Availability_PerDeviceAvailabilityRestriction() {
  // @@protoc_insertion_point(destructor:playapi.proto.finsky.filter_rules.Availability.PerDeviceAvailabilityRestriction)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Availability_PerDeviceAvailabilityRestriction::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.filterinfo_;
}

void Availability_PerDeviceAvailabilityRestriction::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Availability_PerDeviceAvailabilityRestriction::Clear() {
// @@protoc_insertion_point(message_clear_start:playapi.proto.finsky.filter_rules.Availability.PerDeviceAvailabilityRestriction)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.filterinfo_ != nullptr);
    _impl_.filterinfo_->Clear();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.androidid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.availableifowned_) -
        reinterpret_cast<char*>(&_impl_.androidid_)) + sizeof(_impl_.availableifowned_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Availability_PerDeviceAvailabilityRestriction::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 androidId = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 81)) {
          _Internal::set_has_androidid(&has_bits);
          _impl_.androidid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional int32 deviceRestriction = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_devicerestriction(&has_bits);
          _impl_.devicerestriction_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 channelId = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_channelid(&has_bits);
          _impl_.channelid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .playapi.proto.finsky.filter_rules.FilterEvaluationInfo filterInfo = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_filterinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool availableIfOwned = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _Internal::set_has_availableifowned(&has_bits);
          _impl_.availableifowned_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Availability_PerDeviceAvailabilityRestriction::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:playapi.proto.finsky.filter_rules.Availability.PerDeviceAvailabilityRestriction)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 androidId = 10;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(10, this->_internal_androidid(), target);
  }

  // optional int32 deviceRestriction = 11;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(11, this->_internal_devicerestriction(), target);
  }

  // optional int64 channelId = 12;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(12, this->_internal_channelid(), target);
  }

  // optional .playapi.proto.finsky.filter_rules.FilterEvaluationInfo filterInfo = 15;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::filterinfo(this),
        _Internal::filterinfo(this).GetCachedSize(), target, stream);
  }

  // optional bool availableIfOwned = 22;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(22, this->_internal_availableifowned(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:playapi.proto.finsky.filter_rules.Availability.PerDeviceAvailabilityRestriction)
  return target;
}

size_t Availability_PerDeviceAvailabilityRestriction::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:playapi.proto.finsky.filter_rules.Availability.PerDeviceAvailabilityRestriction)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .playapi.proto.finsky.filter_rules.FilterEvaluationInfo filterInfo = 15;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.filterinfo_);
    }

    // optional fixed64 androidId = 10;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional int64 channelId = 12;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_channelid());
    }

    // optional int32 deviceRestriction = 11;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_devicerestriction());
    }

    // optional bool availableIfOwned = 22;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Availability_PerDeviceAvailabilityRestriction::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Availability_PerDeviceAvailabilityRestriction::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Availability_PerDeviceAvailabilityRestriction::GetClassData() const { return &_class_data_; }


void Availability_PerDeviceAvailabilityRestriction::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Availability_PerDeviceAvailabilityRestriction*>(&to_msg);
  auto& from = static_cast<const Availability_PerDeviceAvailabilityRestriction&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:playapi.proto.finsky.filter_rules.Availability.PerDeviceAvailabilityRestriction)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_filterinfo()->::playapi::proto::finsky::filter_rules::FilterEvaluationInfo::MergeFrom(
          from._internal_filterinfo());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.androidid_ = from._impl_.androidid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.channelid_ = from._impl_.channelid_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.devicerestriction_ = from._impl_.devicerestriction_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.availableifowned_ = from._impl_.availableifowned_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Availability_PerDeviceAvailabilityRestriction::CopyFrom(const Availability_PerDeviceAvailabilityRestriction& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:playapi.proto.finsky.filter_rules.Availability.PerDeviceAvailabilityRestriction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Availability_PerDeviceAvailabilityRestriction::IsInitialized() const {
  return true;
}

void Availability_PerDeviceAvailabilityRestriction::InternalSwap(Availability_PerDeviceAvailabilityRestriction* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Availability_PerDeviceAvailabilityRestriction, _impl_.availableifowned_)
      + sizeof(Availability_PerDeviceAvailabilityRestriction::_impl_.availableifowned_)
      - PROTOBUF_FIELD_OFFSET(Availability_PerDeviceAvailabilityRestriction, _impl_.filterinfo_)>(
          reinterpret_cast<char*>(&_impl_.filterinfo_),
          reinterpret_cast<char*>(&other->_impl_.filterinfo_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Availability_PerDeviceAvailabilityRestriction::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_play_5ffilter_5frules_2eproto_getter, &descriptor_table_play_5ffilter_5frules_2eproto_once,
      file_level_metadata_play_5ffilter_5frules_2eproto[0]);
}

// ===================================================================

class Availability::_Internal {
 public:
  using HasBits = decltype(std::declval<Availability>()._impl_._has_bits_);
  static void set_has_restriction(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_offertype(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::playapi::proto::finsky::filter_rules::Rule& rule(const Availability* msg);
  static void set_has_rule(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_availableifowned(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::playapi::proto::finsky::filter_rules::FilterEvaluationInfo& filterinfo(const Availability* msg);
  static void set_has_filterinfo(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::playapi::proto::finsky::OwnershipInfo& ownershipinfo(const Availability* msg);
  static void set_has_ownershipinfo(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_hidden(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

const ::playapi::proto::finsky::filter_rules::Rule&
Availability::_Internal::rule(const Availability* msg) {
  return *msg->_impl_.rule_;
}
const ::playapi::proto::finsky::filter_rules::FilterEvaluationInfo&
Availability::_Internal::filterinfo(const Availability* msg) {
  return *msg->_impl_.filterinfo_;
}
const ::playapi::proto::finsky::OwnershipInfo&
Availability::_Internal::ownershipinfo(const Availability* msg) {
  return *msg->_impl_.ownershipinfo_;
}
void Availability::clear_install() {
  _impl_.install_.Clear();
}
void Availability::clear_ownershipinfo() {
  if (_impl_.ownershipinfo_ != nullptr) _impl_.ownershipinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
Availability::Availability(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:playapi.proto.finsky.filter_rules.Availability)
}
Availability::Availability(const Availability& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Availability* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.perdeviceavailabilityrestriction_){from._impl_.perdeviceavailabilityrestriction_}
    , decltype(_impl_.install_){from._impl_.install_}
    , decltype(_impl_.availabilityproblem_){from._impl_.availabilityproblem_}
    , decltype(_impl_.rule_){nullptr}
    , decltype(_impl_.filterinfo_){nullptr}
    , decltype(_impl_.ownershipinfo_){nullptr}
    , decltype(_impl_.restriction_){}
    , decltype(_impl_.offertype_){}
    , decltype(_impl_.availableifowned_){}
    , decltype(_impl_.hidden_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_rule()) {
    _this->_impl_.rule_ = new ::playapi::proto::finsky::filter_rules::Rule(*from._impl_.rule_);
  }
  if (from._internal_has_filterinfo()) {
    _this->_impl_.filterinfo_ = new ::playapi::proto::finsky::filter_rules::FilterEvaluationInfo(*from._impl_.filterinfo_);
  }
  if (from._internal_has_ownershipinfo()) {
    _this->_impl_.ownershipinfo_ = new ::playapi::proto::finsky::OwnershipInfo(*from._impl_.ownershipinfo_);
  }
  ::memcpy(&_impl_.restriction_, &from._impl_.restriction_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.hidden_) -
    reinterpret_cast<char*>(&_impl_.restriction_)) + sizeof(_impl_.hidden_));
  // @@protoc_insertion_point(copy_constructor:playapi.proto.finsky.filter_rules.Availability)
}

inline void Availability::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.perdeviceavailabilityrestriction_){arena}
    , decltype(_impl_.install_){arena}
    , decltype(_impl_.availabilityproblem_){arena}
    , decltype(_impl_.rule_){nullptr}
    , decltype(_impl_.filterinfo_){nullptr}
    , decltype(_impl_.ownershipinfo_){nullptr}
    , decltype(_impl_.restriction_){0}
    , decltype(_impl_.offertype_){0}
    , decltype(_impl_.availableifowned_){false}
    , decltype(_impl_.hidden_){false}
  };
}

Availability::~Availability() {
  // @@protoc_insertion_point(destructor:playapi.proto.finsky.filter_rules.Availability)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Availability::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.perdeviceavailabilityrestriction_.~RepeatedPtrField();
  _impl_.install_.~RepeatedPtrField();
  _impl_.availabilityproblem_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.rule_;
  if (this != internal_default_instance()) delete _impl_.filterinfo_;
  if (this != internal_default_instance()) delete _impl_.ownershipinfo_;
}

void Availability::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Availability::Clear() {
// @@protoc_insertion_point(message_clear_start:playapi.proto.finsky.filter_rules.Availability)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.perdeviceavailabilityrestriction_.Clear();
  _impl_.install_.Clear();
  _impl_.availabilityproblem_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.rule_ != nullptr);
      _impl_.rule_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.filterinfo_ != nullptr);
      _impl_.filterinfo_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.ownershipinfo_ != nullptr);
      _impl_.ownershipinfo_->Clear();
    }
  }
  if (cached_has_bits & 0x00000078u) {
    ::memset(&_impl_.restriction_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.hidden_) -
        reinterpret_cast<char*>(&_impl_.restriction_)) + sizeof(_impl_.hidden_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Availability::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 restriction = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_restriction(&has_bits);
          _impl_.restriction_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 offerType = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_offertype(&has_bits);
          _impl_.offertype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .playapi.proto.finsky.filter_rules.Rule rule = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_rule(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated group PerDeviceAvailabilityRestriction = 9 { ... };
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 75)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseGroup(_internal_add_perdeviceavailabilityrestriction(), ptr, 75);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<75>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool availableIfOwned = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_availableifowned(&has_bits);
          _impl_.availableifowned_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .playapi.proto.finsky.download.Install install = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_install(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<114>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .playapi.proto.finsky.filter_rules.FilterEvaluationInfo filterInfo = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_filterinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .playapi.proto.finsky.OwnershipInfo ownershipInfo = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_ownershipinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .playapi.proto.finsky.filter_rules.AvailabilityProblem availabilityProblem = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_availabilityproblem(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<146>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool hidden = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_hidden(&has_bits);
          _impl_.hidden_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Availability::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:playapi.proto.finsky.filter_rules.Availability)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 restriction = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_restriction(), target);
  }

  // optional int32 offerType = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_offertype(), target);
  }

  // optional .playapi.proto.finsky.filter_rules.Rule rule = 7;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::rule(this),
        _Internal::rule(this).GetCachedSize(), target, stream);
  }

  // repeated group PerDeviceAvailabilityRestriction = 9 { ... };
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_perdeviceavailabilityrestriction_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteGroup(9, this->_internal_perdeviceavailabilityrestriction(i), target, stream);
  }

  // optional bool availableIfOwned = 13;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(13, this->_internal_availableifowned(), target);
  }

  // repeated .playapi.proto.finsky.download.Install install = 14;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_install_size()); i < n; i++) {
    const auto& repfield = this->_internal_install(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(14, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .playapi.proto.finsky.filter_rules.FilterEvaluationInfo filterInfo = 16;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(16, _Internal::filterinfo(this),
        _Internal::filterinfo(this).GetCachedSize(), target, stream);
  }

  // optional .playapi.proto.finsky.OwnershipInfo ownershipInfo = 17;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(17, _Internal::ownershipinfo(this),
        _Internal::ownershipinfo(this).GetCachedSize(), target, stream);
  }

  // repeated .playapi.proto.finsky.filter_rules.AvailabilityProblem availabilityProblem = 18;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_availabilityproblem_size()); i < n; i++) {
    const auto& repfield = this->_internal_availabilityproblem(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(18, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool hidden = 21;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(21, this->_internal_hidden(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:playapi.proto.finsky.filter_rules.Availability)
  return target;
}

size_t Availability::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:playapi.proto.finsky.filter_rules.Availability)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated group PerDeviceAvailabilityRestriction = 9 { ... };
  total_size += 2UL * this->_internal_perdeviceavailabilityrestriction_size();
  for (const auto& msg : this->_impl_.perdeviceavailabilityrestriction_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GroupSize(msg);
  }

  // repeated .playapi.proto.finsky.download.Install install = 14;
  total_size += 1UL * this->_internal_install_size();
  for (const auto& msg : this->_impl_.install_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .playapi.proto.finsky.filter_rules.AvailabilityProblem availabilityProblem = 18;
  total_size += 2UL * this->_internal_availabilityproblem_size();
  for (const auto& msg : this->_impl_.availabilityproblem_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional .playapi.proto.finsky.filter_rules.Rule rule = 7;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.rule_);
    }

    // optional .playapi.proto.finsky.filter_rules.FilterEvaluationInfo filterInfo = 16;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.filterinfo_);
    }

    // optional .playapi.proto.finsky.OwnershipInfo ownershipInfo = 17;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ownershipinfo_);
    }

    // optional int32 restriction = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_restriction());
    }

    // optional int32 offerType = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_offertype());
    }

    // optional bool availableIfOwned = 13;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool hidden = 21;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Availability::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Availability::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Availability::GetClassData() const { return &_class_data_; }


void Availability::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Availability*>(&to_msg);
  auto& from = static_cast<const Availability&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:playapi.proto.finsky.filter_rules.Availability)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.perdeviceavailabilityrestriction_.MergeFrom(from._impl_.perdeviceavailabilityrestriction_);
  _this->_impl_.install_.MergeFrom(from._impl_.install_);
  _this->_impl_.availabilityproblem_.MergeFrom(from._impl_.availabilityproblem_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_rule()->::playapi::proto::finsky::filter_rules::Rule::MergeFrom(
          from._internal_rule());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_filterinfo()->::playapi::proto::finsky::filter_rules::FilterEvaluationInfo::MergeFrom(
          from._internal_filterinfo());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_ownershipinfo()->::playapi::proto::finsky::OwnershipInfo::MergeFrom(
          from._internal_ownershipinfo());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.restriction_ = from._impl_.restriction_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.offertype_ = from._impl_.offertype_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.availableifowned_ = from._impl_.availableifowned_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.hidden_ = from._impl_.hidden_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Availability::CopyFrom(const Availability& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:playapi.proto.finsky.filter_rules.Availability)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Availability::IsInitialized() const {
  return true;
}

void Availability::InternalSwap(Availability* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.perdeviceavailabilityrestriction_.InternalSwap(&other->_impl_.perdeviceavailabilityrestriction_);
  _impl_.install_.InternalSwap(&other->_impl_.install_);
  _impl_.availabilityproblem_.InternalSwap(&other->_impl_.availabilityproblem_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Availability, _impl_.hidden_)
      + sizeof(Availability::_impl_.hidden_)
      - PROTOBUF_FIELD_OFFSET(Availability, _impl_.rule_)>(
          reinterpret_cast<char*>(&_impl_.rule_),
          reinterpret_cast<char*>(&other->_impl_.rule_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Availability::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_play_5ffilter_5frules_2eproto_getter, &descriptor_table_play_5ffilter_5frules_2eproto_once,
      file_level_metadata_play_5ffilter_5frules_2eproto[1]);
}

// ===================================================================

class AvailabilityProblem::_Internal {
 public:
  using HasBits = decltype(std::declval<AvailabilityProblem>()._impl_._has_bits_);
  static void set_has_problemtype(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

AvailabilityProblem::AvailabilityProblem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:playapi.proto.finsky.filter_rules.AvailabilityProblem)
}
AvailabilityProblem::AvailabilityProblem(const AvailabilityProblem& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AvailabilityProblem* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.missingvalue_){from._impl_.missingvalue_}
    , decltype(_impl_.problemtype_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.problemtype_ = from._impl_.problemtype_;
  // @@protoc_insertion_point(copy_constructor:playapi.proto.finsky.filter_rules.AvailabilityProblem)
}

inline void AvailabilityProblem::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.missingvalue_){arena}
    , decltype(_impl_.problemtype_){0}
  };
}

AvailabilityProblem::~AvailabilityProblem() {
  // @@protoc_insertion_point(destructor:playapi.proto.finsky.filter_rules.AvailabilityProblem)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AvailabilityProblem::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.missingvalue_.~RepeatedPtrField();
}

void AvailabilityProblem::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AvailabilityProblem::Clear() {
// @@protoc_insertion_point(message_clear_start:playapi.proto.finsky.filter_rules.AvailabilityProblem)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.missingvalue_.Clear();
  _impl_.problemtype_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AvailabilityProblem::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 problemType = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_problemtype(&has_bits);
          _impl_.problemtype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string missingValue = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_missingvalue();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "playapi.proto.finsky.filter_rules.AvailabilityProblem.missingValue");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AvailabilityProblem::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:playapi.proto.finsky.filter_rules.AvailabilityProblem)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 problemType = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_problemtype(), target);
  }

  // repeated string missingValue = 2;
  for (int i = 0, n = this->_internal_missingvalue_size(); i < n; i++) {
    const auto& s = this->_internal_missingvalue(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "playapi.proto.finsky.filter_rules.AvailabilityProblem.missingValue");
    target = stream->WriteString(2, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:playapi.proto.finsky.filter_rules.AvailabilityProblem)
  return target;
}

size_t AvailabilityProblem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:playapi.proto.finsky.filter_rules.AvailabilityProblem)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string missingValue = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.missingvalue_.size());
  for (int i = 0, n = _impl_.missingvalue_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.missingvalue_.Get(i));
  }

  // optional int32 problemType = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_problemtype());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AvailabilityProblem::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AvailabilityProblem::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AvailabilityProblem::GetClassData() const { return &_class_data_; }


void AvailabilityProblem::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AvailabilityProblem*>(&to_msg);
  auto& from = static_cast<const AvailabilityProblem&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:playapi.proto.finsky.filter_rules.AvailabilityProblem)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.missingvalue_.MergeFrom(from._impl_.missingvalue_);
  if (from._internal_has_problemtype()) {
    _this->_internal_set_problemtype(from._internal_problemtype());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AvailabilityProblem::CopyFrom(const AvailabilityProblem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:playapi.proto.finsky.filter_rules.AvailabilityProblem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AvailabilityProblem::IsInitialized() const {
  return true;
}

void AvailabilityProblem::InternalSwap(AvailabilityProblem* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.missingvalue_.InternalSwap(&other->_impl_.missingvalue_);
  swap(_impl_.problemtype_, other->_impl_.problemtype_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AvailabilityProblem::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_play_5ffilter_5frules_2eproto_getter, &descriptor_table_play_5ffilter_5frules_2eproto_once,
      file_level_metadata_play_5ffilter_5frules_2eproto[2]);
}

// ===================================================================

class FilterEvaluationInfo::_Internal {
 public:
};

FilterEvaluationInfo::FilterEvaluationInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:playapi.proto.finsky.filter_rules.FilterEvaluationInfo)
}
FilterEvaluationInfo::FilterEvaluationInfo(const FilterEvaluationInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FilterEvaluationInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.ruleevaluation_){from._impl_.ruleevaluation_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:playapi.proto.finsky.filter_rules.FilterEvaluationInfo)
}

inline void FilterEvaluationInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.ruleevaluation_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

FilterEvaluationInfo::~FilterEvaluationInfo() {
  // @@protoc_insertion_point(destructor:playapi.proto.finsky.filter_rules.FilterEvaluationInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FilterEvaluationInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ruleevaluation_.~RepeatedPtrField();
}

void FilterEvaluationInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FilterEvaluationInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:playapi.proto.finsky.filter_rules.FilterEvaluationInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ruleevaluation_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FilterEvaluationInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .playapi.proto.finsky.filter_rules.RuleEvaluation ruleEvaluation = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_ruleevaluation(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FilterEvaluationInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:playapi.proto.finsky.filter_rules.FilterEvaluationInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .playapi.proto.finsky.filter_rules.RuleEvaluation ruleEvaluation = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_ruleevaluation_size()); i < n; i++) {
    const auto& repfield = this->_internal_ruleevaluation(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:playapi.proto.finsky.filter_rules.FilterEvaluationInfo)
  return target;
}

size_t FilterEvaluationInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:playapi.proto.finsky.filter_rules.FilterEvaluationInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .playapi.proto.finsky.filter_rules.RuleEvaluation ruleEvaluation = 1;
  total_size += 1UL * this->_internal_ruleevaluation_size();
  for (const auto& msg : this->_impl_.ruleevaluation_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FilterEvaluationInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FilterEvaluationInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FilterEvaluationInfo::GetClassData() const { return &_class_data_; }


void FilterEvaluationInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FilterEvaluationInfo*>(&to_msg);
  auto& from = static_cast<const FilterEvaluationInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:playapi.proto.finsky.filter_rules.FilterEvaluationInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.ruleevaluation_.MergeFrom(from._impl_.ruleevaluation_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FilterEvaluationInfo::CopyFrom(const FilterEvaluationInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:playapi.proto.finsky.filter_rules.FilterEvaluationInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FilterEvaluationInfo::IsInitialized() const {
  return true;
}

void FilterEvaluationInfo::InternalSwap(FilterEvaluationInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.ruleevaluation_.InternalSwap(&other->_impl_.ruleevaluation_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FilterEvaluationInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_play_5ffilter_5frules_2eproto_getter, &descriptor_table_play_5ffilter_5frules_2eproto_once,
      file_level_metadata_play_5ffilter_5frules_2eproto[3]);
}

// ===================================================================

class Rule::_Internal {
 public:
  using HasBits = decltype(std::declval<Rule>()._impl_._has_bits_);
  static void set_has_negate(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_operator_(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_responsecode(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_comment(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_availabilityproblemtype(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_includemissingvalues(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

Rule::Rule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:playapi.proto.finsky.filter_rules.Rule)
}
Rule::Rule(const Rule& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Rule* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stringarg_){from._impl_.stringarg_}
    , decltype(_impl_.longarg_){from._impl_.longarg_}
    , decltype(_impl_.doublearg_){from._impl_.doublearg_}
    , decltype(_impl_.subrule_){from._impl_.subrule_}
    , decltype(_impl_.stringarghash_){from._impl_.stringarghash_}
    , decltype(_impl_.comment_){}
    , decltype(_impl_.operator__){}
    , decltype(_impl_.key_){}
    , decltype(_impl_.negate_){}
    , decltype(_impl_.includemissingvalues_){}
    , decltype(_impl_.responsecode_){}
    , decltype(_impl_.availabilityproblemtype_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.comment_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.comment_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_comment()) {
    _this->_impl_.comment_.Set(from._internal_comment(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.operator__, &from._impl_.operator__,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.availabilityproblemtype_) -
    reinterpret_cast<char*>(&_impl_.operator__)) + sizeof(_impl_.availabilityproblemtype_));
  // @@protoc_insertion_point(copy_constructor:playapi.proto.finsky.filter_rules.Rule)
}

inline void Rule::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stringarg_){arena}
    , decltype(_impl_.longarg_){arena}
    , decltype(_impl_.doublearg_){arena}
    , decltype(_impl_.subrule_){arena}
    , decltype(_impl_.stringarghash_){arena}
    , decltype(_impl_.comment_){}
    , decltype(_impl_.operator__){0}
    , decltype(_impl_.key_){0}
    , decltype(_impl_.negate_){false}
    , decltype(_impl_.includemissingvalues_){false}
    , decltype(_impl_.responsecode_){0}
    , decltype(_impl_.availabilityproblemtype_){0}
  };
  _impl_.comment_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.comment_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Rule::~Rule() {
  // @@protoc_insertion_point(destructor:playapi.proto.finsky.filter_rules.Rule)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Rule::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.stringarg_.~RepeatedPtrField();
  _impl_.longarg_.~RepeatedField();
  _impl_.doublearg_.~RepeatedField();
  _impl_.subrule_.~RepeatedPtrField();
  _impl_.stringarghash_.~RepeatedField();
  _impl_.comment_.Destroy();
}

void Rule::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Rule::Clear() {
// @@protoc_insertion_point(message_clear_start:playapi.proto.finsky.filter_rules.Rule)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.stringarg_.Clear();
  _impl_.longarg_.Clear();
  _impl_.doublearg_.Clear();
  _impl_.subrule_.Clear();
  _impl_.stringarghash_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.comment_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000007eu) {
    ::memset(&_impl_.operator__, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.availabilityproblemtype_) -
        reinterpret_cast<char*>(&_impl_.operator__)) + sizeof(_impl_.availabilityproblemtype_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Rule::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool negate = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_negate(&has_bits);
          _impl_.negate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 operator = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_operator_(&has_bits);
          _impl_.operator__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 key = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_key(&has_bits);
          _impl_.key_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string stringArg = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_stringarg();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "playapi.proto.finsky.filter_rules.Rule.stringArg");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated int64 longArg = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_longarg(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<40>(ptr));
        } else if (static_cast<uint8_t>(tag) == 42) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_longarg(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated double doubleArg = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_doublearg(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
            ptr += sizeof(double);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<49>(ptr));
        } else if (static_cast<uint8_t>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_doublearg(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .playapi.proto.finsky.filter_rules.Rule subrule = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_subrule(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int32 responseCode = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_responsecode(&has_bits);
          _impl_.responsecode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string comment = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_comment();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "playapi.proto.finsky.filter_rules.Rule.comment");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated fixed64 stringArgHash = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 81)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_stringarghash(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr));
            ptr += sizeof(uint64_t);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<81>(ptr));
        } else if (static_cast<uint8_t>(tag) == 82) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFixed64Parser(_internal_mutable_stringarghash(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 availabilityProblemType = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_availabilityproblemtype(&has_bits);
          _impl_.availabilityproblemtype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool includeMissingValues = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_includemissingvalues(&has_bits);
          _impl_.includemissingvalues_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Rule::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:playapi.proto.finsky.filter_rules.Rule)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool negate = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_negate(), target);
  }

  // optional int32 operator = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_operator_(), target);
  }

  // optional int32 key = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_key(), target);
  }

  // repeated string stringArg = 4;
  for (int i = 0, n = this->_internal_stringarg_size(); i < n; i++) {
    const auto& s = this->_internal_stringarg(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "playapi.proto.finsky.filter_rules.Rule.stringArg");
    target = stream->WriteString(4, s, target);
  }

  // repeated int64 longArg = 5;
  for (int i = 0, n = this->_internal_longarg_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_longarg(i), target);
  }

  // repeated double doubleArg = 6;
  for (int i = 0, n = this->_internal_doublearg_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_doublearg(i), target);
  }

  // repeated .playapi.proto.finsky.filter_rules.Rule subrule = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_subrule_size()); i < n; i++) {
    const auto& repfield = this->_internal_subrule(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional int32 responseCode = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_responsecode(), target);
  }

  // optional string comment = 9;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_comment().data(), static_cast<int>(this->_internal_comment().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "playapi.proto.finsky.filter_rules.Rule.comment");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_comment(), target);
  }

  // repeated fixed64 stringArgHash = 10;
  for (int i = 0, n = this->_internal_stringarghash_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(10, this->_internal_stringarghash(i), target);
  }

  // optional int32 availabilityProblemType = 12;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(12, this->_internal_availabilityproblemtype(), target);
  }

  // optional bool includeMissingValues = 13;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(13, this->_internal_includemissingvalues(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:playapi.proto.finsky.filter_rules.Rule)
  return target;
}

size_t Rule::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:playapi.proto.finsky.filter_rules.Rule)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string stringArg = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.stringarg_.size());
  for (int i = 0, n = _impl_.stringarg_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.stringarg_.Get(i));
  }

  // repeated int64 longArg = 5;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int64Size(this->_impl_.longarg_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_longarg_size());
    total_size += data_size;
  }

  // repeated double doubleArg = 6;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_doublearg_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_doublearg_size());
    total_size += data_size;
  }

  // repeated .playapi.proto.finsky.filter_rules.Rule subrule = 7;
  total_size += 1UL * this->_internal_subrule_size();
  for (const auto& msg : this->_impl_.subrule_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated fixed64 stringArgHash = 10;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_stringarghash_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_stringarghash_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string comment = 9;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_comment());
    }

    // optional int32 operator = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_operator_());
    }

    // optional int32 key = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_key());
    }

    // optional bool negate = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool includeMissingValues = 13;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional int32 responseCode = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_responsecode());
    }

    // optional int32 availabilityProblemType = 12;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_availabilityproblemtype());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Rule::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Rule::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Rule::GetClassData() const { return &_class_data_; }


void Rule::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Rule*>(&to_msg);
  auto& from = static_cast<const Rule&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:playapi.proto.finsky.filter_rules.Rule)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.stringarg_.MergeFrom(from._impl_.stringarg_);
  _this->_impl_.longarg_.MergeFrom(from._impl_.longarg_);
  _this->_impl_.doublearg_.MergeFrom(from._impl_.doublearg_);
  _this->_impl_.subrule_.MergeFrom(from._impl_.subrule_);
  _this->_impl_.stringarghash_.MergeFrom(from._impl_.stringarghash_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_comment(from._internal_comment());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.operator__ = from._impl_.operator__;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.key_ = from._impl_.key_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.negate_ = from._impl_.negate_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.includemissingvalues_ = from._impl_.includemissingvalues_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.responsecode_ = from._impl_.responsecode_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.availabilityproblemtype_ = from._impl_.availabilityproblemtype_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Rule::CopyFrom(const Rule& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:playapi.proto.finsky.filter_rules.Rule)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Rule::IsInitialized() const {
  return true;
}

void Rule::InternalSwap(Rule* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.stringarg_.InternalSwap(&other->_impl_.stringarg_);
  _impl_.longarg_.InternalSwap(&other->_impl_.longarg_);
  _impl_.doublearg_.InternalSwap(&other->_impl_.doublearg_);
  _impl_.subrule_.InternalSwap(&other->_impl_.subrule_);
  _impl_.stringarghash_.InternalSwap(&other->_impl_.stringarghash_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.comment_, lhs_arena,
      &other->_impl_.comment_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Rule, _impl_.availabilityproblemtype_)
      + sizeof(Rule::_impl_.availabilityproblemtype_)
      - PROTOBUF_FIELD_OFFSET(Rule, _impl_.operator__)>(
          reinterpret_cast<char*>(&_impl_.operator__),
          reinterpret_cast<char*>(&other->_impl_.operator__));
}

::PROTOBUF_NAMESPACE_ID::Metadata Rule::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_play_5ffilter_5frules_2eproto_getter, &descriptor_table_play_5ffilter_5frules_2eproto_once,
      file_level_metadata_play_5ffilter_5frules_2eproto[4]);
}

// ===================================================================

class RuleEvaluation::_Internal {
 public:
  using HasBits = decltype(std::declval<RuleEvaluation>()._impl_._has_bits_);
  static const ::playapi::proto::finsky::filter_rules::Rule& rule(const RuleEvaluation* msg);
  static void set_has_rule(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::playapi::proto::finsky::filter_rules::Rule&
RuleEvaluation::_Internal::rule(const RuleEvaluation* msg) {
  return *msg->_impl_.rule_;
}
RuleEvaluation::RuleEvaluation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:playapi.proto.finsky.filter_rules.RuleEvaluation)
}
RuleEvaluation::RuleEvaluation(const RuleEvaluation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RuleEvaluation* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.actualstringvalue_){from._impl_.actualstringvalue_}
    , decltype(_impl_.actuallongvalue_){from._impl_.actuallongvalue_}
    , decltype(_impl_.actualboolvalue_){from._impl_.actualboolvalue_}
    , decltype(_impl_.actualdoublevalue_){from._impl_.actualdoublevalue_}
    , decltype(_impl_.rule_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_rule()) {
    _this->_impl_.rule_ = new ::playapi::proto::finsky::filter_rules::Rule(*from._impl_.rule_);
  }
  // @@protoc_insertion_point(copy_constructor:playapi.proto.finsky.filter_rules.RuleEvaluation)
}

inline void RuleEvaluation::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.actualstringvalue_){arena}
    , decltype(_impl_.actuallongvalue_){arena}
    , decltype(_impl_.actualboolvalue_){arena}
    , decltype(_impl_.actualdoublevalue_){arena}
    , decltype(_impl_.rule_){nullptr}
  };
}

RuleEvaluation::~RuleEvaluation() {
  // @@protoc_insertion_point(destructor:playapi.proto.finsky.filter_rules.RuleEvaluation)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RuleEvaluation::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.actualstringvalue_.~RepeatedPtrField();
  _impl_.actuallongvalue_.~RepeatedField();
  _impl_.actualboolvalue_.~RepeatedField();
  _impl_.actualdoublevalue_.~RepeatedField();
  if (this != internal_default_instance()) delete _impl_.rule_;
}

void RuleEvaluation::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RuleEvaluation::Clear() {
// @@protoc_insertion_point(message_clear_start:playapi.proto.finsky.filter_rules.RuleEvaluation)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.actualstringvalue_.Clear();
  _impl_.actuallongvalue_.Clear();
  _impl_.actualboolvalue_.Clear();
  _impl_.actualdoublevalue_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.rule_ != nullptr);
    _impl_.rule_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RuleEvaluation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .playapi.proto.finsky.filter_rules.Rule rule = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_rule(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string actualStringValue = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_actualstringvalue();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "playapi.proto.finsky.filter_rules.RuleEvaluation.actualStringValue");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated int64 actualLongValue = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_actuallongvalue(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_actuallongvalue(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bool actualBoolValue = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_actualboolvalue(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<uint8_t>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedBoolParser(_internal_mutable_actualboolvalue(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated double actualDoubleValue = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_actualdoublevalue(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
            ptr += sizeof(double);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<41>(ptr));
        } else if (static_cast<uint8_t>(tag) == 42) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_actualdoublevalue(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RuleEvaluation::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:playapi.proto.finsky.filter_rules.RuleEvaluation)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .playapi.proto.finsky.filter_rules.Rule rule = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::rule(this),
        _Internal::rule(this).GetCachedSize(), target, stream);
  }

  // repeated string actualStringValue = 2;
  for (int i = 0, n = this->_internal_actualstringvalue_size(); i < n; i++) {
    const auto& s = this->_internal_actualstringvalue(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "playapi.proto.finsky.filter_rules.RuleEvaluation.actualStringValue");
    target = stream->WriteString(2, s, target);
  }

  // repeated int64 actualLongValue = 3;
  for (int i = 0, n = this->_internal_actuallongvalue_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_actuallongvalue(i), target);
  }

  // repeated bool actualBoolValue = 4;
  for (int i = 0, n = this->_internal_actualboolvalue_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_actualboolvalue(i), target);
  }

  // repeated double actualDoubleValue = 5;
  for (int i = 0, n = this->_internal_actualdoublevalue_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_actualdoublevalue(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:playapi.proto.finsky.filter_rules.RuleEvaluation)
  return target;
}

size_t RuleEvaluation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:playapi.proto.finsky.filter_rules.RuleEvaluation)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string actualStringValue = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.actualstringvalue_.size());
  for (int i = 0, n = _impl_.actualstringvalue_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.actualstringvalue_.Get(i));
  }

  // repeated int64 actualLongValue = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int64Size(this->_impl_.actuallongvalue_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_actuallongvalue_size());
    total_size += data_size;
  }

  // repeated bool actualBoolValue = 4;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_actualboolvalue_size());
    size_t data_size = 1UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_actualboolvalue_size());
    total_size += data_size;
  }

  // repeated double actualDoubleValue = 5;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_actualdoublevalue_size());
    size_t data_size = 8UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_actualdoublevalue_size());
    total_size += data_size;
  }

  // optional .playapi.proto.finsky.filter_rules.Rule rule = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.rule_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RuleEvaluation::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RuleEvaluation::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RuleEvaluation::GetClassData() const { return &_class_data_; }


void RuleEvaluation::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RuleEvaluation*>(&to_msg);
  auto& from = static_cast<const RuleEvaluation&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:playapi.proto.finsky.filter_rules.RuleEvaluation)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.actualstringvalue_.MergeFrom(from._impl_.actualstringvalue_);
  _this->_impl_.actuallongvalue_.MergeFrom(from._impl_.actuallongvalue_);
  _this->_impl_.actualboolvalue_.MergeFrom(from._impl_.actualboolvalue_);
  _this->_impl_.actualdoublevalue_.MergeFrom(from._impl_.actualdoublevalue_);
  if (from._internal_has_rule()) {
    _this->_internal_mutable_rule()->::playapi::proto::finsky::filter_rules::Rule::MergeFrom(
        from._internal_rule());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RuleEvaluation::CopyFrom(const RuleEvaluation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:playapi.proto.finsky.filter_rules.RuleEvaluation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RuleEvaluation::IsInitialized() const {
  return true;
}

void RuleEvaluation::InternalSwap(RuleEvaluation* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.actualstringvalue_.InternalSwap(&other->_impl_.actualstringvalue_);
  _impl_.actuallongvalue_.InternalSwap(&other->_impl_.actuallongvalue_);
  _impl_.actualboolvalue_.InternalSwap(&other->_impl_.actualboolvalue_);
  _impl_.actualdoublevalue_.InternalSwap(&other->_impl_.actualdoublevalue_);
  swap(_impl_.rule_, other->_impl_.rule_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RuleEvaluation::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_play_5ffilter_5frules_2eproto_getter, &descriptor_table_play_5ffilter_5frules_2eproto_once,
      file_level_metadata_play_5ffilter_5frules_2eproto[5]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace filter_rules
}  // namespace finsky
}  // namespace proto
}  // namespace playapi
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::playapi::proto::finsky::filter_rules::Availability_PerDeviceAvailabilityRestriction*
Arena::CreateMaybeMessage< ::playapi::proto::finsky::filter_rules::Availability_PerDeviceAvailabilityRestriction >(Arena* arena) {
  return Arena::CreateMessageInternal< ::playapi::proto::finsky::filter_rules::Availability_PerDeviceAvailabilityRestriction >(arena);
}
template<> PROTOBUF_NOINLINE ::playapi::proto::finsky::filter_rules::Availability*
Arena::CreateMaybeMessage< ::playapi::proto::finsky::filter_rules::Availability >(Arena* arena) {
  return Arena::CreateMessageInternal< ::playapi::proto::finsky::filter_rules::Availability >(arena);
}
template<> PROTOBUF_NOINLINE ::playapi::proto::finsky::filter_rules::AvailabilityProblem*
Arena::CreateMaybeMessage< ::playapi::proto::finsky::filter_rules::AvailabilityProblem >(Arena* arena) {
  return Arena::CreateMessageInternal< ::playapi::proto::finsky::filter_rules::AvailabilityProblem >(arena);
}
template<> PROTOBUF_NOINLINE ::playapi::proto::finsky::filter_rules::FilterEvaluationInfo*
Arena::CreateMaybeMessage< ::playapi::proto::finsky::filter_rules::FilterEvaluationInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::playapi::proto::finsky::filter_rules::FilterEvaluationInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::playapi::proto::finsky::filter_rules::Rule*
Arena::CreateMaybeMessage< ::playapi::proto::finsky::filter_rules::Rule >(Arena* arena) {
  return Arena::CreateMessageInternal< ::playapi::proto::finsky::filter_rules::Rule >(arena);
}
template<> PROTOBUF_NOINLINE ::playapi::proto::finsky::filter_rules::RuleEvaluation*
Arena::CreateMaybeMessage< ::playapi::proto::finsky::filter_rules::RuleEvaluation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::playapi::proto::finsky::filter_rules::RuleEvaluation >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
