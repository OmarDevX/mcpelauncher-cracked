// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: play_search.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_play_5fsearch_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_play_5fsearch_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "play_common.pb.h"
#include "play_document.pb.h"
#include "play_link.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_play_5fsearch_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_play_5fsearch_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_play_5fsearch_2eproto;
namespace playapi {
namespace proto {
namespace finsky {
namespace search {
class NavSuggestion;
struct NavSuggestionDefaultTypeInternal;
extern NavSuggestionDefaultTypeInternal _NavSuggestion_default_instance_;
class RelatedSearch;
struct RelatedSearchDefaultTypeInternal;
extern RelatedSearchDefaultTypeInternal _RelatedSearch_default_instance_;
class SearchResponse;
struct SearchResponseDefaultTypeInternal;
extern SearchResponseDefaultTypeInternal _SearchResponse_default_instance_;
class SearchSuggestResponse;
struct SearchSuggestResponseDefaultTypeInternal;
extern SearchSuggestResponseDefaultTypeInternal _SearchSuggestResponse_default_instance_;
class Suggestion;
struct SuggestionDefaultTypeInternal;
extern SuggestionDefaultTypeInternal _Suggestion_default_instance_;
}  // namespace search
}  // namespace finsky
}  // namespace proto
}  // namespace playapi
PROTOBUF_NAMESPACE_OPEN
template<> ::playapi::proto::finsky::search::NavSuggestion* Arena::CreateMaybeMessage<::playapi::proto::finsky::search::NavSuggestion>(Arena*);
template<> ::playapi::proto::finsky::search::RelatedSearch* Arena::CreateMaybeMessage<::playapi::proto::finsky::search::RelatedSearch>(Arena*);
template<> ::playapi::proto::finsky::search::SearchResponse* Arena::CreateMaybeMessage<::playapi::proto::finsky::search::SearchResponse>(Arena*);
template<> ::playapi::proto::finsky::search::SearchSuggestResponse* Arena::CreateMaybeMessage<::playapi::proto::finsky::search::SearchSuggestResponse>(Arena*);
template<> ::playapi::proto::finsky::search::Suggestion* Arena::CreateMaybeMessage<::playapi::proto::finsky::search::Suggestion>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace playapi {
namespace proto {
namespace finsky {
namespace search {

// ===================================================================

class SearchResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.search.SearchResponse) */ {
 public:
  inline SearchResponse() : SearchResponse(nullptr) {}
  ~SearchResponse() override;
  explicit PROTOBUF_CONSTEXPR SearchResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SearchResponse(const SearchResponse& from);
  SearchResponse(SearchResponse&& from) noexcept
    : SearchResponse() {
    *this = ::std::move(from);
  }

  inline SearchResponse& operator=(const SearchResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchResponse& operator=(SearchResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SearchResponse* internal_default_instance() {
    return reinterpret_cast<const SearchResponse*>(
               &_SearchResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SearchResponse& a, SearchResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SearchResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SearchResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SearchResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SearchResponse& from) {
    SearchResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.search.SearchResponse";
  }
  protected:
  explicit SearchResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDocFieldNumber = 5,
    kRelatedSearchFieldNumber = 6,
    kOriginalQueryFieldNumber = 1,
    kSuggestedQueryFieldNumber = 2,
    kServerLogsCookieFieldNumber = 7,
    kAggregateQueryFieldNumber = 3,
    kFullPageReplacedFieldNumber = 8,
    kContainsSnowFieldNumber = 9,
  };
  // repeated .playapi.proto.finsky.document.DocV2 doc = 5;
  int doc_size() const;
  private:
  int _internal_doc_size() const;
  public:
  void clear_doc();
  ::playapi::proto::finsky::document::DocV2* mutable_doc(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::DocV2 >*
      mutable_doc();
  private:
  const ::playapi::proto::finsky::document::DocV2& _internal_doc(int index) const;
  ::playapi::proto::finsky::document::DocV2* _internal_add_doc();
  public:
  const ::playapi::proto::finsky::document::DocV2& doc(int index) const;
  ::playapi::proto::finsky::document::DocV2* add_doc();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::DocV2 >&
      doc() const;

  // repeated .playapi.proto.finsky.search.RelatedSearch relatedSearch = 6;
  int relatedsearch_size() const;
  private:
  int _internal_relatedsearch_size() const;
  public:
  void clear_relatedsearch();
  ::playapi::proto::finsky::search::RelatedSearch* mutable_relatedsearch(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::search::RelatedSearch >*
      mutable_relatedsearch();
  private:
  const ::playapi::proto::finsky::search::RelatedSearch& _internal_relatedsearch(int index) const;
  ::playapi::proto::finsky::search::RelatedSearch* _internal_add_relatedsearch();
  public:
  const ::playapi::proto::finsky::search::RelatedSearch& relatedsearch(int index) const;
  ::playapi::proto::finsky::search::RelatedSearch* add_relatedsearch();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::search::RelatedSearch >&
      relatedsearch() const;

  // optional string originalQuery = 1;
  bool has_originalquery() const;
  private:
  bool _internal_has_originalquery() const;
  public:
  void clear_originalquery();
  const std::string& originalquery() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_originalquery(ArgT0&& arg0, ArgT... args);
  std::string* mutable_originalquery();
  PROTOBUF_NODISCARD std::string* release_originalquery();
  void set_allocated_originalquery(std::string* originalquery);
  private:
  const std::string& _internal_originalquery() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_originalquery(const std::string& value);
  std::string* _internal_mutable_originalquery();
  public:

  // optional string suggestedQuery = 2;
  bool has_suggestedquery() const;
  private:
  bool _internal_has_suggestedquery() const;
  public:
  void clear_suggestedquery();
  const std::string& suggestedquery() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_suggestedquery(ArgT0&& arg0, ArgT... args);
  std::string* mutable_suggestedquery();
  PROTOBUF_NODISCARD std::string* release_suggestedquery();
  void set_allocated_suggestedquery(std::string* suggestedquery);
  private:
  const std::string& _internal_suggestedquery() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_suggestedquery(const std::string& value);
  std::string* _internal_mutable_suggestedquery();
  public:

  // optional bytes serverLogsCookie = 7;
  bool has_serverlogscookie() const;
  private:
  bool _internal_has_serverlogscookie() const;
  public:
  void clear_serverlogscookie();
  const std::string& serverlogscookie() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serverlogscookie(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serverlogscookie();
  PROTOBUF_NODISCARD std::string* release_serverlogscookie();
  void set_allocated_serverlogscookie(std::string* serverlogscookie);
  private:
  const std::string& _internal_serverlogscookie() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serverlogscookie(const std::string& value);
  std::string* _internal_mutable_serverlogscookie();
  public:

  // optional bool aggregateQuery = 3;
  bool has_aggregatequery() const;
  private:
  bool _internal_has_aggregatequery() const;
  public:
  void clear_aggregatequery();
  bool aggregatequery() const;
  void set_aggregatequery(bool value);
  private:
  bool _internal_aggregatequery() const;
  void _internal_set_aggregatequery(bool value);
  public:

  // optional bool fullPageReplaced = 8;
  bool has_fullpagereplaced() const;
  private:
  bool _internal_has_fullpagereplaced() const;
  public:
  void clear_fullpagereplaced();
  bool fullpagereplaced() const;
  void set_fullpagereplaced(bool value);
  private:
  bool _internal_fullpagereplaced() const;
  void _internal_set_fullpagereplaced(bool value);
  public:

  // optional bool containsSnow = 9;
  bool has_containssnow() const;
  private:
  bool _internal_has_containssnow() const;
  public:
  void clear_containssnow();
  bool containssnow() const;
  void set_containssnow(bool value);
  private:
  bool _internal_containssnow() const;
  void _internal_set_containssnow(bool value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.search.SearchResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::DocV2 > doc_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::search::RelatedSearch > relatedsearch_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr originalquery_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr suggestedquery_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serverlogscookie_;
    bool aggregatequery_;
    bool fullpagereplaced_;
    bool containssnow_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fsearch_2eproto;
};
// -------------------------------------------------------------------

class RelatedSearch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.search.RelatedSearch) */ {
 public:
  inline RelatedSearch() : RelatedSearch(nullptr) {}
  ~RelatedSearch() override;
  explicit PROTOBUF_CONSTEXPR RelatedSearch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RelatedSearch(const RelatedSearch& from);
  RelatedSearch(RelatedSearch&& from) noexcept
    : RelatedSearch() {
    *this = ::std::move(from);
  }

  inline RelatedSearch& operator=(const RelatedSearch& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelatedSearch& operator=(RelatedSearch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RelatedSearch& default_instance() {
    return *internal_default_instance();
  }
  static inline const RelatedSearch* internal_default_instance() {
    return reinterpret_cast<const RelatedSearch*>(
               &_RelatedSearch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RelatedSearch& a, RelatedSearch& b) {
    a.Swap(&b);
  }
  inline void Swap(RelatedSearch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelatedSearch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RelatedSearch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RelatedSearch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RelatedSearch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RelatedSearch& from) {
    RelatedSearch::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RelatedSearch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.search.RelatedSearch";
  }
  protected:
  explicit RelatedSearch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSearchUrlFieldNumber = 1,
    kHeaderFieldNumber = 2,
    kBackendIdFieldNumber = 3,
    kDocTypeFieldNumber = 4,
    kCurrentFieldNumber = 5,
  };
  // optional string searchUrl = 1;
  bool has_searchurl() const;
  private:
  bool _internal_has_searchurl() const;
  public:
  void clear_searchurl();
  const std::string& searchurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_searchurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_searchurl();
  PROTOBUF_NODISCARD std::string* release_searchurl();
  void set_allocated_searchurl(std::string* searchurl);
  private:
  const std::string& _internal_searchurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_searchurl(const std::string& value);
  std::string* _internal_mutable_searchurl();
  public:

  // optional string header = 2;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const std::string& header() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_header(ArgT0&& arg0, ArgT... args);
  std::string* mutable_header();
  PROTOBUF_NODISCARD std::string* release_header();
  void set_allocated_header(std::string* header);
  private:
  const std::string& _internal_header() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_header(const std::string& value);
  std::string* _internal_mutable_header();
  public:

  // optional int32 backendId = 3;
  bool has_backendid() const;
  private:
  bool _internal_has_backendid() const;
  public:
  void clear_backendid();
  int32_t backendid() const;
  void set_backendid(int32_t value);
  private:
  int32_t _internal_backendid() const;
  void _internal_set_backendid(int32_t value);
  public:

  // optional int32 docType = 4;
  bool has_doctype() const;
  private:
  bool _internal_has_doctype() const;
  public:
  void clear_doctype();
  int32_t doctype() const;
  void set_doctype(int32_t value);
  private:
  int32_t _internal_doctype() const;
  void _internal_set_doctype(int32_t value);
  public:

  // optional bool current = 5;
  bool has_current() const;
  private:
  bool _internal_has_current() const;
  public:
  void clear_current();
  bool current() const;
  void set_current(bool value);
  private:
  bool _internal_current() const;
  void _internal_set_current(bool value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.search.RelatedSearch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr searchurl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr header_;
    int32_t backendid_;
    int32_t doctype_;
    bool current_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fsearch_2eproto;
};
// -------------------------------------------------------------------

class SearchSuggestResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.search.SearchSuggestResponse) */ {
 public:
  inline SearchSuggestResponse() : SearchSuggestResponse(nullptr) {}
  ~SearchSuggestResponse() override;
  explicit PROTOBUF_CONSTEXPR SearchSuggestResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SearchSuggestResponse(const SearchSuggestResponse& from);
  SearchSuggestResponse(SearchSuggestResponse&& from) noexcept
    : SearchSuggestResponse() {
    *this = ::std::move(from);
  }

  inline SearchSuggestResponse& operator=(const SearchSuggestResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchSuggestResponse& operator=(SearchSuggestResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchSuggestResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SearchSuggestResponse* internal_default_instance() {
    return reinterpret_cast<const SearchSuggestResponse*>(
               &_SearchSuggestResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SearchSuggestResponse& a, SearchSuggestResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchSuggestResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchSuggestResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SearchSuggestResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SearchSuggestResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SearchSuggestResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SearchSuggestResponse& from) {
    SearchSuggestResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchSuggestResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.search.SearchSuggestResponse";
  }
  protected:
  explicit SearchSuggestResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuggestionFieldNumber = 1,
    kServerLogsCookieFieldNumber = 2,
  };
  // repeated .playapi.proto.finsky.search.Suggestion suggestion = 1;
  int suggestion_size() const;
  private:
  int _internal_suggestion_size() const;
  public:
  void clear_suggestion();
  ::playapi::proto::finsky::search::Suggestion* mutable_suggestion(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::search::Suggestion >*
      mutable_suggestion();
  private:
  const ::playapi::proto::finsky::search::Suggestion& _internal_suggestion(int index) const;
  ::playapi::proto::finsky::search::Suggestion* _internal_add_suggestion();
  public:
  const ::playapi::proto::finsky::search::Suggestion& suggestion(int index) const;
  ::playapi::proto::finsky::search::Suggestion* add_suggestion();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::search::Suggestion >&
      suggestion() const;

  // optional bytes serverLogsCookie = 2;
  bool has_serverlogscookie() const;
  private:
  bool _internal_has_serverlogscookie() const;
  public:
  void clear_serverlogscookie();
  const std::string& serverlogscookie() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serverlogscookie(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serverlogscookie();
  PROTOBUF_NODISCARD std::string* release_serverlogscookie();
  void set_allocated_serverlogscookie(std::string* serverlogscookie);
  private:
  const std::string& _internal_serverlogscookie() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serverlogscookie(const std::string& value);
  std::string* _internal_mutable_serverlogscookie();
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.search.SearchSuggestResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::search::Suggestion > suggestion_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serverlogscookie_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fsearch_2eproto;
};
// -------------------------------------------------------------------

class Suggestion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.search.Suggestion) */ {
 public:
  inline Suggestion() : Suggestion(nullptr) {}
  ~Suggestion() override;
  explicit PROTOBUF_CONSTEXPR Suggestion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Suggestion(const Suggestion& from);
  Suggestion(Suggestion&& from) noexcept
    : Suggestion() {
    *this = ::std::move(from);
  }

  inline Suggestion& operator=(const Suggestion& from) {
    CopyFrom(from);
    return *this;
  }
  inline Suggestion& operator=(Suggestion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Suggestion& default_instance() {
    return *internal_default_instance();
  }
  static inline const Suggestion* internal_default_instance() {
    return reinterpret_cast<const Suggestion*>(
               &_Suggestion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Suggestion& a, Suggestion& b) {
    a.Swap(&b);
  }
  inline void Swap(Suggestion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Suggestion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Suggestion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Suggestion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Suggestion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Suggestion& from) {
    Suggestion::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Suggestion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.search.Suggestion";
  }
  protected:
  explicit Suggestion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuggestedQueryFieldNumber = 2,
    kServerLogsCookieFieldNumber = 4,
    kDisplayTextFieldNumber = 6,
    kNavSuggestionFieldNumber = 3,
    kImageFieldNumber = 5,
    kLinkFieldNumber = 7,
    kDocumentFieldNumber = 8,
    kTypeFieldNumber = 1,
    kSearchBackendFieldNumber = 9,
  };
  // optional string suggestedQuery = 2;
  bool has_suggestedquery() const;
  private:
  bool _internal_has_suggestedquery() const;
  public:
  void clear_suggestedquery();
  const std::string& suggestedquery() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_suggestedquery(ArgT0&& arg0, ArgT... args);
  std::string* mutable_suggestedquery();
  PROTOBUF_NODISCARD std::string* release_suggestedquery();
  void set_allocated_suggestedquery(std::string* suggestedquery);
  private:
  const std::string& _internal_suggestedquery() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_suggestedquery(const std::string& value);
  std::string* _internal_mutable_suggestedquery();
  public:

  // optional bytes serverLogsCookie = 4;
  bool has_serverlogscookie() const;
  private:
  bool _internal_has_serverlogscookie() const;
  public:
  void clear_serverlogscookie();
  const std::string& serverlogscookie() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serverlogscookie(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serverlogscookie();
  PROTOBUF_NODISCARD std::string* release_serverlogscookie();
  void set_allocated_serverlogscookie(std::string* serverlogscookie);
  private:
  const std::string& _internal_serverlogscookie() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serverlogscookie(const std::string& value);
  std::string* _internal_mutable_serverlogscookie();
  public:

  // optional string displayText = 6;
  bool has_displaytext() const;
  private:
  bool _internal_has_displaytext() const;
  public:
  void clear_displaytext();
  const std::string& displaytext() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_displaytext(ArgT0&& arg0, ArgT... args);
  std::string* mutable_displaytext();
  PROTOBUF_NODISCARD std::string* release_displaytext();
  void set_allocated_displaytext(std::string* displaytext);
  private:
  const std::string& _internal_displaytext() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_displaytext(const std::string& value);
  std::string* _internal_mutable_displaytext();
  public:

  // optional .playapi.proto.finsky.search.NavSuggestion navSuggestion = 3;
  bool has_navsuggestion() const;
  private:
  bool _internal_has_navsuggestion() const;
  public:
  void clear_navsuggestion();
  const ::playapi::proto::finsky::search::NavSuggestion& navsuggestion() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::search::NavSuggestion* release_navsuggestion();
  ::playapi::proto::finsky::search::NavSuggestion* mutable_navsuggestion();
  void set_allocated_navsuggestion(::playapi::proto::finsky::search::NavSuggestion* navsuggestion);
  private:
  const ::playapi::proto::finsky::search::NavSuggestion& _internal_navsuggestion() const;
  ::playapi::proto::finsky::search::NavSuggestion* _internal_mutable_navsuggestion();
  public:
  void unsafe_arena_set_allocated_navsuggestion(
      ::playapi::proto::finsky::search::NavSuggestion* navsuggestion);
  ::playapi::proto::finsky::search::NavSuggestion* unsafe_arena_release_navsuggestion();

  // optional .playapi.proto.finsky.Image image = 5;
  bool has_image() const;
  private:
  bool _internal_has_image() const;
  public:
  void clear_image();
  const ::playapi::proto::finsky::Image& image() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::Image* release_image();
  ::playapi::proto::finsky::Image* mutable_image();
  void set_allocated_image(::playapi::proto::finsky::Image* image);
  private:
  const ::playapi::proto::finsky::Image& _internal_image() const;
  ::playapi::proto::finsky::Image* _internal_mutable_image();
  public:
  void unsafe_arena_set_allocated_image(
      ::playapi::proto::finsky::Image* image);
  ::playapi::proto::finsky::Image* unsafe_arena_release_image();

  // optional .playapi.proto.finsky.link.Link link = 7;
  bool has_link() const;
  private:
  bool _internal_has_link() const;
  public:
  void clear_link();
  const ::playapi::proto::finsky::link::Link& link() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::link::Link* release_link();
  ::playapi::proto::finsky::link::Link* mutable_link();
  void set_allocated_link(::playapi::proto::finsky::link::Link* link);
  private:
  const ::playapi::proto::finsky::link::Link& _internal_link() const;
  ::playapi::proto::finsky::link::Link* _internal_mutable_link();
  public:
  void unsafe_arena_set_allocated_link(
      ::playapi::proto::finsky::link::Link* link);
  ::playapi::proto::finsky::link::Link* unsafe_arena_release_link();

  // optional .playapi.proto.finsky.document.DocV2 document = 8;
  bool has_document() const;
  private:
  bool _internal_has_document() const;
  public:
  void clear_document();
  const ::playapi::proto::finsky::document::DocV2& document() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::document::DocV2* release_document();
  ::playapi::proto::finsky::document::DocV2* mutable_document();
  void set_allocated_document(::playapi::proto::finsky::document::DocV2* document);
  private:
  const ::playapi::proto::finsky::document::DocV2& _internal_document() const;
  ::playapi::proto::finsky::document::DocV2* _internal_mutable_document();
  public:
  void unsafe_arena_set_allocated_document(
      ::playapi::proto::finsky::document::DocV2* document);
  ::playapi::proto::finsky::document::DocV2* unsafe_arena_release_document();

  // optional int32 type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  int32_t type() const;
  void set_type(int32_t value);
  private:
  int32_t _internal_type() const;
  void _internal_set_type(int32_t value);
  public:

  // optional int32 searchBackend = 9;
  bool has_searchbackend() const;
  private:
  bool _internal_has_searchbackend() const;
  public:
  void clear_searchbackend();
  int32_t searchbackend() const;
  void set_searchbackend(int32_t value);
  private:
  int32_t _internal_searchbackend() const;
  void _internal_set_searchbackend(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.search.Suggestion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr suggestedquery_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serverlogscookie_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr displaytext_;
    ::playapi::proto::finsky::search::NavSuggestion* navsuggestion_;
    ::playapi::proto::finsky::Image* image_;
    ::playapi::proto::finsky::link::Link* link_;
    ::playapi::proto::finsky::document::DocV2* document_;
    int32_t type_;
    int32_t searchbackend_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fsearch_2eproto;
};
// -------------------------------------------------------------------

class NavSuggestion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.search.NavSuggestion) */ {
 public:
  inline NavSuggestion() : NavSuggestion(nullptr) {}
  ~NavSuggestion() override;
  explicit PROTOBUF_CONSTEXPR NavSuggestion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NavSuggestion(const NavSuggestion& from);
  NavSuggestion(NavSuggestion&& from) noexcept
    : NavSuggestion() {
    *this = ::std::move(from);
  }

  inline NavSuggestion& operator=(const NavSuggestion& from) {
    CopyFrom(from);
    return *this;
  }
  inline NavSuggestion& operator=(NavSuggestion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NavSuggestion& default_instance() {
    return *internal_default_instance();
  }
  static inline const NavSuggestion* internal_default_instance() {
    return reinterpret_cast<const NavSuggestion*>(
               &_NavSuggestion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(NavSuggestion& a, NavSuggestion& b) {
    a.Swap(&b);
  }
  inline void Swap(NavSuggestion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NavSuggestion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NavSuggestion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NavSuggestion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NavSuggestion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NavSuggestion& from) {
    NavSuggestion::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NavSuggestion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.search.NavSuggestion";
  }
  protected:
  explicit NavSuggestion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDocIdFieldNumber = 1,
    kImageBlobFieldNumber = 2,
    kDescriptionFieldNumber = 4,
    kImageFieldNumber = 3,
  };
  // optional string docId = 1;
  bool has_docid() const;
  private:
  bool _internal_has_docid() const;
  public:
  void clear_docid();
  const std::string& docid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_docid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_docid();
  PROTOBUF_NODISCARD std::string* release_docid();
  void set_allocated_docid(std::string* docid);
  private:
  const std::string& _internal_docid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_docid(const std::string& value);
  std::string* _internal_mutable_docid();
  public:

  // optional bytes imageBlob = 2;
  bool has_imageblob() const;
  private:
  bool _internal_has_imageblob() const;
  public:
  void clear_imageblob();
  const std::string& imageblob() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_imageblob(ArgT0&& arg0, ArgT... args);
  std::string* mutable_imageblob();
  PROTOBUF_NODISCARD std::string* release_imageblob();
  void set_allocated_imageblob(std::string* imageblob);
  private:
  const std::string& _internal_imageblob() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_imageblob(const std::string& value);
  std::string* _internal_mutable_imageblob();
  public:

  // optional string description = 4;
  bool has_description() const;
  private:
  bool _internal_has_description() const;
  public:
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // optional .playapi.proto.finsky.Image image = 3;
  bool has_image() const;
  private:
  bool _internal_has_image() const;
  public:
  void clear_image();
  const ::playapi::proto::finsky::Image& image() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::Image* release_image();
  ::playapi::proto::finsky::Image* mutable_image();
  void set_allocated_image(::playapi::proto::finsky::Image* image);
  private:
  const ::playapi::proto::finsky::Image& _internal_image() const;
  ::playapi::proto::finsky::Image* _internal_mutable_image();
  public:
  void unsafe_arena_set_allocated_image(
      ::playapi::proto::finsky::Image* image);
  ::playapi::proto::finsky::Image* unsafe_arena_release_image();

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.search.NavSuggestion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr docid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr imageblob_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::playapi::proto::finsky::Image* image_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5fsearch_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SearchResponse

// optional string originalQuery = 1;
inline bool SearchResponse::_internal_has_originalquery() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SearchResponse::has_originalquery() const {
  return _internal_has_originalquery();
}
inline void SearchResponse::clear_originalquery() {
  _impl_.originalquery_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SearchResponse::originalquery() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.search.SearchResponse.originalQuery)
  return _internal_originalquery();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SearchResponse::set_originalquery(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.originalquery_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.search.SearchResponse.originalQuery)
}
inline std::string* SearchResponse::mutable_originalquery() {
  std::string* _s = _internal_mutable_originalquery();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.search.SearchResponse.originalQuery)
  return _s;
}
inline const std::string& SearchResponse::_internal_originalquery() const {
  return _impl_.originalquery_.Get();
}
inline void SearchResponse::_internal_set_originalquery(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.originalquery_.Set(value, GetArenaForAllocation());
}
inline std::string* SearchResponse::_internal_mutable_originalquery() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.originalquery_.Mutable(GetArenaForAllocation());
}
inline std::string* SearchResponse::release_originalquery() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.search.SearchResponse.originalQuery)
  if (!_internal_has_originalquery()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.originalquery_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.originalquery_.IsDefault()) {
    _impl_.originalquery_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SearchResponse::set_allocated_originalquery(std::string* originalquery) {
  if (originalquery != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.originalquery_.SetAllocated(originalquery, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.originalquery_.IsDefault()) {
    _impl_.originalquery_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.search.SearchResponse.originalQuery)
}

// optional string suggestedQuery = 2;
inline bool SearchResponse::_internal_has_suggestedquery() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SearchResponse::has_suggestedquery() const {
  return _internal_has_suggestedquery();
}
inline void SearchResponse::clear_suggestedquery() {
  _impl_.suggestedquery_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SearchResponse::suggestedquery() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.search.SearchResponse.suggestedQuery)
  return _internal_suggestedquery();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SearchResponse::set_suggestedquery(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.suggestedquery_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.search.SearchResponse.suggestedQuery)
}
inline std::string* SearchResponse::mutable_suggestedquery() {
  std::string* _s = _internal_mutable_suggestedquery();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.search.SearchResponse.suggestedQuery)
  return _s;
}
inline const std::string& SearchResponse::_internal_suggestedquery() const {
  return _impl_.suggestedquery_.Get();
}
inline void SearchResponse::_internal_set_suggestedquery(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.suggestedquery_.Set(value, GetArenaForAllocation());
}
inline std::string* SearchResponse::_internal_mutable_suggestedquery() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.suggestedquery_.Mutable(GetArenaForAllocation());
}
inline std::string* SearchResponse::release_suggestedquery() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.search.SearchResponse.suggestedQuery)
  if (!_internal_has_suggestedquery()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.suggestedquery_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.suggestedquery_.IsDefault()) {
    _impl_.suggestedquery_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SearchResponse::set_allocated_suggestedquery(std::string* suggestedquery) {
  if (suggestedquery != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.suggestedquery_.SetAllocated(suggestedquery, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.suggestedquery_.IsDefault()) {
    _impl_.suggestedquery_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.search.SearchResponse.suggestedQuery)
}

// optional bool aggregateQuery = 3;
inline bool SearchResponse::_internal_has_aggregatequery() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SearchResponse::has_aggregatequery() const {
  return _internal_has_aggregatequery();
}
inline void SearchResponse::clear_aggregatequery() {
  _impl_.aggregatequery_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool SearchResponse::_internal_aggregatequery() const {
  return _impl_.aggregatequery_;
}
inline bool SearchResponse::aggregatequery() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.search.SearchResponse.aggregateQuery)
  return _internal_aggregatequery();
}
inline void SearchResponse::_internal_set_aggregatequery(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.aggregatequery_ = value;
}
inline void SearchResponse::set_aggregatequery(bool value) {
  _internal_set_aggregatequery(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.search.SearchResponse.aggregateQuery)
}

// repeated .playapi.proto.finsky.document.DocV2 doc = 5;
inline int SearchResponse::_internal_doc_size() const {
  return _impl_.doc_.size();
}
inline int SearchResponse::doc_size() const {
  return _internal_doc_size();
}
inline ::playapi::proto::finsky::document::DocV2* SearchResponse::mutable_doc(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.search.SearchResponse.doc)
  return _impl_.doc_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::DocV2 >*
SearchResponse::mutable_doc() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.search.SearchResponse.doc)
  return &_impl_.doc_;
}
inline const ::playapi::proto::finsky::document::DocV2& SearchResponse::_internal_doc(int index) const {
  return _impl_.doc_.Get(index);
}
inline const ::playapi::proto::finsky::document::DocV2& SearchResponse::doc(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.search.SearchResponse.doc)
  return _internal_doc(index);
}
inline ::playapi::proto::finsky::document::DocV2* SearchResponse::_internal_add_doc() {
  return _impl_.doc_.Add();
}
inline ::playapi::proto::finsky::document::DocV2* SearchResponse::add_doc() {
  ::playapi::proto::finsky::document::DocV2* _add = _internal_add_doc();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.search.SearchResponse.doc)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::document::DocV2 >&
SearchResponse::doc() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.search.SearchResponse.doc)
  return _impl_.doc_;
}

// repeated .playapi.proto.finsky.search.RelatedSearch relatedSearch = 6;
inline int SearchResponse::_internal_relatedsearch_size() const {
  return _impl_.relatedsearch_.size();
}
inline int SearchResponse::relatedsearch_size() const {
  return _internal_relatedsearch_size();
}
inline void SearchResponse::clear_relatedsearch() {
  _impl_.relatedsearch_.Clear();
}
inline ::playapi::proto::finsky::search::RelatedSearch* SearchResponse::mutable_relatedsearch(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.search.SearchResponse.relatedSearch)
  return _impl_.relatedsearch_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::search::RelatedSearch >*
SearchResponse::mutable_relatedsearch() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.search.SearchResponse.relatedSearch)
  return &_impl_.relatedsearch_;
}
inline const ::playapi::proto::finsky::search::RelatedSearch& SearchResponse::_internal_relatedsearch(int index) const {
  return _impl_.relatedsearch_.Get(index);
}
inline const ::playapi::proto::finsky::search::RelatedSearch& SearchResponse::relatedsearch(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.search.SearchResponse.relatedSearch)
  return _internal_relatedsearch(index);
}
inline ::playapi::proto::finsky::search::RelatedSearch* SearchResponse::_internal_add_relatedsearch() {
  return _impl_.relatedsearch_.Add();
}
inline ::playapi::proto::finsky::search::RelatedSearch* SearchResponse::add_relatedsearch() {
  ::playapi::proto::finsky::search::RelatedSearch* _add = _internal_add_relatedsearch();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.search.SearchResponse.relatedSearch)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::search::RelatedSearch >&
SearchResponse::relatedsearch() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.search.SearchResponse.relatedSearch)
  return _impl_.relatedsearch_;
}

// optional bytes serverLogsCookie = 7;
inline bool SearchResponse::_internal_has_serverlogscookie() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SearchResponse::has_serverlogscookie() const {
  return _internal_has_serverlogscookie();
}
inline void SearchResponse::clear_serverlogscookie() {
  _impl_.serverlogscookie_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& SearchResponse::serverlogscookie() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.search.SearchResponse.serverLogsCookie)
  return _internal_serverlogscookie();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SearchResponse::set_serverlogscookie(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.serverlogscookie_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.search.SearchResponse.serverLogsCookie)
}
inline std::string* SearchResponse::mutable_serverlogscookie() {
  std::string* _s = _internal_mutable_serverlogscookie();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.search.SearchResponse.serverLogsCookie)
  return _s;
}
inline const std::string& SearchResponse::_internal_serverlogscookie() const {
  return _impl_.serverlogscookie_.Get();
}
inline void SearchResponse::_internal_set_serverlogscookie(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.serverlogscookie_.Set(value, GetArenaForAllocation());
}
inline std::string* SearchResponse::_internal_mutable_serverlogscookie() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.serverlogscookie_.Mutable(GetArenaForAllocation());
}
inline std::string* SearchResponse::release_serverlogscookie() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.search.SearchResponse.serverLogsCookie)
  if (!_internal_has_serverlogscookie()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.serverlogscookie_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.serverlogscookie_.IsDefault()) {
    _impl_.serverlogscookie_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SearchResponse::set_allocated_serverlogscookie(std::string* serverlogscookie) {
  if (serverlogscookie != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.serverlogscookie_.SetAllocated(serverlogscookie, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.serverlogscookie_.IsDefault()) {
    _impl_.serverlogscookie_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.search.SearchResponse.serverLogsCookie)
}

// optional bool fullPageReplaced = 8;
inline bool SearchResponse::_internal_has_fullpagereplaced() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SearchResponse::has_fullpagereplaced() const {
  return _internal_has_fullpagereplaced();
}
inline void SearchResponse::clear_fullpagereplaced() {
  _impl_.fullpagereplaced_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool SearchResponse::_internal_fullpagereplaced() const {
  return _impl_.fullpagereplaced_;
}
inline bool SearchResponse::fullpagereplaced() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.search.SearchResponse.fullPageReplaced)
  return _internal_fullpagereplaced();
}
inline void SearchResponse::_internal_set_fullpagereplaced(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.fullpagereplaced_ = value;
}
inline void SearchResponse::set_fullpagereplaced(bool value) {
  _internal_set_fullpagereplaced(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.search.SearchResponse.fullPageReplaced)
}

// optional bool containsSnow = 9;
inline bool SearchResponse::_internal_has_containssnow() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool SearchResponse::has_containssnow() const {
  return _internal_has_containssnow();
}
inline void SearchResponse::clear_containssnow() {
  _impl_.containssnow_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool SearchResponse::_internal_containssnow() const {
  return _impl_.containssnow_;
}
inline bool SearchResponse::containssnow() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.search.SearchResponse.containsSnow)
  return _internal_containssnow();
}
inline void SearchResponse::_internal_set_containssnow(bool value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.containssnow_ = value;
}
inline void SearchResponse::set_containssnow(bool value) {
  _internal_set_containssnow(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.search.SearchResponse.containsSnow)
}

// -------------------------------------------------------------------

// RelatedSearch

// optional string searchUrl = 1;
inline bool RelatedSearch::_internal_has_searchurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RelatedSearch::has_searchurl() const {
  return _internal_has_searchurl();
}
inline void RelatedSearch::clear_searchurl() {
  _impl_.searchurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RelatedSearch::searchurl() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.search.RelatedSearch.searchUrl)
  return _internal_searchurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RelatedSearch::set_searchurl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.searchurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.search.RelatedSearch.searchUrl)
}
inline std::string* RelatedSearch::mutable_searchurl() {
  std::string* _s = _internal_mutable_searchurl();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.search.RelatedSearch.searchUrl)
  return _s;
}
inline const std::string& RelatedSearch::_internal_searchurl() const {
  return _impl_.searchurl_.Get();
}
inline void RelatedSearch::_internal_set_searchurl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.searchurl_.Set(value, GetArenaForAllocation());
}
inline std::string* RelatedSearch::_internal_mutable_searchurl() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.searchurl_.Mutable(GetArenaForAllocation());
}
inline std::string* RelatedSearch::release_searchurl() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.search.RelatedSearch.searchUrl)
  if (!_internal_has_searchurl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.searchurl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.searchurl_.IsDefault()) {
    _impl_.searchurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RelatedSearch::set_allocated_searchurl(std::string* searchurl) {
  if (searchurl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.searchurl_.SetAllocated(searchurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.searchurl_.IsDefault()) {
    _impl_.searchurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.search.RelatedSearch.searchUrl)
}

// optional string header = 2;
inline bool RelatedSearch::_internal_has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RelatedSearch::has_header() const {
  return _internal_has_header();
}
inline void RelatedSearch::clear_header() {
  _impl_.header_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RelatedSearch::header() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.search.RelatedSearch.header)
  return _internal_header();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RelatedSearch::set_header(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.header_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.search.RelatedSearch.header)
}
inline std::string* RelatedSearch::mutable_header() {
  std::string* _s = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.search.RelatedSearch.header)
  return _s;
}
inline const std::string& RelatedSearch::_internal_header() const {
  return _impl_.header_.Get();
}
inline void RelatedSearch::_internal_set_header(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.header_.Set(value, GetArenaForAllocation());
}
inline std::string* RelatedSearch::_internal_mutable_header() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.header_.Mutable(GetArenaForAllocation());
}
inline std::string* RelatedSearch::release_header() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.search.RelatedSearch.header)
  if (!_internal_has_header()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.header_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.header_.IsDefault()) {
    _impl_.header_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RelatedSearch::set_allocated_header(std::string* header) {
  if (header != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.header_.SetAllocated(header, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.header_.IsDefault()) {
    _impl_.header_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.search.RelatedSearch.header)
}

// optional int32 backendId = 3;
inline bool RelatedSearch::_internal_has_backendid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RelatedSearch::has_backendid() const {
  return _internal_has_backendid();
}
inline void RelatedSearch::clear_backendid() {
  _impl_.backendid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t RelatedSearch::_internal_backendid() const {
  return _impl_.backendid_;
}
inline int32_t RelatedSearch::backendid() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.search.RelatedSearch.backendId)
  return _internal_backendid();
}
inline void RelatedSearch::_internal_set_backendid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.backendid_ = value;
}
inline void RelatedSearch::set_backendid(int32_t value) {
  _internal_set_backendid(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.search.RelatedSearch.backendId)
}

// optional int32 docType = 4;
inline bool RelatedSearch::_internal_has_doctype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RelatedSearch::has_doctype() const {
  return _internal_has_doctype();
}
inline void RelatedSearch::clear_doctype() {
  _impl_.doctype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t RelatedSearch::_internal_doctype() const {
  return _impl_.doctype_;
}
inline int32_t RelatedSearch::doctype() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.search.RelatedSearch.docType)
  return _internal_doctype();
}
inline void RelatedSearch::_internal_set_doctype(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.doctype_ = value;
}
inline void RelatedSearch::set_doctype(int32_t value) {
  _internal_set_doctype(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.search.RelatedSearch.docType)
}

// optional bool current = 5;
inline bool RelatedSearch::_internal_has_current() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool RelatedSearch::has_current() const {
  return _internal_has_current();
}
inline void RelatedSearch::clear_current() {
  _impl_.current_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool RelatedSearch::_internal_current() const {
  return _impl_.current_;
}
inline bool RelatedSearch::current() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.search.RelatedSearch.current)
  return _internal_current();
}
inline void RelatedSearch::_internal_set_current(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.current_ = value;
}
inline void RelatedSearch::set_current(bool value) {
  _internal_set_current(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.search.RelatedSearch.current)
}

// -------------------------------------------------------------------

// SearchSuggestResponse

// repeated .playapi.proto.finsky.search.Suggestion suggestion = 1;
inline int SearchSuggestResponse::_internal_suggestion_size() const {
  return _impl_.suggestion_.size();
}
inline int SearchSuggestResponse::suggestion_size() const {
  return _internal_suggestion_size();
}
inline void SearchSuggestResponse::clear_suggestion() {
  _impl_.suggestion_.Clear();
}
inline ::playapi::proto::finsky::search::Suggestion* SearchSuggestResponse::mutable_suggestion(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.search.SearchSuggestResponse.suggestion)
  return _impl_.suggestion_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::search::Suggestion >*
SearchSuggestResponse::mutable_suggestion() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.search.SearchSuggestResponse.suggestion)
  return &_impl_.suggestion_;
}
inline const ::playapi::proto::finsky::search::Suggestion& SearchSuggestResponse::_internal_suggestion(int index) const {
  return _impl_.suggestion_.Get(index);
}
inline const ::playapi::proto::finsky::search::Suggestion& SearchSuggestResponse::suggestion(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.search.SearchSuggestResponse.suggestion)
  return _internal_suggestion(index);
}
inline ::playapi::proto::finsky::search::Suggestion* SearchSuggestResponse::_internal_add_suggestion() {
  return _impl_.suggestion_.Add();
}
inline ::playapi::proto::finsky::search::Suggestion* SearchSuggestResponse::add_suggestion() {
  ::playapi::proto::finsky::search::Suggestion* _add = _internal_add_suggestion();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.search.SearchSuggestResponse.suggestion)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::search::Suggestion >&
SearchSuggestResponse::suggestion() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.search.SearchSuggestResponse.suggestion)
  return _impl_.suggestion_;
}

// optional bytes serverLogsCookie = 2;
inline bool SearchSuggestResponse::_internal_has_serverlogscookie() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SearchSuggestResponse::has_serverlogscookie() const {
  return _internal_has_serverlogscookie();
}
inline void SearchSuggestResponse::clear_serverlogscookie() {
  _impl_.serverlogscookie_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SearchSuggestResponse::serverlogscookie() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.search.SearchSuggestResponse.serverLogsCookie)
  return _internal_serverlogscookie();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SearchSuggestResponse::set_serverlogscookie(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.serverlogscookie_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.search.SearchSuggestResponse.serverLogsCookie)
}
inline std::string* SearchSuggestResponse::mutable_serverlogscookie() {
  std::string* _s = _internal_mutable_serverlogscookie();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.search.SearchSuggestResponse.serverLogsCookie)
  return _s;
}
inline const std::string& SearchSuggestResponse::_internal_serverlogscookie() const {
  return _impl_.serverlogscookie_.Get();
}
inline void SearchSuggestResponse::_internal_set_serverlogscookie(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.serverlogscookie_.Set(value, GetArenaForAllocation());
}
inline std::string* SearchSuggestResponse::_internal_mutable_serverlogscookie() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.serverlogscookie_.Mutable(GetArenaForAllocation());
}
inline std::string* SearchSuggestResponse::release_serverlogscookie() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.search.SearchSuggestResponse.serverLogsCookie)
  if (!_internal_has_serverlogscookie()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.serverlogscookie_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.serverlogscookie_.IsDefault()) {
    _impl_.serverlogscookie_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SearchSuggestResponse::set_allocated_serverlogscookie(std::string* serverlogscookie) {
  if (serverlogscookie != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.serverlogscookie_.SetAllocated(serverlogscookie, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.serverlogscookie_.IsDefault()) {
    _impl_.serverlogscookie_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.search.SearchSuggestResponse.serverLogsCookie)
}

// -------------------------------------------------------------------

// Suggestion

// optional int32 type = 1;
inline bool Suggestion::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Suggestion::has_type() const {
  return _internal_has_type();
}
inline void Suggestion::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline int32_t Suggestion::_internal_type() const {
  return _impl_.type_;
}
inline int32_t Suggestion::type() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.search.Suggestion.type)
  return _internal_type();
}
inline void Suggestion::_internal_set_type(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.type_ = value;
}
inline void Suggestion::set_type(int32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.search.Suggestion.type)
}

// optional string suggestedQuery = 2;
inline bool Suggestion::_internal_has_suggestedquery() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Suggestion::has_suggestedquery() const {
  return _internal_has_suggestedquery();
}
inline void Suggestion::clear_suggestedquery() {
  _impl_.suggestedquery_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Suggestion::suggestedquery() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.search.Suggestion.suggestedQuery)
  return _internal_suggestedquery();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Suggestion::set_suggestedquery(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.suggestedquery_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.search.Suggestion.suggestedQuery)
}
inline std::string* Suggestion::mutable_suggestedquery() {
  std::string* _s = _internal_mutable_suggestedquery();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.search.Suggestion.suggestedQuery)
  return _s;
}
inline const std::string& Suggestion::_internal_suggestedquery() const {
  return _impl_.suggestedquery_.Get();
}
inline void Suggestion::_internal_set_suggestedquery(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.suggestedquery_.Set(value, GetArenaForAllocation());
}
inline std::string* Suggestion::_internal_mutable_suggestedquery() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.suggestedquery_.Mutable(GetArenaForAllocation());
}
inline std::string* Suggestion::release_suggestedquery() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.search.Suggestion.suggestedQuery)
  if (!_internal_has_suggestedquery()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.suggestedquery_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.suggestedquery_.IsDefault()) {
    _impl_.suggestedquery_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Suggestion::set_allocated_suggestedquery(std::string* suggestedquery) {
  if (suggestedquery != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.suggestedquery_.SetAllocated(suggestedquery, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.suggestedquery_.IsDefault()) {
    _impl_.suggestedquery_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.search.Suggestion.suggestedQuery)
}

// optional .playapi.proto.finsky.search.NavSuggestion navSuggestion = 3;
inline bool Suggestion::_internal_has_navsuggestion() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.navsuggestion_ != nullptr);
  return value;
}
inline bool Suggestion::has_navsuggestion() const {
  return _internal_has_navsuggestion();
}
inline void Suggestion::clear_navsuggestion() {
  if (_impl_.navsuggestion_ != nullptr) _impl_.navsuggestion_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::playapi::proto::finsky::search::NavSuggestion& Suggestion::_internal_navsuggestion() const {
  const ::playapi::proto::finsky::search::NavSuggestion* p = _impl_.navsuggestion_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::search::NavSuggestion&>(
      ::playapi::proto::finsky::search::_NavSuggestion_default_instance_);
}
inline const ::playapi::proto::finsky::search::NavSuggestion& Suggestion::navsuggestion() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.search.Suggestion.navSuggestion)
  return _internal_navsuggestion();
}
inline void Suggestion::unsafe_arena_set_allocated_navsuggestion(
    ::playapi::proto::finsky::search::NavSuggestion* navsuggestion) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.navsuggestion_);
  }
  _impl_.navsuggestion_ = navsuggestion;
  if (navsuggestion) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.search.Suggestion.navSuggestion)
}
inline ::playapi::proto::finsky::search::NavSuggestion* Suggestion::release_navsuggestion() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::playapi::proto::finsky::search::NavSuggestion* temp = _impl_.navsuggestion_;
  _impl_.navsuggestion_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::search::NavSuggestion* Suggestion::unsafe_arena_release_navsuggestion() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.search.Suggestion.navSuggestion)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::playapi::proto::finsky::search::NavSuggestion* temp = _impl_.navsuggestion_;
  _impl_.navsuggestion_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::search::NavSuggestion* Suggestion::_internal_mutable_navsuggestion() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.navsuggestion_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::search::NavSuggestion>(GetArenaForAllocation());
    _impl_.navsuggestion_ = p;
  }
  return _impl_.navsuggestion_;
}
inline ::playapi::proto::finsky::search::NavSuggestion* Suggestion::mutable_navsuggestion() {
  ::playapi::proto::finsky::search::NavSuggestion* _msg = _internal_mutable_navsuggestion();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.search.Suggestion.navSuggestion)
  return _msg;
}
inline void Suggestion::set_allocated_navsuggestion(::playapi::proto::finsky::search::NavSuggestion* navsuggestion) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.navsuggestion_;
  }
  if (navsuggestion) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(navsuggestion);
    if (message_arena != submessage_arena) {
      navsuggestion = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, navsuggestion, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.navsuggestion_ = navsuggestion;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.search.Suggestion.navSuggestion)
}

// optional bytes serverLogsCookie = 4;
inline bool Suggestion::_internal_has_serverlogscookie() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Suggestion::has_serverlogscookie() const {
  return _internal_has_serverlogscookie();
}
inline void Suggestion::clear_serverlogscookie() {
  _impl_.serverlogscookie_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Suggestion::serverlogscookie() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.search.Suggestion.serverLogsCookie)
  return _internal_serverlogscookie();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Suggestion::set_serverlogscookie(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.serverlogscookie_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.search.Suggestion.serverLogsCookie)
}
inline std::string* Suggestion::mutable_serverlogscookie() {
  std::string* _s = _internal_mutable_serverlogscookie();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.search.Suggestion.serverLogsCookie)
  return _s;
}
inline const std::string& Suggestion::_internal_serverlogscookie() const {
  return _impl_.serverlogscookie_.Get();
}
inline void Suggestion::_internal_set_serverlogscookie(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.serverlogscookie_.Set(value, GetArenaForAllocation());
}
inline std::string* Suggestion::_internal_mutable_serverlogscookie() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.serverlogscookie_.Mutable(GetArenaForAllocation());
}
inline std::string* Suggestion::release_serverlogscookie() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.search.Suggestion.serverLogsCookie)
  if (!_internal_has_serverlogscookie()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.serverlogscookie_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.serverlogscookie_.IsDefault()) {
    _impl_.serverlogscookie_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Suggestion::set_allocated_serverlogscookie(std::string* serverlogscookie) {
  if (serverlogscookie != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.serverlogscookie_.SetAllocated(serverlogscookie, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.serverlogscookie_.IsDefault()) {
    _impl_.serverlogscookie_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.search.Suggestion.serverLogsCookie)
}

// optional .playapi.proto.finsky.Image image = 5;
inline bool Suggestion::_internal_has_image() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.image_ != nullptr);
  return value;
}
inline bool Suggestion::has_image() const {
  return _internal_has_image();
}
inline const ::playapi::proto::finsky::Image& Suggestion::_internal_image() const {
  const ::playapi::proto::finsky::Image* p = _impl_.image_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::Image&>(
      ::playapi::proto::finsky::_Image_default_instance_);
}
inline const ::playapi::proto::finsky::Image& Suggestion::image() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.search.Suggestion.image)
  return _internal_image();
}
inline void Suggestion::unsafe_arena_set_allocated_image(
    ::playapi::proto::finsky::Image* image) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.image_);
  }
  _impl_.image_ = image;
  if (image) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.search.Suggestion.image)
}
inline ::playapi::proto::finsky::Image* Suggestion::release_image() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::playapi::proto::finsky::Image* temp = _impl_.image_;
  _impl_.image_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::Image* Suggestion::unsafe_arena_release_image() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.search.Suggestion.image)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::playapi::proto::finsky::Image* temp = _impl_.image_;
  _impl_.image_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::Image* Suggestion::_internal_mutable_image() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.image_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::Image>(GetArenaForAllocation());
    _impl_.image_ = p;
  }
  return _impl_.image_;
}
inline ::playapi::proto::finsky::Image* Suggestion::mutable_image() {
  ::playapi::proto::finsky::Image* _msg = _internal_mutable_image();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.search.Suggestion.image)
  return _msg;
}
inline void Suggestion::set_allocated_image(::playapi::proto::finsky::Image* image) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.image_);
  }
  if (image) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(image));
    if (message_arena != submessage_arena) {
      image = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, image, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.image_ = image;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.search.Suggestion.image)
}

// optional string displayText = 6;
inline bool Suggestion::_internal_has_displaytext() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Suggestion::has_displaytext() const {
  return _internal_has_displaytext();
}
inline void Suggestion::clear_displaytext() {
  _impl_.displaytext_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Suggestion::displaytext() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.search.Suggestion.displayText)
  return _internal_displaytext();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Suggestion::set_displaytext(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.displaytext_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.search.Suggestion.displayText)
}
inline std::string* Suggestion::mutable_displaytext() {
  std::string* _s = _internal_mutable_displaytext();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.search.Suggestion.displayText)
  return _s;
}
inline const std::string& Suggestion::_internal_displaytext() const {
  return _impl_.displaytext_.Get();
}
inline void Suggestion::_internal_set_displaytext(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.displaytext_.Set(value, GetArenaForAllocation());
}
inline std::string* Suggestion::_internal_mutable_displaytext() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.displaytext_.Mutable(GetArenaForAllocation());
}
inline std::string* Suggestion::release_displaytext() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.search.Suggestion.displayText)
  if (!_internal_has_displaytext()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.displaytext_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.displaytext_.IsDefault()) {
    _impl_.displaytext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Suggestion::set_allocated_displaytext(std::string* displaytext) {
  if (displaytext != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.displaytext_.SetAllocated(displaytext, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.displaytext_.IsDefault()) {
    _impl_.displaytext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.search.Suggestion.displayText)
}

// optional .playapi.proto.finsky.link.Link link = 7;
inline bool Suggestion::_internal_has_link() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.link_ != nullptr);
  return value;
}
inline bool Suggestion::has_link() const {
  return _internal_has_link();
}
inline const ::playapi::proto::finsky::link::Link& Suggestion::_internal_link() const {
  const ::playapi::proto::finsky::link::Link* p = _impl_.link_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::link::Link&>(
      ::playapi::proto::finsky::link::_Link_default_instance_);
}
inline const ::playapi::proto::finsky::link::Link& Suggestion::link() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.search.Suggestion.link)
  return _internal_link();
}
inline void Suggestion::unsafe_arena_set_allocated_link(
    ::playapi::proto::finsky::link::Link* link) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.link_);
  }
  _impl_.link_ = link;
  if (link) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.search.Suggestion.link)
}
inline ::playapi::proto::finsky::link::Link* Suggestion::release_link() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::playapi::proto::finsky::link::Link* temp = _impl_.link_;
  _impl_.link_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::link::Link* Suggestion::unsafe_arena_release_link() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.search.Suggestion.link)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::playapi::proto::finsky::link::Link* temp = _impl_.link_;
  _impl_.link_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::link::Link* Suggestion::_internal_mutable_link() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.link_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::link::Link>(GetArenaForAllocation());
    _impl_.link_ = p;
  }
  return _impl_.link_;
}
inline ::playapi::proto::finsky::link::Link* Suggestion::mutable_link() {
  ::playapi::proto::finsky::link::Link* _msg = _internal_mutable_link();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.search.Suggestion.link)
  return _msg;
}
inline void Suggestion::set_allocated_link(::playapi::proto::finsky::link::Link* link) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.link_);
  }
  if (link) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(link));
    if (message_arena != submessage_arena) {
      link = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, link, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.link_ = link;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.search.Suggestion.link)
}

// optional .playapi.proto.finsky.document.DocV2 document = 8;
inline bool Suggestion::_internal_has_document() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.document_ != nullptr);
  return value;
}
inline bool Suggestion::has_document() const {
  return _internal_has_document();
}
inline const ::playapi::proto::finsky::document::DocV2& Suggestion::_internal_document() const {
  const ::playapi::proto::finsky::document::DocV2* p = _impl_.document_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::document::DocV2&>(
      ::playapi::proto::finsky::document::_DocV2_default_instance_);
}
inline const ::playapi::proto::finsky::document::DocV2& Suggestion::document() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.search.Suggestion.document)
  return _internal_document();
}
inline void Suggestion::unsafe_arena_set_allocated_document(
    ::playapi::proto::finsky::document::DocV2* document) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.document_);
  }
  _impl_.document_ = document;
  if (document) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.search.Suggestion.document)
}
inline ::playapi::proto::finsky::document::DocV2* Suggestion::release_document() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::playapi::proto::finsky::document::DocV2* temp = _impl_.document_;
  _impl_.document_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::document::DocV2* Suggestion::unsafe_arena_release_document() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.search.Suggestion.document)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::playapi::proto::finsky::document::DocV2* temp = _impl_.document_;
  _impl_.document_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::document::DocV2* Suggestion::_internal_mutable_document() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.document_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::document::DocV2>(GetArenaForAllocation());
    _impl_.document_ = p;
  }
  return _impl_.document_;
}
inline ::playapi::proto::finsky::document::DocV2* Suggestion::mutable_document() {
  ::playapi::proto::finsky::document::DocV2* _msg = _internal_mutable_document();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.search.Suggestion.document)
  return _msg;
}
inline void Suggestion::set_allocated_document(::playapi::proto::finsky::document::DocV2* document) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.document_);
  }
  if (document) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(document));
    if (message_arena != submessage_arena) {
      document = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, document, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.document_ = document;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.search.Suggestion.document)
}

// optional int32 searchBackend = 9;
inline bool Suggestion::_internal_has_searchbackend() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Suggestion::has_searchbackend() const {
  return _internal_has_searchbackend();
}
inline void Suggestion::clear_searchbackend() {
  _impl_.searchbackend_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline int32_t Suggestion::_internal_searchbackend() const {
  return _impl_.searchbackend_;
}
inline int32_t Suggestion::searchbackend() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.search.Suggestion.searchBackend)
  return _internal_searchbackend();
}
inline void Suggestion::_internal_set_searchbackend(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.searchbackend_ = value;
}
inline void Suggestion::set_searchbackend(int32_t value) {
  _internal_set_searchbackend(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.search.Suggestion.searchBackend)
}

// -------------------------------------------------------------------

// NavSuggestion

// optional string docId = 1;
inline bool NavSuggestion::_internal_has_docid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NavSuggestion::has_docid() const {
  return _internal_has_docid();
}
inline void NavSuggestion::clear_docid() {
  _impl_.docid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NavSuggestion::docid() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.search.NavSuggestion.docId)
  return _internal_docid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NavSuggestion::set_docid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.docid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.search.NavSuggestion.docId)
}
inline std::string* NavSuggestion::mutable_docid() {
  std::string* _s = _internal_mutable_docid();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.search.NavSuggestion.docId)
  return _s;
}
inline const std::string& NavSuggestion::_internal_docid() const {
  return _impl_.docid_.Get();
}
inline void NavSuggestion::_internal_set_docid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.docid_.Set(value, GetArenaForAllocation());
}
inline std::string* NavSuggestion::_internal_mutable_docid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.docid_.Mutable(GetArenaForAllocation());
}
inline std::string* NavSuggestion::release_docid() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.search.NavSuggestion.docId)
  if (!_internal_has_docid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.docid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.docid_.IsDefault()) {
    _impl_.docid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NavSuggestion::set_allocated_docid(std::string* docid) {
  if (docid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.docid_.SetAllocated(docid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.docid_.IsDefault()) {
    _impl_.docid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.search.NavSuggestion.docId)
}

// optional bytes imageBlob = 2;
inline bool NavSuggestion::_internal_has_imageblob() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool NavSuggestion::has_imageblob() const {
  return _internal_has_imageblob();
}
inline void NavSuggestion::clear_imageblob() {
  _impl_.imageblob_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& NavSuggestion::imageblob() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.search.NavSuggestion.imageBlob)
  return _internal_imageblob();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NavSuggestion::set_imageblob(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.imageblob_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.search.NavSuggestion.imageBlob)
}
inline std::string* NavSuggestion::mutable_imageblob() {
  std::string* _s = _internal_mutable_imageblob();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.search.NavSuggestion.imageBlob)
  return _s;
}
inline const std::string& NavSuggestion::_internal_imageblob() const {
  return _impl_.imageblob_.Get();
}
inline void NavSuggestion::_internal_set_imageblob(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.imageblob_.Set(value, GetArenaForAllocation());
}
inline std::string* NavSuggestion::_internal_mutable_imageblob() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.imageblob_.Mutable(GetArenaForAllocation());
}
inline std::string* NavSuggestion::release_imageblob() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.search.NavSuggestion.imageBlob)
  if (!_internal_has_imageblob()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.imageblob_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.imageblob_.IsDefault()) {
    _impl_.imageblob_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NavSuggestion::set_allocated_imageblob(std::string* imageblob) {
  if (imageblob != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.imageblob_.SetAllocated(imageblob, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.imageblob_.IsDefault()) {
    _impl_.imageblob_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.search.NavSuggestion.imageBlob)
}

// optional .playapi.proto.finsky.Image image = 3;
inline bool NavSuggestion::_internal_has_image() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.image_ != nullptr);
  return value;
}
inline bool NavSuggestion::has_image() const {
  return _internal_has_image();
}
inline const ::playapi::proto::finsky::Image& NavSuggestion::_internal_image() const {
  const ::playapi::proto::finsky::Image* p = _impl_.image_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::Image&>(
      ::playapi::proto::finsky::_Image_default_instance_);
}
inline const ::playapi::proto::finsky::Image& NavSuggestion::image() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.search.NavSuggestion.image)
  return _internal_image();
}
inline void NavSuggestion::unsafe_arena_set_allocated_image(
    ::playapi::proto::finsky::Image* image) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.image_);
  }
  _impl_.image_ = image;
  if (image) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.search.NavSuggestion.image)
}
inline ::playapi::proto::finsky::Image* NavSuggestion::release_image() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::playapi::proto::finsky::Image* temp = _impl_.image_;
  _impl_.image_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::Image* NavSuggestion::unsafe_arena_release_image() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.search.NavSuggestion.image)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::playapi::proto::finsky::Image* temp = _impl_.image_;
  _impl_.image_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::Image* NavSuggestion::_internal_mutable_image() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.image_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::Image>(GetArenaForAllocation());
    _impl_.image_ = p;
  }
  return _impl_.image_;
}
inline ::playapi::proto::finsky::Image* NavSuggestion::mutable_image() {
  ::playapi::proto::finsky::Image* _msg = _internal_mutable_image();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.search.NavSuggestion.image)
  return _msg;
}
inline void NavSuggestion::set_allocated_image(::playapi::proto::finsky::Image* image) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.image_);
  }
  if (image) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(image));
    if (message_arena != submessage_arena) {
      image = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, image, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.image_ = image;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.search.NavSuggestion.image)
}

// optional string description = 4;
inline bool NavSuggestion::_internal_has_description() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool NavSuggestion::has_description() const {
  return _internal_has_description();
}
inline void NavSuggestion::clear_description() {
  _impl_.description_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& NavSuggestion::description() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.search.NavSuggestion.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NavSuggestion::set_description(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.search.NavSuggestion.description)
}
inline std::string* NavSuggestion::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.search.NavSuggestion.description)
  return _s;
}
inline const std::string& NavSuggestion::_internal_description() const {
  return _impl_.description_.Get();
}
inline void NavSuggestion::_internal_set_description(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* NavSuggestion::_internal_mutable_description() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* NavSuggestion::release_description() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.search.NavSuggestion.description)
  if (!_internal_has_description()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.description_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NavSuggestion::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.search.NavSuggestion.description)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace search
}  // namespace finsky
}  // namespace proto
}  // namespace playapi

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_play_5fsearch_2eproto
