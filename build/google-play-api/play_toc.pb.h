// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: play_toc.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_play_5ftoc_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_play_5ftoc_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "play_settings.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_play_5ftoc_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_play_5ftoc_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_play_5ftoc_2eproto;
namespace playapi {
namespace proto {
namespace finsky {
namespace toc {
class BillingConfig;
struct BillingConfigDefaultTypeInternal;
extern BillingConfigDefaultTypeInternal _BillingConfig_default_instance_;
class CarrierBillingConfig;
struct CarrierBillingConfigDefaultTypeInternal;
extern CarrierBillingConfigDefaultTypeInternal _CarrierBillingConfig_default_instance_;
class CorpusMetadata;
struct CorpusMetadataDefaultTypeInternal;
extern CorpusMetadataDefaultTypeInternal _CorpusMetadata_default_instance_;
class Experiments;
struct ExperimentsDefaultTypeInternal;
extern ExperimentsDefaultTypeInternal _Experiments_default_instance_;
class SelfUpdateConfig;
struct SelfUpdateConfigDefaultTypeInternal;
extern SelfUpdateConfigDefaultTypeInternal _SelfUpdateConfig_default_instance_;
class TocResponse;
struct TocResponseDefaultTypeInternal;
extern TocResponseDefaultTypeInternal _TocResponse_default_instance_;
}  // namespace toc
}  // namespace finsky
}  // namespace proto
}  // namespace playapi
PROTOBUF_NAMESPACE_OPEN
template<> ::playapi::proto::finsky::toc::BillingConfig* Arena::CreateMaybeMessage<::playapi::proto::finsky::toc::BillingConfig>(Arena*);
template<> ::playapi::proto::finsky::toc::CarrierBillingConfig* Arena::CreateMaybeMessage<::playapi::proto::finsky::toc::CarrierBillingConfig>(Arena*);
template<> ::playapi::proto::finsky::toc::CorpusMetadata* Arena::CreateMaybeMessage<::playapi::proto::finsky::toc::CorpusMetadata>(Arena*);
template<> ::playapi::proto::finsky::toc::Experiments* Arena::CreateMaybeMessage<::playapi::proto::finsky::toc::Experiments>(Arena*);
template<> ::playapi::proto::finsky::toc::SelfUpdateConfig* Arena::CreateMaybeMessage<::playapi::proto::finsky::toc::SelfUpdateConfig>(Arena*);
template<> ::playapi::proto::finsky::toc::TocResponse* Arena::CreateMaybeMessage<::playapi::proto::finsky::toc::TocResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace playapi {
namespace proto {
namespace finsky {
namespace toc {

// ===================================================================

class CarrierBillingConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.toc.CarrierBillingConfig) */ {
 public:
  inline CarrierBillingConfig() : CarrierBillingConfig(nullptr) {}
  ~CarrierBillingConfig() override;
  explicit PROTOBUF_CONSTEXPR CarrierBillingConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CarrierBillingConfig(const CarrierBillingConfig& from);
  CarrierBillingConfig(CarrierBillingConfig&& from) noexcept
    : CarrierBillingConfig() {
    *this = ::std::move(from);
  }

  inline CarrierBillingConfig& operator=(const CarrierBillingConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline CarrierBillingConfig& operator=(CarrierBillingConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CarrierBillingConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const CarrierBillingConfig* internal_default_instance() {
    return reinterpret_cast<const CarrierBillingConfig*>(
               &_CarrierBillingConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CarrierBillingConfig& a, CarrierBillingConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(CarrierBillingConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CarrierBillingConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CarrierBillingConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CarrierBillingConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CarrierBillingConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CarrierBillingConfig& from) {
    CarrierBillingConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CarrierBillingConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.toc.CarrierBillingConfig";
  }
  protected:
  explicit CarrierBillingConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kProvisioningUrlFieldNumber = 4,
    kCredentialsUrlFieldNumber = 5,
    kApiVersionFieldNumber = 3,
    kTosRequiredFieldNumber = 6,
    kPerTransactionCredentialsRequiredFieldNumber = 7,
    kSendSubscriberIdWithCarrierBillingRequestsFieldNumber = 8,
  };
  // optional string id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // optional string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string provisioningUrl = 4;
  bool has_provisioningurl() const;
  private:
  bool _internal_has_provisioningurl() const;
  public:
  void clear_provisioningurl();
  const std::string& provisioningurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_provisioningurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_provisioningurl();
  PROTOBUF_NODISCARD std::string* release_provisioningurl();
  void set_allocated_provisioningurl(std::string* provisioningurl);
  private:
  const std::string& _internal_provisioningurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_provisioningurl(const std::string& value);
  std::string* _internal_mutable_provisioningurl();
  public:

  // optional string credentialsUrl = 5;
  bool has_credentialsurl() const;
  private:
  bool _internal_has_credentialsurl() const;
  public:
  void clear_credentialsurl();
  const std::string& credentialsurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_credentialsurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_credentialsurl();
  PROTOBUF_NODISCARD std::string* release_credentialsurl();
  void set_allocated_credentialsurl(std::string* credentialsurl);
  private:
  const std::string& _internal_credentialsurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_credentialsurl(const std::string& value);
  std::string* _internal_mutable_credentialsurl();
  public:

  // optional int32 apiVersion = 3;
  bool has_apiversion() const;
  private:
  bool _internal_has_apiversion() const;
  public:
  void clear_apiversion();
  int32_t apiversion() const;
  void set_apiversion(int32_t value);
  private:
  int32_t _internal_apiversion() const;
  void _internal_set_apiversion(int32_t value);
  public:

  // optional bool tosRequired = 6;
  bool has_tosrequired() const;
  private:
  bool _internal_has_tosrequired() const;
  public:
  void clear_tosrequired();
  bool tosrequired() const;
  void set_tosrequired(bool value);
  private:
  bool _internal_tosrequired() const;
  void _internal_set_tosrequired(bool value);
  public:

  // optional bool perTransactionCredentialsRequired = 7;
  bool has_pertransactioncredentialsrequired() const;
  private:
  bool _internal_has_pertransactioncredentialsrequired() const;
  public:
  void clear_pertransactioncredentialsrequired();
  bool pertransactioncredentialsrequired() const;
  void set_pertransactioncredentialsrequired(bool value);
  private:
  bool _internal_pertransactioncredentialsrequired() const;
  void _internal_set_pertransactioncredentialsrequired(bool value);
  public:

  // optional bool sendSubscriberIdWithCarrierBillingRequests = 8;
  bool has_sendsubscriberidwithcarrierbillingrequests() const;
  private:
  bool _internal_has_sendsubscriberidwithcarrierbillingrequests() const;
  public:
  void clear_sendsubscriberidwithcarrierbillingrequests();
  bool sendsubscriberidwithcarrierbillingrequests() const;
  void set_sendsubscriberidwithcarrierbillingrequests(bool value);
  private:
  bool _internal_sendsubscriberidwithcarrierbillingrequests() const;
  void _internal_set_sendsubscriberidwithcarrierbillingrequests(bool value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.toc.CarrierBillingConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr provisioningurl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr credentialsurl_;
    int32_t apiversion_;
    bool tosrequired_;
    bool pertransactioncredentialsrequired_;
    bool sendsubscriberidwithcarrierbillingrequests_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5ftoc_2eproto;
};
// -------------------------------------------------------------------

class BillingConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.toc.BillingConfig) */ {
 public:
  inline BillingConfig() : BillingConfig(nullptr) {}
  ~BillingConfig() override;
  explicit PROTOBUF_CONSTEXPR BillingConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BillingConfig(const BillingConfig& from);
  BillingConfig(BillingConfig&& from) noexcept
    : BillingConfig() {
    *this = ::std::move(from);
  }

  inline BillingConfig& operator=(const BillingConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline BillingConfig& operator=(BillingConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BillingConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const BillingConfig* internal_default_instance() {
    return reinterpret_cast<const BillingConfig*>(
               &_BillingConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(BillingConfig& a, BillingConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(BillingConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BillingConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BillingConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BillingConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BillingConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BillingConfig& from) {
    BillingConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BillingConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.toc.BillingConfig";
  }
  protected:
  explicit BillingConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCarrierBillingConfigFieldNumber = 1,
    kMaxIabApiVersionFieldNumber = 2,
  };
  // optional .playapi.proto.finsky.toc.CarrierBillingConfig carrierBillingConfig = 1;
  bool has_carrierbillingconfig() const;
  private:
  bool _internal_has_carrierbillingconfig() const;
  public:
  void clear_carrierbillingconfig();
  const ::playapi::proto::finsky::toc::CarrierBillingConfig& carrierbillingconfig() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::toc::CarrierBillingConfig* release_carrierbillingconfig();
  ::playapi::proto::finsky::toc::CarrierBillingConfig* mutable_carrierbillingconfig();
  void set_allocated_carrierbillingconfig(::playapi::proto::finsky::toc::CarrierBillingConfig* carrierbillingconfig);
  private:
  const ::playapi::proto::finsky::toc::CarrierBillingConfig& _internal_carrierbillingconfig() const;
  ::playapi::proto::finsky::toc::CarrierBillingConfig* _internal_mutable_carrierbillingconfig();
  public:
  void unsafe_arena_set_allocated_carrierbillingconfig(
      ::playapi::proto::finsky::toc::CarrierBillingConfig* carrierbillingconfig);
  ::playapi::proto::finsky::toc::CarrierBillingConfig* unsafe_arena_release_carrierbillingconfig();

  // optional int32 maxIabApiVersion = 2;
  bool has_maxiabapiversion() const;
  private:
  bool _internal_has_maxiabapiversion() const;
  public:
  void clear_maxiabapiversion();
  int32_t maxiabapiversion() const;
  void set_maxiabapiversion(int32_t value);
  private:
  int32_t _internal_maxiabapiversion() const;
  void _internal_set_maxiabapiversion(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.toc.BillingConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::playapi::proto::finsky::toc::CarrierBillingConfig* carrierbillingconfig_;
    int32_t maxiabapiversion_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5ftoc_2eproto;
};
// -------------------------------------------------------------------

class CorpusMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.toc.CorpusMetadata) */ {
 public:
  inline CorpusMetadata() : CorpusMetadata(nullptr) {}
  ~CorpusMetadata() override;
  explicit PROTOBUF_CONSTEXPR CorpusMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CorpusMetadata(const CorpusMetadata& from);
  CorpusMetadata(CorpusMetadata&& from) noexcept
    : CorpusMetadata() {
    *this = ::std::move(from);
  }

  inline CorpusMetadata& operator=(const CorpusMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline CorpusMetadata& operator=(CorpusMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CorpusMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const CorpusMetadata* internal_default_instance() {
    return reinterpret_cast<const CorpusMetadata*>(
               &_CorpusMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CorpusMetadata& a, CorpusMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(CorpusMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CorpusMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CorpusMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CorpusMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CorpusMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CorpusMetadata& from) {
    CorpusMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CorpusMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.toc.CorpusMetadata";
  }
  protected:
  explicit CorpusMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kLandingUrlFieldNumber = 3,
    kLibraryNameFieldNumber = 4,
    kRecsWidgetUrlFieldNumber = 6,
    kShopNameFieldNumber = 7,
    kBackendFieldNumber = 1,
  };
  // optional string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string landingUrl = 3;
  bool has_landingurl() const;
  private:
  bool _internal_has_landingurl() const;
  public:
  void clear_landingurl();
  const std::string& landingurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_landingurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_landingurl();
  PROTOBUF_NODISCARD std::string* release_landingurl();
  void set_allocated_landingurl(std::string* landingurl);
  private:
  const std::string& _internal_landingurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_landingurl(const std::string& value);
  std::string* _internal_mutable_landingurl();
  public:

  // optional string libraryName = 4;
  bool has_libraryname() const;
  private:
  bool _internal_has_libraryname() const;
  public:
  void clear_libraryname();
  const std::string& libraryname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_libraryname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_libraryname();
  PROTOBUF_NODISCARD std::string* release_libraryname();
  void set_allocated_libraryname(std::string* libraryname);
  private:
  const std::string& _internal_libraryname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_libraryname(const std::string& value);
  std::string* _internal_mutable_libraryname();
  public:

  // optional string recsWidgetUrl = 6;
  bool has_recswidgeturl() const;
  private:
  bool _internal_has_recswidgeturl() const;
  public:
  void clear_recswidgeturl();
  const std::string& recswidgeturl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_recswidgeturl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_recswidgeturl();
  PROTOBUF_NODISCARD std::string* release_recswidgeturl();
  void set_allocated_recswidgeturl(std::string* recswidgeturl);
  private:
  const std::string& _internal_recswidgeturl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recswidgeturl(const std::string& value);
  std::string* _internal_mutable_recswidgeturl();
  public:

  // optional string shopName = 7;
  bool has_shopname() const;
  private:
  bool _internal_has_shopname() const;
  public:
  void clear_shopname();
  const std::string& shopname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_shopname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_shopname();
  PROTOBUF_NODISCARD std::string* release_shopname();
  void set_allocated_shopname(std::string* shopname);
  private:
  const std::string& _internal_shopname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_shopname(const std::string& value);
  std::string* _internal_mutable_shopname();
  public:

  // optional int32 backend = 1;
  bool has_backend() const;
  private:
  bool _internal_has_backend() const;
  public:
  void clear_backend();
  int32_t backend() const;
  void set_backend(int32_t value);
  private:
  int32_t _internal_backend() const;
  void _internal_set_backend(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.toc.CorpusMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr landingurl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr libraryname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr recswidgeturl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr shopname_;
    int32_t backend_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5ftoc_2eproto;
};
// -------------------------------------------------------------------

class Experiments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.toc.Experiments) */ {
 public:
  inline Experiments() : Experiments(nullptr) {}
  ~Experiments() override;
  explicit PROTOBUF_CONSTEXPR Experiments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Experiments(const Experiments& from);
  Experiments(Experiments&& from) noexcept
    : Experiments() {
    *this = ::std::move(from);
  }

  inline Experiments& operator=(const Experiments& from) {
    CopyFrom(from);
    return *this;
  }
  inline Experiments& operator=(Experiments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Experiments& default_instance() {
    return *internal_default_instance();
  }
  static inline const Experiments* internal_default_instance() {
    return reinterpret_cast<const Experiments*>(
               &_Experiments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Experiments& a, Experiments& b) {
    a.Swap(&b);
  }
  inline void Swap(Experiments* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Experiments* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Experiments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Experiments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Experiments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Experiments& from) {
    Experiments::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Experiments* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.toc.Experiments";
  }
  protected:
  explicit Experiments(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExperimentIdFieldNumber = 1,
  };
  // repeated string experimentId = 1;
  int experimentid_size() const;
  private:
  int _internal_experimentid_size() const;
  public:
  void clear_experimentid();
  const std::string& experimentid(int index) const;
  std::string* mutable_experimentid(int index);
  void set_experimentid(int index, const std::string& value);
  void set_experimentid(int index, std::string&& value);
  void set_experimentid(int index, const char* value);
  void set_experimentid(int index, const char* value, size_t size);
  std::string* add_experimentid();
  void add_experimentid(const std::string& value);
  void add_experimentid(std::string&& value);
  void add_experimentid(const char* value);
  void add_experimentid(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& experimentid() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_experimentid();
  private:
  const std::string& _internal_experimentid(int index) const;
  std::string* _internal_add_experimentid();
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.toc.Experiments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> experimentid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5ftoc_2eproto;
};
// -------------------------------------------------------------------

class SelfUpdateConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.toc.SelfUpdateConfig) */ {
 public:
  inline SelfUpdateConfig() : SelfUpdateConfig(nullptr) {}
  ~SelfUpdateConfig() override;
  explicit PROTOBUF_CONSTEXPR SelfUpdateConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SelfUpdateConfig(const SelfUpdateConfig& from);
  SelfUpdateConfig(SelfUpdateConfig&& from) noexcept
    : SelfUpdateConfig() {
    *this = ::std::move(from);
  }

  inline SelfUpdateConfig& operator=(const SelfUpdateConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelfUpdateConfig& operator=(SelfUpdateConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SelfUpdateConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const SelfUpdateConfig* internal_default_instance() {
    return reinterpret_cast<const SelfUpdateConfig*>(
               &_SelfUpdateConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SelfUpdateConfig& a, SelfUpdateConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(SelfUpdateConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelfUpdateConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SelfUpdateConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SelfUpdateConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SelfUpdateConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SelfUpdateConfig& from) {
    SelfUpdateConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SelfUpdateConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.toc.SelfUpdateConfig";
  }
  protected:
  explicit SelfUpdateConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLatestClientVersionCodeFieldNumber = 1,
  };
  // optional int32 latestClientVersionCode = 1;
  bool has_latestclientversioncode() const;
  private:
  bool _internal_has_latestclientversioncode() const;
  public:
  void clear_latestclientversioncode();
  int32_t latestclientversioncode() const;
  void set_latestclientversioncode(int32_t value);
  private:
  int32_t _internal_latestclientversioncode() const;
  void _internal_set_latestclientversioncode(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.toc.SelfUpdateConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t latestclientversioncode_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5ftoc_2eproto;
};
// -------------------------------------------------------------------

class TocResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.toc.TocResponse) */ {
 public:
  inline TocResponse() : TocResponse(nullptr) {}
  ~TocResponse() override;
  explicit PROTOBUF_CONSTEXPR TocResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TocResponse(const TocResponse& from);
  TocResponse(TocResponse&& from) noexcept
    : TocResponse() {
    *this = ::std::move(from);
  }

  inline TocResponse& operator=(const TocResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TocResponse& operator=(TocResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TocResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TocResponse* internal_default_instance() {
    return reinterpret_cast<const TocResponse*>(
               &_TocResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TocResponse& a, TocResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TocResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TocResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TocResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TocResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TocResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TocResponse& from) {
    TocResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TocResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.toc.TocResponse";
  }
  protected:
  explicit TocResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCorpusFieldNumber = 1,
    kTosContentFieldNumber = 3,
    kHomeUrlFieldNumber = 4,
    kTosCheckboxTextMarketingEmailsFieldNumber = 6,
    kTosTokenFieldNumber = 7,
    kIconOverrideUrlFieldNumber = 9,
    kRecsWidgetUrlFieldNumber = 13,
    kSocialHomeUrlFieldNumber = 15,
    kHelpUrlFieldNumber = 19,
    kEntertainmentHomeUrlFieldNumber = 21,
    kCookieFieldNumber = 22,
    kExperimentsFieldNumber = 5,
    kUserSettingsFieldNumber = 8,
    kSelfUpdateConfigFieldNumber = 10,
    kBillingConfigFieldNumber = 12,
    kTosVersionDeprecatedFieldNumber = 2,
    kRequiresUploadDeviceConfigFieldNumber = 11,
    kAgeVerificationRequiredFieldNumber = 16,
    kGplusSignupEnabledFieldNumber = 17,
    kRedeemEnabledFieldNumber = 18,
    kThemeIdFieldNumber = 20,
  };
  // repeated .playapi.proto.finsky.toc.CorpusMetadata corpus = 1;
  int corpus_size() const;
  private:
  int _internal_corpus_size() const;
  public:
  void clear_corpus();
  ::playapi::proto::finsky::toc::CorpusMetadata* mutable_corpus(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::toc::CorpusMetadata >*
      mutable_corpus();
  private:
  const ::playapi::proto::finsky::toc::CorpusMetadata& _internal_corpus(int index) const;
  ::playapi::proto::finsky::toc::CorpusMetadata* _internal_add_corpus();
  public:
  const ::playapi::proto::finsky::toc::CorpusMetadata& corpus(int index) const;
  ::playapi::proto::finsky::toc::CorpusMetadata* add_corpus();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::toc::CorpusMetadata >&
      corpus() const;

  // optional string tosContent = 3;
  bool has_toscontent() const;
  private:
  bool _internal_has_toscontent() const;
  public:
  void clear_toscontent();
  const std::string& toscontent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_toscontent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_toscontent();
  PROTOBUF_NODISCARD std::string* release_toscontent();
  void set_allocated_toscontent(std::string* toscontent);
  private:
  const std::string& _internal_toscontent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_toscontent(const std::string& value);
  std::string* _internal_mutable_toscontent();
  public:

  // optional string homeUrl = 4;
  bool has_homeurl() const;
  private:
  bool _internal_has_homeurl() const;
  public:
  void clear_homeurl();
  const std::string& homeurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_homeurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_homeurl();
  PROTOBUF_NODISCARD std::string* release_homeurl();
  void set_allocated_homeurl(std::string* homeurl);
  private:
  const std::string& _internal_homeurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_homeurl(const std::string& value);
  std::string* _internal_mutable_homeurl();
  public:

  // optional string tosCheckboxTextMarketingEmails = 6;
  bool has_toscheckboxtextmarketingemails() const;
  private:
  bool _internal_has_toscheckboxtextmarketingemails() const;
  public:
  void clear_toscheckboxtextmarketingemails();
  const std::string& toscheckboxtextmarketingemails() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_toscheckboxtextmarketingemails(ArgT0&& arg0, ArgT... args);
  std::string* mutable_toscheckboxtextmarketingemails();
  PROTOBUF_NODISCARD std::string* release_toscheckboxtextmarketingemails();
  void set_allocated_toscheckboxtextmarketingemails(std::string* toscheckboxtextmarketingemails);
  private:
  const std::string& _internal_toscheckboxtextmarketingemails() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_toscheckboxtextmarketingemails(const std::string& value);
  std::string* _internal_mutable_toscheckboxtextmarketingemails();
  public:

  // optional string tosToken = 7;
  bool has_tostoken() const;
  private:
  bool _internal_has_tostoken() const;
  public:
  void clear_tostoken();
  const std::string& tostoken() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tostoken(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tostoken();
  PROTOBUF_NODISCARD std::string* release_tostoken();
  void set_allocated_tostoken(std::string* tostoken);
  private:
  const std::string& _internal_tostoken() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tostoken(const std::string& value);
  std::string* _internal_mutable_tostoken();
  public:

  // optional string iconOverrideUrl = 9;
  bool has_iconoverrideurl() const;
  private:
  bool _internal_has_iconoverrideurl() const;
  public:
  void clear_iconoverrideurl();
  const std::string& iconoverrideurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_iconoverrideurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_iconoverrideurl();
  PROTOBUF_NODISCARD std::string* release_iconoverrideurl();
  void set_allocated_iconoverrideurl(std::string* iconoverrideurl);
  private:
  const std::string& _internal_iconoverrideurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_iconoverrideurl(const std::string& value);
  std::string* _internal_mutable_iconoverrideurl();
  public:

  // optional string recsWidgetUrl = 13;
  bool has_recswidgeturl() const;
  private:
  bool _internal_has_recswidgeturl() const;
  public:
  void clear_recswidgeturl();
  const std::string& recswidgeturl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_recswidgeturl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_recswidgeturl();
  PROTOBUF_NODISCARD std::string* release_recswidgeturl();
  void set_allocated_recswidgeturl(std::string* recswidgeturl);
  private:
  const std::string& _internal_recswidgeturl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recswidgeturl(const std::string& value);
  std::string* _internal_mutable_recswidgeturl();
  public:

  // optional string socialHomeUrl = 15;
  bool has_socialhomeurl() const;
  private:
  bool _internal_has_socialhomeurl() const;
  public:
  void clear_socialhomeurl();
  const std::string& socialhomeurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_socialhomeurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_socialhomeurl();
  PROTOBUF_NODISCARD std::string* release_socialhomeurl();
  void set_allocated_socialhomeurl(std::string* socialhomeurl);
  private:
  const std::string& _internal_socialhomeurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_socialhomeurl(const std::string& value);
  std::string* _internal_mutable_socialhomeurl();
  public:

  // optional string helpUrl = 19;
  bool has_helpurl() const;
  private:
  bool _internal_has_helpurl() const;
  public:
  void clear_helpurl();
  const std::string& helpurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_helpurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_helpurl();
  PROTOBUF_NODISCARD std::string* release_helpurl();
  void set_allocated_helpurl(std::string* helpurl);
  private:
  const std::string& _internal_helpurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_helpurl(const std::string& value);
  std::string* _internal_mutable_helpurl();
  public:

  // optional string entertainmentHomeUrl = 21;
  bool has_entertainmenthomeurl() const;
  private:
  bool _internal_has_entertainmenthomeurl() const;
  public:
  void clear_entertainmenthomeurl();
  const std::string& entertainmenthomeurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_entertainmenthomeurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_entertainmenthomeurl();
  PROTOBUF_NODISCARD std::string* release_entertainmenthomeurl();
  void set_allocated_entertainmenthomeurl(std::string* entertainmenthomeurl);
  private:
  const std::string& _internal_entertainmenthomeurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_entertainmenthomeurl(const std::string& value);
  std::string* _internal_mutable_entertainmenthomeurl();
  public:

  // optional string cookie = 22;
  bool has_cookie() const;
  private:
  bool _internal_has_cookie() const;
  public:
  void clear_cookie();
  const std::string& cookie() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cookie(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cookie();
  PROTOBUF_NODISCARD std::string* release_cookie();
  void set_allocated_cookie(std::string* cookie);
  private:
  const std::string& _internal_cookie() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cookie(const std::string& value);
  std::string* _internal_mutable_cookie();
  public:

  // optional .playapi.proto.finsky.toc.Experiments experiments = 5;
  bool has_experiments() const;
  private:
  bool _internal_has_experiments() const;
  public:
  void clear_experiments();
  const ::playapi::proto::finsky::toc::Experiments& experiments() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::toc::Experiments* release_experiments();
  ::playapi::proto::finsky::toc::Experiments* mutable_experiments();
  void set_allocated_experiments(::playapi::proto::finsky::toc::Experiments* experiments);
  private:
  const ::playapi::proto::finsky::toc::Experiments& _internal_experiments() const;
  ::playapi::proto::finsky::toc::Experiments* _internal_mutable_experiments();
  public:
  void unsafe_arena_set_allocated_experiments(
      ::playapi::proto::finsky::toc::Experiments* experiments);
  ::playapi::proto::finsky::toc::Experiments* unsafe_arena_release_experiments();

  // optional .playapi.proto.finsky.settings.OBSOLETEUserSettings userSettings = 8;
  bool has_usersettings() const;
  private:
  bool _internal_has_usersettings() const;
  public:
  void clear_usersettings();
  const ::playapi::proto::finsky::settings::OBSOLETEUserSettings& usersettings() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::settings::OBSOLETEUserSettings* release_usersettings();
  ::playapi::proto::finsky::settings::OBSOLETEUserSettings* mutable_usersettings();
  void set_allocated_usersettings(::playapi::proto::finsky::settings::OBSOLETEUserSettings* usersettings);
  private:
  const ::playapi::proto::finsky::settings::OBSOLETEUserSettings& _internal_usersettings() const;
  ::playapi::proto::finsky::settings::OBSOLETEUserSettings* _internal_mutable_usersettings();
  public:
  void unsafe_arena_set_allocated_usersettings(
      ::playapi::proto::finsky::settings::OBSOLETEUserSettings* usersettings);
  ::playapi::proto::finsky::settings::OBSOLETEUserSettings* unsafe_arena_release_usersettings();

  // optional .playapi.proto.finsky.toc.SelfUpdateConfig selfUpdateConfig = 10;
  bool has_selfupdateconfig() const;
  private:
  bool _internal_has_selfupdateconfig() const;
  public:
  void clear_selfupdateconfig();
  const ::playapi::proto::finsky::toc::SelfUpdateConfig& selfupdateconfig() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::toc::SelfUpdateConfig* release_selfupdateconfig();
  ::playapi::proto::finsky::toc::SelfUpdateConfig* mutable_selfupdateconfig();
  void set_allocated_selfupdateconfig(::playapi::proto::finsky::toc::SelfUpdateConfig* selfupdateconfig);
  private:
  const ::playapi::proto::finsky::toc::SelfUpdateConfig& _internal_selfupdateconfig() const;
  ::playapi::proto::finsky::toc::SelfUpdateConfig* _internal_mutable_selfupdateconfig();
  public:
  void unsafe_arena_set_allocated_selfupdateconfig(
      ::playapi::proto::finsky::toc::SelfUpdateConfig* selfupdateconfig);
  ::playapi::proto::finsky::toc::SelfUpdateConfig* unsafe_arena_release_selfupdateconfig();

  // optional .playapi.proto.finsky.toc.BillingConfig billingConfig = 12;
  bool has_billingconfig() const;
  private:
  bool _internal_has_billingconfig() const;
  public:
  void clear_billingconfig();
  const ::playapi::proto::finsky::toc::BillingConfig& billingconfig() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::toc::BillingConfig* release_billingconfig();
  ::playapi::proto::finsky::toc::BillingConfig* mutable_billingconfig();
  void set_allocated_billingconfig(::playapi::proto::finsky::toc::BillingConfig* billingconfig);
  private:
  const ::playapi::proto::finsky::toc::BillingConfig& _internal_billingconfig() const;
  ::playapi::proto::finsky::toc::BillingConfig* _internal_mutable_billingconfig();
  public:
  void unsafe_arena_set_allocated_billingconfig(
      ::playapi::proto::finsky::toc::BillingConfig* billingconfig);
  ::playapi::proto::finsky::toc::BillingConfig* unsafe_arena_release_billingconfig();

  // optional int32 tosVersionDeprecated = 2;
  bool has_tosversiondeprecated() const;
  private:
  bool _internal_has_tosversiondeprecated() const;
  public:
  void clear_tosversiondeprecated();
  int32_t tosversiondeprecated() const;
  void set_tosversiondeprecated(int32_t value);
  private:
  int32_t _internal_tosversiondeprecated() const;
  void _internal_set_tosversiondeprecated(int32_t value);
  public:

  // optional bool requiresUploadDeviceConfig = 11;
  bool has_requiresuploaddeviceconfig() const;
  private:
  bool _internal_has_requiresuploaddeviceconfig() const;
  public:
  void clear_requiresuploaddeviceconfig();
  bool requiresuploaddeviceconfig() const;
  void set_requiresuploaddeviceconfig(bool value);
  private:
  bool _internal_requiresuploaddeviceconfig() const;
  void _internal_set_requiresuploaddeviceconfig(bool value);
  public:

  // optional bool ageVerificationRequired = 16;
  bool has_ageverificationrequired() const;
  private:
  bool _internal_has_ageverificationrequired() const;
  public:
  void clear_ageverificationrequired();
  bool ageverificationrequired() const;
  void set_ageverificationrequired(bool value);
  private:
  bool _internal_ageverificationrequired() const;
  void _internal_set_ageverificationrequired(bool value);
  public:

  // optional bool gplusSignupEnabled = 17;
  bool has_gplussignupenabled() const;
  private:
  bool _internal_has_gplussignupenabled() const;
  public:
  void clear_gplussignupenabled();
  bool gplussignupenabled() const;
  void set_gplussignupenabled(bool value);
  private:
  bool _internal_gplussignupenabled() const;
  void _internal_set_gplussignupenabled(bool value);
  public:

  // optional bool redeemEnabled = 18;
  bool has_redeemenabled() const;
  private:
  bool _internal_has_redeemenabled() const;
  public:
  void clear_redeemenabled();
  bool redeemenabled() const;
  void set_redeemenabled(bool value);
  private:
  bool _internal_redeemenabled() const;
  void _internal_set_redeemenabled(bool value);
  public:

  // optional int32 themeId = 20;
  bool has_themeid() const;
  private:
  bool _internal_has_themeid() const;
  public:
  void clear_themeid();
  int32_t themeid() const;
  void set_themeid(int32_t value);
  private:
  int32_t _internal_themeid() const;
  void _internal_set_themeid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.toc.TocResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::toc::CorpusMetadata > corpus_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr toscontent_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr homeurl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr toscheckboxtextmarketingemails_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tostoken_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr iconoverrideurl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr recswidgeturl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr socialhomeurl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr helpurl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr entertainmenthomeurl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cookie_;
    ::playapi::proto::finsky::toc::Experiments* experiments_;
    ::playapi::proto::finsky::settings::OBSOLETEUserSettings* usersettings_;
    ::playapi::proto::finsky::toc::SelfUpdateConfig* selfupdateconfig_;
    ::playapi::proto::finsky::toc::BillingConfig* billingconfig_;
    int32_t tosversiondeprecated_;
    bool requiresuploaddeviceconfig_;
    bool ageverificationrequired_;
    bool gplussignupenabled_;
    bool redeemenabled_;
    int32_t themeid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5ftoc_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CarrierBillingConfig

// optional string id = 1;
inline bool CarrierBillingConfig::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CarrierBillingConfig::has_id() const {
  return _internal_has_id();
}
inline void CarrierBillingConfig::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CarrierBillingConfig::id() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.toc.CarrierBillingConfig.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CarrierBillingConfig::set_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.toc.CarrierBillingConfig.id)
}
inline std::string* CarrierBillingConfig::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.toc.CarrierBillingConfig.id)
  return _s;
}
inline const std::string& CarrierBillingConfig::_internal_id() const {
  return _impl_.id_.Get();
}
inline void CarrierBillingConfig::_internal_set_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* CarrierBillingConfig::_internal_mutable_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* CarrierBillingConfig::release_id() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.toc.CarrierBillingConfig.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CarrierBillingConfig::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.toc.CarrierBillingConfig.id)
}

// optional string name = 2;
inline bool CarrierBillingConfig::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CarrierBillingConfig::has_name() const {
  return _internal_has_name();
}
inline void CarrierBillingConfig::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CarrierBillingConfig::name() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.toc.CarrierBillingConfig.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CarrierBillingConfig::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.toc.CarrierBillingConfig.name)
}
inline std::string* CarrierBillingConfig::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.toc.CarrierBillingConfig.name)
  return _s;
}
inline const std::string& CarrierBillingConfig::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CarrierBillingConfig::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CarrierBillingConfig::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CarrierBillingConfig::release_name() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.toc.CarrierBillingConfig.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CarrierBillingConfig::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.toc.CarrierBillingConfig.name)
}

// optional int32 apiVersion = 3;
inline bool CarrierBillingConfig::_internal_has_apiversion() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CarrierBillingConfig::has_apiversion() const {
  return _internal_has_apiversion();
}
inline void CarrierBillingConfig::clear_apiversion() {
  _impl_.apiversion_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t CarrierBillingConfig::_internal_apiversion() const {
  return _impl_.apiversion_;
}
inline int32_t CarrierBillingConfig::apiversion() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.toc.CarrierBillingConfig.apiVersion)
  return _internal_apiversion();
}
inline void CarrierBillingConfig::_internal_set_apiversion(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.apiversion_ = value;
}
inline void CarrierBillingConfig::set_apiversion(int32_t value) {
  _internal_set_apiversion(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.toc.CarrierBillingConfig.apiVersion)
}

// optional string provisioningUrl = 4;
inline bool CarrierBillingConfig::_internal_has_provisioningurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CarrierBillingConfig::has_provisioningurl() const {
  return _internal_has_provisioningurl();
}
inline void CarrierBillingConfig::clear_provisioningurl() {
  _impl_.provisioningurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CarrierBillingConfig::provisioningurl() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.toc.CarrierBillingConfig.provisioningUrl)
  return _internal_provisioningurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CarrierBillingConfig::set_provisioningurl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.provisioningurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.toc.CarrierBillingConfig.provisioningUrl)
}
inline std::string* CarrierBillingConfig::mutable_provisioningurl() {
  std::string* _s = _internal_mutable_provisioningurl();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.toc.CarrierBillingConfig.provisioningUrl)
  return _s;
}
inline const std::string& CarrierBillingConfig::_internal_provisioningurl() const {
  return _impl_.provisioningurl_.Get();
}
inline void CarrierBillingConfig::_internal_set_provisioningurl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.provisioningurl_.Set(value, GetArenaForAllocation());
}
inline std::string* CarrierBillingConfig::_internal_mutable_provisioningurl() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.provisioningurl_.Mutable(GetArenaForAllocation());
}
inline std::string* CarrierBillingConfig::release_provisioningurl() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.toc.CarrierBillingConfig.provisioningUrl)
  if (!_internal_has_provisioningurl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.provisioningurl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.provisioningurl_.IsDefault()) {
    _impl_.provisioningurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CarrierBillingConfig::set_allocated_provisioningurl(std::string* provisioningurl) {
  if (provisioningurl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.provisioningurl_.SetAllocated(provisioningurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.provisioningurl_.IsDefault()) {
    _impl_.provisioningurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.toc.CarrierBillingConfig.provisioningUrl)
}

// optional string credentialsUrl = 5;
inline bool CarrierBillingConfig::_internal_has_credentialsurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CarrierBillingConfig::has_credentialsurl() const {
  return _internal_has_credentialsurl();
}
inline void CarrierBillingConfig::clear_credentialsurl() {
  _impl_.credentialsurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CarrierBillingConfig::credentialsurl() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.toc.CarrierBillingConfig.credentialsUrl)
  return _internal_credentialsurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CarrierBillingConfig::set_credentialsurl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.credentialsurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.toc.CarrierBillingConfig.credentialsUrl)
}
inline std::string* CarrierBillingConfig::mutable_credentialsurl() {
  std::string* _s = _internal_mutable_credentialsurl();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.toc.CarrierBillingConfig.credentialsUrl)
  return _s;
}
inline const std::string& CarrierBillingConfig::_internal_credentialsurl() const {
  return _impl_.credentialsurl_.Get();
}
inline void CarrierBillingConfig::_internal_set_credentialsurl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.credentialsurl_.Set(value, GetArenaForAllocation());
}
inline std::string* CarrierBillingConfig::_internal_mutable_credentialsurl() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.credentialsurl_.Mutable(GetArenaForAllocation());
}
inline std::string* CarrierBillingConfig::release_credentialsurl() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.toc.CarrierBillingConfig.credentialsUrl)
  if (!_internal_has_credentialsurl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.credentialsurl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.credentialsurl_.IsDefault()) {
    _impl_.credentialsurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CarrierBillingConfig::set_allocated_credentialsurl(std::string* credentialsurl) {
  if (credentialsurl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.credentialsurl_.SetAllocated(credentialsurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.credentialsurl_.IsDefault()) {
    _impl_.credentialsurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.toc.CarrierBillingConfig.credentialsUrl)
}

// optional bool tosRequired = 6;
inline bool CarrierBillingConfig::_internal_has_tosrequired() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CarrierBillingConfig::has_tosrequired() const {
  return _internal_has_tosrequired();
}
inline void CarrierBillingConfig::clear_tosrequired() {
  _impl_.tosrequired_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool CarrierBillingConfig::_internal_tosrequired() const {
  return _impl_.tosrequired_;
}
inline bool CarrierBillingConfig::tosrequired() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.toc.CarrierBillingConfig.tosRequired)
  return _internal_tosrequired();
}
inline void CarrierBillingConfig::_internal_set_tosrequired(bool value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.tosrequired_ = value;
}
inline void CarrierBillingConfig::set_tosrequired(bool value) {
  _internal_set_tosrequired(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.toc.CarrierBillingConfig.tosRequired)
}

// optional bool perTransactionCredentialsRequired = 7;
inline bool CarrierBillingConfig::_internal_has_pertransactioncredentialsrequired() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CarrierBillingConfig::has_pertransactioncredentialsrequired() const {
  return _internal_has_pertransactioncredentialsrequired();
}
inline void CarrierBillingConfig::clear_pertransactioncredentialsrequired() {
  _impl_.pertransactioncredentialsrequired_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool CarrierBillingConfig::_internal_pertransactioncredentialsrequired() const {
  return _impl_.pertransactioncredentialsrequired_;
}
inline bool CarrierBillingConfig::pertransactioncredentialsrequired() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.toc.CarrierBillingConfig.perTransactionCredentialsRequired)
  return _internal_pertransactioncredentialsrequired();
}
inline void CarrierBillingConfig::_internal_set_pertransactioncredentialsrequired(bool value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.pertransactioncredentialsrequired_ = value;
}
inline void CarrierBillingConfig::set_pertransactioncredentialsrequired(bool value) {
  _internal_set_pertransactioncredentialsrequired(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.toc.CarrierBillingConfig.perTransactionCredentialsRequired)
}

// optional bool sendSubscriberIdWithCarrierBillingRequests = 8;
inline bool CarrierBillingConfig::_internal_has_sendsubscriberidwithcarrierbillingrequests() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CarrierBillingConfig::has_sendsubscriberidwithcarrierbillingrequests() const {
  return _internal_has_sendsubscriberidwithcarrierbillingrequests();
}
inline void CarrierBillingConfig::clear_sendsubscriberidwithcarrierbillingrequests() {
  _impl_.sendsubscriberidwithcarrierbillingrequests_ = false;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool CarrierBillingConfig::_internal_sendsubscriberidwithcarrierbillingrequests() const {
  return _impl_.sendsubscriberidwithcarrierbillingrequests_;
}
inline bool CarrierBillingConfig::sendsubscriberidwithcarrierbillingrequests() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.toc.CarrierBillingConfig.sendSubscriberIdWithCarrierBillingRequests)
  return _internal_sendsubscriberidwithcarrierbillingrequests();
}
inline void CarrierBillingConfig::_internal_set_sendsubscriberidwithcarrierbillingrequests(bool value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.sendsubscriberidwithcarrierbillingrequests_ = value;
}
inline void CarrierBillingConfig::set_sendsubscriberidwithcarrierbillingrequests(bool value) {
  _internal_set_sendsubscriberidwithcarrierbillingrequests(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.toc.CarrierBillingConfig.sendSubscriberIdWithCarrierBillingRequests)
}

// -------------------------------------------------------------------

// BillingConfig

// optional .playapi.proto.finsky.toc.CarrierBillingConfig carrierBillingConfig = 1;
inline bool BillingConfig::_internal_has_carrierbillingconfig() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.carrierbillingconfig_ != nullptr);
  return value;
}
inline bool BillingConfig::has_carrierbillingconfig() const {
  return _internal_has_carrierbillingconfig();
}
inline void BillingConfig::clear_carrierbillingconfig() {
  if (_impl_.carrierbillingconfig_ != nullptr) _impl_.carrierbillingconfig_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::playapi::proto::finsky::toc::CarrierBillingConfig& BillingConfig::_internal_carrierbillingconfig() const {
  const ::playapi::proto::finsky::toc::CarrierBillingConfig* p = _impl_.carrierbillingconfig_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::toc::CarrierBillingConfig&>(
      ::playapi::proto::finsky::toc::_CarrierBillingConfig_default_instance_);
}
inline const ::playapi::proto::finsky::toc::CarrierBillingConfig& BillingConfig::carrierbillingconfig() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.toc.BillingConfig.carrierBillingConfig)
  return _internal_carrierbillingconfig();
}
inline void BillingConfig::unsafe_arena_set_allocated_carrierbillingconfig(
    ::playapi::proto::finsky::toc::CarrierBillingConfig* carrierbillingconfig) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.carrierbillingconfig_);
  }
  _impl_.carrierbillingconfig_ = carrierbillingconfig;
  if (carrierbillingconfig) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.toc.BillingConfig.carrierBillingConfig)
}
inline ::playapi::proto::finsky::toc::CarrierBillingConfig* BillingConfig::release_carrierbillingconfig() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::playapi::proto::finsky::toc::CarrierBillingConfig* temp = _impl_.carrierbillingconfig_;
  _impl_.carrierbillingconfig_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::toc::CarrierBillingConfig* BillingConfig::unsafe_arena_release_carrierbillingconfig() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.toc.BillingConfig.carrierBillingConfig)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::playapi::proto::finsky::toc::CarrierBillingConfig* temp = _impl_.carrierbillingconfig_;
  _impl_.carrierbillingconfig_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::toc::CarrierBillingConfig* BillingConfig::_internal_mutable_carrierbillingconfig() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.carrierbillingconfig_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::toc::CarrierBillingConfig>(GetArenaForAllocation());
    _impl_.carrierbillingconfig_ = p;
  }
  return _impl_.carrierbillingconfig_;
}
inline ::playapi::proto::finsky::toc::CarrierBillingConfig* BillingConfig::mutable_carrierbillingconfig() {
  ::playapi::proto::finsky::toc::CarrierBillingConfig* _msg = _internal_mutable_carrierbillingconfig();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.toc.BillingConfig.carrierBillingConfig)
  return _msg;
}
inline void BillingConfig::set_allocated_carrierbillingconfig(::playapi::proto::finsky::toc::CarrierBillingConfig* carrierbillingconfig) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.carrierbillingconfig_;
  }
  if (carrierbillingconfig) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(carrierbillingconfig);
    if (message_arena != submessage_arena) {
      carrierbillingconfig = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, carrierbillingconfig, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.carrierbillingconfig_ = carrierbillingconfig;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.toc.BillingConfig.carrierBillingConfig)
}

// optional int32 maxIabApiVersion = 2;
inline bool BillingConfig::_internal_has_maxiabapiversion() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BillingConfig::has_maxiabapiversion() const {
  return _internal_has_maxiabapiversion();
}
inline void BillingConfig::clear_maxiabapiversion() {
  _impl_.maxiabapiversion_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t BillingConfig::_internal_maxiabapiversion() const {
  return _impl_.maxiabapiversion_;
}
inline int32_t BillingConfig::maxiabapiversion() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.toc.BillingConfig.maxIabApiVersion)
  return _internal_maxiabapiversion();
}
inline void BillingConfig::_internal_set_maxiabapiversion(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.maxiabapiversion_ = value;
}
inline void BillingConfig::set_maxiabapiversion(int32_t value) {
  _internal_set_maxiabapiversion(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.toc.BillingConfig.maxIabApiVersion)
}

// -------------------------------------------------------------------

// CorpusMetadata

// optional int32 backend = 1;
inline bool CorpusMetadata::_internal_has_backend() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CorpusMetadata::has_backend() const {
  return _internal_has_backend();
}
inline void CorpusMetadata::clear_backend() {
  _impl_.backend_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int32_t CorpusMetadata::_internal_backend() const {
  return _impl_.backend_;
}
inline int32_t CorpusMetadata::backend() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.toc.CorpusMetadata.backend)
  return _internal_backend();
}
inline void CorpusMetadata::_internal_set_backend(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.backend_ = value;
}
inline void CorpusMetadata::set_backend(int32_t value) {
  _internal_set_backend(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.toc.CorpusMetadata.backend)
}

// optional string name = 2;
inline bool CorpusMetadata::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CorpusMetadata::has_name() const {
  return _internal_has_name();
}
inline void CorpusMetadata::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CorpusMetadata::name() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.toc.CorpusMetadata.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CorpusMetadata::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.toc.CorpusMetadata.name)
}
inline std::string* CorpusMetadata::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.toc.CorpusMetadata.name)
  return _s;
}
inline const std::string& CorpusMetadata::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CorpusMetadata::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CorpusMetadata::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CorpusMetadata::release_name() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.toc.CorpusMetadata.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CorpusMetadata::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.toc.CorpusMetadata.name)
}

// optional string landingUrl = 3;
inline bool CorpusMetadata::_internal_has_landingurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CorpusMetadata::has_landingurl() const {
  return _internal_has_landingurl();
}
inline void CorpusMetadata::clear_landingurl() {
  _impl_.landingurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CorpusMetadata::landingurl() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.toc.CorpusMetadata.landingUrl)
  return _internal_landingurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CorpusMetadata::set_landingurl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.landingurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.toc.CorpusMetadata.landingUrl)
}
inline std::string* CorpusMetadata::mutable_landingurl() {
  std::string* _s = _internal_mutable_landingurl();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.toc.CorpusMetadata.landingUrl)
  return _s;
}
inline const std::string& CorpusMetadata::_internal_landingurl() const {
  return _impl_.landingurl_.Get();
}
inline void CorpusMetadata::_internal_set_landingurl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.landingurl_.Set(value, GetArenaForAllocation());
}
inline std::string* CorpusMetadata::_internal_mutable_landingurl() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.landingurl_.Mutable(GetArenaForAllocation());
}
inline std::string* CorpusMetadata::release_landingurl() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.toc.CorpusMetadata.landingUrl)
  if (!_internal_has_landingurl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.landingurl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.landingurl_.IsDefault()) {
    _impl_.landingurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CorpusMetadata::set_allocated_landingurl(std::string* landingurl) {
  if (landingurl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.landingurl_.SetAllocated(landingurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.landingurl_.IsDefault()) {
    _impl_.landingurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.toc.CorpusMetadata.landingUrl)
}

// optional string libraryName = 4;
inline bool CorpusMetadata::_internal_has_libraryname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CorpusMetadata::has_libraryname() const {
  return _internal_has_libraryname();
}
inline void CorpusMetadata::clear_libraryname() {
  _impl_.libraryname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CorpusMetadata::libraryname() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.toc.CorpusMetadata.libraryName)
  return _internal_libraryname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CorpusMetadata::set_libraryname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.libraryname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.toc.CorpusMetadata.libraryName)
}
inline std::string* CorpusMetadata::mutable_libraryname() {
  std::string* _s = _internal_mutable_libraryname();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.toc.CorpusMetadata.libraryName)
  return _s;
}
inline const std::string& CorpusMetadata::_internal_libraryname() const {
  return _impl_.libraryname_.Get();
}
inline void CorpusMetadata::_internal_set_libraryname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.libraryname_.Set(value, GetArenaForAllocation());
}
inline std::string* CorpusMetadata::_internal_mutable_libraryname() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.libraryname_.Mutable(GetArenaForAllocation());
}
inline std::string* CorpusMetadata::release_libraryname() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.toc.CorpusMetadata.libraryName)
  if (!_internal_has_libraryname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.libraryname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.libraryname_.IsDefault()) {
    _impl_.libraryname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CorpusMetadata::set_allocated_libraryname(std::string* libraryname) {
  if (libraryname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.libraryname_.SetAllocated(libraryname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.libraryname_.IsDefault()) {
    _impl_.libraryname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.toc.CorpusMetadata.libraryName)
}

// optional string recsWidgetUrl = 6;
inline bool CorpusMetadata::_internal_has_recswidgeturl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CorpusMetadata::has_recswidgeturl() const {
  return _internal_has_recswidgeturl();
}
inline void CorpusMetadata::clear_recswidgeturl() {
  _impl_.recswidgeturl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CorpusMetadata::recswidgeturl() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.toc.CorpusMetadata.recsWidgetUrl)
  return _internal_recswidgeturl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CorpusMetadata::set_recswidgeturl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.recswidgeturl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.toc.CorpusMetadata.recsWidgetUrl)
}
inline std::string* CorpusMetadata::mutable_recswidgeturl() {
  std::string* _s = _internal_mutable_recswidgeturl();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.toc.CorpusMetadata.recsWidgetUrl)
  return _s;
}
inline const std::string& CorpusMetadata::_internal_recswidgeturl() const {
  return _impl_.recswidgeturl_.Get();
}
inline void CorpusMetadata::_internal_set_recswidgeturl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.recswidgeturl_.Set(value, GetArenaForAllocation());
}
inline std::string* CorpusMetadata::_internal_mutable_recswidgeturl() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.recswidgeturl_.Mutable(GetArenaForAllocation());
}
inline std::string* CorpusMetadata::release_recswidgeturl() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.toc.CorpusMetadata.recsWidgetUrl)
  if (!_internal_has_recswidgeturl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.recswidgeturl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.recswidgeturl_.IsDefault()) {
    _impl_.recswidgeturl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CorpusMetadata::set_allocated_recswidgeturl(std::string* recswidgeturl) {
  if (recswidgeturl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.recswidgeturl_.SetAllocated(recswidgeturl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.recswidgeturl_.IsDefault()) {
    _impl_.recswidgeturl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.toc.CorpusMetadata.recsWidgetUrl)
}

// optional string shopName = 7;
inline bool CorpusMetadata::_internal_has_shopname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CorpusMetadata::has_shopname() const {
  return _internal_has_shopname();
}
inline void CorpusMetadata::clear_shopname() {
  _impl_.shopname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& CorpusMetadata::shopname() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.toc.CorpusMetadata.shopName)
  return _internal_shopname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CorpusMetadata::set_shopname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.shopname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.toc.CorpusMetadata.shopName)
}
inline std::string* CorpusMetadata::mutable_shopname() {
  std::string* _s = _internal_mutable_shopname();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.toc.CorpusMetadata.shopName)
  return _s;
}
inline const std::string& CorpusMetadata::_internal_shopname() const {
  return _impl_.shopname_.Get();
}
inline void CorpusMetadata::_internal_set_shopname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.shopname_.Set(value, GetArenaForAllocation());
}
inline std::string* CorpusMetadata::_internal_mutable_shopname() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.shopname_.Mutable(GetArenaForAllocation());
}
inline std::string* CorpusMetadata::release_shopname() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.toc.CorpusMetadata.shopName)
  if (!_internal_has_shopname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.shopname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.shopname_.IsDefault()) {
    _impl_.shopname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CorpusMetadata::set_allocated_shopname(std::string* shopname) {
  if (shopname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.shopname_.SetAllocated(shopname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.shopname_.IsDefault()) {
    _impl_.shopname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.toc.CorpusMetadata.shopName)
}

// -------------------------------------------------------------------

// Experiments

// repeated string experimentId = 1;
inline int Experiments::_internal_experimentid_size() const {
  return _impl_.experimentid_.size();
}
inline int Experiments::experimentid_size() const {
  return _internal_experimentid_size();
}
inline void Experiments::clear_experimentid() {
  _impl_.experimentid_.Clear();
}
inline std::string* Experiments::add_experimentid() {
  std::string* _s = _internal_add_experimentid();
  // @@protoc_insertion_point(field_add_mutable:playapi.proto.finsky.toc.Experiments.experimentId)
  return _s;
}
inline const std::string& Experiments::_internal_experimentid(int index) const {
  return _impl_.experimentid_.Get(index);
}
inline const std::string& Experiments::experimentid(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.toc.Experiments.experimentId)
  return _internal_experimentid(index);
}
inline std::string* Experiments::mutable_experimentid(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.toc.Experiments.experimentId)
  return _impl_.experimentid_.Mutable(index);
}
inline void Experiments::set_experimentid(int index, const std::string& value) {
  _impl_.experimentid_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.toc.Experiments.experimentId)
}
inline void Experiments::set_experimentid(int index, std::string&& value) {
  _impl_.experimentid_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.toc.Experiments.experimentId)
}
inline void Experiments::set_experimentid(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.experimentid_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:playapi.proto.finsky.toc.Experiments.experimentId)
}
inline void Experiments::set_experimentid(int index, const char* value, size_t size) {
  _impl_.experimentid_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:playapi.proto.finsky.toc.Experiments.experimentId)
}
inline std::string* Experiments::_internal_add_experimentid() {
  return _impl_.experimentid_.Add();
}
inline void Experiments::add_experimentid(const std::string& value) {
  _impl_.experimentid_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.toc.Experiments.experimentId)
}
inline void Experiments::add_experimentid(std::string&& value) {
  _impl_.experimentid_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.toc.Experiments.experimentId)
}
inline void Experiments::add_experimentid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.experimentid_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:playapi.proto.finsky.toc.Experiments.experimentId)
}
inline void Experiments::add_experimentid(const char* value, size_t size) {
  _impl_.experimentid_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:playapi.proto.finsky.toc.Experiments.experimentId)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Experiments::experimentid() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.toc.Experiments.experimentId)
  return _impl_.experimentid_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Experiments::mutable_experimentid() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.toc.Experiments.experimentId)
  return &_impl_.experimentid_;
}

// -------------------------------------------------------------------

// SelfUpdateConfig

// optional int32 latestClientVersionCode = 1;
inline bool SelfUpdateConfig::_internal_has_latestclientversioncode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SelfUpdateConfig::has_latestclientversioncode() const {
  return _internal_has_latestclientversioncode();
}
inline void SelfUpdateConfig::clear_latestclientversioncode() {
  _impl_.latestclientversioncode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t SelfUpdateConfig::_internal_latestclientversioncode() const {
  return _impl_.latestclientversioncode_;
}
inline int32_t SelfUpdateConfig::latestclientversioncode() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.toc.SelfUpdateConfig.latestClientVersionCode)
  return _internal_latestclientversioncode();
}
inline void SelfUpdateConfig::_internal_set_latestclientversioncode(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.latestclientversioncode_ = value;
}
inline void SelfUpdateConfig::set_latestclientversioncode(int32_t value) {
  _internal_set_latestclientversioncode(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.toc.SelfUpdateConfig.latestClientVersionCode)
}

// -------------------------------------------------------------------

// TocResponse

// repeated .playapi.proto.finsky.toc.CorpusMetadata corpus = 1;
inline int TocResponse::_internal_corpus_size() const {
  return _impl_.corpus_.size();
}
inline int TocResponse::corpus_size() const {
  return _internal_corpus_size();
}
inline void TocResponse::clear_corpus() {
  _impl_.corpus_.Clear();
}
inline ::playapi::proto::finsky::toc::CorpusMetadata* TocResponse::mutable_corpus(int index) {
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.toc.TocResponse.corpus)
  return _impl_.corpus_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::toc::CorpusMetadata >*
TocResponse::mutable_corpus() {
  // @@protoc_insertion_point(field_mutable_list:playapi.proto.finsky.toc.TocResponse.corpus)
  return &_impl_.corpus_;
}
inline const ::playapi::proto::finsky::toc::CorpusMetadata& TocResponse::_internal_corpus(int index) const {
  return _impl_.corpus_.Get(index);
}
inline const ::playapi::proto::finsky::toc::CorpusMetadata& TocResponse::corpus(int index) const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.toc.TocResponse.corpus)
  return _internal_corpus(index);
}
inline ::playapi::proto::finsky::toc::CorpusMetadata* TocResponse::_internal_add_corpus() {
  return _impl_.corpus_.Add();
}
inline ::playapi::proto::finsky::toc::CorpusMetadata* TocResponse::add_corpus() {
  ::playapi::proto::finsky::toc::CorpusMetadata* _add = _internal_add_corpus();
  // @@protoc_insertion_point(field_add:playapi.proto.finsky.toc.TocResponse.corpus)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::playapi::proto::finsky::toc::CorpusMetadata >&
TocResponse::corpus() const {
  // @@protoc_insertion_point(field_list:playapi.proto.finsky.toc.TocResponse.corpus)
  return _impl_.corpus_;
}

// optional int32 tosVersionDeprecated = 2;
inline bool TocResponse::_internal_has_tosversiondeprecated() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool TocResponse::has_tosversiondeprecated() const {
  return _internal_has_tosversiondeprecated();
}
inline void TocResponse::clear_tosversiondeprecated() {
  _impl_.tosversiondeprecated_ = 0;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline int32_t TocResponse::_internal_tosversiondeprecated() const {
  return _impl_.tosversiondeprecated_;
}
inline int32_t TocResponse::tosversiondeprecated() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.toc.TocResponse.tosVersionDeprecated)
  return _internal_tosversiondeprecated();
}
inline void TocResponse::_internal_set_tosversiondeprecated(int32_t value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.tosversiondeprecated_ = value;
}
inline void TocResponse::set_tosversiondeprecated(int32_t value) {
  _internal_set_tosversiondeprecated(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.toc.TocResponse.tosVersionDeprecated)
}

// optional string tosContent = 3;
inline bool TocResponse::_internal_has_toscontent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TocResponse::has_toscontent() const {
  return _internal_has_toscontent();
}
inline void TocResponse::clear_toscontent() {
  _impl_.toscontent_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TocResponse::toscontent() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.toc.TocResponse.tosContent)
  return _internal_toscontent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TocResponse::set_toscontent(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.toscontent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.toc.TocResponse.tosContent)
}
inline std::string* TocResponse::mutable_toscontent() {
  std::string* _s = _internal_mutable_toscontent();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.toc.TocResponse.tosContent)
  return _s;
}
inline const std::string& TocResponse::_internal_toscontent() const {
  return _impl_.toscontent_.Get();
}
inline void TocResponse::_internal_set_toscontent(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.toscontent_.Set(value, GetArenaForAllocation());
}
inline std::string* TocResponse::_internal_mutable_toscontent() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.toscontent_.Mutable(GetArenaForAllocation());
}
inline std::string* TocResponse::release_toscontent() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.toc.TocResponse.tosContent)
  if (!_internal_has_toscontent()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.toscontent_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.toscontent_.IsDefault()) {
    _impl_.toscontent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TocResponse::set_allocated_toscontent(std::string* toscontent) {
  if (toscontent != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.toscontent_.SetAllocated(toscontent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.toscontent_.IsDefault()) {
    _impl_.toscontent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.toc.TocResponse.tosContent)
}

// optional string homeUrl = 4;
inline bool TocResponse::_internal_has_homeurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TocResponse::has_homeurl() const {
  return _internal_has_homeurl();
}
inline void TocResponse::clear_homeurl() {
  _impl_.homeurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TocResponse::homeurl() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.toc.TocResponse.homeUrl)
  return _internal_homeurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TocResponse::set_homeurl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.homeurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.toc.TocResponse.homeUrl)
}
inline std::string* TocResponse::mutable_homeurl() {
  std::string* _s = _internal_mutable_homeurl();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.toc.TocResponse.homeUrl)
  return _s;
}
inline const std::string& TocResponse::_internal_homeurl() const {
  return _impl_.homeurl_.Get();
}
inline void TocResponse::_internal_set_homeurl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.homeurl_.Set(value, GetArenaForAllocation());
}
inline std::string* TocResponse::_internal_mutable_homeurl() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.homeurl_.Mutable(GetArenaForAllocation());
}
inline std::string* TocResponse::release_homeurl() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.toc.TocResponse.homeUrl)
  if (!_internal_has_homeurl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.homeurl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.homeurl_.IsDefault()) {
    _impl_.homeurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TocResponse::set_allocated_homeurl(std::string* homeurl) {
  if (homeurl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.homeurl_.SetAllocated(homeurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.homeurl_.IsDefault()) {
    _impl_.homeurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.toc.TocResponse.homeUrl)
}

// optional .playapi.proto.finsky.toc.Experiments experiments = 5;
inline bool TocResponse::_internal_has_experiments() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.experiments_ != nullptr);
  return value;
}
inline bool TocResponse::has_experiments() const {
  return _internal_has_experiments();
}
inline void TocResponse::clear_experiments() {
  if (_impl_.experiments_ != nullptr) _impl_.experiments_->Clear();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const ::playapi::proto::finsky::toc::Experiments& TocResponse::_internal_experiments() const {
  const ::playapi::proto::finsky::toc::Experiments* p = _impl_.experiments_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::toc::Experiments&>(
      ::playapi::proto::finsky::toc::_Experiments_default_instance_);
}
inline const ::playapi::proto::finsky::toc::Experiments& TocResponse::experiments() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.toc.TocResponse.experiments)
  return _internal_experiments();
}
inline void TocResponse::unsafe_arena_set_allocated_experiments(
    ::playapi::proto::finsky::toc::Experiments* experiments) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.experiments_);
  }
  _impl_.experiments_ = experiments;
  if (experiments) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.toc.TocResponse.experiments)
}
inline ::playapi::proto::finsky::toc::Experiments* TocResponse::release_experiments() {
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::playapi::proto::finsky::toc::Experiments* temp = _impl_.experiments_;
  _impl_.experiments_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::toc::Experiments* TocResponse::unsafe_arena_release_experiments() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.toc.TocResponse.experiments)
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::playapi::proto::finsky::toc::Experiments* temp = _impl_.experiments_;
  _impl_.experiments_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::toc::Experiments* TocResponse::_internal_mutable_experiments() {
  _impl_._has_bits_[0] |= 0x00000400u;
  if (_impl_.experiments_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::toc::Experiments>(GetArenaForAllocation());
    _impl_.experiments_ = p;
  }
  return _impl_.experiments_;
}
inline ::playapi::proto::finsky::toc::Experiments* TocResponse::mutable_experiments() {
  ::playapi::proto::finsky::toc::Experiments* _msg = _internal_mutable_experiments();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.toc.TocResponse.experiments)
  return _msg;
}
inline void TocResponse::set_allocated_experiments(::playapi::proto::finsky::toc::Experiments* experiments) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.experiments_;
  }
  if (experiments) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(experiments);
    if (message_arena != submessage_arena) {
      experiments = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, experiments, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.experiments_ = experiments;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.toc.TocResponse.experiments)
}

// optional string tosCheckboxTextMarketingEmails = 6;
inline bool TocResponse::_internal_has_toscheckboxtextmarketingemails() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TocResponse::has_toscheckboxtextmarketingemails() const {
  return _internal_has_toscheckboxtextmarketingemails();
}
inline void TocResponse::clear_toscheckboxtextmarketingemails() {
  _impl_.toscheckboxtextmarketingemails_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TocResponse::toscheckboxtextmarketingemails() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.toc.TocResponse.tosCheckboxTextMarketingEmails)
  return _internal_toscheckboxtextmarketingemails();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TocResponse::set_toscheckboxtextmarketingemails(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.toscheckboxtextmarketingemails_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.toc.TocResponse.tosCheckboxTextMarketingEmails)
}
inline std::string* TocResponse::mutable_toscheckboxtextmarketingemails() {
  std::string* _s = _internal_mutable_toscheckboxtextmarketingemails();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.toc.TocResponse.tosCheckboxTextMarketingEmails)
  return _s;
}
inline const std::string& TocResponse::_internal_toscheckboxtextmarketingemails() const {
  return _impl_.toscheckboxtextmarketingemails_.Get();
}
inline void TocResponse::_internal_set_toscheckboxtextmarketingemails(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.toscheckboxtextmarketingemails_.Set(value, GetArenaForAllocation());
}
inline std::string* TocResponse::_internal_mutable_toscheckboxtextmarketingemails() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.toscheckboxtextmarketingemails_.Mutable(GetArenaForAllocation());
}
inline std::string* TocResponse::release_toscheckboxtextmarketingemails() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.toc.TocResponse.tosCheckboxTextMarketingEmails)
  if (!_internal_has_toscheckboxtextmarketingemails()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.toscheckboxtextmarketingemails_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.toscheckboxtextmarketingemails_.IsDefault()) {
    _impl_.toscheckboxtextmarketingemails_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TocResponse::set_allocated_toscheckboxtextmarketingemails(std::string* toscheckboxtextmarketingemails) {
  if (toscheckboxtextmarketingemails != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.toscheckboxtextmarketingemails_.SetAllocated(toscheckboxtextmarketingemails, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.toscheckboxtextmarketingemails_.IsDefault()) {
    _impl_.toscheckboxtextmarketingemails_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.toc.TocResponse.tosCheckboxTextMarketingEmails)
}

// optional string tosToken = 7;
inline bool TocResponse::_internal_has_tostoken() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TocResponse::has_tostoken() const {
  return _internal_has_tostoken();
}
inline void TocResponse::clear_tostoken() {
  _impl_.tostoken_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& TocResponse::tostoken() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.toc.TocResponse.tosToken)
  return _internal_tostoken();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TocResponse::set_tostoken(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.tostoken_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.toc.TocResponse.tosToken)
}
inline std::string* TocResponse::mutable_tostoken() {
  std::string* _s = _internal_mutable_tostoken();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.toc.TocResponse.tosToken)
  return _s;
}
inline const std::string& TocResponse::_internal_tostoken() const {
  return _impl_.tostoken_.Get();
}
inline void TocResponse::_internal_set_tostoken(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.tostoken_.Set(value, GetArenaForAllocation());
}
inline std::string* TocResponse::_internal_mutable_tostoken() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.tostoken_.Mutable(GetArenaForAllocation());
}
inline std::string* TocResponse::release_tostoken() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.toc.TocResponse.tosToken)
  if (!_internal_has_tostoken()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.tostoken_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tostoken_.IsDefault()) {
    _impl_.tostoken_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TocResponse::set_allocated_tostoken(std::string* tostoken) {
  if (tostoken != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.tostoken_.SetAllocated(tostoken, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tostoken_.IsDefault()) {
    _impl_.tostoken_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.toc.TocResponse.tosToken)
}

// optional .playapi.proto.finsky.settings.OBSOLETEUserSettings userSettings = 8;
inline bool TocResponse::_internal_has_usersettings() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.usersettings_ != nullptr);
  return value;
}
inline bool TocResponse::has_usersettings() const {
  return _internal_has_usersettings();
}
inline const ::playapi::proto::finsky::settings::OBSOLETEUserSettings& TocResponse::_internal_usersettings() const {
  const ::playapi::proto::finsky::settings::OBSOLETEUserSettings* p = _impl_.usersettings_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::settings::OBSOLETEUserSettings&>(
      ::playapi::proto::finsky::settings::_OBSOLETEUserSettings_default_instance_);
}
inline const ::playapi::proto::finsky::settings::OBSOLETEUserSettings& TocResponse::usersettings() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.toc.TocResponse.userSettings)
  return _internal_usersettings();
}
inline void TocResponse::unsafe_arena_set_allocated_usersettings(
    ::playapi::proto::finsky::settings::OBSOLETEUserSettings* usersettings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.usersettings_);
  }
  _impl_.usersettings_ = usersettings;
  if (usersettings) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.toc.TocResponse.userSettings)
}
inline ::playapi::proto::finsky::settings::OBSOLETEUserSettings* TocResponse::release_usersettings() {
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::playapi::proto::finsky::settings::OBSOLETEUserSettings* temp = _impl_.usersettings_;
  _impl_.usersettings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::settings::OBSOLETEUserSettings* TocResponse::unsafe_arena_release_usersettings() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.toc.TocResponse.userSettings)
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::playapi::proto::finsky::settings::OBSOLETEUserSettings* temp = _impl_.usersettings_;
  _impl_.usersettings_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::settings::OBSOLETEUserSettings* TocResponse::_internal_mutable_usersettings() {
  _impl_._has_bits_[0] |= 0x00000800u;
  if (_impl_.usersettings_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::settings::OBSOLETEUserSettings>(GetArenaForAllocation());
    _impl_.usersettings_ = p;
  }
  return _impl_.usersettings_;
}
inline ::playapi::proto::finsky::settings::OBSOLETEUserSettings* TocResponse::mutable_usersettings() {
  ::playapi::proto::finsky::settings::OBSOLETEUserSettings* _msg = _internal_mutable_usersettings();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.toc.TocResponse.userSettings)
  return _msg;
}
inline void TocResponse::set_allocated_usersettings(::playapi::proto::finsky::settings::OBSOLETEUserSettings* usersettings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.usersettings_);
  }
  if (usersettings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(usersettings));
    if (message_arena != submessage_arena) {
      usersettings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, usersettings, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  _impl_.usersettings_ = usersettings;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.toc.TocResponse.userSettings)
}

// optional string iconOverrideUrl = 9;
inline bool TocResponse::_internal_has_iconoverrideurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TocResponse::has_iconoverrideurl() const {
  return _internal_has_iconoverrideurl();
}
inline void TocResponse::clear_iconoverrideurl() {
  _impl_.iconoverrideurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& TocResponse::iconoverrideurl() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.toc.TocResponse.iconOverrideUrl)
  return _internal_iconoverrideurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TocResponse::set_iconoverrideurl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.iconoverrideurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.toc.TocResponse.iconOverrideUrl)
}
inline std::string* TocResponse::mutable_iconoverrideurl() {
  std::string* _s = _internal_mutable_iconoverrideurl();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.toc.TocResponse.iconOverrideUrl)
  return _s;
}
inline const std::string& TocResponse::_internal_iconoverrideurl() const {
  return _impl_.iconoverrideurl_.Get();
}
inline void TocResponse::_internal_set_iconoverrideurl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.iconoverrideurl_.Set(value, GetArenaForAllocation());
}
inline std::string* TocResponse::_internal_mutable_iconoverrideurl() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.iconoverrideurl_.Mutable(GetArenaForAllocation());
}
inline std::string* TocResponse::release_iconoverrideurl() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.toc.TocResponse.iconOverrideUrl)
  if (!_internal_has_iconoverrideurl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.iconoverrideurl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.iconoverrideurl_.IsDefault()) {
    _impl_.iconoverrideurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TocResponse::set_allocated_iconoverrideurl(std::string* iconoverrideurl) {
  if (iconoverrideurl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.iconoverrideurl_.SetAllocated(iconoverrideurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.iconoverrideurl_.IsDefault()) {
    _impl_.iconoverrideurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.toc.TocResponse.iconOverrideUrl)
}

// optional .playapi.proto.finsky.toc.SelfUpdateConfig selfUpdateConfig = 10;
inline bool TocResponse::_internal_has_selfupdateconfig() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.selfupdateconfig_ != nullptr);
  return value;
}
inline bool TocResponse::has_selfupdateconfig() const {
  return _internal_has_selfupdateconfig();
}
inline void TocResponse::clear_selfupdateconfig() {
  if (_impl_.selfupdateconfig_ != nullptr) _impl_.selfupdateconfig_->Clear();
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline const ::playapi::proto::finsky::toc::SelfUpdateConfig& TocResponse::_internal_selfupdateconfig() const {
  const ::playapi::proto::finsky::toc::SelfUpdateConfig* p = _impl_.selfupdateconfig_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::toc::SelfUpdateConfig&>(
      ::playapi::proto::finsky::toc::_SelfUpdateConfig_default_instance_);
}
inline const ::playapi::proto::finsky::toc::SelfUpdateConfig& TocResponse::selfupdateconfig() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.toc.TocResponse.selfUpdateConfig)
  return _internal_selfupdateconfig();
}
inline void TocResponse::unsafe_arena_set_allocated_selfupdateconfig(
    ::playapi::proto::finsky::toc::SelfUpdateConfig* selfupdateconfig) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.selfupdateconfig_);
  }
  _impl_.selfupdateconfig_ = selfupdateconfig;
  if (selfupdateconfig) {
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.toc.TocResponse.selfUpdateConfig)
}
inline ::playapi::proto::finsky::toc::SelfUpdateConfig* TocResponse::release_selfupdateconfig() {
  _impl_._has_bits_[0] &= ~0x00001000u;
  ::playapi::proto::finsky::toc::SelfUpdateConfig* temp = _impl_.selfupdateconfig_;
  _impl_.selfupdateconfig_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::toc::SelfUpdateConfig* TocResponse::unsafe_arena_release_selfupdateconfig() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.toc.TocResponse.selfUpdateConfig)
  _impl_._has_bits_[0] &= ~0x00001000u;
  ::playapi::proto::finsky::toc::SelfUpdateConfig* temp = _impl_.selfupdateconfig_;
  _impl_.selfupdateconfig_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::toc::SelfUpdateConfig* TocResponse::_internal_mutable_selfupdateconfig() {
  _impl_._has_bits_[0] |= 0x00001000u;
  if (_impl_.selfupdateconfig_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::toc::SelfUpdateConfig>(GetArenaForAllocation());
    _impl_.selfupdateconfig_ = p;
  }
  return _impl_.selfupdateconfig_;
}
inline ::playapi::proto::finsky::toc::SelfUpdateConfig* TocResponse::mutable_selfupdateconfig() {
  ::playapi::proto::finsky::toc::SelfUpdateConfig* _msg = _internal_mutable_selfupdateconfig();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.toc.TocResponse.selfUpdateConfig)
  return _msg;
}
inline void TocResponse::set_allocated_selfupdateconfig(::playapi::proto::finsky::toc::SelfUpdateConfig* selfupdateconfig) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.selfupdateconfig_;
  }
  if (selfupdateconfig) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(selfupdateconfig);
    if (message_arena != submessage_arena) {
      selfupdateconfig = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, selfupdateconfig, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  _impl_.selfupdateconfig_ = selfupdateconfig;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.toc.TocResponse.selfUpdateConfig)
}

// optional bool requiresUploadDeviceConfig = 11;
inline bool TocResponse::_internal_has_requiresuploaddeviceconfig() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool TocResponse::has_requiresuploaddeviceconfig() const {
  return _internal_has_requiresuploaddeviceconfig();
}
inline void TocResponse::clear_requiresuploaddeviceconfig() {
  _impl_.requiresuploaddeviceconfig_ = false;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline bool TocResponse::_internal_requiresuploaddeviceconfig() const {
  return _impl_.requiresuploaddeviceconfig_;
}
inline bool TocResponse::requiresuploaddeviceconfig() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.toc.TocResponse.requiresUploadDeviceConfig)
  return _internal_requiresuploaddeviceconfig();
}
inline void TocResponse::_internal_set_requiresuploaddeviceconfig(bool value) {
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.requiresuploaddeviceconfig_ = value;
}
inline void TocResponse::set_requiresuploaddeviceconfig(bool value) {
  _internal_set_requiresuploaddeviceconfig(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.toc.TocResponse.requiresUploadDeviceConfig)
}

// optional .playapi.proto.finsky.toc.BillingConfig billingConfig = 12;
inline bool TocResponse::_internal_has_billingconfig() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.billingconfig_ != nullptr);
  return value;
}
inline bool TocResponse::has_billingconfig() const {
  return _internal_has_billingconfig();
}
inline void TocResponse::clear_billingconfig() {
  if (_impl_.billingconfig_ != nullptr) _impl_.billingconfig_->Clear();
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline const ::playapi::proto::finsky::toc::BillingConfig& TocResponse::_internal_billingconfig() const {
  const ::playapi::proto::finsky::toc::BillingConfig* p = _impl_.billingconfig_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::toc::BillingConfig&>(
      ::playapi::proto::finsky::toc::_BillingConfig_default_instance_);
}
inline const ::playapi::proto::finsky::toc::BillingConfig& TocResponse::billingconfig() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.toc.TocResponse.billingConfig)
  return _internal_billingconfig();
}
inline void TocResponse::unsafe_arena_set_allocated_billingconfig(
    ::playapi::proto::finsky::toc::BillingConfig* billingconfig) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.billingconfig_);
  }
  _impl_.billingconfig_ = billingconfig;
  if (billingconfig) {
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.toc.TocResponse.billingConfig)
}
inline ::playapi::proto::finsky::toc::BillingConfig* TocResponse::release_billingconfig() {
  _impl_._has_bits_[0] &= ~0x00002000u;
  ::playapi::proto::finsky::toc::BillingConfig* temp = _impl_.billingconfig_;
  _impl_.billingconfig_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::toc::BillingConfig* TocResponse::unsafe_arena_release_billingconfig() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.toc.TocResponse.billingConfig)
  _impl_._has_bits_[0] &= ~0x00002000u;
  ::playapi::proto::finsky::toc::BillingConfig* temp = _impl_.billingconfig_;
  _impl_.billingconfig_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::toc::BillingConfig* TocResponse::_internal_mutable_billingconfig() {
  _impl_._has_bits_[0] |= 0x00002000u;
  if (_impl_.billingconfig_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::toc::BillingConfig>(GetArenaForAllocation());
    _impl_.billingconfig_ = p;
  }
  return _impl_.billingconfig_;
}
inline ::playapi::proto::finsky::toc::BillingConfig* TocResponse::mutable_billingconfig() {
  ::playapi::proto::finsky::toc::BillingConfig* _msg = _internal_mutable_billingconfig();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.toc.TocResponse.billingConfig)
  return _msg;
}
inline void TocResponse::set_allocated_billingconfig(::playapi::proto::finsky::toc::BillingConfig* billingconfig) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.billingconfig_;
  }
  if (billingconfig) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(billingconfig);
    if (message_arena != submessage_arena) {
      billingconfig = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, billingconfig, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  _impl_.billingconfig_ = billingconfig;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.toc.TocResponse.billingConfig)
}

// optional string recsWidgetUrl = 13;
inline bool TocResponse::_internal_has_recswidgeturl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TocResponse::has_recswidgeturl() const {
  return _internal_has_recswidgeturl();
}
inline void TocResponse::clear_recswidgeturl() {
  _impl_.recswidgeturl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& TocResponse::recswidgeturl() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.toc.TocResponse.recsWidgetUrl)
  return _internal_recswidgeturl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TocResponse::set_recswidgeturl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.recswidgeturl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.toc.TocResponse.recsWidgetUrl)
}
inline std::string* TocResponse::mutable_recswidgeturl() {
  std::string* _s = _internal_mutable_recswidgeturl();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.toc.TocResponse.recsWidgetUrl)
  return _s;
}
inline const std::string& TocResponse::_internal_recswidgeturl() const {
  return _impl_.recswidgeturl_.Get();
}
inline void TocResponse::_internal_set_recswidgeturl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.recswidgeturl_.Set(value, GetArenaForAllocation());
}
inline std::string* TocResponse::_internal_mutable_recswidgeturl() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.recswidgeturl_.Mutable(GetArenaForAllocation());
}
inline std::string* TocResponse::release_recswidgeturl() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.toc.TocResponse.recsWidgetUrl)
  if (!_internal_has_recswidgeturl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.recswidgeturl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.recswidgeturl_.IsDefault()) {
    _impl_.recswidgeturl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TocResponse::set_allocated_recswidgeturl(std::string* recswidgeturl) {
  if (recswidgeturl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.recswidgeturl_.SetAllocated(recswidgeturl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.recswidgeturl_.IsDefault()) {
    _impl_.recswidgeturl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.toc.TocResponse.recsWidgetUrl)
}

// optional string socialHomeUrl = 15;
inline bool TocResponse::_internal_has_socialhomeurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool TocResponse::has_socialhomeurl() const {
  return _internal_has_socialhomeurl();
}
inline void TocResponse::clear_socialhomeurl() {
  _impl_.socialhomeurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& TocResponse::socialhomeurl() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.toc.TocResponse.socialHomeUrl)
  return _internal_socialhomeurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TocResponse::set_socialhomeurl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000040u;
 _impl_.socialhomeurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.toc.TocResponse.socialHomeUrl)
}
inline std::string* TocResponse::mutable_socialhomeurl() {
  std::string* _s = _internal_mutable_socialhomeurl();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.toc.TocResponse.socialHomeUrl)
  return _s;
}
inline const std::string& TocResponse::_internal_socialhomeurl() const {
  return _impl_.socialhomeurl_.Get();
}
inline void TocResponse::_internal_set_socialhomeurl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.socialhomeurl_.Set(value, GetArenaForAllocation());
}
inline std::string* TocResponse::_internal_mutable_socialhomeurl() {
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.socialhomeurl_.Mutable(GetArenaForAllocation());
}
inline std::string* TocResponse::release_socialhomeurl() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.toc.TocResponse.socialHomeUrl)
  if (!_internal_has_socialhomeurl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* p = _impl_.socialhomeurl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.socialhomeurl_.IsDefault()) {
    _impl_.socialhomeurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TocResponse::set_allocated_socialhomeurl(std::string* socialhomeurl) {
  if (socialhomeurl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.socialhomeurl_.SetAllocated(socialhomeurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.socialhomeurl_.IsDefault()) {
    _impl_.socialhomeurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.toc.TocResponse.socialHomeUrl)
}

// optional bool ageVerificationRequired = 16;
inline bool TocResponse::_internal_has_ageverificationrequired() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool TocResponse::has_ageverificationrequired() const {
  return _internal_has_ageverificationrequired();
}
inline void TocResponse::clear_ageverificationrequired() {
  _impl_.ageverificationrequired_ = false;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline bool TocResponse::_internal_ageverificationrequired() const {
  return _impl_.ageverificationrequired_;
}
inline bool TocResponse::ageverificationrequired() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.toc.TocResponse.ageVerificationRequired)
  return _internal_ageverificationrequired();
}
inline void TocResponse::_internal_set_ageverificationrequired(bool value) {
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.ageverificationrequired_ = value;
}
inline void TocResponse::set_ageverificationrequired(bool value) {
  _internal_set_ageverificationrequired(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.toc.TocResponse.ageVerificationRequired)
}

// optional bool gplusSignupEnabled = 17;
inline bool TocResponse::_internal_has_gplussignupenabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool TocResponse::has_gplussignupenabled() const {
  return _internal_has_gplussignupenabled();
}
inline void TocResponse::clear_gplussignupenabled() {
  _impl_.gplussignupenabled_ = false;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline bool TocResponse::_internal_gplussignupenabled() const {
  return _impl_.gplussignupenabled_;
}
inline bool TocResponse::gplussignupenabled() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.toc.TocResponse.gplusSignupEnabled)
  return _internal_gplussignupenabled();
}
inline void TocResponse::_internal_set_gplussignupenabled(bool value) {
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.gplussignupenabled_ = value;
}
inline void TocResponse::set_gplussignupenabled(bool value) {
  _internal_set_gplussignupenabled(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.toc.TocResponse.gplusSignupEnabled)
}

// optional bool redeemEnabled = 18;
inline bool TocResponse::_internal_has_redeemenabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool TocResponse::has_redeemenabled() const {
  return _internal_has_redeemenabled();
}
inline void TocResponse::clear_redeemenabled() {
  _impl_.redeemenabled_ = false;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline bool TocResponse::_internal_redeemenabled() const {
  return _impl_.redeemenabled_;
}
inline bool TocResponse::redeemenabled() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.toc.TocResponse.redeemEnabled)
  return _internal_redeemenabled();
}
inline void TocResponse::_internal_set_redeemenabled(bool value) {
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.redeemenabled_ = value;
}
inline void TocResponse::set_redeemenabled(bool value) {
  _internal_set_redeemenabled(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.toc.TocResponse.redeemEnabled)
}

// optional string helpUrl = 19;
inline bool TocResponse::_internal_has_helpurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool TocResponse::has_helpurl() const {
  return _internal_has_helpurl();
}
inline void TocResponse::clear_helpurl() {
  _impl_.helpurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& TocResponse::helpurl() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.toc.TocResponse.helpUrl)
  return _internal_helpurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TocResponse::set_helpurl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000080u;
 _impl_.helpurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.toc.TocResponse.helpUrl)
}
inline std::string* TocResponse::mutable_helpurl() {
  std::string* _s = _internal_mutable_helpurl();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.toc.TocResponse.helpUrl)
  return _s;
}
inline const std::string& TocResponse::_internal_helpurl() const {
  return _impl_.helpurl_.Get();
}
inline void TocResponse::_internal_set_helpurl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.helpurl_.Set(value, GetArenaForAllocation());
}
inline std::string* TocResponse::_internal_mutable_helpurl() {
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.helpurl_.Mutable(GetArenaForAllocation());
}
inline std::string* TocResponse::release_helpurl() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.toc.TocResponse.helpUrl)
  if (!_internal_has_helpurl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* p = _impl_.helpurl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.helpurl_.IsDefault()) {
    _impl_.helpurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TocResponse::set_allocated_helpurl(std::string* helpurl) {
  if (helpurl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.helpurl_.SetAllocated(helpurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.helpurl_.IsDefault()) {
    _impl_.helpurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.toc.TocResponse.helpUrl)
}

// optional int32 themeId = 20;
inline bool TocResponse::_internal_has_themeid() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool TocResponse::has_themeid() const {
  return _internal_has_themeid();
}
inline void TocResponse::clear_themeid() {
  _impl_.themeid_ = 0;
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline int32_t TocResponse::_internal_themeid() const {
  return _impl_.themeid_;
}
inline int32_t TocResponse::themeid() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.toc.TocResponse.themeId)
  return _internal_themeid();
}
inline void TocResponse::_internal_set_themeid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00080000u;
  _impl_.themeid_ = value;
}
inline void TocResponse::set_themeid(int32_t value) {
  _internal_set_themeid(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.toc.TocResponse.themeId)
}

// optional string entertainmentHomeUrl = 21;
inline bool TocResponse::_internal_has_entertainmenthomeurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool TocResponse::has_entertainmenthomeurl() const {
  return _internal_has_entertainmenthomeurl();
}
inline void TocResponse::clear_entertainmenthomeurl() {
  _impl_.entertainmenthomeurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const std::string& TocResponse::entertainmenthomeurl() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.toc.TocResponse.entertainmentHomeUrl)
  return _internal_entertainmenthomeurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TocResponse::set_entertainmenthomeurl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000100u;
 _impl_.entertainmenthomeurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.toc.TocResponse.entertainmentHomeUrl)
}
inline std::string* TocResponse::mutable_entertainmenthomeurl() {
  std::string* _s = _internal_mutable_entertainmenthomeurl();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.toc.TocResponse.entertainmentHomeUrl)
  return _s;
}
inline const std::string& TocResponse::_internal_entertainmenthomeurl() const {
  return _impl_.entertainmenthomeurl_.Get();
}
inline void TocResponse::_internal_set_entertainmenthomeurl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.entertainmenthomeurl_.Set(value, GetArenaForAllocation());
}
inline std::string* TocResponse::_internal_mutable_entertainmenthomeurl() {
  _impl_._has_bits_[0] |= 0x00000100u;
  return _impl_.entertainmenthomeurl_.Mutable(GetArenaForAllocation());
}
inline std::string* TocResponse::release_entertainmenthomeurl() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.toc.TocResponse.entertainmentHomeUrl)
  if (!_internal_has_entertainmenthomeurl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000100u;
  auto* p = _impl_.entertainmenthomeurl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.entertainmenthomeurl_.IsDefault()) {
    _impl_.entertainmenthomeurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TocResponse::set_allocated_entertainmenthomeurl(std::string* entertainmenthomeurl) {
  if (entertainmenthomeurl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.entertainmenthomeurl_.SetAllocated(entertainmenthomeurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.entertainmenthomeurl_.IsDefault()) {
    _impl_.entertainmenthomeurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.toc.TocResponse.entertainmentHomeUrl)
}

// optional string cookie = 22;
inline bool TocResponse::_internal_has_cookie() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool TocResponse::has_cookie() const {
  return _internal_has_cookie();
}
inline void TocResponse::clear_cookie() {
  _impl_.cookie_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const std::string& TocResponse::cookie() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.toc.TocResponse.cookie)
  return _internal_cookie();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TocResponse::set_cookie(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000200u;
 _impl_.cookie_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.toc.TocResponse.cookie)
}
inline std::string* TocResponse::mutable_cookie() {
  std::string* _s = _internal_mutable_cookie();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.toc.TocResponse.cookie)
  return _s;
}
inline const std::string& TocResponse::_internal_cookie() const {
  return _impl_.cookie_.Get();
}
inline void TocResponse::_internal_set_cookie(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.cookie_.Set(value, GetArenaForAllocation());
}
inline std::string* TocResponse::_internal_mutable_cookie() {
  _impl_._has_bits_[0] |= 0x00000200u;
  return _impl_.cookie_.Mutable(GetArenaForAllocation());
}
inline std::string* TocResponse::release_cookie() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.toc.TocResponse.cookie)
  if (!_internal_has_cookie()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000200u;
  auto* p = _impl_.cookie_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cookie_.IsDefault()) {
    _impl_.cookie_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TocResponse::set_allocated_cookie(std::string* cookie) {
  if (cookie != nullptr) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.cookie_.SetAllocated(cookie, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cookie_.IsDefault()) {
    _impl_.cookie_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.toc.TocResponse.cookie)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace toc
}  // namespace finsky
}  // namespace proto
}  // namespace playapi

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_play_5ftoc_2eproto
