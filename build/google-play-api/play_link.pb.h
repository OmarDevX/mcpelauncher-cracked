// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: play_link.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_play_5flink_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_play_5flink_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "play_common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_play_5flink_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_play_5flink_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_play_5flink_2eproto;
namespace playapi {
namespace proto {
namespace finsky {
namespace link {
class DirectPurchase;
struct DirectPurchaseDefaultTypeInternal;
extern DirectPurchaseDefaultTypeInternal _DirectPurchase_default_instance_;
class HelpCenter;
struct HelpCenterDefaultTypeInternal;
extern HelpCenterDefaultTypeInternal _HelpCenter_default_instance_;
class Link;
struct LinkDefaultTypeInternal;
extern LinkDefaultTypeInternal _Link_default_instance_;
class OverflowLink;
struct OverflowLinkDefaultTypeInternal;
extern OverflowLinkDefaultTypeInternal _OverflowLink_default_instance_;
class RedeemGiftCard;
struct RedeemGiftCardDefaultTypeInternal;
extern RedeemGiftCardDefaultTypeInternal _RedeemGiftCard_default_instance_;
class ResolvedLink;
struct ResolvedLinkDefaultTypeInternal;
extern ResolvedLinkDefaultTypeInternal _ResolvedLink_default_instance_;
}  // namespace link
}  // namespace finsky
}  // namespace proto
}  // namespace playapi
PROTOBUF_NAMESPACE_OPEN
template<> ::playapi::proto::finsky::link::DirectPurchase* Arena::CreateMaybeMessage<::playapi::proto::finsky::link::DirectPurchase>(Arena*);
template<> ::playapi::proto::finsky::link::HelpCenter* Arena::CreateMaybeMessage<::playapi::proto::finsky::link::HelpCenter>(Arena*);
template<> ::playapi::proto::finsky::link::Link* Arena::CreateMaybeMessage<::playapi::proto::finsky::link::Link>(Arena*);
template<> ::playapi::proto::finsky::link::OverflowLink* Arena::CreateMaybeMessage<::playapi::proto::finsky::link::OverflowLink>(Arena*);
template<> ::playapi::proto::finsky::link::RedeemGiftCard* Arena::CreateMaybeMessage<::playapi::proto::finsky::link::RedeemGiftCard>(Arena*);
template<> ::playapi::proto::finsky::link::ResolvedLink* Arena::CreateMaybeMessage<::playapi::proto::finsky::link::ResolvedLink>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace playapi {
namespace proto {
namespace finsky {
namespace link {

// ===================================================================

class Link final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.link.Link) */ {
 public:
  inline Link() : Link(nullptr) {}
  ~Link() override;
  explicit PROTOBUF_CONSTEXPR Link(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Link(const Link& from);
  Link(Link&& from) noexcept
    : Link() {
    *this = ::std::move(from);
  }

  inline Link& operator=(const Link& from) {
    CopyFrom(from);
    return *this;
  }
  inline Link& operator=(Link&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Link& default_instance() {
    return *internal_default_instance();
  }
  static inline const Link* internal_default_instance() {
    return reinterpret_cast<const Link*>(
               &_Link_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Link& a, Link& b) {
    a.Swap(&b);
  }
  inline void Swap(Link* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Link* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Link* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Link>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Link& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Link& from) {
    Link::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Link* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.link.Link";
  }
  protected:
  explicit Link(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUriFieldNumber = 1,
    kResolvedLinkFieldNumber = 2,
    kUriBackendFieldNumber = 3,
  };
  // optional string uri = 1;
  bool has_uri() const;
  private:
  bool _internal_has_uri() const;
  public:
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // optional .playapi.proto.finsky.link.ResolvedLink resolvedLink = 2;
  bool has_resolvedlink() const;
  private:
  bool _internal_has_resolvedlink() const;
  public:
  void clear_resolvedlink();
  const ::playapi::proto::finsky::link::ResolvedLink& resolvedlink() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::link::ResolvedLink* release_resolvedlink();
  ::playapi::proto::finsky::link::ResolvedLink* mutable_resolvedlink();
  void set_allocated_resolvedlink(::playapi::proto::finsky::link::ResolvedLink* resolvedlink);
  private:
  const ::playapi::proto::finsky::link::ResolvedLink& _internal_resolvedlink() const;
  ::playapi::proto::finsky::link::ResolvedLink* _internal_mutable_resolvedlink();
  public:
  void unsafe_arena_set_allocated_resolvedlink(
      ::playapi::proto::finsky::link::ResolvedLink* resolvedlink);
  ::playapi::proto::finsky::link::ResolvedLink* unsafe_arena_release_resolvedlink();

  // optional int32 uriBackend = 3;
  bool has_uribackend() const;
  private:
  bool _internal_has_uribackend() const;
  public:
  void clear_uribackend();
  int32_t uribackend() const;
  void set_uribackend(int32_t value);
  private:
  int32_t _internal_uribackend() const;
  void _internal_set_uribackend(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.link.Link)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
    ::playapi::proto::finsky::link::ResolvedLink* resolvedlink_;
    int32_t uribackend_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5flink_2eproto;
};
// -------------------------------------------------------------------

class OverflowLink final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.link.OverflowLink) */ {
 public:
  inline OverflowLink() : OverflowLink(nullptr) {}
  ~OverflowLink() override;
  explicit PROTOBUF_CONSTEXPR OverflowLink(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OverflowLink(const OverflowLink& from);
  OverflowLink(OverflowLink&& from) noexcept
    : OverflowLink() {
    *this = ::std::move(from);
  }

  inline OverflowLink& operator=(const OverflowLink& from) {
    CopyFrom(from);
    return *this;
  }
  inline OverflowLink& operator=(OverflowLink&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OverflowLink& default_instance() {
    return *internal_default_instance();
  }
  static inline const OverflowLink* internal_default_instance() {
    return reinterpret_cast<const OverflowLink*>(
               &_OverflowLink_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(OverflowLink& a, OverflowLink& b) {
    a.Swap(&b);
  }
  inline void Swap(OverflowLink* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OverflowLink* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OverflowLink* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OverflowLink>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OverflowLink& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OverflowLink& from) {
    OverflowLink::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OverflowLink* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.link.OverflowLink";
  }
  protected:
  explicit OverflowLink(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 1,
    kLinkFieldNumber = 2,
  };
  // optional string title = 1;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // optional .playapi.proto.finsky.link.Link link = 2;
  bool has_link() const;
  private:
  bool _internal_has_link() const;
  public:
  void clear_link();
  const ::playapi::proto::finsky::link::Link& link() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::link::Link* release_link();
  ::playapi::proto::finsky::link::Link* mutable_link();
  void set_allocated_link(::playapi::proto::finsky::link::Link* link);
  private:
  const ::playapi::proto::finsky::link::Link& _internal_link() const;
  ::playapi::proto::finsky::link::Link* _internal_mutable_link();
  public:
  void unsafe_arena_set_allocated_link(
      ::playapi::proto::finsky::link::Link* link);
  ::playapi::proto::finsky::link::Link* unsafe_arena_release_link();

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.link.OverflowLink)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::playapi::proto::finsky::link::Link* link_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5flink_2eproto;
};
// -------------------------------------------------------------------

class DirectPurchase final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.link.DirectPurchase) */ {
 public:
  inline DirectPurchase() : DirectPurchase(nullptr) {}
  ~DirectPurchase() override;
  explicit PROTOBUF_CONSTEXPR DirectPurchase(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DirectPurchase(const DirectPurchase& from);
  DirectPurchase(DirectPurchase&& from) noexcept
    : DirectPurchase() {
    *this = ::std::move(from);
  }

  inline DirectPurchase& operator=(const DirectPurchase& from) {
    CopyFrom(from);
    return *this;
  }
  inline DirectPurchase& operator=(DirectPurchase&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DirectPurchase& default_instance() {
    return *internal_default_instance();
  }
  static inline const DirectPurchase* internal_default_instance() {
    return reinterpret_cast<const DirectPurchase*>(
               &_DirectPurchase_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DirectPurchase& a, DirectPurchase& b) {
    a.Swap(&b);
  }
  inline void Swap(DirectPurchase* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DirectPurchase* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DirectPurchase* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DirectPurchase>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DirectPurchase& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DirectPurchase& from) {
    DirectPurchase::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DirectPurchase* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.link.DirectPurchase";
  }
  protected:
  explicit DirectPurchase(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDetailsUrlFieldNumber = 1,
    kPurchaseDocidFieldNumber = 2,
    kParentDocidFieldNumber = 3,
    kOfferTypeFieldNumber = 4,
  };
  // optional string detailsUrl = 1;
  bool has_detailsurl() const;
  private:
  bool _internal_has_detailsurl() const;
  public:
  void clear_detailsurl();
  const std::string& detailsurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_detailsurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_detailsurl();
  PROTOBUF_NODISCARD std::string* release_detailsurl();
  void set_allocated_detailsurl(std::string* detailsurl);
  private:
  const std::string& _internal_detailsurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_detailsurl(const std::string& value);
  std::string* _internal_mutable_detailsurl();
  public:

  // optional string purchaseDocid = 2;
  bool has_purchasedocid() const;
  private:
  bool _internal_has_purchasedocid() const;
  public:
  void clear_purchasedocid();
  const std::string& purchasedocid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_purchasedocid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_purchasedocid();
  PROTOBUF_NODISCARD std::string* release_purchasedocid();
  void set_allocated_purchasedocid(std::string* purchasedocid);
  private:
  const std::string& _internal_purchasedocid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_purchasedocid(const std::string& value);
  std::string* _internal_mutable_purchasedocid();
  public:

  // optional string parentDocid = 3;
  bool has_parentdocid() const;
  private:
  bool _internal_has_parentdocid() const;
  public:
  void clear_parentdocid();
  const std::string& parentdocid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parentdocid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parentdocid();
  PROTOBUF_NODISCARD std::string* release_parentdocid();
  void set_allocated_parentdocid(std::string* parentdocid);
  private:
  const std::string& _internal_parentdocid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parentdocid(const std::string& value);
  std::string* _internal_mutable_parentdocid();
  public:

  // optional int32 offerType = 4;
  bool has_offertype() const;
  private:
  bool _internal_has_offertype() const;
  public:
  void clear_offertype();
  int32_t offertype() const;
  void set_offertype(int32_t value);
  private:
  int32_t _internal_offertype() const;
  void _internal_set_offertype(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.link.DirectPurchase)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr detailsurl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr purchasedocid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parentdocid_;
    int32_t offertype_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5flink_2eproto;
};
// -------------------------------------------------------------------

class HelpCenter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.link.HelpCenter) */ {
 public:
  inline HelpCenter() : HelpCenter(nullptr) {}
  ~HelpCenter() override;
  explicit PROTOBUF_CONSTEXPR HelpCenter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HelpCenter(const HelpCenter& from);
  HelpCenter(HelpCenter&& from) noexcept
    : HelpCenter() {
    *this = ::std::move(from);
  }

  inline HelpCenter& operator=(const HelpCenter& from) {
    CopyFrom(from);
    return *this;
  }
  inline HelpCenter& operator=(HelpCenter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HelpCenter& default_instance() {
    return *internal_default_instance();
  }
  static inline const HelpCenter* internal_default_instance() {
    return reinterpret_cast<const HelpCenter*>(
               &_HelpCenter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(HelpCenter& a, HelpCenter& b) {
    a.Swap(&b);
  }
  inline void Swap(HelpCenter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HelpCenter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HelpCenter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HelpCenter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HelpCenter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HelpCenter& from) {
    HelpCenter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HelpCenter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.link.HelpCenter";
  }
  protected:
  explicit HelpCenter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContextIdFieldNumber = 1,
  };
  // optional string contextId = 1;
  bool has_contextid() const;
  private:
  bool _internal_has_contextid() const;
  public:
  void clear_contextid();
  const std::string& contextid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contextid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contextid();
  PROTOBUF_NODISCARD std::string* release_contextid();
  void set_allocated_contextid(std::string* contextid);
  private:
  const std::string& _internal_contextid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contextid(const std::string& value);
  std::string* _internal_mutable_contextid();
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.link.HelpCenter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contextid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5flink_2eproto;
};
// -------------------------------------------------------------------

class RedeemGiftCard final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.link.RedeemGiftCard) */ {
 public:
  inline RedeemGiftCard() : RedeemGiftCard(nullptr) {}
  ~RedeemGiftCard() override;
  explicit PROTOBUF_CONSTEXPR RedeemGiftCard(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RedeemGiftCard(const RedeemGiftCard& from);
  RedeemGiftCard(RedeemGiftCard&& from) noexcept
    : RedeemGiftCard() {
    *this = ::std::move(from);
  }

  inline RedeemGiftCard& operator=(const RedeemGiftCard& from) {
    CopyFrom(from);
    return *this;
  }
  inline RedeemGiftCard& operator=(RedeemGiftCard&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RedeemGiftCard& default_instance() {
    return *internal_default_instance();
  }
  static inline const RedeemGiftCard* internal_default_instance() {
    return reinterpret_cast<const RedeemGiftCard*>(
               &_RedeemGiftCard_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RedeemGiftCard& a, RedeemGiftCard& b) {
    a.Swap(&b);
  }
  inline void Swap(RedeemGiftCard* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RedeemGiftCard* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RedeemGiftCard* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RedeemGiftCard>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RedeemGiftCard& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RedeemGiftCard& from) {
    RedeemGiftCard::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RedeemGiftCard* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.link.RedeemGiftCard";
  }
  protected:
  explicit RedeemGiftCard(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrefillCodeFieldNumber = 1,
    kPartnerPayloadFieldNumber = 2,
  };
  // optional string prefillCode = 1;
  bool has_prefillcode() const;
  private:
  bool _internal_has_prefillcode() const;
  public:
  void clear_prefillcode();
  const std::string& prefillcode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_prefillcode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_prefillcode();
  PROTOBUF_NODISCARD std::string* release_prefillcode();
  void set_allocated_prefillcode(std::string* prefillcode);
  private:
  const std::string& _internal_prefillcode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prefillcode(const std::string& value);
  std::string* _internal_mutable_prefillcode();
  public:

  // optional string partnerPayload = 2;
  bool has_partnerpayload() const;
  private:
  bool _internal_has_partnerpayload() const;
  public:
  void clear_partnerpayload();
  const std::string& partnerpayload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_partnerpayload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_partnerpayload();
  PROTOBUF_NODISCARD std::string* release_partnerpayload();
  void set_allocated_partnerpayload(std::string* partnerpayload);
  private:
  const std::string& _internal_partnerpayload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_partnerpayload(const std::string& value);
  std::string* _internal_mutable_partnerpayload();
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.link.RedeemGiftCard)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prefillcode_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr partnerpayload_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5flink_2eproto;
};
// -------------------------------------------------------------------

class ResolvedLink final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:playapi.proto.finsky.link.ResolvedLink) */ {
 public:
  inline ResolvedLink() : ResolvedLink(nullptr) {}
  ~ResolvedLink() override;
  explicit PROTOBUF_CONSTEXPR ResolvedLink(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResolvedLink(const ResolvedLink& from);
  ResolvedLink(ResolvedLink&& from) noexcept
    : ResolvedLink() {
    *this = ::std::move(from);
  }

  inline ResolvedLink& operator=(const ResolvedLink& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResolvedLink& operator=(ResolvedLink&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResolvedLink& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResolvedLink* internal_default_instance() {
    return reinterpret_cast<const ResolvedLink*>(
               &_ResolvedLink_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ResolvedLink& a, ResolvedLink& b) {
    a.Swap(&b);
  }
  inline void Swap(ResolvedLink* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResolvedLink* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResolvedLink* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResolvedLink>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResolvedLink& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResolvedLink& from) {
    ResolvedLink::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResolvedLink* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "playapi.proto.finsky.link.ResolvedLink";
  }
  protected:
  explicit ResolvedLink(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDetailsUrlFieldNumber = 1,
    kBrowseUrlFieldNumber = 2,
    kSearchUrlFieldNumber = 3,
    kHomeUrlFieldNumber = 5,
    kServerLogsCookieFieldNumber = 7,
    kWishlistUrlFieldNumber = 9,
    kQueryFieldNumber = 11,
    kMyAccountUrlFieldNumber = 12,
    kGiftUrlFieldNumber = 14,
    kDirectPurchaseFieldNumber = 4,
    kRedeemGiftCardFieldNumber = 6,
    kDocidFieldNumber = 8,
    kHelpCenterFieldNumber = 13,
    kBackendFieldNumber = 10,
  };
  // optional string detailsUrl = 1;
  bool has_detailsurl() const;
  private:
  bool _internal_has_detailsurl() const;
  public:
  void clear_detailsurl();
  const std::string& detailsurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_detailsurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_detailsurl();
  PROTOBUF_NODISCARD std::string* release_detailsurl();
  void set_allocated_detailsurl(std::string* detailsurl);
  private:
  const std::string& _internal_detailsurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_detailsurl(const std::string& value);
  std::string* _internal_mutable_detailsurl();
  public:

  // optional string browseUrl = 2;
  bool has_browseurl() const;
  private:
  bool _internal_has_browseurl() const;
  public:
  void clear_browseurl();
  const std::string& browseurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_browseurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_browseurl();
  PROTOBUF_NODISCARD std::string* release_browseurl();
  void set_allocated_browseurl(std::string* browseurl);
  private:
  const std::string& _internal_browseurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_browseurl(const std::string& value);
  std::string* _internal_mutable_browseurl();
  public:

  // optional string searchUrl = 3;
  bool has_searchurl() const;
  private:
  bool _internal_has_searchurl() const;
  public:
  void clear_searchurl();
  const std::string& searchurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_searchurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_searchurl();
  PROTOBUF_NODISCARD std::string* release_searchurl();
  void set_allocated_searchurl(std::string* searchurl);
  private:
  const std::string& _internal_searchurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_searchurl(const std::string& value);
  std::string* _internal_mutable_searchurl();
  public:

  // optional string homeUrl = 5;
  bool has_homeurl() const;
  private:
  bool _internal_has_homeurl() const;
  public:
  void clear_homeurl();
  const std::string& homeurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_homeurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_homeurl();
  PROTOBUF_NODISCARD std::string* release_homeurl();
  void set_allocated_homeurl(std::string* homeurl);
  private:
  const std::string& _internal_homeurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_homeurl(const std::string& value);
  std::string* _internal_mutable_homeurl();
  public:

  // optional bytes serverLogsCookie = 7;
  bool has_serverlogscookie() const;
  private:
  bool _internal_has_serverlogscookie() const;
  public:
  void clear_serverlogscookie();
  const std::string& serverlogscookie() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serverlogscookie(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serverlogscookie();
  PROTOBUF_NODISCARD std::string* release_serverlogscookie();
  void set_allocated_serverlogscookie(std::string* serverlogscookie);
  private:
  const std::string& _internal_serverlogscookie() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serverlogscookie(const std::string& value);
  std::string* _internal_mutable_serverlogscookie();
  public:

  // optional string wishlistUrl = 9;
  bool has_wishlisturl() const;
  private:
  bool _internal_has_wishlisturl() const;
  public:
  void clear_wishlisturl();
  const std::string& wishlisturl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_wishlisturl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_wishlisturl();
  PROTOBUF_NODISCARD std::string* release_wishlisturl();
  void set_allocated_wishlisturl(std::string* wishlisturl);
  private:
  const std::string& _internal_wishlisturl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_wishlisturl(const std::string& value);
  std::string* _internal_mutable_wishlisturl();
  public:

  // optional string query = 11;
  bool has_query() const;
  private:
  bool _internal_has_query() const;
  public:
  void clear_query();
  const std::string& query() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_query(ArgT0&& arg0, ArgT... args);
  std::string* mutable_query();
  PROTOBUF_NODISCARD std::string* release_query();
  void set_allocated_query(std::string* query);
  private:
  const std::string& _internal_query() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_query(const std::string& value);
  std::string* _internal_mutable_query();
  public:

  // optional string myAccountUrl = 12;
  bool has_myaccounturl() const;
  private:
  bool _internal_has_myaccounturl() const;
  public:
  void clear_myaccounturl();
  const std::string& myaccounturl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_myaccounturl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_myaccounturl();
  PROTOBUF_NODISCARD std::string* release_myaccounturl();
  void set_allocated_myaccounturl(std::string* myaccounturl);
  private:
  const std::string& _internal_myaccounturl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_myaccounturl(const std::string& value);
  std::string* _internal_mutable_myaccounturl();
  public:

  // optional string giftUrl = 14;
  bool has_gifturl() const;
  private:
  bool _internal_has_gifturl() const;
  public:
  void clear_gifturl();
  const std::string& gifturl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gifturl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gifturl();
  PROTOBUF_NODISCARD std::string* release_gifturl();
  void set_allocated_gifturl(std::string* gifturl);
  private:
  const std::string& _internal_gifturl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gifturl(const std::string& value);
  std::string* _internal_mutable_gifturl();
  public:

  // optional .playapi.proto.finsky.link.DirectPurchase directPurchase = 4;
  bool has_directpurchase() const;
  private:
  bool _internal_has_directpurchase() const;
  public:
  void clear_directpurchase();
  const ::playapi::proto::finsky::link::DirectPurchase& directpurchase() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::link::DirectPurchase* release_directpurchase();
  ::playapi::proto::finsky::link::DirectPurchase* mutable_directpurchase();
  void set_allocated_directpurchase(::playapi::proto::finsky::link::DirectPurchase* directpurchase);
  private:
  const ::playapi::proto::finsky::link::DirectPurchase& _internal_directpurchase() const;
  ::playapi::proto::finsky::link::DirectPurchase* _internal_mutable_directpurchase();
  public:
  void unsafe_arena_set_allocated_directpurchase(
      ::playapi::proto::finsky::link::DirectPurchase* directpurchase);
  ::playapi::proto::finsky::link::DirectPurchase* unsafe_arena_release_directpurchase();

  // optional .playapi.proto.finsky.link.RedeemGiftCard redeemGiftCard = 6;
  bool has_redeemgiftcard() const;
  private:
  bool _internal_has_redeemgiftcard() const;
  public:
  void clear_redeemgiftcard();
  const ::playapi::proto::finsky::link::RedeemGiftCard& redeemgiftcard() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::link::RedeemGiftCard* release_redeemgiftcard();
  ::playapi::proto::finsky::link::RedeemGiftCard* mutable_redeemgiftcard();
  void set_allocated_redeemgiftcard(::playapi::proto::finsky::link::RedeemGiftCard* redeemgiftcard);
  private:
  const ::playapi::proto::finsky::link::RedeemGiftCard& _internal_redeemgiftcard() const;
  ::playapi::proto::finsky::link::RedeemGiftCard* _internal_mutable_redeemgiftcard();
  public:
  void unsafe_arena_set_allocated_redeemgiftcard(
      ::playapi::proto::finsky::link::RedeemGiftCard* redeemgiftcard);
  ::playapi::proto::finsky::link::RedeemGiftCard* unsafe_arena_release_redeemgiftcard();

  // optional .playapi.proto.finsky.Docid docid = 8;
  bool has_docid() const;
  private:
  bool _internal_has_docid() const;
  public:
  void clear_docid();
  const ::playapi::proto::finsky::Docid& docid() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::Docid* release_docid();
  ::playapi::proto::finsky::Docid* mutable_docid();
  void set_allocated_docid(::playapi::proto::finsky::Docid* docid);
  private:
  const ::playapi::proto::finsky::Docid& _internal_docid() const;
  ::playapi::proto::finsky::Docid* _internal_mutable_docid();
  public:
  void unsafe_arena_set_allocated_docid(
      ::playapi::proto::finsky::Docid* docid);
  ::playapi::proto::finsky::Docid* unsafe_arena_release_docid();

  // optional .playapi.proto.finsky.link.HelpCenter helpCenter = 13;
  bool has_helpcenter() const;
  private:
  bool _internal_has_helpcenter() const;
  public:
  void clear_helpcenter();
  const ::playapi::proto::finsky::link::HelpCenter& helpcenter() const;
  PROTOBUF_NODISCARD ::playapi::proto::finsky::link::HelpCenter* release_helpcenter();
  ::playapi::proto::finsky::link::HelpCenter* mutable_helpcenter();
  void set_allocated_helpcenter(::playapi::proto::finsky::link::HelpCenter* helpcenter);
  private:
  const ::playapi::proto::finsky::link::HelpCenter& _internal_helpcenter() const;
  ::playapi::proto::finsky::link::HelpCenter* _internal_mutable_helpcenter();
  public:
  void unsafe_arena_set_allocated_helpcenter(
      ::playapi::proto::finsky::link::HelpCenter* helpcenter);
  ::playapi::proto::finsky::link::HelpCenter* unsafe_arena_release_helpcenter();

  // optional int32 backend = 10;
  bool has_backend() const;
  private:
  bool _internal_has_backend() const;
  public:
  void clear_backend();
  int32_t backend() const;
  void set_backend(int32_t value);
  private:
  int32_t _internal_backend() const;
  void _internal_set_backend(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:playapi.proto.finsky.link.ResolvedLink)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr detailsurl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr browseurl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr searchurl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr homeurl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serverlogscookie_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr wishlisturl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr query_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr myaccounturl_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gifturl_;
    ::playapi::proto::finsky::link::DirectPurchase* directpurchase_;
    ::playapi::proto::finsky::link::RedeemGiftCard* redeemgiftcard_;
    ::playapi::proto::finsky::Docid* docid_;
    ::playapi::proto::finsky::link::HelpCenter* helpcenter_;
    int32_t backend_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_play_5flink_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Link

// optional string uri = 1;
inline bool Link::_internal_has_uri() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Link::has_uri() const {
  return _internal_has_uri();
}
inline void Link::clear_uri() {
  _impl_.uri_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Link::uri() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.link.Link.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Link::set_uri(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.uri_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.link.Link.uri)
}
inline std::string* Link::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.link.Link.uri)
  return _s;
}
inline const std::string& Link::_internal_uri() const {
  return _impl_.uri_.Get();
}
inline void Link::_internal_set_uri(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.uri_.Set(value, GetArenaForAllocation());
}
inline std::string* Link::_internal_mutable_uri() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.uri_.Mutable(GetArenaForAllocation());
}
inline std::string* Link::release_uri() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.link.Link.uri)
  if (!_internal_has_uri()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.uri_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uri_.IsDefault()) {
    _impl_.uri_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Link::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.uri_.SetAllocated(uri, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uri_.IsDefault()) {
    _impl_.uri_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.link.Link.uri)
}

// optional .playapi.proto.finsky.link.ResolvedLink resolvedLink = 2;
inline bool Link::_internal_has_resolvedlink() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.resolvedlink_ != nullptr);
  return value;
}
inline bool Link::has_resolvedlink() const {
  return _internal_has_resolvedlink();
}
inline void Link::clear_resolvedlink() {
  if (_impl_.resolvedlink_ != nullptr) _impl_.resolvedlink_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::playapi::proto::finsky::link::ResolvedLink& Link::_internal_resolvedlink() const {
  const ::playapi::proto::finsky::link::ResolvedLink* p = _impl_.resolvedlink_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::link::ResolvedLink&>(
      ::playapi::proto::finsky::link::_ResolvedLink_default_instance_);
}
inline const ::playapi::proto::finsky::link::ResolvedLink& Link::resolvedlink() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.link.Link.resolvedLink)
  return _internal_resolvedlink();
}
inline void Link::unsafe_arena_set_allocated_resolvedlink(
    ::playapi::proto::finsky::link::ResolvedLink* resolvedlink) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.resolvedlink_);
  }
  _impl_.resolvedlink_ = resolvedlink;
  if (resolvedlink) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.link.Link.resolvedLink)
}
inline ::playapi::proto::finsky::link::ResolvedLink* Link::release_resolvedlink() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::playapi::proto::finsky::link::ResolvedLink* temp = _impl_.resolvedlink_;
  _impl_.resolvedlink_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::link::ResolvedLink* Link::unsafe_arena_release_resolvedlink() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.link.Link.resolvedLink)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::playapi::proto::finsky::link::ResolvedLink* temp = _impl_.resolvedlink_;
  _impl_.resolvedlink_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::link::ResolvedLink* Link::_internal_mutable_resolvedlink() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.resolvedlink_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::link::ResolvedLink>(GetArenaForAllocation());
    _impl_.resolvedlink_ = p;
  }
  return _impl_.resolvedlink_;
}
inline ::playapi::proto::finsky::link::ResolvedLink* Link::mutable_resolvedlink() {
  ::playapi::proto::finsky::link::ResolvedLink* _msg = _internal_mutable_resolvedlink();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.link.Link.resolvedLink)
  return _msg;
}
inline void Link::set_allocated_resolvedlink(::playapi::proto::finsky::link::ResolvedLink* resolvedlink) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.resolvedlink_;
  }
  if (resolvedlink) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(resolvedlink);
    if (message_arena != submessage_arena) {
      resolvedlink = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resolvedlink, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.resolvedlink_ = resolvedlink;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.link.Link.resolvedLink)
}

// optional int32 uriBackend = 3;
inline bool Link::_internal_has_uribackend() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Link::has_uribackend() const {
  return _internal_has_uribackend();
}
inline void Link::clear_uribackend() {
  _impl_.uribackend_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t Link::_internal_uribackend() const {
  return _impl_.uribackend_;
}
inline int32_t Link::uribackend() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.link.Link.uriBackend)
  return _internal_uribackend();
}
inline void Link::_internal_set_uribackend(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.uribackend_ = value;
}
inline void Link::set_uribackend(int32_t value) {
  _internal_set_uribackend(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.link.Link.uriBackend)
}

// -------------------------------------------------------------------

// OverflowLink

// optional string title = 1;
inline bool OverflowLink::_internal_has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OverflowLink::has_title() const {
  return _internal_has_title();
}
inline void OverflowLink::clear_title() {
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OverflowLink::title() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.link.OverflowLink.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OverflowLink::set_title(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.link.OverflowLink.title)
}
inline std::string* OverflowLink::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.link.OverflowLink.title)
  return _s;
}
inline const std::string& OverflowLink::_internal_title() const {
  return _impl_.title_.Get();
}
inline void OverflowLink::_internal_set_title(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* OverflowLink::_internal_mutable_title() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* OverflowLink::release_title() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.link.OverflowLink.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.title_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void OverflowLink::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.link.OverflowLink.title)
}

// optional .playapi.proto.finsky.link.Link link = 2;
inline bool OverflowLink::_internal_has_link() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.link_ != nullptr);
  return value;
}
inline bool OverflowLink::has_link() const {
  return _internal_has_link();
}
inline void OverflowLink::clear_link() {
  if (_impl_.link_ != nullptr) _impl_.link_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::playapi::proto::finsky::link::Link& OverflowLink::_internal_link() const {
  const ::playapi::proto::finsky::link::Link* p = _impl_.link_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::link::Link&>(
      ::playapi::proto::finsky::link::_Link_default_instance_);
}
inline const ::playapi::proto::finsky::link::Link& OverflowLink::link() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.link.OverflowLink.link)
  return _internal_link();
}
inline void OverflowLink::unsafe_arena_set_allocated_link(
    ::playapi::proto::finsky::link::Link* link) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.link_);
  }
  _impl_.link_ = link;
  if (link) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.link.OverflowLink.link)
}
inline ::playapi::proto::finsky::link::Link* OverflowLink::release_link() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::playapi::proto::finsky::link::Link* temp = _impl_.link_;
  _impl_.link_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::link::Link* OverflowLink::unsafe_arena_release_link() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.link.OverflowLink.link)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::playapi::proto::finsky::link::Link* temp = _impl_.link_;
  _impl_.link_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::link::Link* OverflowLink::_internal_mutable_link() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.link_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::link::Link>(GetArenaForAllocation());
    _impl_.link_ = p;
  }
  return _impl_.link_;
}
inline ::playapi::proto::finsky::link::Link* OverflowLink::mutable_link() {
  ::playapi::proto::finsky::link::Link* _msg = _internal_mutable_link();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.link.OverflowLink.link)
  return _msg;
}
inline void OverflowLink::set_allocated_link(::playapi::proto::finsky::link::Link* link) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.link_;
  }
  if (link) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(link);
    if (message_arena != submessage_arena) {
      link = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, link, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.link_ = link;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.link.OverflowLink.link)
}

// -------------------------------------------------------------------

// DirectPurchase

// optional string detailsUrl = 1;
inline bool DirectPurchase::_internal_has_detailsurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DirectPurchase::has_detailsurl() const {
  return _internal_has_detailsurl();
}
inline void DirectPurchase::clear_detailsurl() {
  _impl_.detailsurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DirectPurchase::detailsurl() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.link.DirectPurchase.detailsUrl)
  return _internal_detailsurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DirectPurchase::set_detailsurl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.detailsurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.link.DirectPurchase.detailsUrl)
}
inline std::string* DirectPurchase::mutable_detailsurl() {
  std::string* _s = _internal_mutable_detailsurl();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.link.DirectPurchase.detailsUrl)
  return _s;
}
inline const std::string& DirectPurchase::_internal_detailsurl() const {
  return _impl_.detailsurl_.Get();
}
inline void DirectPurchase::_internal_set_detailsurl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.detailsurl_.Set(value, GetArenaForAllocation());
}
inline std::string* DirectPurchase::_internal_mutable_detailsurl() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.detailsurl_.Mutable(GetArenaForAllocation());
}
inline std::string* DirectPurchase::release_detailsurl() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.link.DirectPurchase.detailsUrl)
  if (!_internal_has_detailsurl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.detailsurl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.detailsurl_.IsDefault()) {
    _impl_.detailsurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DirectPurchase::set_allocated_detailsurl(std::string* detailsurl) {
  if (detailsurl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.detailsurl_.SetAllocated(detailsurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.detailsurl_.IsDefault()) {
    _impl_.detailsurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.link.DirectPurchase.detailsUrl)
}

// optional string purchaseDocid = 2;
inline bool DirectPurchase::_internal_has_purchasedocid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DirectPurchase::has_purchasedocid() const {
  return _internal_has_purchasedocid();
}
inline void DirectPurchase::clear_purchasedocid() {
  _impl_.purchasedocid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DirectPurchase::purchasedocid() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.link.DirectPurchase.purchaseDocid)
  return _internal_purchasedocid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DirectPurchase::set_purchasedocid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.purchasedocid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.link.DirectPurchase.purchaseDocid)
}
inline std::string* DirectPurchase::mutable_purchasedocid() {
  std::string* _s = _internal_mutable_purchasedocid();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.link.DirectPurchase.purchaseDocid)
  return _s;
}
inline const std::string& DirectPurchase::_internal_purchasedocid() const {
  return _impl_.purchasedocid_.Get();
}
inline void DirectPurchase::_internal_set_purchasedocid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.purchasedocid_.Set(value, GetArenaForAllocation());
}
inline std::string* DirectPurchase::_internal_mutable_purchasedocid() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.purchasedocid_.Mutable(GetArenaForAllocation());
}
inline std::string* DirectPurchase::release_purchasedocid() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.link.DirectPurchase.purchaseDocid)
  if (!_internal_has_purchasedocid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.purchasedocid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.purchasedocid_.IsDefault()) {
    _impl_.purchasedocid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DirectPurchase::set_allocated_purchasedocid(std::string* purchasedocid) {
  if (purchasedocid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.purchasedocid_.SetAllocated(purchasedocid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.purchasedocid_.IsDefault()) {
    _impl_.purchasedocid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.link.DirectPurchase.purchaseDocid)
}

// optional string parentDocid = 3;
inline bool DirectPurchase::_internal_has_parentdocid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DirectPurchase::has_parentdocid() const {
  return _internal_has_parentdocid();
}
inline void DirectPurchase::clear_parentdocid() {
  _impl_.parentdocid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& DirectPurchase::parentdocid() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.link.DirectPurchase.parentDocid)
  return _internal_parentdocid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DirectPurchase::set_parentdocid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.parentdocid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.link.DirectPurchase.parentDocid)
}
inline std::string* DirectPurchase::mutable_parentdocid() {
  std::string* _s = _internal_mutable_parentdocid();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.link.DirectPurchase.parentDocid)
  return _s;
}
inline const std::string& DirectPurchase::_internal_parentdocid() const {
  return _impl_.parentdocid_.Get();
}
inline void DirectPurchase::_internal_set_parentdocid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.parentdocid_.Set(value, GetArenaForAllocation());
}
inline std::string* DirectPurchase::_internal_mutable_parentdocid() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.parentdocid_.Mutable(GetArenaForAllocation());
}
inline std::string* DirectPurchase::release_parentdocid() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.link.DirectPurchase.parentDocid)
  if (!_internal_has_parentdocid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.parentdocid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parentdocid_.IsDefault()) {
    _impl_.parentdocid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DirectPurchase::set_allocated_parentdocid(std::string* parentdocid) {
  if (parentdocid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.parentdocid_.SetAllocated(parentdocid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parentdocid_.IsDefault()) {
    _impl_.parentdocid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.link.DirectPurchase.parentDocid)
}

// optional int32 offerType = 4;
inline bool DirectPurchase::_internal_has_offertype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DirectPurchase::has_offertype() const {
  return _internal_has_offertype();
}
inline void DirectPurchase::clear_offertype() {
  _impl_.offertype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t DirectPurchase::_internal_offertype() const {
  return _impl_.offertype_;
}
inline int32_t DirectPurchase::offertype() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.link.DirectPurchase.offerType)
  return _internal_offertype();
}
inline void DirectPurchase::_internal_set_offertype(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.offertype_ = value;
}
inline void DirectPurchase::set_offertype(int32_t value) {
  _internal_set_offertype(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.link.DirectPurchase.offerType)
}

// -------------------------------------------------------------------

// HelpCenter

// optional string contextId = 1;
inline bool HelpCenter::_internal_has_contextid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HelpCenter::has_contextid() const {
  return _internal_has_contextid();
}
inline void HelpCenter::clear_contextid() {
  _impl_.contextid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& HelpCenter::contextid() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.link.HelpCenter.contextId)
  return _internal_contextid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HelpCenter::set_contextid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.contextid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.link.HelpCenter.contextId)
}
inline std::string* HelpCenter::mutable_contextid() {
  std::string* _s = _internal_mutable_contextid();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.link.HelpCenter.contextId)
  return _s;
}
inline const std::string& HelpCenter::_internal_contextid() const {
  return _impl_.contextid_.Get();
}
inline void HelpCenter::_internal_set_contextid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.contextid_.Set(value, GetArenaForAllocation());
}
inline std::string* HelpCenter::_internal_mutable_contextid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.contextid_.Mutable(GetArenaForAllocation());
}
inline std::string* HelpCenter::release_contextid() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.link.HelpCenter.contextId)
  if (!_internal_has_contextid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.contextid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contextid_.IsDefault()) {
    _impl_.contextid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void HelpCenter::set_allocated_contextid(std::string* contextid) {
  if (contextid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.contextid_.SetAllocated(contextid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contextid_.IsDefault()) {
    _impl_.contextid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.link.HelpCenter.contextId)
}

// -------------------------------------------------------------------

// RedeemGiftCard

// optional string prefillCode = 1;
inline bool RedeemGiftCard::_internal_has_prefillcode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RedeemGiftCard::has_prefillcode() const {
  return _internal_has_prefillcode();
}
inline void RedeemGiftCard::clear_prefillcode() {
  _impl_.prefillcode_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RedeemGiftCard::prefillcode() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.link.RedeemGiftCard.prefillCode)
  return _internal_prefillcode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RedeemGiftCard::set_prefillcode(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.prefillcode_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.link.RedeemGiftCard.prefillCode)
}
inline std::string* RedeemGiftCard::mutable_prefillcode() {
  std::string* _s = _internal_mutable_prefillcode();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.link.RedeemGiftCard.prefillCode)
  return _s;
}
inline const std::string& RedeemGiftCard::_internal_prefillcode() const {
  return _impl_.prefillcode_.Get();
}
inline void RedeemGiftCard::_internal_set_prefillcode(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.prefillcode_.Set(value, GetArenaForAllocation());
}
inline std::string* RedeemGiftCard::_internal_mutable_prefillcode() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.prefillcode_.Mutable(GetArenaForAllocation());
}
inline std::string* RedeemGiftCard::release_prefillcode() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.link.RedeemGiftCard.prefillCode)
  if (!_internal_has_prefillcode()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.prefillcode_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.prefillcode_.IsDefault()) {
    _impl_.prefillcode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RedeemGiftCard::set_allocated_prefillcode(std::string* prefillcode) {
  if (prefillcode != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.prefillcode_.SetAllocated(prefillcode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.prefillcode_.IsDefault()) {
    _impl_.prefillcode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.link.RedeemGiftCard.prefillCode)
}

// optional string partnerPayload = 2;
inline bool RedeemGiftCard::_internal_has_partnerpayload() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RedeemGiftCard::has_partnerpayload() const {
  return _internal_has_partnerpayload();
}
inline void RedeemGiftCard::clear_partnerpayload() {
  _impl_.partnerpayload_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RedeemGiftCard::partnerpayload() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.link.RedeemGiftCard.partnerPayload)
  return _internal_partnerpayload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RedeemGiftCard::set_partnerpayload(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.partnerpayload_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.link.RedeemGiftCard.partnerPayload)
}
inline std::string* RedeemGiftCard::mutable_partnerpayload() {
  std::string* _s = _internal_mutable_partnerpayload();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.link.RedeemGiftCard.partnerPayload)
  return _s;
}
inline const std::string& RedeemGiftCard::_internal_partnerpayload() const {
  return _impl_.partnerpayload_.Get();
}
inline void RedeemGiftCard::_internal_set_partnerpayload(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.partnerpayload_.Set(value, GetArenaForAllocation());
}
inline std::string* RedeemGiftCard::_internal_mutable_partnerpayload() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.partnerpayload_.Mutable(GetArenaForAllocation());
}
inline std::string* RedeemGiftCard::release_partnerpayload() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.link.RedeemGiftCard.partnerPayload)
  if (!_internal_has_partnerpayload()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.partnerpayload_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.partnerpayload_.IsDefault()) {
    _impl_.partnerpayload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void RedeemGiftCard::set_allocated_partnerpayload(std::string* partnerpayload) {
  if (partnerpayload != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.partnerpayload_.SetAllocated(partnerpayload, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.partnerpayload_.IsDefault()) {
    _impl_.partnerpayload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.link.RedeemGiftCard.partnerPayload)
}

// -------------------------------------------------------------------

// ResolvedLink

// optional string detailsUrl = 1;
inline bool ResolvedLink::_internal_has_detailsurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResolvedLink::has_detailsurl() const {
  return _internal_has_detailsurl();
}
inline void ResolvedLink::clear_detailsurl() {
  _impl_.detailsurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ResolvedLink::detailsurl() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.link.ResolvedLink.detailsUrl)
  return _internal_detailsurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResolvedLink::set_detailsurl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.detailsurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.link.ResolvedLink.detailsUrl)
}
inline std::string* ResolvedLink::mutable_detailsurl() {
  std::string* _s = _internal_mutable_detailsurl();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.link.ResolvedLink.detailsUrl)
  return _s;
}
inline const std::string& ResolvedLink::_internal_detailsurl() const {
  return _impl_.detailsurl_.Get();
}
inline void ResolvedLink::_internal_set_detailsurl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.detailsurl_.Set(value, GetArenaForAllocation());
}
inline std::string* ResolvedLink::_internal_mutable_detailsurl() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.detailsurl_.Mutable(GetArenaForAllocation());
}
inline std::string* ResolvedLink::release_detailsurl() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.link.ResolvedLink.detailsUrl)
  if (!_internal_has_detailsurl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.detailsurl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.detailsurl_.IsDefault()) {
    _impl_.detailsurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ResolvedLink::set_allocated_detailsurl(std::string* detailsurl) {
  if (detailsurl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.detailsurl_.SetAllocated(detailsurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.detailsurl_.IsDefault()) {
    _impl_.detailsurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.link.ResolvedLink.detailsUrl)
}

// optional string browseUrl = 2;
inline bool ResolvedLink::_internal_has_browseurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ResolvedLink::has_browseurl() const {
  return _internal_has_browseurl();
}
inline void ResolvedLink::clear_browseurl() {
  _impl_.browseurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ResolvedLink::browseurl() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.link.ResolvedLink.browseUrl)
  return _internal_browseurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResolvedLink::set_browseurl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.browseurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.link.ResolvedLink.browseUrl)
}
inline std::string* ResolvedLink::mutable_browseurl() {
  std::string* _s = _internal_mutable_browseurl();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.link.ResolvedLink.browseUrl)
  return _s;
}
inline const std::string& ResolvedLink::_internal_browseurl() const {
  return _impl_.browseurl_.Get();
}
inline void ResolvedLink::_internal_set_browseurl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.browseurl_.Set(value, GetArenaForAllocation());
}
inline std::string* ResolvedLink::_internal_mutable_browseurl() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.browseurl_.Mutable(GetArenaForAllocation());
}
inline std::string* ResolvedLink::release_browseurl() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.link.ResolvedLink.browseUrl)
  if (!_internal_has_browseurl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.browseurl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.browseurl_.IsDefault()) {
    _impl_.browseurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ResolvedLink::set_allocated_browseurl(std::string* browseurl) {
  if (browseurl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.browseurl_.SetAllocated(browseurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.browseurl_.IsDefault()) {
    _impl_.browseurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.link.ResolvedLink.browseUrl)
}

// optional string searchUrl = 3;
inline bool ResolvedLink::_internal_has_searchurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ResolvedLink::has_searchurl() const {
  return _internal_has_searchurl();
}
inline void ResolvedLink::clear_searchurl() {
  _impl_.searchurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ResolvedLink::searchurl() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.link.ResolvedLink.searchUrl)
  return _internal_searchurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResolvedLink::set_searchurl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.searchurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.link.ResolvedLink.searchUrl)
}
inline std::string* ResolvedLink::mutable_searchurl() {
  std::string* _s = _internal_mutable_searchurl();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.link.ResolvedLink.searchUrl)
  return _s;
}
inline const std::string& ResolvedLink::_internal_searchurl() const {
  return _impl_.searchurl_.Get();
}
inline void ResolvedLink::_internal_set_searchurl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.searchurl_.Set(value, GetArenaForAllocation());
}
inline std::string* ResolvedLink::_internal_mutable_searchurl() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.searchurl_.Mutable(GetArenaForAllocation());
}
inline std::string* ResolvedLink::release_searchurl() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.link.ResolvedLink.searchUrl)
  if (!_internal_has_searchurl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.searchurl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.searchurl_.IsDefault()) {
    _impl_.searchurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ResolvedLink::set_allocated_searchurl(std::string* searchurl) {
  if (searchurl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.searchurl_.SetAllocated(searchurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.searchurl_.IsDefault()) {
    _impl_.searchurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.link.ResolvedLink.searchUrl)
}

// optional .playapi.proto.finsky.link.DirectPurchase directPurchase = 4;
inline bool ResolvedLink::_internal_has_directpurchase() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.directpurchase_ != nullptr);
  return value;
}
inline bool ResolvedLink::has_directpurchase() const {
  return _internal_has_directpurchase();
}
inline void ResolvedLink::clear_directpurchase() {
  if (_impl_.directpurchase_ != nullptr) _impl_.directpurchase_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const ::playapi::proto::finsky::link::DirectPurchase& ResolvedLink::_internal_directpurchase() const {
  const ::playapi::proto::finsky::link::DirectPurchase* p = _impl_.directpurchase_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::link::DirectPurchase&>(
      ::playapi::proto::finsky::link::_DirectPurchase_default_instance_);
}
inline const ::playapi::proto::finsky::link::DirectPurchase& ResolvedLink::directpurchase() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.link.ResolvedLink.directPurchase)
  return _internal_directpurchase();
}
inline void ResolvedLink::unsafe_arena_set_allocated_directpurchase(
    ::playapi::proto::finsky::link::DirectPurchase* directpurchase) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.directpurchase_);
  }
  _impl_.directpurchase_ = directpurchase;
  if (directpurchase) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.link.ResolvedLink.directPurchase)
}
inline ::playapi::proto::finsky::link::DirectPurchase* ResolvedLink::release_directpurchase() {
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::playapi::proto::finsky::link::DirectPurchase* temp = _impl_.directpurchase_;
  _impl_.directpurchase_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::link::DirectPurchase* ResolvedLink::unsafe_arena_release_directpurchase() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.link.ResolvedLink.directPurchase)
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::playapi::proto::finsky::link::DirectPurchase* temp = _impl_.directpurchase_;
  _impl_.directpurchase_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::link::DirectPurchase* ResolvedLink::_internal_mutable_directpurchase() {
  _impl_._has_bits_[0] |= 0x00000200u;
  if (_impl_.directpurchase_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::link::DirectPurchase>(GetArenaForAllocation());
    _impl_.directpurchase_ = p;
  }
  return _impl_.directpurchase_;
}
inline ::playapi::proto::finsky::link::DirectPurchase* ResolvedLink::mutable_directpurchase() {
  ::playapi::proto::finsky::link::DirectPurchase* _msg = _internal_mutable_directpurchase();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.link.ResolvedLink.directPurchase)
  return _msg;
}
inline void ResolvedLink::set_allocated_directpurchase(::playapi::proto::finsky::link::DirectPurchase* directpurchase) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.directpurchase_;
  }
  if (directpurchase) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(directpurchase);
    if (message_arena != submessage_arena) {
      directpurchase = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, directpurchase, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.directpurchase_ = directpurchase;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.link.ResolvedLink.directPurchase)
}

// optional string homeUrl = 5;
inline bool ResolvedLink::_internal_has_homeurl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ResolvedLink::has_homeurl() const {
  return _internal_has_homeurl();
}
inline void ResolvedLink::clear_homeurl() {
  _impl_.homeurl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ResolvedLink::homeurl() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.link.ResolvedLink.homeUrl)
  return _internal_homeurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResolvedLink::set_homeurl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.homeurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.link.ResolvedLink.homeUrl)
}
inline std::string* ResolvedLink::mutable_homeurl() {
  std::string* _s = _internal_mutable_homeurl();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.link.ResolvedLink.homeUrl)
  return _s;
}
inline const std::string& ResolvedLink::_internal_homeurl() const {
  return _impl_.homeurl_.Get();
}
inline void ResolvedLink::_internal_set_homeurl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.homeurl_.Set(value, GetArenaForAllocation());
}
inline std::string* ResolvedLink::_internal_mutable_homeurl() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.homeurl_.Mutable(GetArenaForAllocation());
}
inline std::string* ResolvedLink::release_homeurl() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.link.ResolvedLink.homeUrl)
  if (!_internal_has_homeurl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.homeurl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.homeurl_.IsDefault()) {
    _impl_.homeurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ResolvedLink::set_allocated_homeurl(std::string* homeurl) {
  if (homeurl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.homeurl_.SetAllocated(homeurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.homeurl_.IsDefault()) {
    _impl_.homeurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.link.ResolvedLink.homeUrl)
}

// optional .playapi.proto.finsky.link.RedeemGiftCard redeemGiftCard = 6;
inline bool ResolvedLink::_internal_has_redeemgiftcard() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.redeemgiftcard_ != nullptr);
  return value;
}
inline bool ResolvedLink::has_redeemgiftcard() const {
  return _internal_has_redeemgiftcard();
}
inline void ResolvedLink::clear_redeemgiftcard() {
  if (_impl_.redeemgiftcard_ != nullptr) _impl_.redeemgiftcard_->Clear();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const ::playapi::proto::finsky::link::RedeemGiftCard& ResolvedLink::_internal_redeemgiftcard() const {
  const ::playapi::proto::finsky::link::RedeemGiftCard* p = _impl_.redeemgiftcard_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::link::RedeemGiftCard&>(
      ::playapi::proto::finsky::link::_RedeemGiftCard_default_instance_);
}
inline const ::playapi::proto::finsky::link::RedeemGiftCard& ResolvedLink::redeemgiftcard() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.link.ResolvedLink.redeemGiftCard)
  return _internal_redeemgiftcard();
}
inline void ResolvedLink::unsafe_arena_set_allocated_redeemgiftcard(
    ::playapi::proto::finsky::link::RedeemGiftCard* redeemgiftcard) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.redeemgiftcard_);
  }
  _impl_.redeemgiftcard_ = redeemgiftcard;
  if (redeemgiftcard) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.link.ResolvedLink.redeemGiftCard)
}
inline ::playapi::proto::finsky::link::RedeemGiftCard* ResolvedLink::release_redeemgiftcard() {
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::playapi::proto::finsky::link::RedeemGiftCard* temp = _impl_.redeemgiftcard_;
  _impl_.redeemgiftcard_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::link::RedeemGiftCard* ResolvedLink::unsafe_arena_release_redeemgiftcard() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.link.ResolvedLink.redeemGiftCard)
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::playapi::proto::finsky::link::RedeemGiftCard* temp = _impl_.redeemgiftcard_;
  _impl_.redeemgiftcard_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::link::RedeemGiftCard* ResolvedLink::_internal_mutable_redeemgiftcard() {
  _impl_._has_bits_[0] |= 0x00000400u;
  if (_impl_.redeemgiftcard_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::link::RedeemGiftCard>(GetArenaForAllocation());
    _impl_.redeemgiftcard_ = p;
  }
  return _impl_.redeemgiftcard_;
}
inline ::playapi::proto::finsky::link::RedeemGiftCard* ResolvedLink::mutable_redeemgiftcard() {
  ::playapi::proto::finsky::link::RedeemGiftCard* _msg = _internal_mutable_redeemgiftcard();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.link.ResolvedLink.redeemGiftCard)
  return _msg;
}
inline void ResolvedLink::set_allocated_redeemgiftcard(::playapi::proto::finsky::link::RedeemGiftCard* redeemgiftcard) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.redeemgiftcard_;
  }
  if (redeemgiftcard) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(redeemgiftcard);
    if (message_arena != submessage_arena) {
      redeemgiftcard = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, redeemgiftcard, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.redeemgiftcard_ = redeemgiftcard;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.link.ResolvedLink.redeemGiftCard)
}

// optional bytes serverLogsCookie = 7;
inline bool ResolvedLink::_internal_has_serverlogscookie() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ResolvedLink::has_serverlogscookie() const {
  return _internal_has_serverlogscookie();
}
inline void ResolvedLink::clear_serverlogscookie() {
  _impl_.serverlogscookie_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& ResolvedLink::serverlogscookie() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.link.ResolvedLink.serverLogsCookie)
  return _internal_serverlogscookie();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResolvedLink::set_serverlogscookie(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.serverlogscookie_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.link.ResolvedLink.serverLogsCookie)
}
inline std::string* ResolvedLink::mutable_serverlogscookie() {
  std::string* _s = _internal_mutable_serverlogscookie();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.link.ResolvedLink.serverLogsCookie)
  return _s;
}
inline const std::string& ResolvedLink::_internal_serverlogscookie() const {
  return _impl_.serverlogscookie_.Get();
}
inline void ResolvedLink::_internal_set_serverlogscookie(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.serverlogscookie_.Set(value, GetArenaForAllocation());
}
inline std::string* ResolvedLink::_internal_mutable_serverlogscookie() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.serverlogscookie_.Mutable(GetArenaForAllocation());
}
inline std::string* ResolvedLink::release_serverlogscookie() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.link.ResolvedLink.serverLogsCookie)
  if (!_internal_has_serverlogscookie()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.serverlogscookie_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.serverlogscookie_.IsDefault()) {
    _impl_.serverlogscookie_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ResolvedLink::set_allocated_serverlogscookie(std::string* serverlogscookie) {
  if (serverlogscookie != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.serverlogscookie_.SetAllocated(serverlogscookie, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.serverlogscookie_.IsDefault()) {
    _impl_.serverlogscookie_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.link.ResolvedLink.serverLogsCookie)
}

// optional .playapi.proto.finsky.Docid docid = 8;
inline bool ResolvedLink::_internal_has_docid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.docid_ != nullptr);
  return value;
}
inline bool ResolvedLink::has_docid() const {
  return _internal_has_docid();
}
inline const ::playapi::proto::finsky::Docid& ResolvedLink::_internal_docid() const {
  const ::playapi::proto::finsky::Docid* p = _impl_.docid_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::Docid&>(
      ::playapi::proto::finsky::_Docid_default_instance_);
}
inline const ::playapi::proto::finsky::Docid& ResolvedLink::docid() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.link.ResolvedLink.docid)
  return _internal_docid();
}
inline void ResolvedLink::unsafe_arena_set_allocated_docid(
    ::playapi::proto::finsky::Docid* docid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.docid_);
  }
  _impl_.docid_ = docid;
  if (docid) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.link.ResolvedLink.docid)
}
inline ::playapi::proto::finsky::Docid* ResolvedLink::release_docid() {
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::playapi::proto::finsky::Docid* temp = _impl_.docid_;
  _impl_.docid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::Docid* ResolvedLink::unsafe_arena_release_docid() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.link.ResolvedLink.docid)
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::playapi::proto::finsky::Docid* temp = _impl_.docid_;
  _impl_.docid_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::Docid* ResolvedLink::_internal_mutable_docid() {
  _impl_._has_bits_[0] |= 0x00000800u;
  if (_impl_.docid_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::Docid>(GetArenaForAllocation());
    _impl_.docid_ = p;
  }
  return _impl_.docid_;
}
inline ::playapi::proto::finsky::Docid* ResolvedLink::mutable_docid() {
  ::playapi::proto::finsky::Docid* _msg = _internal_mutable_docid();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.link.ResolvedLink.docid)
  return _msg;
}
inline void ResolvedLink::set_allocated_docid(::playapi::proto::finsky::Docid* docid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.docid_);
  }
  if (docid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(docid));
    if (message_arena != submessage_arena) {
      docid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, docid, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  _impl_.docid_ = docid;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.link.ResolvedLink.docid)
}

// optional string wishlistUrl = 9;
inline bool ResolvedLink::_internal_has_wishlisturl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ResolvedLink::has_wishlisturl() const {
  return _internal_has_wishlisturl();
}
inline void ResolvedLink::clear_wishlisturl() {
  _impl_.wishlisturl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& ResolvedLink::wishlisturl() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.link.ResolvedLink.wishlistUrl)
  return _internal_wishlisturl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResolvedLink::set_wishlisturl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.wishlisturl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.link.ResolvedLink.wishlistUrl)
}
inline std::string* ResolvedLink::mutable_wishlisturl() {
  std::string* _s = _internal_mutable_wishlisturl();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.link.ResolvedLink.wishlistUrl)
  return _s;
}
inline const std::string& ResolvedLink::_internal_wishlisturl() const {
  return _impl_.wishlisturl_.Get();
}
inline void ResolvedLink::_internal_set_wishlisturl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.wishlisturl_.Set(value, GetArenaForAllocation());
}
inline std::string* ResolvedLink::_internal_mutable_wishlisturl() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.wishlisturl_.Mutable(GetArenaForAllocation());
}
inline std::string* ResolvedLink::release_wishlisturl() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.link.ResolvedLink.wishlistUrl)
  if (!_internal_has_wishlisturl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.wishlisturl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.wishlisturl_.IsDefault()) {
    _impl_.wishlisturl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ResolvedLink::set_allocated_wishlisturl(std::string* wishlisturl) {
  if (wishlisturl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.wishlisturl_.SetAllocated(wishlisturl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.wishlisturl_.IsDefault()) {
    _impl_.wishlisturl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.link.ResolvedLink.wishlistUrl)
}

// optional int32 backend = 10;
inline bool ResolvedLink::_internal_has_backend() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool ResolvedLink::has_backend() const {
  return _internal_has_backend();
}
inline void ResolvedLink::clear_backend() {
  _impl_.backend_ = 0;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline int32_t ResolvedLink::_internal_backend() const {
  return _impl_.backend_;
}
inline int32_t ResolvedLink::backend() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.link.ResolvedLink.backend)
  return _internal_backend();
}
inline void ResolvedLink::_internal_set_backend(int32_t value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.backend_ = value;
}
inline void ResolvedLink::set_backend(int32_t value) {
  _internal_set_backend(value);
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.link.ResolvedLink.backend)
}

// optional string query = 11;
inline bool ResolvedLink::_internal_has_query() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ResolvedLink::has_query() const {
  return _internal_has_query();
}
inline void ResolvedLink::clear_query() {
  _impl_.query_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& ResolvedLink::query() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.link.ResolvedLink.query)
  return _internal_query();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResolvedLink::set_query(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000040u;
 _impl_.query_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.link.ResolvedLink.query)
}
inline std::string* ResolvedLink::mutable_query() {
  std::string* _s = _internal_mutable_query();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.link.ResolvedLink.query)
  return _s;
}
inline const std::string& ResolvedLink::_internal_query() const {
  return _impl_.query_.Get();
}
inline void ResolvedLink::_internal_set_query(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.query_.Set(value, GetArenaForAllocation());
}
inline std::string* ResolvedLink::_internal_mutable_query() {
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.query_.Mutable(GetArenaForAllocation());
}
inline std::string* ResolvedLink::release_query() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.link.ResolvedLink.query)
  if (!_internal_has_query()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* p = _impl_.query_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.query_.IsDefault()) {
    _impl_.query_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ResolvedLink::set_allocated_query(std::string* query) {
  if (query != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.query_.SetAllocated(query, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.query_.IsDefault()) {
    _impl_.query_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.link.ResolvedLink.query)
}

// optional string myAccountUrl = 12;
inline bool ResolvedLink::_internal_has_myaccounturl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ResolvedLink::has_myaccounturl() const {
  return _internal_has_myaccounturl();
}
inline void ResolvedLink::clear_myaccounturl() {
  _impl_.myaccounturl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& ResolvedLink::myaccounturl() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.link.ResolvedLink.myAccountUrl)
  return _internal_myaccounturl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResolvedLink::set_myaccounturl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000080u;
 _impl_.myaccounturl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.link.ResolvedLink.myAccountUrl)
}
inline std::string* ResolvedLink::mutable_myaccounturl() {
  std::string* _s = _internal_mutable_myaccounturl();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.link.ResolvedLink.myAccountUrl)
  return _s;
}
inline const std::string& ResolvedLink::_internal_myaccounturl() const {
  return _impl_.myaccounturl_.Get();
}
inline void ResolvedLink::_internal_set_myaccounturl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.myaccounturl_.Set(value, GetArenaForAllocation());
}
inline std::string* ResolvedLink::_internal_mutable_myaccounturl() {
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.myaccounturl_.Mutable(GetArenaForAllocation());
}
inline std::string* ResolvedLink::release_myaccounturl() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.link.ResolvedLink.myAccountUrl)
  if (!_internal_has_myaccounturl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* p = _impl_.myaccounturl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.myaccounturl_.IsDefault()) {
    _impl_.myaccounturl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ResolvedLink::set_allocated_myaccounturl(std::string* myaccounturl) {
  if (myaccounturl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.myaccounturl_.SetAllocated(myaccounturl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.myaccounturl_.IsDefault()) {
    _impl_.myaccounturl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.link.ResolvedLink.myAccountUrl)
}

// optional .playapi.proto.finsky.link.HelpCenter helpCenter = 13;
inline bool ResolvedLink::_internal_has_helpcenter() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.helpcenter_ != nullptr);
  return value;
}
inline bool ResolvedLink::has_helpcenter() const {
  return _internal_has_helpcenter();
}
inline void ResolvedLink::clear_helpcenter() {
  if (_impl_.helpcenter_ != nullptr) _impl_.helpcenter_->Clear();
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline const ::playapi::proto::finsky::link::HelpCenter& ResolvedLink::_internal_helpcenter() const {
  const ::playapi::proto::finsky::link::HelpCenter* p = _impl_.helpcenter_;
  return p != nullptr ? *p : reinterpret_cast<const ::playapi::proto::finsky::link::HelpCenter&>(
      ::playapi::proto::finsky::link::_HelpCenter_default_instance_);
}
inline const ::playapi::proto::finsky::link::HelpCenter& ResolvedLink::helpcenter() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.link.ResolvedLink.helpCenter)
  return _internal_helpcenter();
}
inline void ResolvedLink::unsafe_arena_set_allocated_helpcenter(
    ::playapi::proto::finsky::link::HelpCenter* helpcenter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.helpcenter_);
  }
  _impl_.helpcenter_ = helpcenter;
  if (helpcenter) {
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:playapi.proto.finsky.link.ResolvedLink.helpCenter)
}
inline ::playapi::proto::finsky::link::HelpCenter* ResolvedLink::release_helpcenter() {
  _impl_._has_bits_[0] &= ~0x00001000u;
  ::playapi::proto::finsky::link::HelpCenter* temp = _impl_.helpcenter_;
  _impl_.helpcenter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::playapi::proto::finsky::link::HelpCenter* ResolvedLink::unsafe_arena_release_helpcenter() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.link.ResolvedLink.helpCenter)
  _impl_._has_bits_[0] &= ~0x00001000u;
  ::playapi::proto::finsky::link::HelpCenter* temp = _impl_.helpcenter_;
  _impl_.helpcenter_ = nullptr;
  return temp;
}
inline ::playapi::proto::finsky::link::HelpCenter* ResolvedLink::_internal_mutable_helpcenter() {
  _impl_._has_bits_[0] |= 0x00001000u;
  if (_impl_.helpcenter_ == nullptr) {
    auto* p = CreateMaybeMessage<::playapi::proto::finsky::link::HelpCenter>(GetArenaForAllocation());
    _impl_.helpcenter_ = p;
  }
  return _impl_.helpcenter_;
}
inline ::playapi::proto::finsky::link::HelpCenter* ResolvedLink::mutable_helpcenter() {
  ::playapi::proto::finsky::link::HelpCenter* _msg = _internal_mutable_helpcenter();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.link.ResolvedLink.helpCenter)
  return _msg;
}
inline void ResolvedLink::set_allocated_helpcenter(::playapi::proto::finsky::link::HelpCenter* helpcenter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.helpcenter_;
  }
  if (helpcenter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(helpcenter);
    if (message_arena != submessage_arena) {
      helpcenter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, helpcenter, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  _impl_.helpcenter_ = helpcenter;
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.link.ResolvedLink.helpCenter)
}

// optional string giftUrl = 14;
inline bool ResolvedLink::_internal_has_gifturl() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ResolvedLink::has_gifturl() const {
  return _internal_has_gifturl();
}
inline void ResolvedLink::clear_gifturl() {
  _impl_.gifturl_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const std::string& ResolvedLink::gifturl() const {
  // @@protoc_insertion_point(field_get:playapi.proto.finsky.link.ResolvedLink.giftUrl)
  return _internal_gifturl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResolvedLink::set_gifturl(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000100u;
 _impl_.gifturl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:playapi.proto.finsky.link.ResolvedLink.giftUrl)
}
inline std::string* ResolvedLink::mutable_gifturl() {
  std::string* _s = _internal_mutable_gifturl();
  // @@protoc_insertion_point(field_mutable:playapi.proto.finsky.link.ResolvedLink.giftUrl)
  return _s;
}
inline const std::string& ResolvedLink::_internal_gifturl() const {
  return _impl_.gifturl_.Get();
}
inline void ResolvedLink::_internal_set_gifturl(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.gifturl_.Set(value, GetArenaForAllocation());
}
inline std::string* ResolvedLink::_internal_mutable_gifturl() {
  _impl_._has_bits_[0] |= 0x00000100u;
  return _impl_.gifturl_.Mutable(GetArenaForAllocation());
}
inline std::string* ResolvedLink::release_gifturl() {
  // @@protoc_insertion_point(field_release:playapi.proto.finsky.link.ResolvedLink.giftUrl)
  if (!_internal_has_gifturl()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000100u;
  auto* p = _impl_.gifturl_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.gifturl_.IsDefault()) {
    _impl_.gifturl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ResolvedLink::set_allocated_gifturl(std::string* gifturl) {
  if (gifturl != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.gifturl_.SetAllocated(gifturl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.gifturl_.IsDefault()) {
    _impl_.gifturl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:playapi.proto.finsky.link.ResolvedLink.giftUrl)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace link
}  // namespace finsky
}  // namespace proto
}  // namespace playapi

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_play_5flink_2eproto
